/**
 * ANAF Queue Service
 * 
 * Acest serviciu gestionează cererile către API-ul ANAF folosind BullMQ pentru a evita
 * depășirea limitelor de rate (1 request/secundă, maximum 100 CUI-uri per cerere).
 * Implementează caching, batch processing și rate limiting.
 */

import { Queue, Worker, Job } from 'bullmq';
import { nanoid } from 'nanoid';
import Redis from 'ioredis';
import { anafService, AnafCompanyData } from './anaf.service';
import AuditService from '../../../modules/audit/services/audit.service';
// Eliminată dependența de external save
import { getDrizzleInstance } from '../../../common/drizzle/db';
import { anafCompanyData } from '../schema/crm.schema';
import { eq } from 'drizzle-orm';
import { safeIsoString, nowIsoString } from '../utils/date-utils';

// Configurația pentru conectarea la Redis
const REDIS_CONNECTION = {
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  maxRetriesPerRequest: null // Necesar pentru BullMQ
};

// Numele cozii BullMQ
const ANAF_QUEUE_NAME = 'anaf-requests';

// Tipul pentru batch-ul de cereri
interface AnafBatchRequest {
  batchId: string;
  cuiList: string[];
  requesterId: string;
  requesterCompanyId: string;
}

// Tipuri pentru callback-uri
type AnafCompanyCallback = (company: AnafCompanyData | null, error?: Error) => void;

// Cache timeout în secunde (24 ore)
const CACHE_TIMEOUT = 24 * 60 * 60;

export class AnafQueueService {
  private queue: Queue;
  private worker: Worker;
  private redis: Redis;
  private db = getDrizzleInstance();
  
  // Map pentru stocarea callback-urilor
  private callbacks: Map<string, AnafCompanyCallback> = new Map();
  
  constructor() {
    // Inițializare Redis
    this.redis = new Redis(REDIS_CONNECTION);
    
    // Inițializare coadă BullMQ
    this.queue = new Queue(ANAF_QUEUE_NAME, {
      connection: this.redis,
      defaultJobOptions: {
        removeOnComplete: true,
        removeOnFail: 1000, // Keep failed jobs for debugging
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 5000
        }
      }
    });
    
    // Inițializare worker BullMQ
    this.worker = new Worker(
      ANAF_QUEUE_NAME,
      async (job) => this.processBatch(job),
      { connection: this.redis, concurrency: 1 } // Un singur job la un moment dat pentru a respecta limita de rate
    );
    
    // Log inițializare
    console.log('[AnafQueueService] 🚀 Serviciu de coadă ANAF inițializat');
    
    // Setare handler pentru erori
    this.worker.on('failed', (job, error) => {
      console.error(`[AnafQueueService] ❌ Job eșuat ${job?.id}:`, error);
    });
    
    // Setare handler pentru completare
    this.worker.on('completed', (job) => {
      console.log(`[AnafQueueService] ✅ Job finalizat ${job.id}`);
    });
  }
  
  /**
   * Adaugă o cerere în coadă pentru un singur CUI
   * Verifică mai întâi cache-ul, apoi adaugă cererea în coada de batch dacă e necesar
   * 
   * @param cui Codul fiscal (cu sau fără RO)
   * @param userId ID-ul utilizatorului care face cererea
   * @param companyId ID-ul companiei utilizatorului  
   * @returns Promise cu datele companiei
   */
  async queueCompanyRequest(cui: string, userId: string, companyId: string): Promise<AnafCompanyData | null> {
    // Curăță CUI-ul
    const cleanCui = cui.replace(/^RO/i, '').trim();
    
    console.log(`[AnafQueueService] 📝 Începe procesarea cererii pentru CUI ${cleanCui}`);
    
    // Verifică cache-ul
    const cachedData = await this.getFromCache(cleanCui);
    if (cachedData) {
      console.log(`[AnafQueueService] 🔍 Date găsite în cache pentru CUI ${cleanCui}`);
      
      // Verifică dacă există și în DB - dacă nu, salvează din cache în DB
      const existsInDb = await this.checkExistsInDatabase(cleanCui);
      if (!existsInDb) {
        console.log(`[AnafQueueService] 💾 Date găsite în cache dar nu în baza de date pentru CUI ${cleanCui}, salvăm în DB`);
        await this.saveToDatabase(cachedData, userId, companyId);
      }
      
      return cachedData;
    }
    
    // Verifică DB-ul
    const dbData = await this.getFromDatabase(cleanCui);
    if (dbData) {
      console.log(`[AnafQueueService] 🔍 Date găsite în baza de date pentru CUI ${cleanCui}`);
      // Actualizează și cache-ul
      await this.addToCache(cleanCui, dbData);
      return dbData;
    }
    
    console.log(`[AnafQueueService] 📋 Nu s-au găsit date locale pentru CUI ${cleanCui}, se adaugă în batch`);
    
    // Dacă nu există în cache, creează o cerere nouă
    return new Promise((resolve, reject) => {
      // Generează un ID unic pentru cerere
      const requestId = nanoid();
      
      console.log(`[AnafQueueService] 🆔 Generat ID pentru cerere: ${requestId} pentru CUI ${cleanCui}`);
      
      // Salvează callback-ul pentru a fi apelat când avem rezultatul
      this.callbacks.set(requestId, (company, error) => {
        if (error) {
          console.error(`[AnafQueueService] ❌ Eroare la callback pentru CUI ${cleanCui}:`, error);
          reject(error);
        } else {
          console.log(`[AnafQueueService] ✅ Callback executat cu succes pentru CUI ${cleanCui}`);
          resolve(company);
        }
      });
      
      // Adaugă CUI-ul în batch
      this.addToBatch(cleanCui, requestId, userId, companyId);
    });
  }
  
  /**
   * Adaugă un CUI la un batch de cereri sau creează un batch nou
   * 
   * @param cui Codul fiscal
   * @param requestId ID-ul cererii
   * @param userId ID-ul utilizatorului
   * @param companyId ID-ul companiei
   */
  private async addToBatch(cui: string, requestId: string, userId: string, companyId: string): Promise<void> {
    try {
      // Salvăm asocierea CUI - requestId pentru a ști la ce cerere aparține rezultatul
      await this.redis.set(`anaf:request:${cui}`, requestId, 'EX', 3600); // Expiră după 1 oră
      
      // Generăm un timer de 500ms pentru a grupa mai multe cereri în același batch
      setTimeout(async () => {
        // Verificăm dacă mai există deja un batch în așteptare
        const pendingBatch = await this.redis.get('anaf:pending-batch');
        
        if (pendingBatch) {
          // Adăugăm CUI-ul la batch-ul existent
          const batch: AnafBatchRequest = JSON.parse(pendingBatch);
          
          // Verificăm dacă CUI-ul nu este deja în batch
          if (!batch.cuiList.includes(cui)) {
            batch.cuiList.push(cui);
            
            // Dacă am atins limita de 100 de CUI-uri sau alt prag, trimitem batch-ul
            if (batch.cuiList.length >= 50) { // Folosim 50 ca limită pentru siguranță
              // Ștergem batch-ul din Redis
              await this.redis.del('anaf:pending-batch');
              
              // Adăugăm batch-ul în coadă
              await this.queue.add('anaf-batch', batch);
              console.log(`[AnafQueueService] 📦 Batch trimis cu ${batch.cuiList.length} CUI-uri`);
            } else {
              // Actualizăm batch-ul în Redis
              await this.redis.set('anaf:pending-batch', JSON.stringify(batch), 'EX', 60);
            }
          }
        } else {
          // Creăm un batch nou
          const newBatch: AnafBatchRequest = {
            batchId: nanoid(),
            cuiList: [cui],
            requesterId: userId,
            requesterCompanyId: companyId
          };
          
          // Salvăm batch-ul în Redis
          await this.redis.set('anaf:pending-batch', JSON.stringify(newBatch), 'EX', 60);
          
          // Setăm un timer pentru a trimite batch-ul după o perioadă, chiar dacă nu atinge limita
          setTimeout(async () => {
            // Verificăm dacă batch-ul mai există
            const currentBatch = await this.redis.get('anaf:pending-batch');
            if (currentBatch) {
              const batch: AnafBatchRequest = JSON.parse(currentBatch);
              
              // Verificăm dacă ID-ul batch-ului este același
              if (batch.batchId === newBatch.batchId) {
                // Ștergem batch-ul din Redis
                await this.redis.del('anaf:pending-batch');
                
                // Adăugăm batch-ul în coadă doar dacă conține cel puțin un CUI
                if (batch.cuiList.length > 0) {
                  await this.queue.add('anaf-batch', batch);
                  console.log(`[AnafQueueService] ⏱️ Timeout batch cu ${batch.cuiList.length} CUI-uri`);
                }
              }
            }
          }, 2000); // Trimite batch-ul după 2 secunde dacă nu s-au mai adăugat cereri
        }
      }, 100); // 100ms delay pentru a permite gruparea cererilor
    } catch (error) {
      console.error('[AnafQueueService] ❌ Eroare la adăugarea în batch:', error);
      
      // Apelăm callback-ul cu eroare
      const callback = this.callbacks.get(requestId);
      if (callback) {
        callback(null, error instanceof Error ? error : new Error(String(error)));
        this.callbacks.delete(requestId);
      }
    }
  }
  
  /**
   * Procesează un batch de cereri ANAF
   * 
   * @param job Job-ul BullMQ 
   */
  private async processBatch(job: Job): Promise<void> {
    try {
      const batch = job.data as AnafBatchRequest;
      console.log(`[AnafQueueService] 🔄 Procesare batch ${batch.batchId} cu ${batch.cuiList.length} CUI-uri`);
      
      // Împărțim CUI-urile în batch-uri mai mici dacă este necesar
      const maxBatchSize = 100; // Limita API-ului ANAF
      const batches: string[][] = [];
      
      for (let i = 0; i < batch.cuiList.length; i += maxBatchSize) {
        batches.push(batch.cuiList.slice(i, i + maxBatchSize));
      }
      
      // Procesăm fiecare sub-batch
      for (const subBatch of batches) {
        try {
          const response = await anafService.queryAnaf(subBatch);
          console.log(`[AnafQueueService] ✅ Răspuns ANAF pentru sub-batch: ${response.found.length} găsite, ${response.notFound.length} negăsite`);
          
          // Procesăm companiile găsite
          for (const company of response.found) {
            const cui = company.date_generale.cui;
            
            // Salvăm datele în cache
            await this.addToCache(cui, company);
            
            // Salvăm datele în baza de date
            await this.saveToDatabase(company, batch.requesterId, batch.requesterCompanyId);
            
            // Apelăm callback-ul asociat cu acest CUI
            const requestId = await this.redis.get(`anaf:request:${cui}`);
            if (requestId) {
              const callback = this.callbacks.get(requestId);
              if (callback) {
                callback(company);
                this.callbacks.delete(requestId);
              }
              
              // Ștergem asocierea din Redis
              await this.redis.del(`anaf:request:${cui}`);
            }
          }
          
          // Procesăm CUI-urile negăsite
          for (const cui of response.notFound) {
            const requestId = await this.redis.get(`anaf:request:${cui}`);
            if (requestId) {
              const callback = this.callbacks.get(requestId);
              if (callback) {
                callback(null);
                this.callbacks.delete(requestId);
              }
              
              // Ștergem asocierea din Redis
              await this.redis.del(`anaf:request:${cui}`);
            }
          }
        } catch (error) {
          console.error(`[AnafQueueService] ❌ Eroare la interogarea sub-batch ANAF:`, error);
          
          // Gestionăm erorile pentru acest sub-batch
          // Dacă eșuează, încercăm să apelăm callback-urile cu erori
          for (const cui of subBatch) {
            const requestId = await this.redis.get(`anaf:request:${cui}`);
            if (requestId) {
              const callback = this.callbacks.get(requestId);
              if (callback) {
                callback(null, error instanceof Error ? error : new Error(String(error)));
                this.callbacks.delete(requestId);
              }
              
              // Ștergem asocierea din Redis
              await this.redis.del(`anaf:request:${cui}`);
            }
          }
        }
        
        // Așteptăm 1 secundă între sub-batch-uri pentru a respecta limita de rate
        if (batches.length > 1) {
          await new Promise(resolve => setTimeout(resolve, 1100)); // 1.1 secunde pentru siguranță
        }
      }
      
      console.log(`[AnafQueueService] ✅ Procesare batch ${batch.batchId} finalizată`);
    } catch (error) {
      console.error(`[AnafQueueService] ❌ Eroare la procesarea batch-ului:`, error);
      throw error; // Propagăm eroarea pentru ca BullMQ să poată face retry
    }
  }
  
  /**
   * Salvează datele unei companii în cache
   * 
   * @param cui CUI-ul companiei
   * @param data Datele companiei
   */
  private async addToCache(cui: string, data: AnafCompanyData): Promise<void> {
    try {
      await this.redis.set(`anaf:company:${cui}`, JSON.stringify(data), 'EX', CACHE_TIMEOUT);
    } catch (error) {
      console.error(`[AnafQueueService] ❌ Eroare la salvarea în cache:`, error);
    }
  }
  
  /**
   * Obține datele unei companii din cache
   * 
   * @param cui CUI-ul companiei
   * @returns Datele companiei sau null dacă nu există în cache
   */
  private async getFromCache(cui: string): Promise<AnafCompanyData | null> {
    try {
      const data = await this.redis.get(`anaf:company:${cui}`);
      if (data) {
        return JSON.parse(data) as AnafCompanyData;
      }
      return null;
    } catch (error) {
      console.error(`[AnafQueueService] ❌ Eroare la obținerea din cache:`, error);
      return null;
    }
  }
  
  /**
   * Salvează datele unei companii în baza de date
   * 
   * @param company Datele companiei
   * @param userId ID-ul utilizatorului care a făcut cererea
   * @param companyId ID-ul companiei utilizatorului
   */
  private async saveToDatabase(company: AnafCompanyData, userId: string, companyId: string): Promise<void> {
    try {
      const cui = company.date_generale.cui;
      console.log(`[AnafQueueService] 💾 Salvare date ANAF pentru CUI ${cui} în baza de date`);
      
      // Tratăm cazul când perioade_TVA poate fi un array sau un obiect direct
      let perioadeArray: any[] = [];
      const perioadeTva = company.inregistrare_scop_Tva?.perioade_TVA;
      
      if (perioadeTva) {
        if (Array.isArray(perioadeTva)) {
          perioadeArray = perioadeTva;
        } else {
          // Dacă nu e array, îl tratăm ca un singur obiect și îl punem într-un array
          perioadeArray = [perioadeTva];
        }
      }
      
      // Convertim datele în formatul corect pentru baza de date (Date object)
      const convertToDate = (dateStr: string | null | undefined): Date | null => {
        if (!dateStr) return null;
        if (dateStr === '') return null;
        
        // Dacă este deja un obiect Date, îl returnăm direct
        if (dateStr instanceof Date) return dateStr;
        
        try {
          // Normalizăm stringul
          const trimmedDate = typeof dateStr === 'string' ? dateStr.trim() : dateStr;
          
          // Pentru date în format PostgreSQL sau ISO (YYYY-MM-DD sau YYYY-MM-DDTHH:MM:SS)
          if (typeof trimmedDate === 'string' && trimmedDate.match(/^\d{4}-\d{2}-\d{2}(T.*)?$/)) {
            const dateObj = new Date(trimmedDate);
            if (!isNaN(dateObj.getTime())) {
              return dateObj;
            }
          }
          
          // Pentru formate tip ANAF (DD.MM.YYYY)
          if (typeof trimmedDate === 'string' && trimmedDate.includes('.') && trimmedDate.match(/^\d{2}\.\d{2}\.\d{4}$/)) {
            const parts = trimmedDate.split('.');
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Luna în JS este 0-indexed
            const year = parseInt(parts[2], 10);
            
            // Validăm componentele
            if (!isNaN(day) && !isNaN(month) && !isNaN(year) && 
                day >= 1 && day <= 31 && month >= 0 && month <= 11 && year >= 1900) {
              const date = new Date(year, month, day, 12, 0, 0); // Setăm ora la 12 pentru a evita probleme de fus orar
              
              // Verificăm dacă data rezultată e validă
              if (!isNaN(date.getTime())) {
                return date;
              }
            }
          }
          
          // ANAF folosește și formatul YYYY-MM-DD
          if (typeof trimmedDate === 'string' && trimmedDate.includes('-')) {
            const parts = trimmedDate.split('-');
            if (parts.length === 3) {
              const year = parseInt(parts[0]);
              const month = parseInt(parts[1]) - 1; // Lunile sunt indexate de la 0
              const day = parseInt(parts[2]);
              
              // Validăm datele
              if (!isNaN(year) && !isNaN(month) && !isNaN(day) && 
                  year >= 1900 && year <= 2100 && month >= 0 && month <= 11 && day >= 1 && day <= 31) {
                const date = new Date(year, month, day, 12, 0, 0); // Setăm ora la 12 pentru a evita probleme de fus orar
                
                // Verificăm dacă data rezultată este validă
                if (!isNaN(date.getTime())) {
                  return date;
                }
              }
            }
          }
          
          // Pentru timestamp-uri (număr sau string numeric)
          if (typeof trimmedDate === 'string' && /^\d+$/.test(trimmedDate)) {
            const timestamp = parseInt(trimmedDate, 10);
            const timestampDate = new Date(timestamp);
            if (!isNaN(timestampDate.getTime())) {
              return timestampDate;
            }
          }
          
          // Încercăm cu Date() direct dacă formatul este diferit
          if (typeof trimmedDate === 'string') {
            const date = new Date(trimmedDate);
            if (!isNaN(date.getTime())) {
              return date;
            }
          }
          
          console.warn(`[AnafQueueService] ⚠️ Format de dată nerecunoscut sau invalid: ${trimmedDate}`);
          return null;
        } catch (e) {
          console.error(`[AnafQueueService] ❌ Eroare la conversia datei [${dateStr}]:`, e);
          return null;
        }
      };
      
      // Verificăm dacă există deja înregistrarea
      const existingRecord = await this.db.select().from(anafCompanyData).where(eq(anafCompanyData.cui, cui));
      
      // Verificăm dacă există perioade TVA și extragem prima
      const inregistrareTva = company.inregistrare_scop_Tva || {};
      const perioadeArrayTva = inregistrareTva.perioade_TVA || [];
      const primaPerioadaTva = perioadeArrayTva[0] || {};
      
      /**
       * Funcția robustă globală pentru conversia datelor în format ISO string sau null
       * Gestionează multiple formate de date inclusiv ISO, românesc, și timestamp
       * 
       * @param value Valoarea de convertit (string, Date, timestamp, etc.)
       * @returns String în format ISO 8601 sau null dacă conversia nu este posibilă
       */
      const toIsoString = (value: any): string | null => {
        if (value === null || value === undefined || value === '') return null;
        
        // Dacă e deja un Date, convertim direct la ISO string
        if (value instanceof Date) {
          return isNaN(value.getTime()) ? null : value.toISOString();
        }
        
        // Dacă e numeric (timestamp), convertim la Date
        if (typeof value === 'number') {
          try {
            const date = new Date(value);
            return isNaN(date.getTime()) ? null : date.toISOString();
          } catch (e) {
            console.error(`[AnafQueueService] ❌ Eroare la conversia timestamp [${value}] în ISO string:`, e);
            return null;
          }
        }
        
        // Dacă e string, verificăm diverse formate
        if (typeof value === 'string') {
          // Curățăm stringul
          const cleanValue = value.trim();
          
          // Verificăm dacă e deja în format ISO
          if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(cleanValue)) {
            return cleanValue; // deja e în format ISO
          }
          
          // Pattern pentru data în format YYYY-MM-DD
          if (/^\d{4}-\d{2}-\d{2}$/.test(cleanValue)) {
            return `${cleanValue}T00:00:00.000Z`;
          }
          
          // Pattern pentru data în format DD.MM.YYYY (românesc cu punct)
          if (/^\d{2}\.\d{2}\.\d{4}$/.test(cleanValue)) {
            const parts = cleanValue.split('.');
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Luna 0-11 în JS
            const year = parseInt(parts[2], 10);
            const date = new Date(Date.UTC(year, month, day));
            return isNaN(date.getTime()) ? null : date.toISOString();
          }
          
          // Pattern pentru data în format DD-MM-YYYY (românesc cu liniuță)
          if (/^\d{2}-\d{2}-\d{4}$/.test(cleanValue)) {
            const parts = cleanValue.split('-');
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Luna 0-11 în JS
            const year = parseInt(parts[2], 10);
            const date = new Date(Date.UTC(year, month, day));
            return isNaN(date.getTime()) ? null : date.toISOString();
          }
          
          // Încercăm să convertim direct ca ultimă opțiune
          try {
            const date = new Date(cleanValue);
            // Verificăm explicit dacă avem o dată validă
            if (!isNaN(date.getTime())) {
              return date.toISOString();
            }
            return null;
          } catch (e) {
            console.error(`[AnafQueueService] ❌ Eroare la conversia datei [${cleanValue}] în ISO string:`, e);
            return null;
          }
        }
        
        // Alte tipuri nu sunt acceptate
        console.warn(`[AnafQueueService] ⚠️ Tip de dată neacceptat pentru conversie: ${typeof value}`);
        return null;
      };
      
      // Mapăm câmpurile din API la structura bazei noastre de date
      const anafData = {
        companyId: companyId || undefined, // Folosim undefined în loc de null pentru Drizzle
        cui: cui,
        dataInterogare: company.date_generale?.data || null,
        denumire: company.date_generale?.denumire || null,
        adresa: company.date_generale?.adresa || null,
        nrRegCom: company.date_generale?.nrRegCom || null,
        telefon: company.date_generale?.telefon || null,
        fax: company.date_generale?.fax || null,
        codPostal: company.date_generale?.codPostal || null,
        act: company.date_generale?.act || null,
        stareInregistrare: company.date_generale?.stare_inregistrare || null,
        dataInregistrare: company.date_generale?.data_inregistrare || null,
        codCaen: company.date_generale?.cod_CAEN || null,
        iban: company.date_generale?.iban || null,
        statusRoEFactura: company.date_generale?.statusRO_e_Factura || false,
        organFiscalCompetent: company.date_generale?.organ_fiscal_competent || null,
        formaJuridica: company.date_generale?.forma_juridica || null,
        formaOrganizare: company.date_generale?.forma_organizare || null,
        formaProprietate: company.date_generale?.forma_de_proprietate || null,
        
        // Date fiscale și TVA
        platitorTva: inregistrareTva?.scpTVA || false,
        dataTva: primaPerioadaTva?.data || null,
        dataStartTva: primaPerioadaTva?.data_inceput_ScpTVA || null,
        dataEndTva: primaPerioadaTva?.data_sfarsit_ScpTVA || null,
        mesajTva: primaPerioadaTva?.mesaj_ScpTVA || null,
        statusTva: primaPerioadaTva?.statusScpTVA || null,
        
        // TVA la încasare - structura corectată
        platitorTvaIncasare: company.inregistrare_RTVAI?.statusTvaIncasare || false,
        dataInceputTvaIncasare: company.inregistrare_RTVAI?.dataInceputTvaInc || null,
        dataAnulareTvaIncasare: null, // Acest câmp nu există în APIv9, trebuie calculat sau lăsat null
        dataPanaLaTvaIncasare: company.inregistrare_RTVAI?.dataSfarsitTvaInc || null,
        
        // Split TVA - structura corectată
        platitorTvaSplit: company.inregistrare_SplitTVA?.statusSplitTVA || false,
        dataInregistrareTvaSplit: company.inregistrare_SplitTVA?.dataInceputSplitTVA || null,
        dataRadiereTvaSplit: company.inregistrare_SplitTVA?.dataSfarsitSplitTVA || null,
        
        // Alte date fiscale
        statusInactivi: company.stare_inactiv?.statusInactivi || false,
        dataInactivare: company.stare_inactiv?.dataInactivare || null,
        dataReactivare: company.stare_inactiv?.dataReactivare || null,
        dataPublicare: company.stare_inactiv?.dataPublicare || null,
        dataRadiere: company.stare_inactiv?.dataRadiere || null,
        
        // Split TVA și insolvență
        statusSplitTva: company.inregistrare_SplitTVA?.statusSplitTVA || false,
        dataInceputSplitTva: company.inregistrare_SplitTVA?.dataInceputSplitTVA || null,
        statusInsolventa: company.inregistrare_RISF?.dataInceputRISF ? true : false,
        dataInceputInsolventa: company.inregistrare_RISF?.dataInceputRISF || null,
        dataInchidereInsolventa: company.inregistrare_RISF?.dataInchidereRISF || null,
        
        // Capitol TVA și alte metadate
        capitolTva: inregistrareTva.capitol || null,
        
        // Stare și metadate
        statusActiv: true,
        rawResponse: JSON.stringify(company),
        lastCheckedAt: new Date().toISOString(),
        observatii: null,
        isUpdatedFromAnaf: true,
        
        // Timestamps pentru audit
        createdAt: existingRecord.length > 0 ? undefined : new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      // Salvăm în baza de date
      if (existingRecord.length > 0) {
        // Actualizăm înregistrarea existentă
        console.log(`[AnafQueueService] 🔄 Actualizăm datele pentru CUI ${cui}`);
        
        // Folosim funcția robustă globală definită la linia 488
        
        // Filtrăm doar câmpurile care există în schema bazei de date
        // și convertim valorile temporale în ISO string pentru compatibilitate cu Postgres
        // Folosim funcția robustă globală toIsoString definită mai sus
        const normalizedData = {
          cui: anafData.cui,
          companyId: anafData.companyId,
          dataInterogare: anafData.dataInterogare,
          denumire: anafData.denumire,
          adresa: anafData.adresa,
          nrRegCom: anafData.nrRegCom,
          telefon: anafData.telefon,
          fax: anafData.fax,
          codPostal: anafData.codPostal,
          act: anafData.act,
          stareInregistrare: anafData.stareInregistrare,
          
          // Date tipuri temporale - CONVERTITE LA ISO STRING
          dataInregistrare: toIsoString(anafData.dataInregistrare),
          dataStartTva: toIsoString(anafData.dataStartTva),
          dataEndTva: toIsoString(anafData.dataEndTva),
          dataInceputTvaIncasare: toIsoString(anafData.dataInceputTvaIncasare),
          dataAnulareTvaIncasare: toIsoString(anafData.dataAnulareTvaIncasare),
          dataPanaLaTvaIncasare: toIsoString(anafData.dataPanaLaTvaIncasare),
          dataInregistrareTvaSplit: toIsoString(anafData.dataInregistrareTvaSplit),
          dataRadiereTvaSplit: toIsoString(anafData.dataRadiereTvaSplit),
          dataInactivare: toIsoString(anafData.dataInactivare),
          dataReactivare: toIsoString(anafData.dataReactivare),
          dataPublicare: toIsoString(anafData.dataPublicare),
          dataRadiere: toIsoString(anafData.dataRadiere),
          dataInceputSplitTva: toIsoString(anafData.dataInceputSplitTva),
          dataInceputInsolventa: toIsoString(anafData.dataInceputInsolventa),
          dataInchidereInsolventa: toIsoString(anafData.dataInchidereInsolventa),
          
          // Valori booleene și text
          codCaen: anafData.codCaen,
          iban: anafData.iban,
          statusRoEFactura: anafData.statusRoEFactura,
          organFiscalCompetent: anafData.organFiscalCompetent,
          formaJuridica: anafData.formaJuridica,
          formaOrganizare: anafData.formaOrganizare,
          formaProprietate: anafData.formaProprietate,
          
          // TVA și fiscalitate
          platitorTva: anafData.platitorTva,
          dataTva: toIsoString(anafData.dataTva),
          mesajTva: anafData.mesajTva,
          statusTva: anafData.statusTva,
          platitorTvaIncasare: anafData.platitorTvaIncasare,
          platitorTvaSplit: anafData.platitorTvaSplit,
          statusInactivi: anafData.statusInactivi,
          statusSplitTva: anafData.statusSplitTva,
          statusInsolventa: anafData.statusInsolventa,
          capitolTva: anafData.capitolTva,
          
          // Metadata
          statusActiv: anafData.statusActiv,
          rawResponse: anafData.rawResponse,
          lastCheckedAt: toIsoString(new Date()),
          observatii: anafData.observatii,
          isUpdatedFromAnaf: anafData.isUpdatedFromAnaf,
          
          // Date audit
          updatedAt: toIsoString(new Date()),
          updatedBy: userId || undefined
        };
        
        await this.db.update(anafCompanyData)
          .set(normalizedData)
          .where(eq(anafCompanyData.cui, cui));
          
        console.log(`[AnafQueueService] ✅ Date ANAF actualizate pentru CUI ${cui}`);
      } else {
        // Inserăm o nouă înregistrare
        console.log(`[AnafQueueService] 📥 Inserăm date ANAF noi pentru CUI ${cui}`);
        
        // Filtrăm doar câmpurile care există în schema bazei de date
        // și convertim valorile temporale și de tip potrivit
        // Folosim funcția robustă globală toIsoString definită mai sus
        
        const normalizedData = {
          cui: anafData.cui,
          companyId: anafData.companyId,
          dataInterogare: anafData.dataInterogare,
          denumire: anafData.denumire,
          adresa: anafData.adresa,
          nrRegCom: anafData.nrRegCom,
          telefon: anafData.telefon,
          fax: anafData.fax,
          codPostal: anafData.codPostal,
          act: anafData.act,
          stareInregistrare: anafData.stareInregistrare,
          
          // Date tipuri temporale - CONVERTITE LA ISO STRING
          dataInregistrare: toIsoString(anafData.dataInregistrare),
          dataStartTva: toIsoString(anafData.dataStartTva),
          dataEndTva: toIsoString(anafData.dataEndTva),
          dataInceputTvaIncasare: toIsoString(anafData.dataInceputTvaIncasare),
          dataAnulareTvaIncasare: toIsoString(anafData.dataAnulareTvaIncasare),
          dataPanaLaTvaIncasare: toIsoString(anafData.dataPanaLaTvaIncasare),
          dataInregistrareTvaSplit: toIsoString(anafData.dataInregistrareTvaSplit),
          dataRadiereTvaSplit: toIsoString(anafData.dataRadiereTvaSplit),
          dataInactivare: toIsoString(anafData.dataInactivare),
          dataReactivare: toIsoString(anafData.dataReactivare),
          dataPublicare: toIsoString(anafData.dataPublicare),
          dataRadiere: toIsoString(anafData.dataRadiere),
          dataInceputSplitTva: toIsoString(anafData.dataInceputSplitTva),
          dataInceputInsolventa: toIsoString(anafData.dataInceputInsolventa),
          dataInchidereInsolventa: toIsoString(anafData.dataInchidereInsolventa),
          
          // Valori booleene și text
          codCaen: anafData.codCaen,
          iban: anafData.iban,
          statusRoEFactura: anafData.statusRoEFactura,
          organFiscalCompetent: anafData.organFiscalCompetent,
          formaJuridica: anafData.formaJuridica,
          formaOrganizare: anafData.formaOrganizare,
          formaProprietate: anafData.formaProprietate,
          
          // TVA și fiscalitate
          platitorTva: anafData.platitorTva,
          dataTva: toIsoString(anafData.dataTva),
          mesajTva: anafData.mesajTva,
          statusTva: anafData.statusTva,
          platitorTvaIncasare: anafData.platitorTvaIncasare,
          platitorTvaSplit: anafData.platitorTvaSplit,
          statusInactivi: anafData.statusInactivi,
          statusSplitTva: anafData.statusSplitTva,
          statusInsolventa: anafData.statusInsolventa,
          capitolTva: anafData.capitolTva,
          
          // Metadata
          statusActiv: anafData.statusActiv,
          rawResponse: anafData.rawResponse,
          lastCheckedAt: toIsoString(new Date()),
          observatii: anafData.observatii,
          isUpdatedFromAnaf: anafData.isUpdatedFromAnaf,
          
          // Date audit
          createdAt: toIsoString(new Date()),
          updatedAt: toIsoString(new Date()),
          createdBy: userId || undefined,
          updatedBy: userId || undefined
        };
        
        await this.db.insert(anafCompanyData).values(normalizedData);
        console.log(`[AnafQueueService] ✅ Date ANAF noi inserate pentru CUI ${cui}`);
      }
      
      // Auditare
      AuditService.log({
        userId: userId || 'system',
        companyId: companyId || 'unknown',
        action: 'anaf_company_data_saved',
        entity: 'anaf_company_data',
        details: { 
          cui,
          success: true 
        }
      });
      
      console.log(`[AnafQueueService] ✅ Date ANAF pentru CUI ${cui} salvate în baza de date`);
    } catch (error) {
      console.error('[AnafQueueService] ❌ Eroare la salvarea datelor ANAF în baza de date:', error);
    }
  }
  
  /**
   * Obține datele unei companii din baza de date
   * 
   * @param cui CUI-ul companiei  
   * @returns Datele companiei sau null dacă nu există
   */
  /**
   * Verifică dacă există o înregistrare în baza de date pentru acest CUI
   * 
   * @param cui CUI-ul companiei
   * @returns true dacă există, false dacă nu
   */
  private async checkExistsInDatabase(cui: string): Promise<boolean> {
    try {
      const record = await this.db.select({ id: anafCompanyData.id }).from(anafCompanyData).where(eq(anafCompanyData.cui, cui));
      return record.length > 0;
    } catch (error) {
      console.error('[AnafQueueService] ❌ Eroare la verificarea existenței în baza de date:', error);
      return false;
    }
  }

  /**
   * Obține datele unei companii din baza de date
   * 
   * @param cui CUI-ul companiei  
   * @returns Datele companiei sau null dacă nu există
   */
  private async getFromDatabase(cui: string): Promise<AnafCompanyData | null> {
    try {
      const record = await this.db.select().from(anafCompanyData).where(eq(anafCompanyData.cui, cui));
      
      if (record.length > 0) {
        // Verificăm dacă datele sunt recente (mai noi de 24 ore)
        const lastCheckedDate = record[0].lastCheckedAt;
        
        // lastCheckedAt poate fi un string ISO sau un obiect Date, tratăm ambele cazuri
        let lastChecked: Date | null = null;
        if (lastCheckedDate instanceof Date) {
          lastChecked = lastCheckedDate;
        } else if (typeof lastCheckedDate === 'string' && lastCheckedDate) {
          lastChecked = new Date(lastCheckedDate);
        }
        
        // Verifică validitatea datei
        if (lastChecked && !isNaN(lastChecked.getTime())) {
          const now = new Date();
          // Calculăm diferența în milisecunde
          const diff = now.getTime() - lastChecked.getTime();
          
          // Dacă datele sunt mai vechi de 24 ore, le considerăm expirate
          if (diff > CACHE_TIMEOUT * 1000) {
            console.log(`[AnafQueueService] 🕒 Date pentru CUI ${cui} expirate în baza de date (mai vechi de ${CACHE_TIMEOUT/3600} ore)`);
            return null;
          }
        } else {
          console.warn(`[AnafQueueService] ⚠️ lastCheckedAt invalid pentru CUI ${cui}: ${lastCheckedDate}`);
        }
        
        // Convertim înregistrarea din DB în formatul AnafCompanyData
        if (record[0].rawResponse) {
          try {
            let parsedResponse: AnafCompanyData;
            
            // Verificăm dacă rawResponse este deja un obiect sau un string JSON
            if (typeof record[0].rawResponse === 'object' && record[0].rawResponse !== null) {
              parsedResponse = record[0].rawResponse as unknown as AnafCompanyData;
            } else if (typeof record[0].rawResponse === 'string') {
              parsedResponse = JSON.parse(record[0].rawResponse) as AnafCompanyData;
            } else {
              console.warn(`[AnafQueueService] ⚠️ Format rawResponse neașteptat pentru CUI ${cui}: ${typeof record[0].rawResponse}`);
              return null;
            }
            
            console.log(`[AnafQueueService] ✅ Date pentru CUI ${cui} găsite în baza de date`);
            return parsedResponse;
          } catch (e) {
            console.error(`[AnafQueueService] ❌ Eroare la parsarea JSON din baza de date pentru CUI ${cui}:`, e);
            return null;
          }
        } else {
          console.warn(`[AnafQueueService] ⚠️ Înregistrarea pentru CUI ${cui} nu conține rawResponse`);
        }
      } else {
        console.log(`[AnafQueueService] 🔍 Nu s-au găsit date în baza de date pentru CUI ${cui}`);
      }
      
      return null;
    } catch (error) {
      console.error(`[AnafQueueService] ❌ Eroare la obținerea datelor din baza de date pentru CUI ${cui}:`, error);
      return null;
    }
  }
  
  /**
   * Închide serviciul și conexiunile
   */
  async close(): Promise<void> {
    await this.worker.close();
    await this.queue.close();
    await this.redis.quit();
  }
}

// Exportă o instanță singleton
export const anafQueueService = new AnafQueueService();