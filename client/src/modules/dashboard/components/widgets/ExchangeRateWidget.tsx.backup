/**
 * Exchange Rate Widget Component
 * 
 * Displays current exchange rates from BNR for selected currencies
 * with 10-day trends and manual refresh functionality.
 */
import React, { useState, useMemo, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Separator } from '@/components/ui/separator';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { RefreshCw, TrendingUp, TrendingDown, Minus, AlertCircle } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { formatDate, formatNumber } from '@/lib/utils';
import { fetchExchangeRates, refreshExchangeRates, fetchHistoricalExchangeRates } from '@/lib/api-helpers';

// Define the exchange rate data structure
type ExchangeRate = {
  currency: string;
  rate: number;
  trend: 'up' | 'down' | 'stable';
  change: number;
  previousRate?: number;
};

// Currencies to display
const DISPLAY_CURRENCIES = ['EUR', 'USD', 'TRY'];

// Tabs for different views
const TABS = [
  { id: 'main', label: 'Toate', currencies: DISPLAY_CURRENCIES },
];

const ExchangeRateWidget: React.FC = () => {
  const [activeTab, setActiveTab] = useState('main');
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  // Query to fetch latest exchange rates
  const { 
    data: rates, 
    isLoading: isLoadingRates, 
    isError: isErrorRates,
    error: ratesError 
  } = useQuery({
    queryKey: ['/api/exchange-rates/bnr/all'],
    queryFn: async () => {
      try {
        const data = await fetchExchangeRates();
        
        if (!data.rates) {
          throw new Error('Invalid response format: missing rates data');
        }
        
        // Convert object to array and filter only the currencies we want to display
        return {
          base: data.base || 'RON',
          date: data.date || new Date().toISOString().split('T')[0],
          rates: DISPLAY_CURRENCIES.map(currency => ({
            currency,
            rate: data.rates[currency] || 0,
            // Trend and change will be added after we get historical data
            trend: 'stable' as const,
            change: 0
          })).filter(rate => rate.rate > 0),
        };
      } catch (err) {
        console.error('Error fetching exchange rates:', err);
        throw err;
      }
    },
    staleTime: 60 * 60 * 1000, // 1 hour
  });
  
  // Query to fetch historical exchange rates for trends
  const { 
    data: historicalData,
    isLoading: isLoadingHistorical,
    isError: isErrorHistorical
  } = useQuery({
    queryKey: ['/api/exchange-rates/historical'],
    queryFn: async () => {
      try {
        return await fetchHistoricalExchangeRates(DISPLAY_CURRENCIES, 10);
      } catch (err) {
        console.error('Error fetching historical exchange rates:', err);
        throw err;
      }
    },
    staleTime: 60 * 60 * 1000, // 1 hour
  });
  
  // Combine current rates with trend data
  const ratesWithTrends = useMemo(() => {
    if (!rates?.rates || !historicalData?.data || historicalData.data.length < 2) 
      return rates?.rates;
    
    // Get the latest and previous data points
    const latestDay = historicalData.data[historicalData.data.length - 1];
    const previousDay = historicalData.data[historicalData.data.length - 2];
    
    return rates.rates.map(rate => {
      const currency = rate.currency;
      const currentRate = rate.rate;
      const previousRate = previousDay[currency];
      
      // Calculate trend and change
      let trend: 'up' | 'down' | 'stable' = 'stable';
      let change = 0;
      
      if (previousRate && currentRate > 0 && previousRate > 0) {
        change = ((currentRate - previousRate) / previousRate) * 100;
        if (change > 0.01) trend = 'up';
        else if (change < -0.01) trend = 'down';
      }
      
      return {
        ...rate,
        trend,
        change: Math.abs(change),
        previousRate
      };
    });
  }, [rates, historicalData]);
  
  // Determine if we're loading or have an error
  const isLoading = isLoadingRates || isLoadingHistorical;
  const isError = isErrorRates || isErrorHistorical;
  const error = ratesError;
  
  // Mutation to manually refresh rates
  const refreshMutation = useMutation({
    mutationFn: refreshExchangeRates,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/exchange-rates/bnr/all'] });
      toast({
        title: 'Curs actualizat',
        description: 'Ratele de schimb au fost actualizate cu succes.',
        variant: 'default',
      });
    },
    onError: (error) => {
      toast({
        title: 'Eroare',
        description: `Nu s-au putut actualiza ratele de schimb: ${error instanceof Error ? error.message : 'Eroare necunoscută'}`,
        variant: 'destructive',
      });
    },
  });
  
  // Filter rates based on active tab and combine with trend info
  const getDisplayRates = () => {
    if (!ratesWithTrends) return [];
    
    const currentTab = TABS.find(tab => tab.id === activeTab);
    if (!currentTab) return ratesWithTrends;
    
    return ratesWithTrends.filter(rate => 
      currentTab.currencies.includes(rate.currency)
    );
  };
  
  // Get trend indicator component
  const getTrendIndicator = (trend: 'up' | 'down' | 'stable', change: number) => {
    if (trend === 'up') return <TrendingUp className="h-4 w-4 text-red-500" />;
    if (trend === 'down') return <TrendingDown className="h-4 w-4 text-green-500" />;
    return <Minus className="h-4 w-4 text-gray-400" />;
  };
  
  // Historical record type for type safety
  type HistoricalRecord = {
    date: string;
    [key: string]: string | number | null;
  };
  
  // Chart data point type
  type ChartDataPoint = {
    date: string;
    value: number;
  };
  
  // Generate mini sparkline chart for a currency
  const getMiniChart = (currency: string) => {
    if (!historicalData?.data || historicalData.data.length < 2) {
      return (
        <div className="flex items-center justify-center h-6 w-full text-xs text-gray-400">
          Date insuficiente pentru grafic
        </div>
      );
    }
    
    // Get raw data for this currency
    const rawData = historicalData.data.map((day: HistoricalRecord) => ({
      date: day.date,
      value: day[currency] !== null ? (day[currency] as number) : null
    }));
    
    // Fill in null values with interpolated values for better graph continuity
    let chartData: ChartDataPoint[] = [];
    let lastValidIndex: number = -1;
    
    // First pass - find valid values and simple fills
    for (let i = 0; i < rawData.length; i++) {
      if (rawData[i].value !== null) {
        // Add directly if it's a valid point
        chartData.push({
          date: rawData[i].date,
          value: rawData[i].value as number
        });
        lastValidIndex = chartData.length - 1;
      } else if (lastValidIndex !== -1) {
        // We have a previous valid point, use its value temporarily
        chartData.push({
          date: rawData[i].date,
          value: chartData[lastValidIndex].value
        });
      } else {
        // No valid points yet, look ahead for the first valid point
        const nextValidIndex = rawData.findIndex((d, idx) => idx > i && d.value !== null);
        if (nextValidIndex !== -1) {
          // Found a future valid point, use its value
          chartData.push({
            date: rawData[i].date, 
            value: rawData[nextValidIndex].value as number
          });
        } else {
          // No valid points at all, skip
          continue;
        }
      }
    }
    
    // Second pass - interpolate between known values for better curves
    for (let i = 1; i < chartData.length - 1; i++) {
      // Find the previous and next concrete (non-interpolated) data points
      const prevIdx = rawData.findIndex(d => d.date === chartData[i-1].date && d.value !== null);
      const nextIdx = rawData.findIndex((d, idx) => idx > (prevIdx !== -1 ? prevIdx : i-1) && d.value !== null);
      
      if (prevIdx !== -1 && nextIdx !== -1) {
        const prevValue = rawData[prevIdx].value as number;
        const nextValue = rawData[nextIdx].value as number;
        const totalDistance = nextIdx - prevIdx;
        const currentPosition = i - prevIdx;
        
        // Linear interpolation
        if (totalDistance > 1) {
          chartData[i].value = prevValue + (nextValue - prevValue) * (currentPosition / totalDistance);
        }
      }
    }
    
    if (chartData.length < 2) {
      return (
        <div className="flex items-center justify-center h-6 w-full text-xs text-gray-400">
          Date insuficiente pentru grafic
        </div>
      );
    }
    
    // Determine trend for chart color
    const firstValue = chartData[0].value;
    const lastValue = chartData[chartData.length - 1].value;
    const chartTrend = lastValue > firstValue ? 'up' : lastValue < firstValue ? 'down' : 'stable';
    
    // Calculate chart dimensions and scale
    const width = 200;
    const height = 40;
    const padding = 5;  // Padding around the chart
    
    const effectiveWidth = width - (padding * 2);
    const effectiveHeight = height - (padding * 2);
    
    const min = Math.min(...chartData.map((d: ChartDataPoint) => d.value));
    const max = Math.max(...chartData.map((d: ChartDataPoint) => d.value));
    
    // Add a small buffer to min/max for visual appeal
    const valueRange = (max - min) * 1.1 || 1; // Avoid division by zero and add 10% buffer
    
    // Generate path for the sparkline
    const points = chartData.map((d: ChartDataPoint, i: number) => {
      const x = padding + (i / (chartData.length - 1)) * effectiveWidth;
      const y = height - padding - ((d.value - min) / valueRange) * effectiveHeight;
      return `${x},${y}`;
    });
    
    const path = `M${points.join(' L')}`;
    
    // Choose color based on trend
    const strokeColor = chartTrend === 'up' 
      ? 'rgb(239, 68, 68)' // red-500
      : chartTrend === 'down' 
        ? 'rgb(34, 197, 94)' // green-500
        : 'rgb(156, 163, 175)'; // gray-400
    
    const fillColor = chartTrend === 'up' 
      ? 'rgba(239, 68, 68, 0.1)' // red-500 with alpha
      : chartTrend === 'down' 
        ? 'rgba(34, 197, 94, 0.1)' // green-500 with alpha
        : 'rgba(156, 163, 175, 0.1)'; // gray-400 with alpha
    
    // Create area fill path (path + bottom line back to start)
    const areaPath = `${path} L${padding + effectiveWidth},${height - padding} L${padding},${height - padding} Z`;
    
    // Calculate dot positions for first, last, min and max values
    const firstPoint = points[0].split(',').map(Number);
    const lastPoint = points[points.length - 1].split(',').map(Number);
    
    // Find min and max value indices
    const minIndex = chartData.findIndex(d => d.value === min);
    const maxIndex = chartData.findIndex(d => d.value === max);
    
    // Convert to point coordinates
    const minPoint = minIndex >= 0 ? points[minIndex].split(',').map(Number) : null;
    const maxPoint = maxIndex >= 0 ? points[maxIndex].split(',').map(Number) : null;
    
    return (
      <svg width={width} height={height} className="opacity-90">
        {/* Area fill */}
        <path 
          d={areaPath} 
          fill={fillColor}
        />
        
        {/* Line */}
        <path 
          d={path} 
          fill="none" 
          stroke={strokeColor} 
          strokeWidth="2" 
          strokeLinecap="round" 
          strokeLinejoin="round"
        />
        
        {/* Dots for start and end */}
        <circle cx={firstPoint[0]} cy={firstPoint[1]} r="2.5" fill="#fff" stroke={strokeColor} strokeWidth="1.5" />
        <circle cx={lastPoint[0]} cy={lastPoint[1]} r="3" fill={strokeColor} />
        
        {/* Grid lines */}
        <line 
          x1={padding} x2={width - padding} 
          y1={height - padding} y2={height - padding} 
          stroke="#e5e7eb" strokeWidth="1" strokeDasharray="3,3" 
        />
        
        <text x="5" y="15" className="text-xs fill-gray-400" fontSize="8">
          {chartData.length > 0 ? formatDate(new Date(chartData[0].date)) : ''}
        </text>
        
        <text x={width - 50} y="15" className="text-xs fill-gray-400" fontSize="8" textAnchor="end">
          {chartData.length > 0 ? formatDate(new Date(chartData[chartData.length - 1].date)) : ''}
        </text>
      </svg>
    );
  };
  
  // Handle manual refresh
  const handleRefresh = () => {
    refreshMutation.mutate();
  };
  
  // If there's an error, show error state
  if (isError) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle className="text-lg">Curs BNR</CardTitle>
          <CardDescription>Ratele oficiale de schimb</CardDescription>
        </CardHeader>
        <CardContent className="p-6 text-center">
          <AlertCircle className="h-12 w-12 text-destructive mx-auto mb-4" />
          <p className="mb-2 font-medium">Eroare la încărcarea datelor</p>
          <p className="text-sm text-muted-foreground mb-4">
            {error instanceof Error ? error.message : 'Nu s-au putut încărca ratele de schimb'}
          </p>
          <Button 
            variant="outline" 
            size="sm" 
            onClick={() => queryClient.invalidateQueries({ queryKey: ['/api/exchange-rates/bnr/all'] })}
          >
            <RefreshCw className="h-4 w-4 mr-2" />
            Reîncearcă
          </Button>
        </CardContent>
      </Card>
    );
  }
  
  return (
    <Card className="w-full">
      <CardHeader className="pb-3">
        <div className="flex justify-between items-center">
          <div>
            <CardTitle className="text-lg">Curs BNR</CardTitle>
            <CardDescription>
              {rates?.date 
                ? `Actualizat: ${formatDate(new Date(rates.date))}`
                : 'Ratele oficiale de schimb'
              }
            </CardDescription>
          </div>
          <Button 
            variant="outline" 
            size="sm" 
            onClick={handleRefresh}
            disabled={refreshMutation.isPending}
          >
            <RefreshCw className={`h-4 w-4 mr-2 ${refreshMutation.isPending ? 'animate-spin' : ''}`} />
            Actualizează
          </Button>
        </div>
      </CardHeader>
      <CardContent className="pb-2">
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <TabsList className="mb-4">
            {TABS.map((tab) => (
              <TabsTrigger key={tab.id} value={tab.id}>
                {tab.label}
              </TabsTrigger>
            ))}
          </TabsList>
          
          {isLoading ? (
            <div className="py-6 space-y-4">
              {[1, 2, 3].map((i) => (
                <div key={i} className="flex flex-col animate-pulse">
                  <div className="flex justify-between">
                    <div className="h-5 w-12 bg-muted rounded"></div>
                    <div className="h-5 w-20 bg-muted rounded"></div>
                  </div>
                  <div className="h-6 w-full bg-muted rounded mt-2 opacity-40"></div>
                </div>
              ))}
            </div>
          ) : (
            <div className="space-y-4">
              {getDisplayRates().map((rate) => (
                <div key={rate.currency} className="pb-3">
                  <div className="flex justify-between items-center mb-2">
                    <div className="flex items-center">
                      <div className="font-medium text-lg">{rate.currency}</div>
                      <div className="ml-2 px-2 py-0.5 text-xs bg-gray-100 rounded-full">
                        {rate.currency === 'EUR' ? 'Euro' : 
                         rate.currency === 'USD' ? 'Dolar SUA' : 
                         rate.currency === 'TRY' ? 'Liră turcească' : rate.currency}
                      </div>
                    </div>
                    <div className="flex items-center">
                      <span className="tabular-nums font-medium text-lg">
                        {formatNumber(rate.rate, 4)}
                      </span>
                      <span className="ml-2">
                        {getTrendIndicator(rate.trend, rate.change)}
                      </span>
                      <span className={`ml-2 text-xs ${rate.trend === 'up' ? 'text-red-500' : rate.trend === 'down' ? 'text-green-500' : 'text-gray-500'}`}>
                        {rate.change > 0 ? `+${rate.change.toFixed(2)}%` : rate.change < 0 ? `${rate.change.toFixed(2)}%` : '0.00%'}
                      </span>
                    </div>
                  </div>
                  
                  {/* 10-day trend mini chart with label */}
                  <div className="mt-2">
                    <div className="text-xs text-gray-500 mb-1">Evoluție ultimele 10 zile:</div>
                    <div className="bg-gray-50 p-2 rounded-md flex justify-center">
                      {getMiniChart(rate.currency)}
                    </div>
                  </div>
                  
                  {/* Separator between rates */}
                  {rate.currency !== getDisplayRates()[getDisplayRates().length - 1].currency && (
                    <Separator className="mt-4" />
                  )}
                </div>
              ))}
            </div>
          )}
        </Tabs>
      </CardContent>
      <CardFooter className="pt-1">
        <p className="text-xs text-muted-foreground">Sursă: Banca Națională a României</p>
      </CardFooter>
    </Card>
  );
};

export default ExchangeRateWidget;