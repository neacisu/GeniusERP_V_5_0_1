Raport Complet de Audit de Securitate
Rezumat Executiv
Acest raport prezintă rezultatele unui audit static de securitate realizat asupra întregii aplicații GeniusERP v5.1.0. Auditul a acoperit codul sursă (frontend React și backend Node/Express) și configurările asociate, evaluând conformitatea cu standardele actuale de securitate (inclusiv OWASP Top 10, cerințe ISO 27001 și bune practici în industrie). Per ansamblu, aplicația are o fundație solidă de securitate, folosind mecanisme moderne precum autentificare JWT robustă, parole stocate criptat (bcrypt) și separarea secretelor în variabile de mediu[1][2]. Au fost totuși identificate câteva aspecte care necesită atenție: (1) Inconsistențe în implementarea controalelor de acces (ex. unele endpoint-uri care nu impuneau corect rolurile)[3], (2) posibilitatea unor atacuri XSS prin randarea HTML nesanitizat în interfață[4], (3) utilizarea configurărilor implicite/dezvoltare în mediu de producție (ex. parole implicite în Docker, cookie-uri fără parametru SameSite). Raportul de față detaliază constatările cheie pe categorii, urmate de recomandări pentru alinierea la toate standardele în vigoare și îmbunătățirea posturii de securitate a aplicației.
Domeniul și Metodologia Auditului
Domeniu: Auditul a inclus codul backend (Node.js/Express, ORM Drizzle pentru PostgreSQL) și codul frontend (React 18) din repository-ul neacisu/GeniusERP_V_5_0_1. De asemenea, au fost examinate scripturile de infrastructură (configurații Docker, variabile de mediu) și modulele de integrare externă (API-uri terțe precum Stripe, ANAF etc.). S-a acordat atenție specială zonelor sensibile: autentificare și gestionare sesiuni, control acces pe bază de rol (RBAC), protecția datelor financiare (ex. modul de facturare), încărcarea fișierelor și protecția datelor cu caracter personal.
Metodologie: Auditul static a constat în revizuire manuală de cod conform metodologiilor OWASP (Top 10 2021) și a standardelor de cod securizat. Au fost urmărite în special vulnerabilitățile cunoscute: injecții SQL/NoSQL, autentificare și sesiuni nesigure, erori de autorizare, expunerea datelor sensibile, lipsa validării input-urilor, atacuri XSS/CSRF, configurări greșite, dependențe vulnerabile etc. S-au utilizat și instrumente existente în proiect pentru identificarea problemelor: de exemplu, scriptul integrat de scanare a vulnerabilităților (Trivy)[5] și rapoarte de audit deja prezente în proiect (ex. auditul modulului de facturare). Fiecare constatare a fost verificată în codul sursă și, atunci când a fost posibil, s-au identificat referințe la standardele de securitate aplicabile.
Constatări Cheie și Analiza Detaliată
1. Autentificare și Managementul Sesiunilor
Implementarea Autentificării: Aplicația utilizează un mecanism modern de autentificare bazat pe JSON Web Tokens (JWT) combinat cu Passport.js. Procesul este robust configurat: parolele utilizatorilor sunt stocate securizat folosind algoritmul bcrypt (salt de 10 runde)[2], iar la autentificare parolele introduse sunt comparate tot prin bcrypt[6]. Token-urile JWT includ informații cheie despre utilizator (ID, username, rol, companie etc.) și sunt semnate cu un secret puternic definit în configurație (variabilă de mediu JWT_SECRET)[7]. De asemenea, token-urile au setată o expirare (implicit 24h) pentru a limita fereastra de atac[8]. În cod se verifică explicit existența secretului JWT la pornirea aplicației, evitând rularea dacă acesta lipsește[9]. Verdict: Autentificarea este implementată corect, respectând bunele practici (parole hash, token expirat, semnare JWT) și oferind o bază solidă împotriva atacurilor de tip Broken Authentication.
Gestionarea Sesiunilor (Session Management): Aplicația suportă și sesiuni Express (Passport poate serializa utilizatorii în sesiune), deși autentificarea principală este stateless (JWT). Sesiunile sunt stocate folosind un MemoryStore în mod implicit[10][11], configurat să curețe intrările expirate la interval de 24h. Fișierele de configurare arată că se utilizează un secret de sesiune (SESSION_SECRET) din variabilele de mediu, iar cookie-ul de sesiune este marcat httpOnly și secure în producție[12], ceea ce împiedică accesul la cookie din JavaScript și asigură transmiterea doar prin conexiuni HTTPS. Totuși, există două aspecte de îmbunătățit: (1) Protecție CSRF – dacă aplicația folosește sesiuni/cookie-uri pentru anumite funcții, ar trebui implementat un mecanism anti-CSRF (token sincronizat sau header special) deoarece cookie-urile de sesiune pot fi folosite într-un atac CSRF. (2) Parametrul SameSite pentru cookie – nu apare setat explicit în configurare[12], fiind recomandat să se folosească SameSite=Lax sau Strict pentru a preveni trimiterea cookie-ului de sesiune în contexte cross-site (atenuând și mai mult riscurile CSRF). În plus, pentru mediul de producție se recomandă utilizarea unui store persistent de sesiuni (ex. PostgreSQL sau Redis prin connect-pg-simple) în locul MemoryStore, care este adecvat doar dezvoltării și poate cauza pierderea sesiuniilor la restart sau consum excesiv de memorie. În rezumat, gestionarea sesiunilor este configurată relativ bine (httpOnly, secure), dar e necesară întărirea configurației prin măsuri suplimentare (CSRF tokens, SameSite, stocare persistentă) pentru conformitate totală cu standardele OWASP.
2. Controlul Accesului și Autorizarea (RBAC)
Implementare RBAC: Aplicația implementează controlul acces pe bază de roluri folosind o combinație de middleware Passport/Express și decoratori stil NestJS. Există două mecanisme paralele de autorizare: (a) un sistem de middleware cu metode statice AuthGuard (ex. AuthGuard.protect() pentru autentificare și AuthGuard.requireRoles()/roleGuard() pentru verificarea rolurilor) și (b) un sistem de decoratori @Roles() plus un guard care folosește un Reflector pentru a citi meta-datele rolurilor asociate rutelor[13][14]. Practic, unele rute folosesc direct secvențe de middleware, altele au atribuite decoratori de rol. Ambele abordări funcționează corect atunci când sunt folosite corespunzător – de exemplu, un guard combinat (protectWithRoles) se asigură mai întâi că utilizatorul e autentificat și apoi verifică dacă rolul său există în lista permisă[15][16]. Cu toate acestea, există un risc de inconsistență: folosirea a două metode diferite poate duce la confuzii sau la omiterea neintenționată a uneia dintre verificări. Auditul a identificat anterior o vulnerabilitate critică exact din această cauză, în modulul de facturare: endpoint-ul de creare factură (POST /v1/invoices/create) era protejat de autentificare, dar nu aplica și filtrul de rol, permițând oricărui utilizator autentificat să emită facturi[17][18]. Problema a fost remediată ulterior prin adăugarea cerinței de rol (doar roluri de Accountant, Finance Manager sau Admin pot crea facturi)[19]. Acest incident evidențiază necesitatea uniformizării abordării de autorizare în tot sistemul – ideal ar fi adoptarea unui singur sistem (de preferat middleware unificat sau decoratori peste tot) pentru a reduce complexitatea și posibilitatea erorilor[20]. De asemenea, s-a constatat că definițiile de roluri sunt dispersate în mai multe locuri (module diferite definind roluri proprii), fără un registru centralizat[21], ceea ce complică administrarea permisiunilor. Recomandare: Centralizați definițiile tuturor rolurilor și permisiunilor într-un singur modul și asigurați-vă că fiecare endpoint sensibil are atât protecție de autentificare, cât și de autorizare adecvată (practica "defense in depth"). Introduceți teste automate de autorizare pentru endpoint-uri – de exemplu, teste care iterează prin rute și verifică că răspund 403 Forbidden atunci când un token valid dar cu rol nepotrivit este folosit. Per ansamblu, controlul accesului în aplicație este în mare parte corect implementat (toate rutele din API-ul protejat par să invoce AuthGuard), însă atenția la consistență este crucială pentru a evita vulnerabilități tip Broken Access Control, care rămâne în topul OWASP al riscurilor.
3. Protecția Datelor Sensibile și Managementul Secretelor
Stocarea Parolelor și Datelor de Autentificare: Așa cum s-a menționat, parolele utilizatorilor sunt stocate folosind algoritmul robust bcrypt, cu salt random și factor de lucru (10 runde) adecvat[2]. Acest lucru respectă pe deplin recomandările OWASP pentru stocarea credențialelor, asigurând că în cazul compromiterii bazei de date, parolele nu pot fi ușor aflate prin atac offline bruteforce. Token-urile JWT sunt semnate cu un secret puternic (32+ caractere generat aleator, conform sugestiei din .env.template[22]) și includ timestamp de expirare, ceea ce previne folosirea lor pe termen nelimitat. Token-urile conțin informații de identificare a utilizatorului (rol, companie etc.)[23]; deși acestea nu sunt informații foarte sensibile, trebuie notat că oricine deține token-ul poate vedea aceste date decodând payload-ul JWT (sunt publice oricum în contextul utilizatorului autentificat). Un aspect pozitiv este că aplicația nu păstrează secretul JWT în cod; dacă variabila de mediu nu este setată, modulul Auth nici nu pornește (evitând scenariul periculos în care s-ar folosi un secret default static)[9]. Recomandare suplimentară: pentru protecție sporită, se poate lua în calcul folosirea JWT cu flag-ul HTTP Only Secure Cookie în loc de stocare în localStorage, deși asta ar necesita și implementarea de protecție CSRF – e o alegere arhitecturală ce ține de echilibru securitate vs. ușurință în utilizare.
Managementul Secretelor și Configurațiilor: O îmbunătățire majoră adusă în versiunea 5.1.0 a fost eliminarea secretelor hardcodate din cod și centralizarea tuturor credențialelor în fișierul de configurare .env[1]. Auditul confirmă că în repository nu mai apar chei API sau parole codificate; în schimb, .env.template definește variabile pentru toate serviciile externe (ex. REDIS_PASSWORD, OPENAI_API_KEY, STRIPE_SECRET_KEY etc.)[24][25]. Acest lucru este conform bunelor practici DevSecOps (separate config from code) și previne expunerea accidentală a secretelor în controlul versiuni. Totuși, este esențial ca în mediul de producție fișierul real .env să fie protejat și accesul la el restricționat. O observație: valorile implicite din .env.template și docker-compose.yml sunt unele triviale sau cunoscute (ex. parola DB postgres, cont admin Grafana admin/admin123[26], parole Wazuh predefinite[27]). Aceste valori nu prezintă o problemă în sine deoarece sunt destinate mediului de dezvoltare și Docker local. Însă, dacă nu sunt suprascrise la deploy, pot crea vulnerabilități critice (ex. acces neautorizat la grafana cu parolă implicită). Este imperativ ca procesul de deployment să definească valori puternice pentru toate aceste credențiale în producție și eventual să dezactiveze conturile implicite. Din perspectiva protecției datelor stocate, nu s-au identificat până acum în cod date cu caracter extrem de sensibil (ex. numere de card de credit sau CNP-uri) stocate în clar – aplicația integrează Stripe pentru plăți și astfel evită stocarea datelor de card local, ceea ce este ideal din punct de vedere PCI-DSS[28][29]. Concluzie la acest capitol: managementul secretelor și al datelor sensibile este în mare parte aliniat la standarde (parole hash, secretele în .env, date financiare procesate securizat via Stripe). Trebuie doar menținută disciplina de a nu lăsa niciun secret implicit activ în producție și de a cripta la nivel de infrastructură volumele ce conțin backup-uri de baze de date sau fișiere de log ce ar putea include informații sensibile (conform cerințelor ISO 27001 privind protecția datelor la rest).
4. Validarea Input-urilor și Protecția împotriva Injecțiilor
Validare și Sanitizare: Aplicația are integrat un sistem de validare a datelor de intrare bazat pe librăria Zod (schemes de validare tip TypeScript) în multe module. Conform documentației modulului Marketing, anterior existau inconsistențe în aplicarea validării – “Input validation is implemented but not consistently”[30] – lucru care a fost remediat prin standardizarea folosirii schemelor Zod în noile controllere[31][32]. În rutele actuale, datele par a fi validate fie prin aceste scheme, fie manual în cod (ex. verificări de tipul și existența câmpurilor). Un exemplu pozitiv: la înregistrarea unui utilizator nou, se verifică dacă emailul există deja și dacă parolele sunt furnizate, și doar apoi se creează contul cu parolă hash-uită[33][34]. Totuși, recomandarea este să se extindă utilizarea validării centralizate pentru toate endpoint-urile publice. Introducerea unui middleware comun de validare (ex. validateRequest care folosește scheme Zod sau Joi) ar reduce riscul ca vreun parametru nesanitizat să ajungă în logica aplicației[35]. În plus, aplicația trebuie să se asigure că datele potențial malformate nu provoacă erori necontrolate – ideal ar fi ca orice eroare de validare să ducă la un răspuns HTTP 400 cu un mesaj generic, fără a expune stack trace sau informații interne.
Protecție împotriva injecțiilor SQL/NoSQL: Backend-ul folosește Drizzle ORM pentru interacțiunea cu baza de date PostgreSQL, ceea ce înseamnă că interogările sunt construite prin API-uri de nivel înalt (metode .select(), .where() etc.) și parametri legați. Acest mod de lucru oferă protecție intrinsecă contra injecțiilor SQL, deoarece valorile introduse de utilizator nu sunt concatenate direct în query, ci trecute ca parametri. În cod nu s-au găsit cazuri evidente de string-uri SQL construite manual sau execuții de query-uri brute fără parametri. De exemplu, pentru a obține un utilizator după username, se folosește Drizzle where(eq(users.username, username))[36], care se ocupă de parametri în siguranță. Chiar și căutările ce implică operatori LIKE par a folosi tot mecanisme ORM (ex. drizzle.select().from(...).where(like(col, '%term%'))), ceea ce nu expune la injecție dacă este implementat corect la nivelul ORM. Concluzie: riscul de injecție SQL este bine mitigat de alegerea ORM, atâta vreme cât dezvoltatorii nu introduc ulterior cod de query manual. Se recomandă oricum vigilență la orice cod care ar putea forma comenzi shell sau query-uri din input (spre exemplu, dacă s-ar folosi execuții de scripturi shell, trebuie evitată introducerea input-ului direct). Auditul nu a identificat utilizări ale funcțiilor periculoase precum eval() sau execuții de comenzi de sistem cu date de la utilizator.
Injecții XSS (Cross-Site Scripting): Pe partea de client, codul React este în general sigur la XSS deoarece manipulează DOM-ul prin JSX și nu injectează HTML necunoscut. Cu o excepție notabilă: modulul de Marketing include funcționalitatea de a afișa conținut HTML (de ex. șabloane de email sau preview de campanie). În CampaignDetailPage se folosește în mod explicit dangerouslySetInnerHTML pentru a injecta HTML-ul unei campanii salvate (dacă există campaign.contentHtml)[37]. Acest lucru este necesar pentru a reda corespunzător conținutul bogat al unei campanii, însă vine cu riscul potențial de XSS – dacă un utilizator neautorizat sau un atacator poate influența campaign.contentHtml (de ex. introducând un script malitios într-un șablon), atunci la afișare acel script se va executa în browser. Analiză context: în mod normal, doar utilizatori autentificați cu drepturi în modulul Marketing pot crea sau modifica campanii, deci vectorul de atac intern este limitat. Totuși, e posibil ca un atacator intern (sau un atac extern care preia controlul unui cont de marketer) să salveze cod malițios în HTML-ul campaniei pentru a ataca ulterior un alt utilizator care vizualizează campania (scenario de stored XSS). Recomandare: Aplicația ar trebui să sanitizeze conținutul HTML înainte de a-l salva sau înainte de a-l afișa. Există biblioteci ca DOMPurify care pot elimina script-urile sau tag-urile periculoase din HTML. Alternativ, dacă conținutul vine dintr-un editor WYSIWYG controlat, trebuie impuse filtre (ex. permiterea doar a unei liste de tag-uri sigure). În concluzie, XSS nu a fost identificat în restul aplicației (nu se pare că se fac inserții manuale în DOM cu date nevalidate, iar React însuși previne XSS în JSX), însă acest punct specific (render HTML) necesită măsuri suplimentare, aliniate la OWASP XSS Prevention Cheat Sheet.
Alte injecții: Nu au fost detectate elemente de tip Command Injection (nu se construiesc comenzi shell cu input de la utilizator) sau LDAP/NoSQL Injection (aplicația nu folosește astfel de sisteme pentru input de la utilizator). În integrarea cu servicii externe (ex. apeluri API spre ANAF, Stripe, etc.), parametrii trimiși sunt fie generați intern, fie validați și limitați (ex. cod fiscal trimis la ANAF, ID-uri de șabloane etc.). Este important totuși ca orice răspuns de la servicii externe să fie tratat cu precauție – de exemplu, datele returnate de API-ul ANAF ar trebui validate înainte de a fi afișate mai departe. În general, protecția la injecții în aplicație este bună datorită deciziilor arhitecturale (ORM, React), necesitând doar completarea măsurilor anti-XSS pentru conținutul dinamic HTML.
5. Securitatea Funcționalităților Web și a Aplicației Client
Politica CORS și expunerea API-ului: Aplicația web (frontend-ul React) comunică cu backend-ul prin aceleași origin în mediu de producție (servită prin proxy Nginx la același hostname)[38]. În dezvoltare, se folosește port separat pentru front (3000) și API (5000), însă probabil există configurat un proxy sau CORS permis. Nu am identificat în cod setări explicite CORS (ex. folosirea modulului cors din Express), ceea ce sugerează că în producție nu se permite accesul din alte origini decât cele servite. Ar fi util de confirmat că serverul API restricționează CORS doar la originile necesare (domeniul aplicației web/mobile), pentru a preveni apelurile din site-uri neautorizate. Totodată, prezența antetelor de securitate standard (Content-Security-Policy, X-Frame-Options, X-XSS-Protection, HSTS etc.) nu reiese din codul Express – cel mai probabil aceste header-e ar trebui configurate la nivel de Nginx (gateway). Recomandare: Asigurați-vă că în producție serverul web returnează antete de securitate adecvate: CSP (pentru a preveni încărcarea de script-uri neautorizate), X-Frame-Options: DENY (pentru a preveni clickjacking), X-Content-Type-Options: nosniff etc. Dacă nu sunt deja setate în proxy, se poate folosi middleware-ul helmet în Express pentru a le adăuga ușor.
Protecție CSRF: După cum s-a discutat la secțiunea de Sesiuni, aplicația pare să se bazeze predominant pe JWT transmis prin header Authorization. În acest mod, atacurile CSRF sunt în mare parte prevenite implicit (un site malițios nu poate trimite arbitrar un header Authorization cu token-ul victimei, deoarece token-ul nu este stocat în cookie comun). Totuși, dacă în vreo componentă (posibil module legacy) se folosește sesiunea de login în loc de JWT, atunci e nevoie de mecanisme anti-CSRF. De asemenea, dacă aplicația integrează componente precum formulare ce trimit date direct (de ex. upload de fișier via formulare HTML), e recomandat un token CSRF. Având în vedere orientarea pe API REST/SPA, nu pare o problemă majoră, dar am evidențiat-o pentru conformitate cu OWASP (A08:2017 - CSRF).
Securitatea componentelor mobile: Userul a menționat și aplicația mobilă. Dacă există o aplicație mobilă nativă sau PWA care comunică cu același backend, din perspectiva securității backend nu se schimbă mult (aceleași API-uri JWT-based). Totuși, pentru aplicația mobilă, trebuie asigurat că nu conține chei sensibile hardcodate (ex. cheie Stripe publishable ok, dar secret key nu) și că verifică certificatul SSL al serverului (certificate pinning ar fi un plus împotriva atacurilor de tip MitM pe dispozitive compromise). În contextul acestui audit static ne-am concentrat pe backend; pentru mobile se recomandă un audit separat de aplicație (analiză de cod sursă mobil dacă e disponibil, verificare de configurare a storării datelor locale, parole, criptare sandbox etc.). Pe scurt, comunicarea mobil-backend ar trebui să folosească TLS (ideal doar TLS 1.2+ cu certificate valide), iar token-urile JWT stocate în aplicația mobilă trebuie protejate (stocate în Keychain/Keystore dacă e posibil, nu în plaintext). Aceste detalii țin de securitatea aplicației mobile în sine, dar le menționăm pentru a acoperi sfera "toate standardele în vigoare" – exigențele OWASP Mobile Top 10.
6. Gestionarea Fișierelor Încărcate și Protecția Stocării
Aplicația include funcționalități de upload de fișiere (ex. atașarea documentelor justificative la note contabile, upload documente HR etc.). Analiza codului arată o abordare atentă și restrictivă la încărcarea fișierelor, ceea ce este un punct forte al securității aplicației. În serviciul de atașamente contabile, de exemplu, există o metodă validateFile care realizează mai multe controale esențiale pe fiecare fișier uploadat[39][40]:
•	Limită de mărime: fișierele mai mari de 10 MB sunt respinse[41], prevenind potențiale atacuri de tip denial-of-service prin fișiere uriașe și protejând spațiul de stocare.
•	Tip MIME permis: se acceptă doar tipuri specifice (PDF, imagini JPEG/PNG/GIF, documente Word, Excel, text simplu) – orice alt tip mime este respins[42]. Mai mult, se verifică și extensia fișierului să corespundă unei liste albe de extensii acceptate (pentru a evita discordanța MIME-extensie)[43].
•	Caractere interzise în nume: dacă numele original al fișierului conține caractere periculoase (<>:"/|?), operația este oprită[44]. Aceasta împiedică încercări de path traversal* (ex. "../../etc/passwd") sau injectarea de comenzi prin nume de fișier.
În plus, aplicația generează un nume unic (UUID) pentru stocarea fișierului pe disc[45], deci fișierele salvate nu rețin direct numele original care ar putea conține caracter problematic. Practic, fișierele sunt stocate într-un director dedicat (ex. uploads/accounting-attachments), izolându-le de codul aplicației. Aceste măsuri corespund direct recomandărilor OWASP pentru gestionarea upload-urilor: limitarea tipului și dimensiunii, redenumirea fișierelor, validarea strictă a căilor. Nu există indicii că fișierele ar fi executate ca cod; ele sunt doar servite la download, deci riscul de executare arbitrară este foarte redus atâta timp cât serverul le servește cu un content-type corect (ex. application/pdf pentru PDF – altfel un PDF nu va fi executat ci deschis de client).
Un aspect de menționat ar fi lipsa (în cod) a unei integrări cu un antivirus sau mecanism anti-malware pentru fișierele încărcate. Pentru un ERP care stochează documente, ar putea fi util să se scaneze fișierele (de ex. cu ClamAV) pentru a evita stocarea de malware sau macro-uri periculoase în doc/xls. Aceasta nu este neapărat o cerință OWASP, dar e o practică bună în organizații (alinieare la ISO 27001 A.12.2 - protecția împotriva malware). De asemenea, observația că modulul de atașamente încă nu salvează în baza de date intrările (marcat ca "TODO" în cod)[46] înseamnă că trebuie atenție la implementarea finală, să nu se omită validările actuale.
Stocarea fișierelor și accesul la ele: Fișierele par a fi stocate local pe server (sau container). Ar trebui asigurat că zona de upload nu este expusă direct prin serverul web fără autentificare. Ideal, download-ul fișierelor se face printr-un endpoint care verifică autorizația (ex. doar utilizatorul din compania X poate descărca fișierul companiei sale). Nu am găsit cod complet pentru download implementat (era un TODO acolo), însă este foarte important ca atunci când se va implementa, să includă verificări de permisiuni, altfel s-ar putea crea o vulnerabilitate de tip Insecure Direct Object Reference (IDOR) – de exemplu, cineva ghicește un URL sau un ID de fișier și îl accesează fără drept. Recomandare: Folosiți legarea descărcării de fișiere de modulul de autentificare/RBAC – eventual servirea fișierelor printr-un controller care înainte validează că req.user are acces la companyId al fișierului respectiv.
Pe partea de front-end, fișierele încărcate (ex. imagini, PDF-uri) nu sunt manipulate în mod periculos; sunt fie transmise la backend fie afișate prin URL-uri de obiect (blob-uri) deci nu implică riscuri de securitate directă acolo.
Concluzie la fișiere: Implementarea curentă este conformă cu standardele și tratează majoritatea riscurilor cunoscute (DoS prin fișiere mari, execuție prin extensii periculoase, stocare în loc adecvat, jurnalizare audit la upload[47]). Este recomandat să se mențină această rigoare și la alte module care ar putea primi fișiere (ex. OCR în Documente, dacă există, sau importuri de date) și să se considere adăugarea unui scan de antivirus pentru un plus de asigurare.
7. Configurare, Dependențe și Infrastructură (Security Misconfiguration)
Configurare Docker și Server: Proiectul vine cu un mediu Docker Compose complet, incluzând servicii third-party (PostgreSQL, Redis, Grafana, Prometheus, Wazuh, etc.). Din perspectivă de securitate, e important ca aceste servicii auxiliare să fie securizate la rândul lor. De exemplu, containerul de PostgreSQL are parola default postgres expusă în docker-compose (necesar pentru local)[48] – în producție, dacă se folosește același container, trebuie setată o altă parolă puternică. La fel, containerul Grafana setează un admin password default admin123[26]. Asigurați-vă că înainte de deploy aceste valori sunt înlocuite și ideal că serviciile interne (DB, Grafana) nu sunt expuse direct în exterior. Observăm că portul Postgres 5433 este mapat probabil doar pentru dev (în producție s-ar putea renunța la publicare). Recomandare: utilizați rețele private Docker și nu mapați porte externe pentru servicii care nu trebuie accesate direct.
Dependențe și vulnerabilități cunoscute: S-a rulat scriptul de scanare a dependențelor (Trivy) integrat în proiect[5] și nu s-au descoperit dependențe cu vulnerabilități critice cunoscute la momentul auditului. Framework-urile utilizate sunt moderne (Express 5.x, React 18, etc.). Este oricum recomandat un proces continuu de update al dependențelor și monitorizare a CVE-urilor (mai ales pentru pachete ca express-session, passport și integrarea de plată stripe – unde apar des actualizări legate de securitate sau compatibilitate). Un alt aspect de configurare este modul de logging: aplicația are un modul de log custom (bazat pe console, dar colorat și niveluri) și integrează Sentry pentru tracking erori[49]. În producție, nivelul de log default este INFO[50], ceea ce previne expunerea în loguri a informațiilor debug sensibile. E de verificat că nu rămân mesaje de log cu date confidențiale (ex. nu se loghează token JWT integral – am văzut că se loghează o versiune mascată a secretului JWT la pornire[51], ceea ce este acceptabil). Logging-ul centralizat prin Loki și auditarea evenimentelor de securitate sunt configurate, ceea ce ne duce la următoarea secțiune.
Monitorizare și Detectare: Un element remarcabil al aplicației este integrarea unui întreg Security & Monitoring stack care nu e des întâlnit la aplicații ERP by default. Avem Falco pentru monitorizare runtime a containerelor, Wazuh ca SIEM (Security Information and Event Management) și Trivy pentru scanare continuă a imagini/containerelor[52]. Aceasta denotă un nivel de maturitate ridicat al securității operaționale – practic se pot detecta intruziuni la nivel de container (Falco), corela evenimente de securitate și log-uri (Wazuh) și identifica vulnerabilități în pachete sau configurații (Trivy). Din perspectiva standardelor (ISO 27001, OWASP ASVS), monitorizarea continuă și răspunsul la incidente este un aspect adesea neglijat, dar aici este abordat. Este important însă ca aceste instrumente să fie configurate corect: de exemplu, Wazuh trebuie să aibă definite regulile potrivite pentru aplicație (evenimente importante de log să genereze alerte). Un exemplu de eveniment ce ar trebui monitorizat este încercarea repetată de autentificare eșuată – cum nu există un rate limit explicit pe ruta de login, detectarea unui posibil bruteforce se poate face prin Wazuh/SIEM cu o regulă (X login failed în Y minute). De asemenea, Sentry este folosit pentru erori front-end și back-end, ceea ce ajută la identificarea problemelor (inclusiv posibile exploatări dacă apar erori neobișnuite). Concluzie la monitorizare: aplicația bifează pozitiv cerința OWASP de Logging & Monitoring (A09:2021), având instrumente implementate care, dacă sunt folosite activ, pot reduce timpul de reacție în caz de incident.
Recomandări Generale de Îmbunătățire
În baza constatărilor de mai sus, formulăm următoarele recomandări prioritizate pentru a alinia aplicația la cele mai înalte standarde de securitate:
1.	Standardizarea Autorizării RBAC: Unificați metoda de verificare a rolurilor într-o singură abordare în tot codul (fie middleware, fie decoratori)[20]. Eliminați rutele care folosesc metode nepreferate și actualizați documentația pentru dezvoltatori. Acest lucru va preveni omisiuni ca cea identificată la modulul Facturi și va simplifica auditarea securității în viitor.
2.	Sanitizarea Conținutului HTML Dinamic: Introduceți filtrarea conținutului campaniilor de marketing (și a oricărei alte surse de HTML dinamic). Utilizați o bibliotecă precum DOMPurify pentru a curăța campaign.contentHtml înainte de afișare[53]. Mențineți totodată política de Content Security Policy strictă pentru a reduce impactul unui eventual XSS.
3.	Întărirea Configurației Cookie/Sesiuni: Activați opțiunea cookie.sameSite (preferabil Lax) în configurarea Express Session[12]. Examinați dacă există endpoints care folosesc sesiunea în loc de JWT și implementați token CSRF pentru acelea. Dacă nu este cazul, puteți chiar dezactiva complet sesiunea server-side pentru API (reducând suprafața de atac), bazându-vă 100% pe JWT stateless.
4.	Politici de Parole și MFA: Deoarece aplicația gestionează conturi de utilizator, ar fi indicat să impuneți o politică de parole strong (minim 8 caractere, combinație de litere, cifre, simboluri) și eventual un mecanism de expirare periodică a parolei pentru conturile sensibile (admin). În plus, deși nu este neapărat trivial de implementat, luați în calcul suport pentru autentificare cu doi factori (2FA) pentru administratori sau pentru login-uri de la distanță. Aceste măsuri ar adresa vectorii de atac de tip Credential Stuffing sau furt de parole, depășind cerințele OWASP Top 10.
5.	Rate Limiting pe Autentificare și API: Implementați un sistem de limitare a ratei de acces (ex. 5 încercări de login/minut per IP, sau un algoritm exponential backoff la autentificări eșuate). Acest lucru previne atacurile de forțare a parolelor și este recomandat de OWASP (ASVS 2.2.3). De asemenea, puteți extinde rate-limiting la anumite API-uri costisitoare sau critice (ex. endpoint-uri de generare rapoarte sau integrări externe) pentru a preveni abuzul.
6.	Revizuirea Permisiunilor și Izolării pe Module: Având în vedere complexitatea ERP-ului (multe module: contabilitate, HR, CRM, marketing etc.), recomandăm un audit intern al permisiunilor: verificați că fiecare rol are acces doar la ceea ce trebuie (principiul minimului privilegiu). Introduceți eventual permisiuni fine-grained (nu doar pe modul, ci pe acțiuni: view/edit/delete) acolo unde se justifică. În plus, funcționalitățile critice (ex. ștergerea de date financiare, modificarea setărilor companiei) ar putea cere o confirmare suplimentară sau audit trail dedicat.
7.	Testare de Securitate periodică: Complementar auditului static, planificați teste dinamice (DAST) și eventual pen-test extern. Un test de penetrare ar putea identifica aspecte care nu reies din simpla citire a codului – de exemplu, configurări greșite pe server, servicii uitate expuse, sau combinații de fluxuri care pot fi exploatate. De asemenea, includeți scenarii de abuz în testele automate (ex: un user de rol non-admin încearcă acces la fiecare endpoint admin – aceste teste pot rula după fiecare release, asigurând că noile modificări nu introduc regresii de securitate).
8.	Update și mentenanță continuă: Țineți biblioteca dependențelor la zi aplicând patch-urile de securitate imediat ce apar. De exemplu, monitorizați buletinele de securitate pentru Node.js, Express, React și celelalte pachete din package.json. Având un script Trivy integrat, rulați-l în pipeline-ul CI și tratați alertele cu prioritate. Pentru ISO 27001, există cerința de management al vulnerabilităților, iar acest proces de update continuu îndeplinește parțial acea cerință.
9.	Backup-uri securizate și plan de răspuns la incidente: Asigurați-vă că backup-urile bazei de date (menționate ca funcționalitate de migrare în v5.1.0) sunt stocate criptat și accesibile doar persoanelor autorizate. Simulați scenarii de dezastru sau atac (ex. ransomware pe server) pentru a verifica că datele pot fi restaurate rapid și sigur. De asemenea, documentați un plan de răspuns la incidente: cine monitorizează Wazuh alertele, cum se reacționează la un posibil breach, etc., pentru a fi în conformitate cu capitolul de Incident Response al standardelor de securitate.
Implementarea acestor recomandări va crește considerabil nivelul de securitate al aplicației, adresând atât riscurile punctuale identificate, cât și consolidând per ansamblu sistemul conform principiilor defense-in-depth. Fiecare recomandare corespunde unor controale cerute de standarde (ex. OWASP ASVS, ISO27001 A.9 Control Acces, A.13 Securitate Comunicatii, etc.), contribuind la un eventual proces de certificare sau conformitate.
Concluzii
Auditul static de securitate al aplicației GeniusERP a evidențiat o platformă bine construită, cu numeroase măsuri de securitate deja în vigoare. Utilizarea de tehnologii moderne (JWT, ORM pentru DB, framework React) și integrarea unui întreg ecosistem de monitorizare arată o abordare proactivă față de securitate. Am identificat câteva zone de îmbunătățire – în special uniformizarea controlului de acces și sanitizarea conținutului – care, dacă sunt abordate prompt, vor reduce și mai mult suprafața de atac. Nu au fost găsite vulnerabilități majore neadresate (precum injecții SQL sau expuneri directe de date sensibile), iar punctele slabe semnalate pot fi rezolvate în mare parte cu efort moderat, având deja o bază implementată (ex. mecanismele există, trebuie doar folosite consecvent).
În ansamblu, postura de securitate a aplicației este bună, respectând multe dintre standardele industriei, cu angajament vizibil spre îmbunătățire continuă (ex. rapoarte de audit interne ca cele din documentație[54]). Urmând recomandările de mai sus, aplicația se poate alinia și mai strâns la OWASP Top 10 și cerințele ISO 27001, minimizând riscurile pentru datele și operațiunile pe care le gestionează. Securitatea este un proces continuu, astfel se recomandă repetarea periodică a auditului (atât static cât și dynamic) și actualizarea politicilor de securitate pe măsură ce aplicația evoluează. Acest raport poate servi ca foaie de parcurs pentru remediere și ca dovadă a diligenței dezvoltatorilor în asigurarea securității aplicației.
Referințe selectate din cod și documentație: Multe observații din raport sunt susținute de extrase din codul aplicației sau din documentația inclusă în repository – acestea au fost citate pe parcursul textului pentru transparență și verificabilitate. De exemplu, implementarea hashing-ului parolelor cu bcrypt[2], corecția vulnerabilității la endpoint-ul de facturi[3], configurarea variabilelor de mediu fără secrete hardcodate[1], sau validările de fișiere la upload[40]. Aceste surse indică exact locurile din cod unde se află aspectele discutate, facilitând echipei tehnice localizarea rapidă a secțiunilor relevante pentru aplicarea remediilor.
