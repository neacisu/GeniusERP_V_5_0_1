var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc42) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc42 = __getOwnPropDesc(from, key)) || desc42.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc42 = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc42.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc42.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc42[key] : k > 4 ? void 0 : { get: desc42.get, set: desc42.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc42[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc42.get = fn), __expectFn(fn = it.set) && (desc42.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc42 && __defProp(target, name, desc42), p ? k ^ 4 ? extra : desc42 : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// server/modules/crm/schema/crm.schema.ts
import {
  pgTable,
  uuid,
  text,
  timestamp,
  boolean,
  integer,
  numeric,
  date,
  json,
  index
} from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";
import { relations } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
var anafCompanyData, crm_companies, customers, contacts, pipelines, pipelineStages, deals, dealStageHistory, activities, tags, customerTags, dealTags, revenueForecasts, salesQuotas, segments, scoringRules, emailTemplates, anafCompanyDataRelations, crmCompaniesRelations, customerRelations, contactRelations, pipelineRelations, pipelineStageRelations, dealRelations, dealStageHistoryRelations, activityRelations, tagRelations, customerTagRelations, dealTagRelations, revenueForecastRelations, salesQuotaRelations, segmentRelations, scoringRuleRelations, emailTemplateRelations, insertCustomerSchema, insertContactSchema, insertPipelineSchema, insertPipelineStageSchema, insertDealSchema, insertDealStageHistorySchema, insertActivitySchema, insertTagSchema, insertCustomerTagSchema, insertDealTagSchema, insertRevenueForecastSchema, insertSalesQuotaSchema, insertSegmentSchema, insertScoringRuleSchema, insertEmailTemplateSchema, insertAnafCompanyDataSchema;
var init_crm_schema = __esm({
  "server/modules/crm/schema/crm.schema.ts"() {
    "use strict";
    init_schema4();
    anafCompanyData = pgTable("anaf_company_data", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").references(() => companies.id),
      // Eliminat notNull() pentru a permite salvarea de date ANAF independente
      customerId: uuid("customer_id").references(() => customers.id),
      // Date generale
      cui: text("cui").notNull(),
      dataInterogare: date("data_interogare").notNull(),
      denumire: text("denumire"),
      adresa: text("adresa"),
      nrRegCom: text("nr_reg_com"),
      telefon: text("telefon"),
      fax: text("fax"),
      codPostal: text("cod_postal"),
      act: text("act"),
      stareInregistrare: text("stare_inregistrare"),
      dataInregistrare: date("data_inregistrare"),
      codCAEN: text("cod_caen"),
      iban: text("iban"),
      statusROeFactura: boolean("status_ro_e_factura").default(false),
      organFiscalCompetent: text("organ_fiscal_competent"),
      formaDeProprietate: text("forma_de_proprietate"),
      formaOrganizare: text("forma_organizare"),
      formaJuridica: text("forma_juridica"),
      // Înregistrare în scop de TVA
      scpTVA: boolean("scp_tva").default(false),
      // Ultima perioadă TVA (cea activă)
      dataInceputScpTVA: date("data_inceput_scp_tva"),
      dataSfarsitScpTVA: date("data_sfarsit_scp_tva"),
      dataAnulImpScpTVA: date("data_anul_imp_scp_tva"),
      mesajScpTVA: text("mesaj_scp_tva"),
      // Înregistrare TVA la încasare
      dataInceputTvaInc: date("data_inceput_tva_inc"),
      dataSfarsitTvaInc: date("data_sfarsit_tva_inc"),
      dataActualizareTvaInc: date("data_actualizare_tva_inc"),
      dataPublicareTvaInc: date("data_publicare_tva_inc"),
      tipActTvaInc: text("tip_act_tva_inc"),
      statusTvaIncasare: boolean("status_tva_incasare").default(false),
      // Stare inactiv
      dataInactivare: date("data_inactivare"),
      dataReactivare: date("data_reactivare"),
      dataPublicare: date("data_publicare"),
      dataRadiere: date("data_radiere"),
      statusInactivi: boolean("status_inactivi").default(false),
      // Split TVA
      dataInceputSplitTVA: date("data_inceput_split_tva"),
      dataAnulareSplitTVA: date("data_anulare_split_tva"),
      statusSplitTVA: boolean("status_split_tva").default(false),
      // Adresa sediu social
      sdenumireStrada: text("ss_denumire_strada"),
      snumarStrada: text("ss_numar_strada"),
      sdenumireLocalitate: text("ss_denumire_localitate"),
      scodLocalitate: text("ss_cod_localitate"),
      sdenumireJudet: text("ss_denumire_judet"),
      scodJudet: text("ss_cod_judet"),
      scodJudetAuto: text("ss_cod_judet_auto"),
      stara: text("ss_tara"),
      sdetaliiAdresa: text("ss_detalii_adresa"),
      scodPostal: text("ss_cod_postal"),
      // Adresa domiciliu fiscal
      ddenumireStrada: text("df_denumire_strada"),
      dnumarStrada: text("df_numar_strada"),
      ddenumireLocalitate: text("df_denumire_localitate"),
      dcodLocalitate: text("df_cod_localitate"),
      ddenumireJudet: text("df_denumire_judet"),
      dcodJudet: text("df_cod_judet"),
      dcodJudetAuto: text("df_cod_judet_auto"),
      dtara: text("df_tara"),
      ddetaliiAdresa: text("df_detalii_adresa"),
      dcodPostal: text("df_cod_postal"),
      // Istoricul tuturor perioadelor de TVA
      perioadeTVA: json("perioade_tva").default([]),
      // Date și metadate
      rawResponse: json("raw_response"),
      // Răspunsul complet de la ANAF
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      lastCheckedAt: timestamp("last_checked_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      // Flags pentru integrarea cu modulele interne
      isAdditionalInfoLoaded: boolean("is_additional_info_loaded").default(false),
      isUpdatedFromAnaf: boolean("is_updated_from_anaf").default(true),
      observatii: text("observatii")
    }, (anafData) => ({
      cuiIdx: index("anaf_company_cui_idx").on(anafData.cui),
      customerIdx: index("anaf_company_customer_idx").on(anafData.customerId),
      companyIdx: index("anaf_company_company_idx").on(anafData.companyId)
    }));
    crm_companies = pgTable("crm_companies", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      description: text("description"),
      website: text("website"),
      industry: text("industry"),
      size: text("size"),
      phone: text("phone"),
      email: text("email"),
      address: text("address"),
      city: text("city"),
      postalCode: text("postal_code"),
      country: text("country"),
      vatNumber: text("vat_number"),
      registrationNumber: text("registration_number"),
      cui: text("cui").unique(),
      // CUI field for storing formatted tax ID
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      companyId: uuid("company_id").references(() => companies.id),
      status: text("status").default("active"),
      customFields: json("custom_fields").default({}),
      logoUrl: text("logo_url"),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      parentCompanyId: uuid("parent_company_id").references(() => crm_companies.id),
      annualRevenue: numeric("annual_revenue"),
      isCustomer: boolean("is_customer").default(true),
      isSupplier: boolean("is_supplier").default(false),
      // Câmpuri pentru conturile analitice
      analythic_401: text("analythic_401"),
      // Cont analitic furnizori (401.x)
      analythic_4111: text("analythic_4111")
      // Cont analitic clienți (4111.x)
    }, (crmCompany) => ({
      cuiIdx: index("crm_company_cui_idx").on(crmCompany.cui),
      companyIdIdx: index("crm_company_company_id_idx").on(crmCompany.companyId)
    }));
    customers = pgTable("crm_customers", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      name: text("name").notNull(),
      email: text("email"),
      phone: text("phone"),
      address: text("address"),
      city: text("city"),
      county: text("county"),
      country: text("country").default("Romania"),
      postalCode: text("postal_code"),
      type: text("type").default("lead"),
      // lead, prospect, customer, partner, etc.
      segment: text("segment"),
      // Enterprise, SMB, Startup, etc.
      industry: text("industry"),
      source: text("source"),
      // Website, Referral, Marketing, etc.
      leadScore: integer("lead_score").default(0),
      leadStatus: text("lead_status").default("New"),
      leadQualificationDate: timestamp("lead_qualification_date", { withTimezone: true }),
      ownerId: uuid("owner_id").references(() => users.id),
      fiscalCode: text("fiscal_code"),
      // CUI / CIF in Romania
      registrationNumber: text("registration_number"),
      // J40/123/2020 format in Romania
      vatPayer: boolean("vat_payer").default(false),
      website: text("website"),
      notes: text("notes"),
      annualRevenue: numeric("annual_revenue", { precision: 20, scale: 2 }),
      employeeCount: integer("employee_count"),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      isActive: boolean("is_active").default(true),
      customFields: json("custom_fields").default({})
    });
    contacts = pgTable("crm_contacts", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      customerId: uuid("customer_id").references(() => customers.id),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      firstName: text("first_name").notNull(),
      lastName: text("last_name").notNull(),
      email: text("email"),
      phone: text("phone"),
      mobile: text("mobile"),
      title: text("title"),
      // Job title
      department: text("department"),
      decisionMaker: boolean("decision_maker").default(false),
      influenceLevel: integer("influence_level").default(5),
      // 1-10 scale
      preferredContactMethod: text("preferred_contact_method").default("email"),
      notes: text("notes"),
      birthDate: date("birth_date"),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      lastContactedAt: timestamp("last_contacted_at", { withTimezone: true }),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      isActive: boolean("is_active").default(true),
      customFields: json("custom_fields").default({})
    });
    pipelines = pgTable("crm_pipelines", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      name: text("name").notNull(),
      description: text("description"),
      isDefault: boolean("is_default").default(false),
      displayOrder: integer("display_order").default(0),
      targetDealSize: numeric("target_deal_size", { precision: 20, scale: 2 }),
      targetConversionRate: numeric("target_conversion_rate", { precision: 5, scale: 2 }),
      targetCycleTimeDays: integer("target_cycle_time_days"),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      isActive: boolean("is_active").default(true)
    });
    pipelineStages = pgTable("crm_stages", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      pipelineId: uuid("pipeline_id").notNull().references(() => pipelines.id, { onDelete: "cascade" }),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      name: text("name").notNull(),
      description: text("description"),
      probability: numeric("probability", { precision: 5, scale: 2 }).default("0"),
      expectedDuration: integer("expected_duration").default(0),
      // In days
      expectedDays: integer("expected_days").default(0),
      // Legacy field, maintained for compatibility
      displayOrder: integer("display_order").default(0),
      sortOrder: integer("sort_order").default(0),
      // Legacy field for ordering, maintained for compatibility
      color: text("color").default("#808080"),
      stageType: text("stage_type").default("standard"),
      // standard, qualification, proposal, negotiation, closed_won, closed_lost
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      isActive: boolean("is_active").default(true)
    });
    deals = pgTable("crm_deals", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      customerId: uuid("customer_id").references(() => customers.id),
      pipelineId: uuid("pipeline_id").notNull().references(() => pipelines.id),
      stageId: uuid("stage_id").notNull().references(() => pipelineStages.id),
      name: text("name").notNull(),
      // Keep for backward compatibility
      title: text("title").notNull(),
      description: text("description"),
      amount: numeric("amount", { precision: 20, scale: 2 }),
      currency: text("currency").default("RON"),
      probability: numeric("probability", { precision: 5, scale: 2 }).default("0"),
      expectedCloseDate: date("expected_close_date"),
      actualCloseDate: date("actual_close_date"),
      dealType: text("deal_type").default("New Business"),
      // New Business, Upsell, Renewal, etc.
      priority: text("priority").default("medium"),
      // low, medium, high
      source: text("source"),
      ownerId: uuid("owner_id").references(() => users.id),
      healthScore: integer("health_score").default(50),
      // 0-100 scale
      status: text("status").default("open"),
      // open, won, lost
      wonReason: text("won_reason"),
      lostReason: text("lost_reason"),
      lostCompetitor: text("lost_competitor"),
      products: json("products").default([]),
      // List of products in the deal
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      isActive: boolean("is_active").default(true),
      customFields: json("custom_fields").default({})
    });
    dealStageHistory = pgTable("crm_stage_history", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      dealId: uuid("deal_id").notNull().references(() => deals.id, { onDelete: "cascade" }),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      fromStageId: uuid("from_stage_id").references(() => pipelineStages.id),
      toStageId: uuid("to_stage_id").notNull().references(() => pipelineStages.id),
      changedAt: timestamp("changed_at", { withTimezone: true }).defaultNow(),
      // Renamed from transitionDate to match DB
      timeInStage: integer("time_in_stage"),
      // Renamed from daysInStage to match DB
      changedBy: uuid("changed_by").references(() => users.id),
      // Renamed from userId to match DB
      notes: text("notes")
    });
    activities = pgTable("crm_activities", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      title: text("title").notNull(),
      description: text("description"),
      activityType: text("activity_type").notNull(),
      // call, meeting, email, task, note
      status: text("status").default("pending"),
      // pending, completed, cancelled
      startTime: timestamp("start_time", { withTimezone: true }),
      endTime: timestamp("end_time", { withTimezone: true }),
      dealId: uuid("deal_id").references(() => deals.id),
      contactId: uuid("contact_id").references(() => contacts.id),
      clientCompanyId: uuid("client_company_id").references(() => crm_companies.id),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      assignedTo: uuid("assigned_to").references(() => users.id),
      outcome: text("outcome"),
      completedAt: timestamp("completed_at", { withTimezone: true }),
      location: text("location"),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      customFields: json("custom_fields").default({})
    });
    tags = pgTable("crm_tags", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      name: text("name").notNull(),
      color: text("color").default("#808080"),
      category: text("category").default("general"),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id)
    });
    customerTags = pgTable("crm_customer_tags", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      customerId: uuid("customer_id").notNull().references(() => customers.id, { onDelete: "cascade" }),
      tagId: uuid("tag_id").notNull().references(() => tags.id, { onDelete: "cascade" }),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id)
    });
    dealTags = pgTable("crm_deal_tags", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      dealId: uuid("deal_id").notNull().references(() => deals.id, { onDelete: "cascade" }),
      tagId: uuid("tag_id").notNull().references(() => tags.id, { onDelete: "cascade" }),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id)
    });
    revenueForecasts = pgTable("crm_revenue_forecasts", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      year: integer("year").notNull(),
      month: integer("month").notNull(),
      pipeline: numeric("pipeline", { precision: 20, scale: 2 }),
      // Total value of all deals
      weighted: numeric("weighted", { precision: 20, scale: 2 }),
      // Probability-weighted value
      bestCase: numeric("best_case", { precision: 20, scale: 2 }),
      // Best case scenario
      commit: numeric("commit", { precision: 20, scale: 2 }),
      // Committed forecast
      closed: numeric("closed", { precision: 20, scale: 2 }),
      // Already closed deals
      forecastAccuracy: numeric("forecast_accuracy", { precision: 5, scale: 2 }),
      currency: text("currency").default("RON"),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      calculatedBy: uuid("calculated_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id),
      notes: text("notes")
    });
    salesQuotas = pgTable("crm_sales_quotas", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      year: integer("year").notNull(),
      month: integer("month").notNull(),
      userId: uuid("user_id").notNull().references(() => users.id),
      targetAmount: numeric("target_amount", { precision: 20, scale: 2 }),
      actualAmount: numeric("actual_amount", { precision: 20, scale: 2 }),
      targetDeals: integer("target_deals"),
      actualDeals: integer("actual_deals"),
      currency: text("currency").default("RON"),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id)
    });
    segments = pgTable("crm_segments", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      name: text("name").notNull(),
      description: text("description"),
      entityType: text("entity_type").notNull(),
      // customers, contacts, deals
      criteria: json("criteria").notNull(),
      // JSON with filter criteria
      isPublic: boolean("is_public").default(false),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id)
    });
    scoringRules = pgTable("crm_scoring_rules", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      name: text("name").notNull(),
      description: text("description"),
      field: text("field").notNull(),
      // Which field to evaluate
      operator: text("operator").notNull(),
      // equals, contains, greater_than, etc.
      value: text("value").notNull(),
      // Value to compare against
      points: integer("points").notNull().default(1),
      // Points to add/subtract
      ruleType: text("rule_type").default("demographic"),
      // demographic, behavioral, engagement
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id)
    });
    emailTemplates = pgTable("crm_email_templates", {
      id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
      companyId: uuid("company_id").notNull().references(() => companies.id),
      name: text("name").notNull(),
      subject: text("subject").notNull(),
      content: text("content").notNull(),
      isActive: boolean("is_active").default(true),
      templateType: text("template_type").default("custom"),
      // custom, system, follow-up, etc.
      variables: json("variables").default([]),
      createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid("created_by").references(() => users.id),
      updatedBy: uuid("updated_by").references(() => users.id)
    });
    anafCompanyDataRelations = relations(anafCompanyData, ({ one }) => ({
      company: one(companies, {
        fields: [anafCompanyData.companyId],
        references: [companies.id]
      }),
      customer: one(customers, {
        fields: [anafCompanyData.customerId],
        references: [customers.id]
      }),
      createdByUser: one(users, {
        fields: [anafCompanyData.createdBy],
        references: [users.id]
      }),
      updatedByUser: one(users, {
        fields: [anafCompanyData.updatedBy],
        references: [users.id]
      })
    }));
    crmCompaniesRelations = relations(crm_companies, ({ one, many }) => ({
      company: one(companies, {
        fields: [crm_companies.companyId],
        references: [companies.id]
      }),
      parentCompany: one(crm_companies, {
        fields: [crm_companies.parentCompanyId],
        references: [crm_companies.id]
      }),
      createdByUser: one(users, {
        fields: [crm_companies.createdBy],
        references: [users.id]
      }),
      updatedByUser: one(users, {
        fields: [crm_companies.updatedBy],
        references: [users.id]
      }),
      activities: many(activities)
    }));
    customerRelations = relations(customers, ({ one, many }) => ({
      company: one(companies, {
        fields: [customers.companyId],
        references: [companies.id]
      }),
      owner: one(users, {
        fields: [customers.ownerId],
        references: [users.id]
      }),
      contacts: many(contacts),
      deals: many(deals),
      activities: many(activities),
      tags: many(customerTags)
    }));
    contactRelations = relations(contacts, ({ one, many }) => ({
      company: one(companies, {
        fields: [contacts.companyId],
        references: [companies.id]
      }),
      customer: one(customers, {
        fields: [contacts.customerId],
        references: [customers.id]
      }),
      activities: many(activities)
    }));
    pipelineRelations = relations(pipelines, ({ one, many }) => ({
      company: one(companies, {
        fields: [pipelines.companyId],
        references: [companies.id]
      }),
      stages: many(pipelineStages),
      deals: many(deals)
    }));
    pipelineStageRelations = relations(pipelineStages, ({ one, many }) => ({
      company: one(companies, {
        fields: [pipelineStages.companyId],
        references: [companies.id]
      }),
      pipeline: one(pipelines, {
        fields: [pipelineStages.pipelineId],
        references: [pipelines.id]
      }),
      deals: many(deals),
      stageTransitionsTo: many(dealStageHistory, { relationName: "toStage" }),
      stageTransitionsFrom: many(dealStageHistory, { relationName: "fromStage" })
    }));
    dealRelations = relations(deals, ({ one, many }) => ({
      company: one(companies, {
        fields: [deals.companyId],
        references: [companies.id]
      }),
      customer: one(customers, {
        fields: [deals.customerId],
        references: [customers.id]
      }),
      pipeline: one(pipelines, {
        fields: [deals.pipelineId],
        references: [pipelines.id]
      }),
      stage: one(pipelineStages, {
        fields: [deals.stageId],
        references: [pipelineStages.id]
      }),
      owner: one(users, {
        fields: [deals.ownerId],
        references: [users.id]
      }),
      activities: many(activities),
      stageHistory: many(dealStageHistory),
      tags: many(dealTags)
    }));
    dealStageHistoryRelations = relations(dealStageHistory, ({ one }) => ({
      company: one(companies, {
        fields: [dealStageHistory.companyId],
        references: [companies.id]
      }),
      deal: one(deals, {
        fields: [dealStageHistory.dealId],
        references: [deals.id]
      }),
      fromStage: one(pipelineStages, {
        fields: [dealStageHistory.fromStageId],
        references: [pipelineStages.id],
        relationName: "fromStage"
      }),
      toStage: one(pipelineStages, {
        fields: [dealStageHistory.toStageId],
        references: [pipelineStages.id],
        relationName: "toStage"
      }),
      user: one(users, {
        fields: [dealStageHistory.changedBy],
        references: [users.id]
      })
    }));
    activityRelations = relations(activities, ({ one }) => ({
      company: one(companies, {
        fields: [activities.companyId],
        references: [companies.id]
      }),
      deal: one(deals, {
        fields: [activities.dealId],
        references: [deals.id]
      }),
      clientCompany: one(crm_companies, {
        fields: [activities.clientCompanyId],
        references: [crm_companies.id]
      }),
      contact: one(contacts, {
        fields: [activities.contactId],
        references: [contacts.id]
      }),
      assignedUser: one(users, {
        fields: [activities.assignedTo],
        references: [users.id]
      }),
      createdByUser: one(users, {
        fields: [activities.createdBy],
        references: [users.id]
      })
    }));
    tagRelations = relations(tags, ({ one, many }) => ({
      company: one(companies, {
        fields: [tags.companyId],
        references: [companies.id]
      }),
      customerTags: many(customerTags),
      dealTags: many(dealTags)
    }));
    customerTagRelations = relations(customerTags, ({ one }) => ({
      company: one(companies, {
        fields: [customerTags.companyId],
        references: [companies.id]
      }),
      customer: one(customers, {
        fields: [customerTags.customerId],
        references: [customers.id]
      }),
      tag: one(tags, {
        fields: [customerTags.tagId],
        references: [tags.id]
      })
    }));
    dealTagRelations = relations(dealTags, ({ one }) => ({
      company: one(companies, {
        fields: [dealTags.companyId],
        references: [companies.id]
      }),
      deal: one(deals, {
        fields: [dealTags.dealId],
        references: [deals.id]
      }),
      tag: one(tags, {
        fields: [dealTags.tagId],
        references: [tags.id]
      })
    }));
    revenueForecastRelations = relations(revenueForecasts, ({ one }) => ({
      company: one(companies, {
        fields: [revenueForecasts.companyId],
        references: [companies.id]
      }),
      calculator: one(users, {
        fields: [revenueForecasts.calculatedBy],
        references: [users.id]
      })
    }));
    salesQuotaRelations = relations(salesQuotas, ({ one }) => ({
      company: one(companies, {
        fields: [salesQuotas.companyId],
        references: [companies.id]
      }),
      user: one(users, {
        fields: [salesQuotas.userId],
        references: [users.id]
      })
    }));
    segmentRelations = relations(segments, ({ one }) => ({
      company: one(companies, {
        fields: [segments.companyId],
        references: [companies.id]
      }),
      creator: one(users, {
        fields: [segments.createdBy],
        references: [users.id]
      })
    }));
    scoringRuleRelations = relations(scoringRules, ({ one }) => ({
      company: one(companies, {
        fields: [scoringRules.companyId],
        references: [companies.id]
      })
    }));
    emailTemplateRelations = relations(emailTemplates, ({ one }) => ({
      company: one(companies, {
        fields: [emailTemplates.companyId],
        references: [companies.id]
      })
    }));
    insertCustomerSchema = createInsertSchema(customers);
    insertContactSchema = createInsertSchema(contacts);
    insertPipelineSchema = createInsertSchema(pipelines);
    insertPipelineStageSchema = createInsertSchema(pipelineStages);
    insertDealSchema = createInsertSchema(deals);
    insertDealStageHistorySchema = createInsertSchema(dealStageHistory);
    insertActivitySchema = createInsertSchema(activities);
    insertTagSchema = createInsertSchema(tags);
    insertCustomerTagSchema = createInsertSchema(customerTags);
    insertDealTagSchema = createInsertSchema(dealTags);
    insertRevenueForecastSchema = createInsertSchema(revenueForecasts);
    insertSalesQuotaSchema = createInsertSchema(salesQuotas);
    insertSegmentSchema = createInsertSchema(segments);
    insertScoringRuleSchema = createInsertSchema(scoringRules);
    insertEmailTemplateSchema = createInsertSchema(emailTemplates);
    insertAnafCompanyDataSchema = createInsertSchema(anafCompanyData).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      lastCheckedAt: true
    });
  }
});

// server/modules/hr/schema/hr.schema.ts
import {
  pgTable as pgTable2,
  uuid as uuid2,
  text as text2,
  varchar,
  numeric as numeric2,
  timestamp as timestamp2,
  date as date2,
  index as index2,
  boolean as boolean2,
  integer as integer2,
  json as json2,
  primaryKey as primaryKey2,
  time,
  smallint
} from "drizzle-orm/pg-core";
import { sql as sql2 } from "drizzle-orm";
var employees, employmentContracts, payrollLogs, absences, workSchedules, commissionStructures, employeeCommissions, departments, jobPositions, anafExportLogs, revisalExportLogs;
var init_hr_schema = __esm({
  "server/modules/hr/schema/hr.schema.ts"() {
    "use strict";
    init_schema4();
    employees = pgTable2("hr_employees", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      userId: uuid2("user_id").references(() => users.id),
      // Personal Information
      firstName: text2("first_name").notNull(),
      lastName: text2("last_name").notNull(),
      email: text2("email").notNull(),
      phone: text2("phone"),
      personalEmail: text2("personal_email"),
      personalPhone: text2("personal_phone"),
      // Official Identification (Revisal/ANAF required)
      cnp: varchar("cnp", { length: 13 }).notNull(),
      // Romanian personal identification number
      idSeriesNumber: varchar("id_series_number", { length: 20 }),
      // CI/BI Series and number
      birthDate: date2("birth_date"),
      birthPlace: text2("birth_place"),
      nationality: text2("nationality").default("Romanian"),
      // Address
      address: text2("address"),
      city: text2("city"),
      county: text2("county"),
      postalCode: varchar("postal_code", { length: 10 }),
      // Basic Employment Info
      position: text2("position").notNull(),
      department: text2("department"),
      departmentId: uuid2("department_id").references(() => departments.id),
      managerEmployeeId: uuid2("manager_employee_id").references(() => employees.id),
      // Status
      isActive: boolean2("is_active").default(true),
      status: varchar("status", { length: 50 }).default("active"),
      // active, terminated, suspended, etc.
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      companyIdx: index2("hr_employee_company_idx").on(table.companyId),
      cnpIdx: index2("hr_employee_cnp_idx").on(table.cnp)
    }));
    employmentContracts = pgTable2("hr_employment_contracts", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      employeeId: uuid2("employee_id").notNull().references(() => employees.id),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Contract Identification
      contractNumber: varchar("contract_number", { length: 50 }).notNull(),
      revisalId: varchar("revisal_id", { length: 50 }),
      // Registration number in REVISAL
      // Contract Type (Codul Muncii)
      contractType: varchar("contract_type", { length: 50 }).notNull().default("full_time"),
      // full_time, part_time
      durationType: varchar("duration_type", { length: 50 }).notNull().default("indefinite"),
      // indefinite, definite
      // Status
      status: varchar("status", { length: 50 }).notNull().default("active"),
      // draft, active, suspended, terminated, transferred
      // Dates
      startDate: date2("start_date").notNull(),
      endDate: date2("end_date"),
      // For fixed-term contracts
      isIndefinite: boolean2("is_indefinite").default(false),
      suspendedFrom: date2("suspended_from"),
      suspendedUntil: date2("suspended_until"),
      terminationDate: date2("termination_date"),
      terminationReason: text2("termination_reason"),
      // Working Time (Revisal required)
      workingTime: varchar("working_time", { length: 50 }),
      workingHoursPerDay: numeric2("working_hours_per_day", { precision: 5, scale: 2 }).notNull().default("8"),
      workingHoursPerWeek: numeric2("working_hours_per_week", { precision: 5, scale: 2 }).notNull().default("40"),
      // Compensation
      baseSalaryGross: numeric2("base_salary_gross", { precision: 12, scale: 2 }).notNull(),
      currency: varchar("currency", { length: 3 }).default("RON").notNull(),
      paymentInterval: varchar("payment_interval", { length: 20 }).default("monthly").notNull(),
      // monthly, weekly, etc.
      // CAEN and COR Codes (REVISAL requirement)
      caenCode: varchar("caen_code", { length: 10 }),
      // Activity classification
      corCode: varchar("cor_code", { length: 10 }).notNull(),
      // Occupation classification
      // Leave Entitlement
      annualLeaveEntitlement: integer2("annual_leave_entitlement").default(21),
      // In days
      // Special Cases
      isTelemuncaPossible: boolean2("is_telemunca_possible").default(false),
      // Remote work possibility
      hasCompetitionClause: boolean2("has_competition_clause").default(false),
      hasConfidentialityClause: boolean2("has_confidentiality_clause").default(true),
      // Document Management
      contractFilePath: text2("contract_file_path"),
      annexesFilePaths: json2("annexes_file_paths").default([]),
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      employeeContractIdx: index2("hr_employment_contract_employee_idx").on(table.employeeId),
      companyContractIdx: index2("hr_employment_contract_company_idx").on(table.companyId),
      contractNumberIdx: index2("hr_employment_contract_number_idx").on(table.contractNumber)
    }));
    payrollLogs = pgTable2("hr_payroll_logs", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      employeeId: uuid2("employee_id").notNull().references(() => employees.id),
      employmentContractId: uuid2("employment_contract_id").notNull().references(() => employmentContracts.id),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Period
      year: integer2("year").notNull(),
      month: integer2("month").notNull(),
      // 1-12
      // Status
      status: varchar("status", { length: 50 }).default("draft").notNull(),
      // draft, calculated, finalized, paid
      paymentDate: date2("payment_date"),
      // Base Values
      workingDaysInMonth: smallint("working_days_in_month").notNull(),
      workedDays: numeric2("worked_days", { precision: 5, scale: 2 }).notNull(),
      // Gross Salary Components
      baseSalaryGross: numeric2("base_salary_gross", { precision: 12, scale: 2 }).notNull(),
      grossTotal: numeric2("gross_total", { precision: 12, scale: 2 }).notNull(),
      // Bonuses and Additional Income
      overtimeHours: numeric2("overtime_hours", { precision: 5, scale: 2 }).default("0"),
      overtimeAmount: numeric2("overtime_amount", { precision: 12, scale: 2 }).default("0"),
      mealTicketsCount: integer2("meal_tickets_count").default(0),
      mealTicketsValue: numeric2("meal_tickets_value", { precision: 12, scale: 2 }).default("0"),
      giftTicketsValue: numeric2("gift_tickets_value", { precision: 12, scale: 2 }).default("0"),
      vacationTicketsValue: numeric2("vacation_tickets_value", { precision: 12, scale: 2 }).default("0"),
      bonuses: numeric2("bonuses", { precision: 12, scale: 2 }).default("0"),
      commissions: numeric2("commissions", { precision: 12, scale: 2 }).default("0"),
      otherCompensations: json2("other_compensations").default({}),
      // Tax Exemptions
      itExemptionType: varchar("it_exemption_type", { length: 50 }),
      // IT, research, disabled, construction, etc.
      // Employee Contributions
      casBasis: numeric2("cas_basis", { precision: 12, scale: 2 }),
      casEmployeeAmount: numeric2("cas_employee_amount", { precision: 12, scale: 2 }),
      // 25% of CAS basis
      cassEmployeeAmount: numeric2("cass_employee_amount", { precision: 12, scale: 2 }),
      // 10% of CASS basis
      incomeTaxAmount: numeric2("income_tax_amount", { precision: 12, scale: 2 }),
      // 10% usually
      // Employer Contributions
      camEmployerAmount: numeric2("cam_employer_amount", { precision: 12, scale: 2 }),
      // Work insurance contribution (2.25%)
      // Net Calculation
      netSalary: numeric2("net_salary", { precision: 12, scale: 2 }).notNull(),
      // Deductions
      personalDeduction: numeric2("personal_deduction", { precision: 12, scale: 2 }).default("0"),
      otherDeductions: json2("other_deductions").default({}),
      // ANAF Declaration information
      anafDeclarationStatus: varchar("anaf_declaration_status", { length: 50 }).default("pending"),
      // pending, submitted, accepted
      anafDeclarationDate: date2("anaf_declaration_date"),
      anafDeclarationNumber: varchar("anaf_declaration_number", { length: 50 }),
      // Document references
      payslipFilePath: text2("payslip_file_path"),
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      employeePayrollIdx: index2("hr_payroll_employee_idx").on(table.employeeId),
      companyPayrollIdx: index2("hr_payroll_company_idx").on(table.companyId),
      periodIdx: index2("hr_payroll_period_idx").on(table.year, table.month)
    }));
    absences = pgTable2("hr_absences", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      employeeId: uuid2("employee_id").notNull().references(() => employees.id),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Absence Period
      startDate: date2("start_date").notNull(),
      endDate: date2("end_date").notNull(),
      workingDays: numeric2("working_days", { precision: 5, scale: 2 }).notNull(),
      // Type Classification (Romanian standards)
      absenceType: varchar("absence_type", { length: 50 }).notNull(),
      // annual_leave, medical_leave, unpaid_leave, etc.
      absenceCode: varchar("absence_code", { length: 10 }),
      // CO, CM, CFS, etc.
      medicalLeaveCode: varchar("medical_leave_code", { length: 10 }),
      // 01, 02, etc. for medical leave types
      // Approval
      status: varchar("status", { length: 50 }).default("pending").notNull(),
      // pending, approved, rejected
      approvedBy: uuid2("approved_by").references(() => users.id),
      approvedAt: timestamp2("approved_at", { withTimezone: true }),
      rejectionReason: text2("rejection_reason"),
      // Medical Certificate Details (for medical leave)
      medicalCertificateNumber: varchar("medical_certificate_number", { length: 50 }),
      medicalCertificateDate: date2("medical_certificate_date"),
      medicalCertificateIssuedBy: text2("medical_certificate_issued_by"),
      medicalCertificateFilePath: text2("medical_certificate_file_path"),
      // Comments
      notes: text2("notes"),
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      employeeAbsenceIdx: index2("hr_absence_employee_idx").on(table.employeeId),
      companyAbsenceIdx: index2("hr_absence_company_idx").on(table.companyId),
      dateRangeIdx: index2("hr_absence_date_range_idx").on(table.startDate, table.endDate)
    }));
    workSchedules = pgTable2("hr_work_schedules", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      employmentContractId: uuid2("employment_contract_id").notNull().references(() => employmentContracts.id),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Schedule Definition
      dayOfWeek: integer2("day_of_week").notNull(),
      // 1 (Monday) to 7 (Sunday)
      startTime: time("start_time", { precision: 0 }).notNull(),
      endTime: time("end_time", { precision: 0 }).notNull(),
      breakStartTime: time("break_start_time", { precision: 0 }),
      breakEndTime: time("break_end_time", { precision: 0 }),
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow()
    }, (table) => ({
      contractScheduleIdx: index2("hr_work_schedule_contract_idx").on(table.employmentContractId),
      companyScheduleIdx: index2("hr_work_schedule_company_idx").on(table.companyId),
      // Primary key combination
      uniqueSchedule: primaryKey2(table.employmentContractId, table.dayOfWeek)
    }));
    commissionStructures = pgTable2("hr_commission_structures", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Basic Info
      name: text2("name").notNull(),
      description: text2("description"),
      isActive: boolean2("is_active").default(true),
      // Type
      structureType: varchar("structure_type", { length: 50 }).notNull(),
      // sales, performance, mixed
      calculationPeriod: varchar("calculation_period", { length: 20 }).default("monthly").notNull(),
      // monthly, quarterly, etc.
      // Rules
      basePercentage: numeric2("base_percentage", { precision: 5, scale: 2 }),
      tiersDefinition: json2("tiers_definition").default([]),
      // Array of tier objects with thresholds and percentages
      targetMetrics: json2("target_metrics").default({}),
      // What is being measured (sales volume, customer acquisition, etc.)
      calculationFormula: text2("calculation_formula"),
      // Formula or explanation of calculation logic
      // Constraints
      minimumQualifyingAmount: numeric2("minimum_qualifying_amount", { precision: 12, scale: 2 }),
      maximumCommissionCap: numeric2("maximum_commission_cap", { precision: 12, scale: 2 }),
      // Timestamps
      validFrom: date2("valid_from").notNull(),
      validTo: date2("valid_to"),
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      companyCommissionStructureIdx: index2("hr_commission_structure_company_idx").on(table.companyId)
    }));
    employeeCommissions = pgTable2("hr_employee_commissions", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      employeeId: uuid2("employee_id").notNull().references(() => employees.id),
      commissionStructureId: uuid2("commission_structure_id").notNull().references(() => commissionStructures.id),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Period
      year: integer2("year").notNull(),
      month: integer2("month").notNull(),
      // 1-12
      // Targets and Performance
      targetAmount: numeric2("target_amount", { precision: 12, scale: 2 }),
      achievedAmount: numeric2("achieved_amount", { precision: 12, scale: 2 }),
      achievementPercentage: numeric2("achievement_percentage", { precision: 5, scale: 2 }),
      // Commission Calculation
      calculatedCommission: numeric2("calculated_commission", { precision: 12, scale: 2 }),
      adjustmentAmount: numeric2("adjustment_amount", { precision: 12, scale: 2 }).default("0"),
      adjustmentReason: text2("adjustment_reason"),
      finalCommissionAmount: numeric2("final_commission_amount", { precision: 12, scale: 2 }),
      // Processing Status
      status: varchar("status", { length: 50 }).default("calculated").notNull(),
      // calculated, approved, paid, disputed
      approvedBy: uuid2("approved_by").references(() => users.id),
      approvedAt: timestamp2("approved_at", { withTimezone: true }),
      paidInPayrollId: uuid2("paid_in_payroll_id").references(() => payrollLogs.id),
      // Details
      performanceMetrics: json2("performance_metrics").default({}),
      // Detailed performance data
      calculationDetails: json2("calculation_details").default({}),
      // How the commission was calculated
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      employeeCommissionIdx: index2("hr_employee_commission_employee_idx").on(table.employeeId),
      structureCommissionIdx: index2("hr_employee_commission_structure_idx").on(table.commissionStructureId),
      companyCommissionIdx: index2("hr_employee_commission_company_idx").on(table.companyId),
      periodCommissionIdx: index2("hr_employee_commission_period_idx").on(table.year, table.month)
    }));
    departments = pgTable2("hr_departments", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Basic Info
      name: text2("name").notNull(),
      code: varchar("code", { length: 20 }),
      description: text2("description"),
      // Hierarchy
      parentDepartmentId: uuid2("parent_department_id").references(() => departments.id),
      // Management
      managerId: uuid2("manager_id").references(() => employees.id),
      // Budget Code
      costCenter: varchar("cost_center", { length: 50 }),
      // Status
      isActive: boolean2("is_active").default(true),
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      companyDepartmentIdx: index2("hr_department_company_idx").on(table.companyId),
      parentDepartmentIdx: index2("hr_department_parent_idx").on(table.parentDepartmentId)
    }));
    jobPositions = pgTable2("hr_job_positions", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Position Details
      name: text2("name").notNull(),
      internalCode: varchar("internal_code", { length: 20 }),
      corCode: varchar("cor_code", { length: 10 }).notNull(),
      // Romanian Classification of Occupations code
      // Description
      description: text2("description"),
      responsibilities: text2("responsibilities"),
      requirements: text2("requirements"),
      // Department
      departmentId: uuid2("department_id").references(() => departments.id),
      // Salary Range
      minimumSalary: numeric2("minimum_salary", { precision: 12, scale: 2 }),
      maximumSalary: numeric2("maximum_salary", { precision: 12, scale: 2 }),
      // Status
      isActive: boolean2("is_active").default(true),
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      companyPositionIdx: index2("hr_job_position_company_idx").on(table.companyId),
      departmentPositionIdx: index2("hr_job_position_department_idx").on(table.departmentId),
      corCodeIdx: index2("hr_job_position_cor_idx").on(table.corCode)
    }));
    anafExportLogs = pgTable2("hr_anaf_export_logs", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Declaration Type
      declarationType: varchar("declaration_type", { length: 10 }).notNull(),
      // D112, D205, etc.
      // Period
      year: integer2("year").notNull(),
      month: integer2("month"),
      // 1-12, null for annual declarations
      quarter: integer2("quarter"),
      // 1-4, null for monthly or annual declarations
      // Status
      status: varchar("status", { length: 50 }).default("generated").notNull(),
      // generated, submitted, accepted, rejected
      submissionDate: timestamp2("submission_date", { withTimezone: true }),
      acceptanceDate: timestamp2("acceptance_date", { withTimezone: true }),
      rejectionReason: text2("rejection_reason"),
      // Reference Numbers
      declarationNumber: varchar("declaration_number", { length: 50 }),
      registrationNumber: varchar("registration_number", { length: 50 }),
      // Files
      declarationFilePath: text2("declaration_file_path"),
      receiptFilePath: text2("receipt_file_path"),
      // Totals
      employeeCount: integer2("employee_count").notNull(),
      grossSalaryTotal: numeric2("gross_salary_total", { precision: 12, scale: 2 }).notNull(),
      casEmployeeTotal: numeric2("cas_employee_total", { precision: 12, scale: 2 }).notNull(),
      cassEmployeeTotal: numeric2("cass_employee_total", { precision: 12, scale: 2 }).notNull(),
      incomeTaxTotal: numeric2("income_tax_total", { precision: 12, scale: 2 }).notNull(),
      camEmployerTotal: numeric2("cam_employer_total", { precision: 12, scale: 2 }).notNull(),
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      companyAnafIdx: index2("hr_anaf_export_company_idx").on(table.companyId),
      periodAnafIdx: index2("hr_anaf_export_period_idx").on(table.year, table.month, table.quarter),
      typeAnafIdx: index2("hr_anaf_export_type_idx").on(table.declarationType)
    }));
    revisalExportLogs = pgTable2("hr_revisal_export_logs", {
      id: uuid2("id").primaryKey().default(sql2`gen_random_uuid()`),
      companyId: uuid2("company_id").notNull().references(() => companies.id),
      // Export Details
      revisalVersion: varchar("revisal_version", { length: 20 }).notNull(),
      exportDate: timestamp2("export_date", { withTimezone: true }).notNull(),
      // Statistics
      employeeCount: integer2("employee_count").notNull(),
      newEmployeeCount: integer2("new_employee_count").notNull(),
      modifiedEmployeeCount: integer2("modified_employee_count").notNull(),
      suspendedEmployeeCount: integer2("suspended_employee_count").notNull(),
      terminatedEmployeeCount: integer2("terminated_employee_count").notNull(),
      // File
      exportFilePath: text2("export_file_path").notNull(),
      // Status
      submissionStatus: varchar("submission_status", { length: 50 }).default("generated").notNull(),
      // generated, submitted, accepted, rejected
      submissionDate: date2("submission_date"),
      registrationNumber: varchar("registration_number", { length: 50 }),
      // Timestamps
      createdAt: timestamp2("created_at", { withTimezone: true }).defaultNow(),
      updatedAt: timestamp2("updated_at", { withTimezone: true }).defaultNow(),
      createdBy: uuid2("created_by").references(() => users.id),
      updatedBy: uuid2("updated_by").references(() => users.id)
    }, (table) => ({
      companyRevisalIdx: index2("hr_revisal_export_company_idx").on(table.companyId),
      dateRevisalIdx: index2("hr_revisal_export_date_idx").on(table.exportDate)
    }));
  }
});

// server/modules/accounting/schema/accounting.schema.ts
import { pgTable as pgTable3, uuid as uuid3, text as text3, timestamp as timestamp3, numeric as numeric3, jsonb } from "drizzle-orm/pg-core";
import { relations as relations2 } from "drizzle-orm";
var ledgerEntries, ledgerLines, journalTypes, accountBalances, fiscalPeriods, chartOfAccounts, ledgerEntriesRelations, ledgerLinesRelations, chartOfAccountsRelations;
var init_accounting_schema = __esm({
  "server/modules/accounting/schema/accounting.schema.ts"() {
    "use strict";
    ledgerEntries = pgTable3("ledger_entries", {
      id: uuid3("id").primaryKey().notNull(),
      companyId: uuid3("company_id").notNull(),
      franchiseId: uuid3("franchise_id"),
      type: text3("type").notNull(),
      referenceNumber: text3("reference_number"),
      amount: numeric3("amount").notNull(),
      description: text3("description").notNull(),
      metadata: jsonb("metadata"),
      // Metadata
      createdAt: timestamp3("created_at").notNull(),
      updatedAt: timestamp3("updated_at").notNull(),
      createdBy: uuid3("created_by")
    });
    ledgerLines = pgTable3("ledger_lines", {
      id: uuid3("id").primaryKey().notNull(),
      ledgerEntryId: uuid3("ledger_entry_id").notNull().references(() => ledgerEntries.id, { onDelete: "cascade" }),
      accountId: text3("account_id").notNull(),
      debitAmount: numeric3("debit_amount").notNull().default("0"),
      creditAmount: numeric3("credit_amount").notNull().default("0"),
      description: text3("description"),
      metadata: jsonb("metadata"),
      // Metadata
      createdAt: timestamp3("created_at").notNull(),
      updatedAt: timestamp3("updated_at").notNull()
    });
    journalTypes = pgTable3("journal_types", {
      id: uuid3("id").primaryKey().notNull(),
      code: text3("code").notNull().unique(),
      name: text3("name").notNull(),
      description: text3("description"),
      // Metadata
      createdAt: timestamp3("created_at").notNull(),
      updatedAt: timestamp3("updated_at").notNull()
    });
    accountBalances = pgTable3("account_balances", {
      id: uuid3("id").primaryKey().notNull(),
      companyId: uuid3("company_id").notNull(),
      franchiseId: uuid3("franchise_id"),
      accountId: text3("account_id").notNull(),
      periodYear: numeric3("period_year").notNull(),
      periodMonth: numeric3("period_month").notNull(),
      openingDebit: numeric3("opening_debit").notNull().default("0"),
      openingCredit: numeric3("opening_credit").notNull().default("0"),
      periodDebit: numeric3("period_debit").notNull().default("0"),
      periodCredit: numeric3("period_credit").notNull().default("0"),
      closingDebit: numeric3("closing_debit").notNull().default("0"),
      closingCredit: numeric3("closing_credit").notNull().default("0"),
      // Metadata
      createdAt: timestamp3("created_at").notNull(),
      updatedAt: timestamp3("updated_at").notNull()
    });
    fiscalPeriods = pgTable3("fiscal_periods", {
      id: uuid3("id").primaryKey().notNull(),
      companyId: uuid3("company_id").notNull(),
      year: numeric3("year").notNull(),
      month: numeric3("month").notNull(),
      startDate: timestamp3("start_date").notNull(),
      endDate: timestamp3("end_date").notNull(),
      isClosed: numeric3("is_closed").notNull().default("0"),
      closedAt: timestamp3("closed_at"),
      closedBy: uuid3("closed_by"),
      // Metadata
      createdAt: timestamp3("created_at").notNull(),
      updatedAt: timestamp3("updated_at").notNull()
    });
    chartOfAccounts = pgTable3("chart_of_accounts", {
      id: uuid3("id").primaryKey().notNull(),
      companyId: uuid3("company_id"),
      code: text3("code").notNull(),
      name: text3("name").notNull(),
      description: text3("description"),
      accountClass: numeric3("account_class").notNull(),
      accountGroup: numeric3("account_group").notNull(),
      accountType: text3("account_type").notNull(),
      isActive: numeric3("is_active").notNull().default("1"),
      parentId: uuid3("parent_id"),
      // Metadata
      createdAt: timestamp3("created_at").notNull(),
      updatedAt: timestamp3("updated_at").notNull()
    });
    ledgerEntriesRelations = relations2(ledgerEntries, ({ many }) => ({
      lines: many(ledgerLines)
    }));
    ledgerLinesRelations = relations2(ledgerLines, ({ one }) => ({
      entry: one(ledgerEntries, {
        fields: [ledgerLines.ledgerEntryId],
        references: [ledgerEntries.id]
      })
    }));
    chartOfAccountsRelations = relations2(chartOfAccounts, ({ one, many }) => ({
      parent: one(chartOfAccounts, {
        fields: [chartOfAccounts.parentId],
        references: [chartOfAccounts.id]
      }),
      children: many(chartOfAccounts)
    }));
  }
});

// server/modules/accounting/schema/index.ts
var init_schema = __esm({
  "server/modules/accounting/schema/index.ts"() {
    "use strict";
    init_accounting_schema();
  }
});

// server/utils/id.ts
import { randomUUID } from "crypto";
function createId() {
  return randomUUID();
}
var init_id = __esm({
  "server/utils/id.ts"() {
    "use strict";
  }
});

// server/modules/analytics/schema/analytics.schema.ts
import {
  pgTable as pgTable4,
  varchar as varchar2,
  text as text4,
  timestamp as timestamp4,
  boolean as boolean3,
  pgEnum as pgEnum2,
  integer as integer3
} from "drizzle-orm/pg-core";
var reportTypeEnum, alertSeverityEnum, alertStatusEnum, predictiveModelTypeEnum, predictiveScenarioTypeEnum, analyticsDashboards, analyticsReports, reportExecutionHistory, dashboardViews, analyticsMetrics, metricsHistory, analyticsAlerts, alertHistory, biCostCenters, biBusinessUnits, biCostAllocations, costAllocationHistory, predictiveModels, modelTrainingHistory, predictiveScenarios, scenarioResults;
var init_analytics_schema = __esm({
  "server/modules/analytics/schema/analytics.schema.ts"() {
    "use strict";
    init_id();
    reportTypeEnum = pgEnum2("report_type", [
      "financial",
      "inventory",
      "sales",
      "marketing",
      "operations",
      "custom"
    ]);
    alertSeverityEnum = pgEnum2("alert_severity", [
      "critical",
      "high",
      "medium",
      "low",
      "info"
    ]);
    alertStatusEnum = pgEnum2("alert_status", [
      "active",
      "acknowledged",
      "resolved",
      "dismissed"
    ]);
    predictiveModelTypeEnum = pgEnum2("predictive_model_type", [
      "inventory",
      "sales",
      "pricing",
      "marketing",
      "financial",
      "custom"
    ]);
    predictiveScenarioTypeEnum = pgEnum2("predictive_scenario_type", [
      "inventory_planning",
      "sales_forecasting",
      "pricing_optimization",
      "budget_planning",
      "marketing_campaign",
      "custom"
    ]);
    analyticsDashboards = pgTable4("analytics_dashboards", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      name: varchar2("name", { length: 100 }).notNull(),
      description: text4("description"),
      layout: text4("layout"),
      // JSON string with dashboard layout
      createdAt: timestamp4("created_at").defaultNow().notNull(),
      updatedAt: timestamp4("updated_at").defaultNow().notNull(),
      createdBy: varchar2("created_by").notNull(),
      // References user ID
      updatedBy: varchar2("updated_by"),
      // References user ID
      isPublic: boolean3("is_public").default(false).notNull(),
      refreshInterval: integer3("refresh_interval")
      // in seconds
    });
    analyticsReports = pgTable4("analytics_reports", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      name: varchar2("name", { length: 100 }).notNull(),
      description: text4("description"),
      type: reportTypeEnum("type").notNull(),
      parameters: text4("parameters"),
      result: text4("result"),
      createdAt: timestamp4("created_at").defaultNow().notNull(),
      updatedAt: timestamp4("updated_at").defaultNow().notNull(),
      createdBy: varchar2("created_by").notNull(),
      // References user ID
      updatedBy: varchar2("updated_by"),
      // References user ID
      isPublic: boolean3("is_public").default(false).notNull(),
      dashboardId: varchar2("dashboard_id").references(() => analyticsDashboards.id),
      schedule: varchar2("schedule", { length: 50 })
    });
    reportExecutionHistory = pgTable4("report_execution_history", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      reportId: varchar2("report_id").notNull().references(() => analyticsReports.id),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      executedBy: varchar2("executed_by").notNull(),
      // References user ID
      executedAt: timestamp4("executed_at").defaultNow().notNull(),
      parameters: text4("parameters"),
      result: text4("result"),
      executionTime: integer3("execution_time"),
      // in milliseconds
      status: varchar2("status", { length: 20 }).notNull(),
      errorMessage: text4("error_message")
    });
    dashboardViews = pgTable4("dashboard_views", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      dashboardId: varchar2("dashboard_id").notNull().references(() => analyticsDashboards.id),
      userId: varchar2("user_id").notNull(),
      // References user ID
      viewedAt: timestamp4("viewed_at").defaultNow().notNull(),
      viewDuration: integer3("view_duration"),
      // in seconds
      companyId: varchar2("company_id").notNull()
      // References company ID
    });
    analyticsMetrics = pgTable4("analytics_metrics", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      name: varchar2("name", { length: 100 }).notNull(),
      description: text4("description"),
      type: varchar2("type", { length: 50 }).notNull(),
      value: text4("value").notNull(),
      unit: varchar2("unit", { length: 20 }),
      timestamp: timestamp4("timestamp").defaultNow().notNull(),
      period: varchar2("period", { length: 20 }),
      // daily, weekly, monthly, quarterly, yearly
      source: varchar2("source", { length: 50 }),
      metadata: text4("metadata")
      // JSON string with additional metadata
    });
    metricsHistory = pgTable4("metrics_history", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      metricId: varchar2("metric_id").notNull().references(() => analyticsMetrics.id),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      value: text4("value").notNull(),
      timestamp: timestamp4("timestamp").defaultNow().notNull(),
      period: varchar2("period", { length: 20 }),
      // daily, weekly, monthly, quarterly, yearly
      metadata: text4("metadata")
      // JSON string with additional context
    });
    analyticsAlerts = pgTable4("analytics_alerts", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      name: varchar2("name", { length: 100 }).notNull(),
      description: text4("description"),
      metricId: varchar2("metric_id").references(() => analyticsMetrics.id),
      condition: text4("condition").notNull(),
      // e.g., "value > 1000"
      severity: alertSeverityEnum("severity").notNull(),
      status: alertStatusEnum("status").notNull().default("active"),
      createdAt: timestamp4("created_at").defaultNow().notNull(),
      updatedAt: timestamp4("updated_at").defaultNow().notNull(),
      createdBy: varchar2("created_by").notNull(),
      // References user ID
      updatedBy: varchar2("updated_by"),
      // References user ID
      lastTriggeredAt: timestamp4("last_triggered_at"),
      notificationChannels: text4("notification_channels"),
      // JSON string with notification settings
      isActive: boolean3("is_active").default(true).notNull()
    });
    alertHistory = pgTable4("alert_history", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      alertId: varchar2("alert_id").notNull().references(() => analyticsAlerts.id),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      previousStatus: alertStatusEnum("previous_status"),
      newStatus: alertStatusEnum("new_status").notNull(),
      triggeredAt: timestamp4("triggered_at").defaultNow().notNull(),
      acknowledgedBy: varchar2("acknowledged_by"),
      // References user ID
      acknowledgedAt: timestamp4("acknowledged_at"),
      resolvedBy: varchar2("resolved_by"),
      // References user ID
      resolvedAt: timestamp4("resolved_at"),
      metricValue: text4("metric_value"),
      message: text4("message"),
      notificationSent: boolean3("notification_sent").default(false).notNull()
    });
    biCostCenters = pgTable4("bi_cost_centers", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      name: varchar2("name", { length: 100 }).notNull(),
      code: varchar2("code", { length: 50 }).notNull(),
      description: text4("description"),
      budget: text4("budget"),
      // Decimal as text
      managerUserId: varchar2("manager_user_id"),
      // References user ID
      parentCostCenterId: varchar2("parent_cost_center_id"),
      // Self-reference added in SQL migrations
      createdAt: timestamp4("created_at").defaultNow().notNull(),
      updatedAt: timestamp4("updated_at").defaultNow().notNull(),
      createdBy: varchar2("created_by").notNull(),
      // References user ID
      updatedBy: varchar2("updated_by"),
      // References user ID
      isActive: boolean3("is_active").default(true).notNull()
    });
    biBusinessUnits = pgTable4("bi_business_units", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      name: varchar2("name", { length: 100 }).notNull(),
      code: varchar2("code", { length: 50 }).notNull(),
      description: text4("description"),
      managerUserId: varchar2("manager_user_id"),
      // References user ID
      parentBusinessUnitId: varchar2("parent_business_unit_id"),
      // Self-reference added in SQL migrations
      costCenterId: varchar2("cost_center_id").references(() => biCostCenters.id),
      createdAt: timestamp4("created_at").defaultNow().notNull(),
      updatedAt: timestamp4("updated_at").defaultNow().notNull(),
      createdBy: varchar2("created_by").notNull(),
      // References user ID
      updatedBy: varchar2("updated_by"),
      // References user ID
      isActive: boolean3("is_active").default(true).notNull()
    });
    biCostAllocations = pgTable4("bi_cost_allocations", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      name: varchar2("name", { length: 100 }).notNull(),
      description: text4("description"),
      sourceCostCenterId: varchar2("source_cost_center_id").notNull().references(() => biCostCenters.id),
      targetCostCenterId: varchar2("target_cost_center_id").notNull().references(() => biCostCenters.id),
      allocationMethod: varchar2("allocation_method", { length: 50 }).notNull(),
      // fixed, percentage, usage-based
      allocationValue: text4("allocation_value").notNull(),
      // Amount or percentage as text
      startDate: timestamp4("start_date").notNull(),
      endDate: timestamp4("end_date"),
      frequency: varchar2("frequency", { length: 20 }),
      // monthly, quarterly, yearly
      createdAt: timestamp4("created_at").defaultNow().notNull(),
      updatedAt: timestamp4("updated_at").defaultNow().notNull(),
      createdBy: varchar2("created_by").notNull(),
      // References user ID
      updatedBy: varchar2("updated_by"),
      // References user ID
      isActive: boolean3("is_active").default(true).notNull()
    });
    costAllocationHistory = pgTable4("cost_allocation_history", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      costAllocationId: varchar2("cost_allocation_id").notNull().references(() => biCostAllocations.id),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      periodStart: timestamp4("period_start").notNull(),
      periodEnd: timestamp4("period_end").notNull(),
      amount: text4("amount").notNull(),
      // Decimal as text
      allocatedAt: timestamp4("allocated_at").defaultNow().notNull(),
      allocatedBy: varchar2("allocated_by").notNull(),
      // References user ID
      notes: text4("notes")
    });
    predictiveModels = pgTable4("predictive_models", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      name: varchar2("name", { length: 100 }).notNull(),
      description: text4("description"),
      type: predictiveModelTypeEnum("type").notNull(),
      algorithm: varchar2("algorithm", { length: 50 }).notNull(),
      parameters: text4("parameters"),
      // JSON string with model parameters
      modelData: text4("model_data"),
      // Serialized model data or reference
      accuracy: text4("accuracy"),
      // Decimal as text
      lastTrainedAt: timestamp4("last_trained_at"),
      createdAt: timestamp4("created_at").defaultNow().notNull(),
      updatedAt: timestamp4("updated_at").defaultNow().notNull(),
      createdBy: varchar2("created_by").notNull(),
      // References user ID
      updatedBy: varchar2("updated_by"),
      // References user ID
      isActive: boolean3("is_active").default(true).notNull(),
      version: integer3("version").default(1).notNull()
    });
    modelTrainingHistory = pgTable4("model_training_history", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      modelId: varchar2("model_id").notNull().references(() => predictiveModels.id),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      trainedAt: timestamp4("trained_at").defaultNow().notNull(),
      trainedBy: varchar2("trained_by").notNull(),
      // References user ID
      parameters: text4("parameters"),
      // JSON string with training parameters
      trainingDataSize: integer3("training_data_size"),
      accuracy: text4("accuracy"),
      // Decimal as text
      metrics: text4("metrics"),
      // JSON string with performance metrics
      duration: integer3("duration"),
      // in seconds
      version: integer3("version").notNull(),
      status: varchar2("status", { length: 20 }).notNull()
      // success, failed, in-progress
    });
    predictiveScenarios = pgTable4("predictive_scenarios", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      name: varchar2("name", { length: 100 }).notNull(),
      description: text4("description"),
      type: predictiveScenarioTypeEnum("type").notNull(),
      modelId: varchar2("model_id").notNull().references(() => predictiveModels.id),
      parameters: text4("parameters"),
      // JSON string with scenario parameters
      createdAt: timestamp4("created_at").defaultNow().notNull(),
      updatedAt: timestamp4("updated_at").defaultNow().notNull(),
      createdBy: varchar2("created_by").notNull(),
      // References user ID
      updatedBy: varchar2("updated_by"),
      // References user ID
      lastRunAt: timestamp4("last_run_at"),
      isActive: boolean3("is_active").default(true).notNull()
    });
    scenarioResults = pgTable4("scenario_results", {
      id: varchar2("id").primaryKey().notNull().$defaultFn(() => createId()),
      scenarioId: varchar2("scenario_id").notNull().references(() => predictiveScenarios.id),
      companyId: varchar2("company_id").notNull(),
      // References company ID
      runAt: timestamp4("run_at").defaultNow().notNull(),
      runBy: varchar2("run_by").notNull(),
      // References user ID
      parameters: text4("parameters"),
      // JSON string with run parameters
      results: text4("results").notNull(),
      // JSON string with scenario results
      duration: integer3("duration"),
      // in seconds
      status: varchar2("status", { length: 20 }).notNull(),
      // success, failed, in-progress
      notes: text4("notes")
    });
  }
});

// server/modules/integrations/schema/integrations.schema.ts
import {
  pgTable as pgTable5,
  uuid as uuid5,
  text as text5,
  timestamp as timestamp5,
  boolean as boolean4,
  json as json4,
  pgEnum as pgEnum3,
  unique,
  index as index3
} from "drizzle-orm/pg-core";
import { sql as sql3 } from "drizzle-orm";
import { createInsertSchema as createInsertSchema2 } from "drizzle-zod";
import { z } from "zod";
var IntegrationProvider, IntegrationStatus, integrationProviderEnum, integrationStatusEnum, integrations, insertIntegrationSchema, updateIntegrationSchema;
var init_integrations_schema = __esm({
  "server/modules/integrations/schema/integrations.schema.ts"() {
    "use strict";
    IntegrationProvider = /* @__PURE__ */ ((IntegrationProvider3) => {
      IntegrationProvider3["SHOPIFY_ADMIN"] = "shopify_admin";
      IntegrationProvider3["SHOPIFY_STOREFRONT"] = "shopify_storefront";
      IntegrationProvider3["PRESTASHOP"] = "prestashop";
      IntegrationProvider3["WOOCOMMERCE"] = "woocommerce";
      IntegrationProvider3["STRIPE"] = "stripe";
      IntegrationProvider3["PAYPAL"] = "paypal";
      IntegrationProvider3["EMAIL"] = "email";
      IntegrationProvider3["SMS"] = "sms";
      IntegrationProvider3["ANAF"] = "anaf";
      IntegrationProvider3["REVISAL"] = "revisal";
      IntegrationProvider3["API"] = "api";
      return IntegrationProvider3;
    })(IntegrationProvider || {});
    IntegrationStatus = /* @__PURE__ */ ((IntegrationStatus2) => {
      IntegrationStatus2["ACTIVE"] = "active";
      IntegrationStatus2["INACTIVE"] = "inactive";
      IntegrationStatus2["PENDING"] = "pending";
      IntegrationStatus2["ERROR"] = "error";
      return IntegrationStatus2;
    })(IntegrationStatus || {});
    integrationProviderEnum = pgEnum3("integration_provider", Object.values(IntegrationProvider));
    integrationStatusEnum = pgEnum3("integration_status", Object.values(IntegrationStatus));
    integrations = pgTable5("integrations", {
      id: uuid5("id").primaryKey().default(sql3`gen_random_uuid()`),
      companyId: uuid5("company_id").notNull(),
      provider: integrationProviderEnum("provider").notNull(),
      name: text5("name").notNull(),
      description: text5("description"),
      config: json4("config").default({}),
      isConnected: boolean4("is_connected").default(false),
      status: integrationStatusEnum("status").default("inactive" /* INACTIVE */),
      lastSyncedAt: timestamp5("last_synced_at", { withTimezone: true }),
      isActive: boolean4("is_active").default(true),
      metadata: json4("metadata").default({}),
      createdAt: timestamp5("created_at", { withTimezone: true }).defaultNow().notNull(),
      updatedAt: timestamp5("updated_at", { withTimezone: true }).defaultNow().notNull(),
      createdBy: uuid5("created_by"),
      updatedBy: uuid5("updated_by")
    }, (table) => ({
      companyIndex: index3("integrations_company_idx").on(table.companyId),
      providerIndex: index3("integrations_provider_idx").on(table.provider),
      uniqueCompanyProvider: unique("unique_company_provider").on(table.companyId, table.provider)
    }));
    insertIntegrationSchema = createInsertSchema2(integrations, {
      config: z.record(z.any()).optional(),
      metadata: z.record(z.any()).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateIntegrationSchema = createInsertSchema2(integrations, {
      config: z.record(z.any()).optional(),
      metadata: z.record(z.any()).optional()
    }).omit({
      id: true,
      companyId: true,
      createdAt: true,
      updatedAt: true,
      createdBy: true
    }).partial();
  }
});

// server/modules/ecommerce/schema/ecommerce.schema.ts
import {
  pgTable as pgTable6,
  uuid as uuid6,
  text as text6,
  timestamp as timestamp6,
  boolean as boolean5,
  integer as integer4,
  numeric as numeric4,
  json as json5,
  pgEnum as pgEnum4,
  unique as unique2,
  index as index4
} from "drizzle-orm/pg-core";
import { sql as sql4 } from "drizzle-orm";
import { relations as relations3 } from "drizzle-orm";
import { createInsertSchema as createInsertSchema3 } from "drizzle-zod";
import { z as z2 } from "zod";
var OrderStatus, OrderSource, PaymentStatus, PaymentMethod, orderStatusEnum, orderSourceEnum, paymentStatusEnum, paymentMethodEnum, orders, orderItems, transactions, shopifyCollections, shopifyProducts, shopifyVariants, orderRelations, orderItemRelations, transactionRelations, shopifyProductRelations, shopifyVariantRelations, insertOrderSchema, insertOrderItemSchema, insertTransactionSchema, insertShopifyCollectionSchema, insertShopifyProductSchema, insertShopifyVariantSchema;
var init_ecommerce_schema = __esm({
  "server/modules/ecommerce/schema/ecommerce.schema.ts"() {
    "use strict";
    init_crm_schema();
    OrderStatus = /* @__PURE__ */ ((OrderStatus3) => {
      OrderStatus3["PENDING"] = "pending";
      OrderStatus3["PROCESSING"] = "processing";
      OrderStatus3["COMPLETED"] = "completed";
      OrderStatus3["SHIPPED"] = "shipped";
      OrderStatus3["DELIVERED"] = "delivered";
      OrderStatus3["CANCELLED"] = "cancelled";
      OrderStatus3["REFUNDED"] = "refunded";
      OrderStatus3["ON_HOLD"] = "on_hold";
      OrderStatus3["PAYMENT_FAILED"] = "payment_failed";
      return OrderStatus3;
    })(OrderStatus || {});
    OrderSource = /* @__PURE__ */ ((OrderSource2) => {
      OrderSource2["MANUAL"] = "manual";
      OrderSource2["WEBSITE"] = "website";
      OrderSource2["POS"] = "pos";
      OrderSource2["SHOPIFY"] = "shopify";
      OrderSource2["MOBILE_APP"] = "mobile_app";
      return OrderSource2;
    })(OrderSource || {});
    PaymentStatus = /* @__PURE__ */ ((PaymentStatus3) => {
      PaymentStatus3["PENDING"] = "pending";
      PaymentStatus3["PAID"] = "paid";
      PaymentStatus3["PARTIALLY_PAID"] = "partially_paid";
      PaymentStatus3["REFUNDED"] = "refunded";
      PaymentStatus3["PARTIALLY_REFUNDED"] = "partially_refunded";
      PaymentStatus3["FAILED"] = "failed";
      return PaymentStatus3;
    })(PaymentStatus || {});
    PaymentMethod = /* @__PURE__ */ ((PaymentMethod5) => {
      PaymentMethod5["CREDIT_CARD"] = "credit_card";
      PaymentMethod5["DEBIT_CARD"] = "debit_card";
      PaymentMethod5["BANK_TRANSFER"] = "bank_transfer";
      PaymentMethod5["CASH"] = "cash";
      PaymentMethod5["REVOLUT"] = "revolut";
      PaymentMethod5["STRIPE"] = "stripe";
      PaymentMethod5["PAYPAL"] = "paypal";
      PaymentMethod5["OTHER"] = "other";
      return PaymentMethod5;
    })(PaymentMethod || {});
    orderStatusEnum = pgEnum4("order_status", [
      "pending" /* PENDING */,
      "processing" /* PROCESSING */,
      "completed" /* COMPLETED */,
      "shipped" /* SHIPPED */,
      "delivered" /* DELIVERED */,
      "cancelled" /* CANCELLED */,
      "refunded" /* REFUNDED */,
      "on_hold" /* ON_HOLD */,
      "payment_failed" /* PAYMENT_FAILED */
    ]);
    orderSourceEnum = pgEnum4("order_source", [
      "manual" /* MANUAL */,
      "website" /* WEBSITE */,
      "pos" /* POS */,
      "shopify" /* SHOPIFY */,
      "mobile_app" /* MOBILE_APP */
    ]);
    paymentStatusEnum = pgEnum4("payment_status", [
      "pending" /* PENDING */,
      "paid" /* PAID */,
      "partially_paid" /* PARTIALLY_PAID */,
      "refunded" /* REFUNDED */,
      "partially_refunded" /* PARTIALLY_REFUNDED */,
      "failed" /* FAILED */
    ]);
    paymentMethodEnum = pgEnum4("payment_method", [
      "credit_card" /* CREDIT_CARD */,
      "debit_card" /* DEBIT_CARD */,
      "bank_transfer" /* BANK_TRANSFER */,
      "cash" /* CASH */,
      "revolut" /* REVOLUT */,
      "stripe" /* STRIPE */,
      "paypal" /* PAYPAL */,
      "other" /* OTHER */
    ]);
    orders = pgTable6("ecommerce_orders", {
      id: uuid6("id").primaryKey().default(sql4`gen_random_uuid()`),
      companyId: uuid6("company_id").notNull(),
      franchiseId: uuid6("franchise_id"),
      customerId: uuid6("customer_id").references(() => customers.id),
      orderNumber: text6("order_number").notNull().unique(),
      externalId: text6("external_id"),
      // External order ID (e.g., from Shopify)
      externalOrderNumber: text6("external_order_number"),
      // External order number
      orderDate: timestamp6("order_date", { withTimezone: true }).defaultNow().notNull(),
      status: orderStatusEnum("status").default("pending" /* PENDING */).notNull(),
      source: orderSourceEnum("source").default("website" /* WEBSITE */).notNull(),
      customerName: text6("customer_name"),
      customerEmail: text6("customer_email"),
      customerPhone: text6("customer_phone"),
      shippingAddress: json5("shipping_address").default({}),
      billingAddress: json5("billing_address").default({}),
      shippingMethod: text6("shipping_method"),
      shippingCost: numeric4("shipping_cost", { precision: 15, scale: 2 }).default("0").notNull(),
      subtotal: numeric4("subtotal", { precision: 15, scale: 2 }).default("0").notNull(),
      taxAmount: numeric4("tax_amount", { precision: 15, scale: 2 }).default("0").notNull(),
      discountAmount: numeric4("discount_amount", { precision: 15, scale: 2 }).default("0").notNull(),
      totalAmount: numeric4("total_amount", { precision: 15, scale: 2 }).default("0").notNull(),
      currency: text6("currency").default("RON").notNull(),
      notes: text6("notes"),
      paymentStatus: paymentStatusEnum("payment_status").default("pending" /* PENDING */).notNull(),
      tags: json5("tags").default([]),
      metadata: json5("metadata").default({}),
      integrationSource: text6("integration_source"),
      // e.g., shopify, prestashop, etc.
      syncedAt: timestamp6("synced_at", { withTimezone: true }),
      createdAt: timestamp6("created_at", { withTimezone: true }).defaultNow().notNull(),
      updatedAt: timestamp6("updated_at", { withTimezone: true }).defaultNow().notNull(),
      createdBy: uuid6("created_by"),
      updatedBy: uuid6("updated_by")
    }, (orders2) => ({
      companyIndex: index4("ecommerce_orders_company_idx").on(orders2.companyId),
      customerIndex: index4("ecommerce_orders_customer_idx").on(orders2.customerId),
      sourceIndex: index4("ecommerce_orders_source_idx").on(orders2.source),
      statusIndex: index4("ecommerce_orders_status_idx").on(orders2.status),
      dateIndex: index4("ecommerce_orders_date_idx").on(orders2.orderDate),
      companyDateIndex: index4("ecommerce_orders_company_date_idx").on(orders2.companyId, orders2.orderDate),
      companyFranchiseIndex: index4("ecommerce_orders_company_franchise_idx").on(orders2.companyId, orders2.franchiseId)
    }));
    orderItems = pgTable6("ecommerce_order_items", {
      id: uuid6("id").primaryKey().default(sql4`gen_random_uuid()`),
      orderId: uuid6("order_id").notNull().references(() => orders.id, { onDelete: "cascade" }),
      companyId: uuid6("company_id").notNull(),
      productId: uuid6("product_id"),
      // Reference to inventory product
      externalProductId: text6("external_product_id"),
      // External product ID (e.g., from Shopify)
      sku: text6("sku"),
      name: text6("name").notNull(),
      description: text6("description"),
      quantity: numeric4("quantity", { precision: 10, scale: 2 }).notNull(),
      unitPrice: numeric4("unit_price", { precision: 15, scale: 2 }).notNull(),
      taxRate: numeric4("tax_rate", { precision: 5, scale: 2 }).default("19").notNull(),
      taxAmount: numeric4("tax_amount", { precision: 15, scale: 2 }).default("0").notNull(),
      discountAmount: numeric4("discount_amount", { precision: 15, scale: 2 }).default("0").notNull(),
      totalAmount: numeric4("total_amount", { precision: 15, scale: 2 }).notNull(),
      metadata: json5("metadata").default({}),
      createdAt: timestamp6("created_at", { withTimezone: true }).defaultNow().notNull(),
      updatedAt: timestamp6("updated_at", { withTimezone: true }).defaultNow().notNull()
    }, (orderItems2) => ({
      orderIndex: index4("ecommerce_order_items_order_idx").on(orderItems2.orderId),
      productIndex: index4("ecommerce_order_items_product_idx").on(orderItems2.productId)
    }));
    transactions = pgTable6("ecommerce_transactions", {
      id: uuid6("id").primaryKey().default(sql4`gen_random_uuid()`),
      companyId: uuid6("company_id").notNull(),
      franchiseId: uuid6("franchise_id"),
      orderId: uuid6("order_id").references(() => orders.id),
      transactionNumber: text6("transaction_number").notNull().unique(),
      amount: numeric4("amount", { precision: 15, scale: 2 }).notNull(),
      currency: text6("currency").default("RON").notNull(),
      paymentMethod: paymentMethodEnum("payment_method").notNull(),
      status: text6("status").notNull(),
      // success, failed, pending, refunded
      processorId: text6("processor_id"),
      // ID from payment processor
      processorResponse: json5("processor_response").default({}),
      refundAmount: numeric4("refund_amount", { precision: 15, scale: 2 }).default("0"),
      refundReason: text6("refund_reason"),
      metadata: json5("metadata").default({}),
      createdAt: timestamp6("created_at", { withTimezone: true }).defaultNow().notNull(),
      updatedAt: timestamp6("updated_at", { withTimezone: true }).defaultNow().notNull(),
      createdBy: uuid6("created_by"),
      updatedBy: uuid6("updated_by")
    }, (transactions2) => ({
      companyIndex: index4("ecommerce_transactions_company_idx").on(transactions2.companyId),
      orderIndex: index4("ecommerce_transactions_order_idx").on(transactions2.orderId),
      dateIndex: index4("ecommerce_transactions_date_idx").on(transactions2.createdAt),
      companyDateIndex: index4("ecommerce_transactions_company_date_idx").on(transactions2.companyId, transactions2.createdAt),
      companyFranchiseIndex: index4("ecommerce_transactions_company_franchise_idx").on(transactions2.companyId, transactions2.franchiseId)
    }));
    shopifyCollections = pgTable6("ecommerce_shopify_collections", {
      id: uuid6("id").primaryKey().default(sql4`gen_random_uuid()`),
      companyId: uuid6("company_id").notNull(),
      shopifyCollectionId: text6("shopify_collection_id").notNull(),
      title: text6("title").notNull(),
      description: text6("description"),
      handle: text6("handle"),
      localCategoryId: uuid6("local_category_id"),
      // Reference to local inventory category
      isActive: boolean5("is_active").default(true),
      lastSyncedAt: timestamp6("last_synced_at", { withTimezone: true }),
      metadata: json5("metadata").default({}),
      createdAt: timestamp6("created_at", { withTimezone: true }).defaultNow().notNull(),
      updatedAt: timestamp6("updated_at", { withTimezone: true }).defaultNow().notNull()
    }, (shopifyCollections2) => ({
      companyIndex: index4("ecommerce_shopify_collections_company_idx").on(shopifyCollections2.companyId),
      shopifyIdIndex: index4("ecommerce_shopify_collections_shopify_id_idx").on(shopifyCollections2.shopifyCollectionId),
      uniqueShopifyCollection: unique2("unique_shopify_collection").on(shopifyCollections2.companyId, shopifyCollections2.shopifyCollectionId)
    }));
    shopifyProducts = pgTable6("ecommerce_shopify_products", {
      id: uuid6("id").primaryKey().default(sql4`gen_random_uuid()`),
      companyId: uuid6("company_id").notNull(),
      shopifyProductId: text6("shopify_product_id").notNull(),
      title: text6("title").notNull(),
      description: text6("description"),
      handle: text6("handle"),
      productType: text6("product_type"),
      vendor: text6("vendor"),
      tags: json5("tags").default([]),
      localProductId: uuid6("local_product_id"),
      // Reference to local inventory product
      isActive: boolean5("is_active").default(true),
      lastSyncedAt: timestamp6("last_synced_at", { withTimezone: true }),
      metadata: json5("metadata").default({}),
      createdAt: timestamp6("created_at", { withTimezone: true }).defaultNow().notNull(),
      updatedAt: timestamp6("updated_at", { withTimezone: true }).defaultNow().notNull()
    }, (shopifyProducts2) => ({
      companyIndex: index4("ecommerce_shopify_products_company_idx").on(shopifyProducts2.companyId),
      shopifyIdIndex: index4("ecommerce_shopify_products_shopify_id_idx").on(shopifyProducts2.shopifyProductId),
      uniqueShopifyProduct: unique2("unique_shopify_product").on(shopifyProducts2.companyId, shopifyProducts2.shopifyProductId)
    }));
    shopifyVariants = pgTable6("ecommerce_shopify_variants", {
      id: uuid6("id").primaryKey().default(sql4`gen_random_uuid()`),
      companyId: uuid6("company_id").notNull(),
      shopifyProductId: text6("shopify_product_id").notNull(),
      shopifyVariantId: text6("shopify_variant_id").notNull(),
      shopifyProductEntryId: uuid6("shopify_product_entry_id").notNull().references(() => shopifyProducts.id, { onDelete: "cascade" }),
      title: text6("title").notNull(),
      sku: text6("sku"),
      barcode: text6("barcode"),
      price: numeric4("price", { precision: 15, scale: 2 }),
      compareAtPrice: numeric4("compare_at_price", { precision: 15, scale: 2 }),
      inventory: integer4("inventory"),
      localInventoryItemId: uuid6("local_inventory_item_id"),
      // Reference to local inventory item
      isActive: boolean5("is_active").default(true),
      lastSyncedAt: timestamp6("last_synced_at", { withTimezone: true }),
      metadata: json5("metadata").default({}),
      createdAt: timestamp6("created_at", { withTimezone: true }).defaultNow().notNull(),
      updatedAt: timestamp6("updated_at", { withTimezone: true }).defaultNow().notNull()
    }, (shopifyVariants2) => ({
      shopifyProductIndex: index4("ecommerce_shopify_variants_product_idx").on(shopifyVariants2.shopifyProductEntryId),
      shopifyIdIndex: index4("ecommerce_shopify_variants_shopify_id_idx").on(shopifyVariants2.shopifyVariantId),
      uniqueShopifyVariant: unique2("unique_shopify_variant").on(shopifyVariants2.companyId, shopifyVariants2.shopifyVariantId)
    }));
    orderRelations = relations3(orders, ({ one, many }) => ({
      customer: one(customers, {
        fields: [orders.customerId],
        references: [customers.id]
      }),
      items: many(orderItems),
      transactions: many(transactions)
    }));
    orderItemRelations = relations3(orderItems, ({ one }) => ({
      order: one(orders, {
        fields: [orderItems.orderId],
        references: [orders.id]
      })
    }));
    transactionRelations = relations3(transactions, ({ one }) => ({
      order: one(orders, {
        fields: [transactions.orderId],
        references: [orders.id]
      })
    }));
    shopifyProductRelations = relations3(shopifyProducts, ({ many }) => ({
      variants: many(shopifyVariants)
    }));
    shopifyVariantRelations = relations3(shopifyVariants, ({ one }) => ({
      product: one(shopifyProducts, {
        fields: [shopifyVariants.shopifyProductEntryId],
        references: [shopifyProducts.id]
      })
    }));
    insertOrderSchema = createInsertSchema3(orders, {
      // Custom validations can be added here
      tags: z2.array(z2.string()).optional(),
      metadata: z2.record(z2.any()).optional(),
      shippingAddress: z2.record(z2.any()).optional(),
      billingAddress: z2.record(z2.any()).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOrderItemSchema = createInsertSchema3(orderItems).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertTransactionSchema = createInsertSchema3(transactions, {
      metadata: z2.record(z2.any()).optional(),
      processorResponse: z2.record(z2.any()).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertShopifyCollectionSchema = createInsertSchema3(shopifyCollections, {
      metadata: z2.record(z2.any()).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertShopifyProductSchema = createInsertSchema3(shopifyProducts, {
      tags: z2.array(z2.string()).optional(),
      metadata: z2.record(z2.any()).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertShopifyVariantSchema = createInsertSchema3(shopifyVariants, {
      metadata: z2.record(z2.any()).optional()
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
  }
});

// server/modules/ecommerce/schema/index.ts
var init_schema2 = __esm({
  "server/modules/ecommerce/schema/index.ts"() {
    "use strict";
    init_ecommerce_schema();
  }
});

// shared/schema/collaboration.schema.ts
import {
  pgTable as pgTable7,
  uuid as uuid7,
  text as text7,
  timestamp as timestamp7,
  pgEnum as pgEnum5,
  index as index5,
  jsonb as jsonb2,
  varchar as varchar3,
  boolean as boolean6
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema4 } from "drizzle-zod";
import { z as z3 } from "zod";
var TaskStatus, TaskPriority, TaskType, CommunityCategory, taskStatusEnum, taskPriorityEnum, taskTypeEnum, collaborationTasks, collaborationNotes, collaborationThreads, collaborationMessages, taskAssignmentHistory, taskStatusHistory, taskWatchers, insertCollaborationTaskSchema, insertCollaborationNoteSchema, insertCollaborationThreadSchema, insertCollaborationMessageSchema, insertTaskWatcherSchema, collaborationActivities, collaborationNotifications, insertActivitySchema2, insertNotificationSchema;
var init_collaboration_schema = __esm({
  "shared/schema/collaboration.schema.ts"() {
    "use strict";
    TaskStatus = /* @__PURE__ */ ((TaskStatus2) => {
      TaskStatus2["PENDING"] = "pending";
      TaskStatus2["IN_PROGRESS"] = "in_progress";
      TaskStatus2["COMPLETED"] = "completed";
      TaskStatus2["BLOCKED"] = "blocked";
      TaskStatus2["DEFERRED"] = "deferred";
      TaskStatus2["CANCELLED"] = "cancelled";
      TaskStatus2["REVIEW"] = "review";
      return TaskStatus2;
    })(TaskStatus || {});
    TaskPriority = /* @__PURE__ */ ((TaskPriority3) => {
      TaskPriority3["LOW"] = "low";
      TaskPriority3["NORMAL"] = "normal";
      TaskPriority3["HIGH"] = "high";
      TaskPriority3["URGENT"] = "urgent";
      TaskPriority3["CRITICAL"] = "critical";
      return TaskPriority3;
    })(TaskPriority || {});
    TaskType = /* @__PURE__ */ ((TaskType3) => {
      TaskType3["REGULAR"] = "regular";
      TaskType3["PROJECT"] = "project";
      TaskType3["MEETING"] = "meeting";
      TaskType3["APPROVAL"] = "approval";
      TaskType3["REVIEW"] = "review";
      TaskType3["DECISION"] = "decision";
      return TaskType3;
    })(TaskType || {});
    CommunityCategory = /* @__PURE__ */ ((CommunityCategory3) => {
      CommunityCategory3["ANUNTURI"] = "ANUNTURI";
      CommunityCategory3["INTREBARI"] = "INTREBARI";
      CommunityCategory3["IDEI"] = "IDEI";
      CommunityCategory3["EVENIMENTE"] = "EVENIMENTE";
      CommunityCategory3["RESURSE"] = "RESURSE";
      CommunityCategory3["TUTORIALE"] = "TUTORIALE";
      return CommunityCategory3;
    })(CommunityCategory || {});
    taskStatusEnum = pgEnum5("task_status", [
      "pending" /* PENDING */,
      "in_progress" /* IN_PROGRESS */,
      "completed" /* COMPLETED */,
      "blocked" /* BLOCKED */,
      "deferred" /* DEFERRED */,
      "cancelled" /* CANCELLED */,
      "review" /* REVIEW */
    ]);
    taskPriorityEnum = pgEnum5("task_priority", [
      "low" /* LOW */,
      "normal" /* NORMAL */,
      "high" /* HIGH */,
      "urgent" /* URGENT */,
      "critical" /* CRITICAL */
    ]);
    taskTypeEnum = pgEnum5("task_type", [
      "regular" /* REGULAR */,
      "project" /* PROJECT */,
      "meeting" /* MEETING */,
      "approval" /* APPROVAL */,
      "review" /* REVIEW */,
      "decision" /* DECISION */
    ]);
    collaborationTasks = pgTable7("collaboration_tasks", {
      id: uuid7("id").primaryKey().defaultRandom(),
      companyId: uuid7("company_id").notNull(),
      franchiseId: uuid7("franchise_id"),
      title: varchar3("title", { length: 255 }).notNull(),
      description: text7("description").notNull(),
      type: taskTypeEnum("type").default("regular" /* REGULAR */),
      status: taskStatusEnum("status").default("pending" /* PENDING */),
      priority: taskPriorityEnum("priority").default("normal" /* NORMAL */),
      assignedTo: uuid7("assigned_to").notNull(),
      supervisorId: uuid7("supervisor_id"),
      dueDate: timestamp7("due_date"),
      completionDate: timestamp7("completion_date"),
      metadata: jsonb2("metadata").default({}),
      tags: jsonb2("tags").default([]),
      isRecurring: boolean6("is_recurring").default(false),
      recurringPattern: jsonb2("recurring_pattern").default({}),
      parentTaskId: uuid7("parent_task_id"),
      relatedItems: jsonb2("related_items").default({}),
      // Can store relations to documents, invoices, etc.
      createdAt: timestamp7("created_at").defaultNow(),
      updatedAt: timestamp7("updated_at").defaultNow(),
      createdBy: uuid7("created_by"),
      updatedBy: uuid7("updated_by")
    }, (table) => ({
      companyIdIdx: index5("collaboration_tasks_company_id_idx").on(table.companyId),
      assignedToIdx: index5("collaboration_tasks_assigned_to_idx").on(table.assignedTo),
      supervisorIdIdx: index5("collaboration_tasks_supervisor_id_idx").on(table.supervisorId),
      statusIdx: index5("collaboration_tasks_status_idx").on(table.status),
      priorityIdx: index5("collaboration_tasks_priority_idx").on(table.priority),
      dueDateIdx: index5("collaboration_tasks_due_date_idx").on(table.dueDate),
      typeIdx: index5("collaboration_tasks_type_idx").on(table.type),
      parentTaskIdIdx: index5("collaboration_tasks_parent_task_id_idx").on(table.parentTaskId)
    }));
    collaborationNotes = pgTable7("collaboration_notes", {
      id: uuid7("id").primaryKey().defaultRandom(),
      taskId: uuid7("task_id").notNull(),
      companyId: uuid7("company_id").notNull(),
      userId: uuid7("user_id").notNull(),
      content: text7("content").notNull(),
      contentHtml: text7("content_html"),
      isPrivate: boolean6("is_private").default(false),
      isPinned: boolean6("is_pinned").default(false),
      attachments: jsonb2("attachments").default([]),
      metadata: jsonb2("metadata").default({}),
      createdAt: timestamp7("created_at").defaultNow(),
      updatedAt: timestamp7("updated_at").defaultNow(),
      editedBy: uuid7("edited_by")
    }, (table) => ({
      taskIdIdx: index5("collaboration_notes_task_id_idx").on(table.taskId),
      companyIdIdx: index5("collaboration_notes_company_id_idx").on(table.companyId),
      userIdIdx: index5("collaboration_notes_user_id_idx").on(table.userId),
      createdAtIdx: index5("collaboration_notes_created_at_idx").on(table.createdAt)
    }));
    collaborationThreads = pgTable7("collaboration_threads", {
      id: uuid7("id").primaryKey().defaultRandom(),
      companyId: uuid7("company_id").notNull(),
      franchiseId: uuid7("franchise_id"),
      title: varchar3("title", { length: 255 }).notNull(),
      description: text7("description"),
      isPrivate: boolean6("is_private").default(false),
      isClosed: boolean6("is_closed").default(false),
      category: varchar3("category", { length: 100 }),
      tags: jsonb2("tags").default([]),
      participants: jsonb2("participants").default([]),
      lastMessageAt: timestamp7("last_message_at").defaultNow(),
      metadata: jsonb2("metadata").default({}),
      createdAt: timestamp7("created_at").defaultNow(),
      updatedAt: timestamp7("updated_at").defaultNow(),
      createdBy: uuid7("created_by").notNull(),
      updatedBy: uuid7("updated_by")
    }, (table) => ({
      companyIdIdx: index5("collaboration_threads_company_id_idx").on(table.companyId),
      createdByIdx: index5("collaboration_threads_created_by_idx").on(table.createdBy),
      categoryIdx: index5("collaboration_threads_category_idx").on(table.category),
      lastMessageAtIdx: index5("collaboration_threads_last_message_at_idx").on(table.lastMessageAt)
    }));
    collaborationMessages = pgTable7("collaboration_messages", {
      id: uuid7("id").primaryKey().defaultRandom(),
      threadId: uuid7("thread_id").notNull(),
      companyId: uuid7("company_id").notNull(),
      userId: uuid7("user_id").notNull(),
      content: text7("content").notNull(),
      contentHtml: text7("content_html"),
      isEdited: boolean6("is_edited").default(false),
      attachments: jsonb2("attachments").default([]),
      mentions: jsonb2("mentions").default([]),
      replyToId: uuid7("reply_to_id"),
      metadata: jsonb2("metadata").default({}),
      createdAt: timestamp7("created_at").defaultNow(),
      updatedAt: timestamp7("updated_at").defaultNow(),
      editedBy: uuid7("edited_by")
    }, (table) => ({
      threadIdIdx: index5("collaboration_messages_thread_id_idx").on(table.threadId),
      companyIdIdx: index5("collaboration_messages_company_id_idx").on(table.companyId),
      userIdIdx: index5("collaboration_messages_user_id_idx").on(table.userId),
      createdAtIdx: index5("collaboration_messages_created_at_idx").on(table.createdAt),
      replyToIdIdx: index5("collaboration_messages_reply_to_id_idx").on(table.replyToId)
    }));
    taskAssignmentHistory = pgTable7("collaboration_task_assignments", {
      id: uuid7("id").primaryKey().defaultRandom(),
      taskId: uuid7("task_id").notNull(),
      companyId: uuid7("company_id").notNull(),
      assignedTo: uuid7("assigned_to").notNull(),
      assignedBy: uuid7("assigned_by").notNull(),
      assignedFrom: uuid7("assigned_from"),
      comments: text7("comments"),
      createdAt: timestamp7("created_at").defaultNow()
    }, (table) => ({
      taskIdIdx: index5("collaboration_task_assignments_task_id_idx").on(table.taskId),
      assignedToIdx: index5("collaboration_task_assignments_assigned_to_idx").on(table.assignedTo),
      assignedByIdx: index5("collaboration_task_assignments_assigned_by_idx").on(table.assignedBy),
      createdAtIdx: index5("collaboration_task_assignments_created_at_idx").on(table.createdAt)
    }));
    taskStatusHistory = pgTable7("collaboration_task_status_history", {
      id: uuid7("id").primaryKey().defaultRandom(),
      taskId: uuid7("task_id").notNull(),
      companyId: uuid7("company_id").notNull(),
      status: taskStatusEnum("status").notNull(),
      previousStatus: taskStatusEnum("previous_status"),
      changedBy: uuid7("changed_by").notNull(),
      comments: text7("comments"),
      metadata: jsonb2("metadata").default({}),
      createdAt: timestamp7("created_at").defaultNow()
    }, (table) => ({
      taskIdIdx: index5("collaboration_task_status_history_task_id_idx").on(table.taskId),
      statusIdx: index5("collaboration_task_status_history_status_idx").on(table.status),
      changedByIdx: index5("collaboration_task_status_history_changed_by_idx").on(table.changedBy),
      createdAtIdx: index5("collaboration_task_status_history_created_at_idx").on(table.createdAt)
    }));
    taskWatchers = pgTable7("collaboration_task_watchers", {
      id: uuid7("id").primaryKey().defaultRandom(),
      taskId: uuid7("task_id").notNull(),
      companyId: uuid7("company_id").notNull(),
      userId: uuid7("user_id").notNull(),
      notificationPreference: jsonb2("notification_preference").default({}),
      createdAt: timestamp7("created_at").defaultNow()
    }, (table) => ({
      taskIdIdx: index5("collaboration_task_watchers_task_id_idx").on(table.taskId),
      userIdIdx: index5("collaboration_task_watchers_user_id_idx").on(table.userId),
      taskUserIdx: index5("collaboration_task_watchers_task_user_idx").on(table.taskId, table.userId)
    }));
    insertCollaborationTaskSchema = createInsertSchema4(collaborationTasks, {
      id: z3.string().uuid().optional(),
      status: z3.nativeEnum(TaskStatus).optional(),
      priority: z3.nativeEnum(TaskPriority).optional(),
      type: z3.nativeEnum(TaskType).optional(),
      createdAt: z3.date().optional(),
      updatedAt: z3.date().optional(),
      tags: z3.array(z3.string()).optional(),
      relatedItems: z3.record(z3.string(), z3.any()).optional()
    });
    insertCollaborationNoteSchema = createInsertSchema4(collaborationNotes, {
      id: z3.string().uuid().optional(),
      createdAt: z3.date().optional(),
      updatedAt: z3.date().optional(),
      attachments: z3.array(z3.any()).optional()
    });
    insertCollaborationThreadSchema = createInsertSchema4(collaborationThreads, {
      id: z3.string().uuid().optional(),
      createdAt: z3.date().optional(),
      updatedAt: z3.date().optional(),
      tags: z3.array(z3.string()).optional(),
      participants: z3.array(z3.string()).optional(),
      category: z3.nativeEnum(CommunityCategory).optional()
    });
    insertCollaborationMessageSchema = createInsertSchema4(collaborationMessages, {
      id: z3.string().uuid().optional(),
      createdAt: z3.date().optional(),
      updatedAt: z3.date().optional(),
      attachments: z3.array(z3.any()).optional(),
      mentions: z3.array(z3.string()).optional()
    });
    insertTaskWatcherSchema = createInsertSchema4(taskWatchers, {
      id: z3.string().uuid().optional(),
      createdAt: z3.date().optional(),
      notificationPreference: z3.record(z3.string(), z3.any()).optional()
    });
    collaborationActivities = pgTable7("collaboration_activities", {
      id: uuid7("id").primaryKey().defaultRandom(),
      companyId: uuid7("company_id").notNull(),
      userId: uuid7("user_id").notNull(),
      type: varchar3("type", { length: 50 }).notNull(),
      objectType: varchar3("object_type", { length: 50 }).notNull(),
      objectId: uuid7("object_id").notNull(),
      title: varchar3("title", { length: 255 }).notNull(),
      data: jsonb2("data").default({}),
      createdAt: timestamp7("created_at").defaultNow()
    }, (table) => ({
      companyIdIdx: index5("collaboration_activities_company_id_idx").on(table.companyId),
      userIdIdx: index5("collaboration_activities_user_id_idx").on(table.userId),
      typeIdx: index5("collaboration_activities_type_idx").on(table.type),
      objectTypeIdx: index5("collaboration_activities_object_type_idx").on(table.objectType),
      objectIdIdx: index5("collaboration_activities_object_id_idx").on(table.objectId),
      createdAtIdx: index5("collaboration_activities_created_at_idx").on(table.createdAt)
    }));
    collaborationNotifications = pgTable7("collaboration_notifications", {
      id: uuid7("id").primaryKey().defaultRandom(),
      companyId: uuid7("company_id").notNull(),
      userId: uuid7("user_id").notNull(),
      type: varchar3("type", { length: 50 }).notNull(),
      title: varchar3("title", { length: 255 }).notNull(),
      message: text7("message").notNull(),
      status: varchar3("status", { length: 50 }).default("UNREAD").notNull(),
      sourceType: varchar3("source_type", { length: 50 }),
      sourceId: uuid7("source_id"),
      actionType: varchar3("action_type", { length: 50 }),
      actionTarget: varchar3("action_target", { length: 255 }),
      metadata: jsonb2("metadata").default({}),
      createdAt: timestamp7("created_at").defaultNow(),
      updatedAt: timestamp7("updated_at").defaultNow()
    }, (table) => ({
      companyIdIdx: index5("collaboration_notifications_company_id_idx").on(table.companyId),
      userIdIdx: index5("collaboration_notifications_user_id_idx").on(table.userId),
      statusIdx: index5("collaboration_notifications_status_idx").on(table.status),
      typeIdx: index5("collaboration_notifications_type_idx").on(table.type),
      sourceTypeIdx: index5("collaboration_notifications_source_type_idx").on(table.sourceType),
      createdAtIdx: index5("collaboration_notifications_created_at_idx").on(table.createdAt)
    }));
    insertActivitySchema2 = createInsertSchema4(collaborationActivities, {
      id: z3.string().uuid().optional(),
      createdAt: z3.date().optional(),
      data: z3.record(z3.string(), z3.any()).optional()
    });
    insertNotificationSchema = createInsertSchema4(collaborationNotifications, {
      id: z3.string().uuid().optional(),
      createdAt: z3.date().optional(),
      updatedAt: z3.date().optional(),
      metadata: z3.record(z3.string(), z3.any()).optional()
    });
  }
});

// shared/schema/invoice-numbering.schema.ts
import { sql as sql5 } from "drizzle-orm";
import { createInsertSchema as createInsertSchema5 } from "drizzle-zod";
import { z as z4 } from "zod";
import {
  pgTable as pgTable8,
  text as text8,
  uuid as uuid8,
  varchar as varchar4,
  integer as integer5,
  timestamp as timestamp8,
  boolean as boolean7,
  unique as unique3
} from "drizzle-orm/pg-core";
var invoiceNumberingSettings, insertInvoiceNumberingSettingsSchema, updateInvoiceNumberingSettingsSchema;
var init_invoice_numbering_schema = __esm({
  "shared/schema/invoice-numbering.schema.ts"() {
    "use strict";
    invoiceNumberingSettings = pgTable8("invoice_numbering_settings", {
      id: uuid8("id").defaultRandom().primaryKey(),
      // The company that owns this numbering configuration
      companyId: uuid8("company_id").notNull(),
      // Series code (e.g., 'FDI', 'AVANS', etc.)
      series: varchar4("series", { length: 10 }).notNull(),
      // The current number in the sequence (will be incremented with each new invoice)
      currentNumber: integer5("current_number").notNull().default(1),
      // The last used number (used for tracking and auditing)
      lastNumber: integer5("last_number"),
      // The next number to be used (calculated from currentNumber)
      nextNumber: integer5("next_number").notNull().default(1),
      // Prefix to be added before the number (optional)
      prefix: varchar4("prefix", { length: 10 }),
      // Suffix to be added after the number (optional, like year)
      suffix: varchar4("suffix", { length: 10 }),
      // Year component (optional, for annual series reset)
      year: integer5("year"),
      // The padding width for the number part (e.g., 5 means '00001')
      paddingWidth: integer5("padding_width").notNull().default(5),
      // Whether this series is active and available for use
      isActive: boolean7("is_active").notNull().default(true),
      // Whether this is the default series for the company/warehouse/franchise
      isDefault: boolean7("is_default").default(false),
      // Specific warehouse ID (optional) - if set, this series can only be used for this warehouse
      warehouseId: uuid8("warehouse_id"),
      // Specific franchise ID (optional) - if set, this series can only be used for this franchise
      franchiseId: uuid8("franchise_id"),
      // Description of the numbering sequence
      description: text8("description"),
      // Creation timestamp
      createdAt: timestamp8("created_at").notNull().default(sql5`CURRENT_TIMESTAMP`),
      // Last update timestamp
      updatedAt: timestamp8("updated_at").notNull().default(sql5`CURRENT_TIMESTAMP`)
      // Unique constraint to ensure series + warehouse + franchise combination is unique per company
    }, (table) => {
      return {
        seriesWarehouseFranchiseUnique: unique3().on(table.companyId, table.series, table.warehouseId, table.franchiseId)
      };
    });
    insertInvoiceNumberingSettingsSchema = createInsertSchema5(invoiceNumberingSettings).omit({ id: true, createdAt: true, updatedAt: true }).extend({
      series: z4.string().min(1).max(10).regex(
        /^[A-Z0-9]+$/,
        "Seria trebuie s\u0103 con\u021Bin\u0103 doar litere mari \u0219i cifre"
      ),
      currentNumber: z4.number().int().min(1).optional(),
      nextNumber: z4.number().int().min(1).optional(),
      lastNumber: z4.number().int().min(0).optional(),
      paddingWidth: z4.number().int().min(1).max(10).optional(),
      prefix: z4.string().max(10).optional(),
      suffix: z4.string().max(10).optional(),
      year: z4.number().int().optional(),
      franchiseId: z4.string().uuid().optional().nullable(),
      isDefault: z4.boolean().optional()
    });
    updateInvoiceNumberingSettingsSchema = createInsertSchema5(invoiceNumberingSettings).omit({ id: true, companyId: true, createdAt: true, updatedAt: true }).extend({
      series: z4.string().min(1).max(10).regex(
        /^[A-Z0-9]+$/,
        "Seria trebuie s\u0103 con\u021Bin\u0103 doar litere mari \u0219i cifre"
      ).optional(),
      currentNumber: z4.number().int().min(1).optional(),
      nextNumber: z4.number().int().min(1).optional(),
      lastNumber: z4.number().int().min(0).optional(),
      paddingWidth: z4.number().int().min(1).max(10).optional(),
      prefix: z4.string().max(10).optional(),
      suffix: z4.string().max(10).optional(),
      year: z4.number().int().optional(),
      franchiseId: z4.string().uuid().optional().nullable(),
      isDefault: z4.boolean().optional()
    });
  }
});

// shared/schema/warehouse.ts
import { pgTable as pgTable9, text as text9, uuid as uuid9, timestamp as timestamp9, boolean as boolean8, pgEnum as pgEnum6 } from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema6 } from "drizzle-zod";
var warehouseTypeEnum, warehouseTypeEnumType, warehouses, insertWarehouseSchema;
var init_warehouse = __esm({
  "shared/schema/warehouse.ts"() {
    "use strict";
    warehouseTypeEnum = {
      DEPOZIT: "depozit",
      MAGAZIN: "magazin",
      CUSTODIE: "custodie",
      TRANSFER: "transfer"
    };
    warehouseTypeEnumType = pgEnum6("gestiune_type", ["depozit", "magazin", "custodie", "transfer"]);
    warehouses = pgTable9("warehouses", {
      id: uuid9("id").primaryKey().defaultRandom(),
      companyId: uuid9("company_id").notNull(),
      franchiseId: uuid9("franchise_id"),
      name: text9("name").notNull(),
      code: text9("code").notNull(),
      location: text9("location"),
      address: text9("address"),
      type: warehouseTypeEnumType("type").notNull(),
      isActive: boolean8("is_active").notNull().default(true),
      createdAt: timestamp9("created_at").notNull().defaultNow(),
      updatedAt: timestamp9("updated_at").notNull().defaultNow()
    });
    insertWarehouseSchema = createInsertSchema6(warehouses).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
  }
});

// server/modules/inventory/schema/inventory.schema.ts
import { z as z5 } from "zod";
var gestiuneTypeEnum, stockTrackingTypeEnum, nirStatusEnum, transferStatusEnum, purchaseOrderStatusEnum, reservationSourceEnum, insertWarehouseSchema2, insertNirDocumentSchema, insertNirItemSchema, insertTransferDocumentSchema, insertTransferItemSchema, insertPurchaseOrderSchema, insertPurchaseOrderItemSchema, insertStockReservationSchema, createWarehouseSchema, createNirDocumentSchema, createNirItemSchema, createTransferDocumentSchema, createTransferItemSchema, createPurchaseOrderSchema, createPurchaseOrderItemSchema, createStockReservationSchema;
var init_inventory_schema = __esm({
  "server/modules/inventory/schema/inventory.schema.ts"() {
    "use strict";
    gestiuneTypeEnum = {
      enumValues: ["depozit", "magazin", "custodie", "transfer"]
    };
    stockTrackingTypeEnum = {
      enumValues: ["QUANTITATIVE", "QUANTITATIVE_VALUE", "VALUE_ONLY"]
    };
    nirStatusEnum = {
      enumValues: ["draft", "pending", "approved", "rejected"]
    };
    transferStatusEnum = {
      enumValues: ["draft", "issued", "in_transit", "received", "cancelled"]
    };
    purchaseOrderStatusEnum = {
      enumValues: ["draft", "sent", "partial", "complete", "cancelled"]
    };
    reservationSourceEnum = {
      enumValues: ["online_order", "sales_order", "warehouse_transfer", "other"]
    };
    insertWarehouseSchema2 = z5.object({
      companyId: z5.string().uuid(),
      franchiseId: z5.string().uuid().optional().nullable(),
      name: z5.string().min(3).max(100),
      code: z5.string().min(2).max(20),
      type: z5.enum(gestiuneTypeEnum.enumValues),
      trackingType: z5.enum(stockTrackingTypeEnum.enumValues),
      location: z5.string().max(255).optional().nullable(),
      responsible: z5.string().max(100).optional().nullable(),
      isActive: z5.boolean().default(true)
    });
    insertNirDocumentSchema = z5.object({
      companyId: z5.string().uuid(),
      franchiseId: z5.string().uuid().optional().nullable(),
      nirNumber: z5.string().min(3),
      warehouseId: z5.string().uuid(),
      warehouseType: z5.string(),
      isCustody: z5.boolean().optional().default(false),
      supplierId: z5.string().uuid(),
      supplierInvoiceNumber: z5.string().optional().nullable(),
      receiptDate: z5.date().default(() => /* @__PURE__ */ new Date()),
      status: z5.enum(nirStatusEnum.enumValues).default("draft"),
      totalValueNoVat: z5.number().default(0),
      totalVat: z5.number().default(0),
      totalValueWithVat: z5.number().default(0),
      currency: z5.string().optional().default("RON"),
      exchangeRate: z5.number().optional().default(1)
    });
    insertNirItemSchema = z5.object({
      productId: z5.string().uuid(),
      quantity: z5.number().positive(),
      batchNo: z5.string().optional().nullable(),
      expiryDate: z5.date().optional().nullable(),
      purchasePrice: z5.number().nonnegative(),
      purchasePriceWithVat: z5.number().optional(),
      sellingPrice: z5.number().optional(),
      sellingPriceWithVat: z5.number().optional(),
      vatRate: z5.number().nonnegative().default(19),
      vatValue: z5.number().optional().default(0),
      totalValueNoVat: z5.number().optional().default(0),
      totalValueWithVat: z5.number().optional().default(0)
    });
    insertTransferDocumentSchema = z5.object({
      companyId: z5.string().uuid(),
      franchiseId: z5.string().uuid().optional().nullable(),
      referenceNumber: z5.string().min(3),
      sourceWarehouseId: z5.string().uuid(),
      destinationWarehouseId: z5.string().uuid(),
      transferDate: z5.date().default(() => /* @__PURE__ */ new Date()),
      status: z5.enum(transferStatusEnum.enumValues).default("draft"),
      totalValueNoVat: z5.number().default(0),
      totalVat: z5.number().default(0),
      totalValueWithVat: z5.number().default(0),
      currency: z5.string().optional().default("RON"),
      exchangeRate: z5.number().optional().default(1),
      notes: z5.string().optional().nullable()
    });
    insertTransferItemSchema = z5.object({
      productId: z5.string().uuid(),
      quantity: z5.number().positive(),
      batchNo: z5.string().optional().nullable(),
      expiryDate: z5.date().optional().nullable(),
      unitPrice: z5.number().nonnegative(),
      unitPriceWithVat: z5.number().optional(),
      vatRate: z5.number().nonnegative().default(19),
      vatValue: z5.number().optional().default(0),
      totalValueNoVat: z5.number().optional().default(0),
      totalValueWithVat: z5.number().optional().default(0)
    });
    insertPurchaseOrderSchema = z5.object({
      companyId: z5.string().uuid(),
      franchiseId: z5.string().uuid().optional().nullable(),
      poNumber: z5.string().min(3),
      warehouseId: z5.string().uuid(),
      supplierId: z5.string().uuid(),
      orderDate: z5.date().default(() => /* @__PURE__ */ new Date()),
      expectedDeliveryDate: z5.date().optional().nullable(),
      status: z5.enum(purchaseOrderStatusEnum.enumValues).default("draft"),
      totalValueNoVat: z5.number().default(0),
      totalVat: z5.number().default(0),
      totalValueWithVat: z5.number().default(0),
      currency: z5.string().optional().default("RON"),
      exchangeRate: z5.number().optional().default(1),
      notes: z5.string().optional().nullable()
    });
    insertPurchaseOrderItemSchema = z5.object({
      productId: z5.string().uuid(),
      quantity: z5.number().positive(),
      unitPrice: z5.number().positive(),
      unitPriceWithVat: z5.number().optional(),
      vatRate: z5.number().nonnegative().default(19),
      vatValue: z5.number().optional().default(0),
      totalValueNoVat: z5.number().optional().default(0),
      totalValueWithVat: z5.number().optional().default(0)
    });
    insertStockReservationSchema = z5.object({
      stockId: z5.string().uuid(),
      reservationQuantity: z5.number().positive(),
      sourceType: z5.enum(reservationSourceEnum.enumValues),
      sourceId: z5.string().uuid().optional().nullable(),
      notes: z5.string().optional().nullable(),
      reservationDate: z5.date().default(() => /* @__PURE__ */ new Date()),
      expiryDate: z5.date().optional().nullable(),
      isActive: z5.boolean().default(true),
      createdBy: z5.string().uuid().optional().nullable()
    });
    createWarehouseSchema = insertWarehouseSchema2;
    createNirDocumentSchema = insertNirDocumentSchema;
    createNirItemSchema = insertNirItemSchema;
    createTransferDocumentSchema = insertTransferDocumentSchema;
    createTransferItemSchema = insertTransferItemSchema;
    createPurchaseOrderSchema = insertPurchaseOrderSchema;
    createPurchaseOrderItemSchema = insertPurchaseOrderItemSchema;
    createStockReservationSchema = insertStockReservationSchema;
  }
});

// server/modules/inventory/schema/index.ts
var init_schema3 = __esm({
  "server/modules/inventory/schema/index.ts"() {
    "use strict";
    init_inventory_schema();
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  CommunityCategory: () => CommunityCategory,
  IntegrationProvider: () => IntegrationProvider,
  IntegrationStatus: () => IntegrationStatus,
  OrderSource: () => OrderSource,
  OrderStatus: () => OrderStatus,
  PaymentMethod: () => PaymentMethod,
  PaymentStatus: () => PaymentStatus,
  TaskPriority: () => TaskPriority,
  TaskStatus: () => TaskStatus,
  TaskType: () => TaskType,
  absences: () => absences,
  accountBalanceRelations: () => accountBalanceRelations,
  accountBalances: () => accountBalances2,
  accountClasses: () => accountClasses,
  accountGroupRelations: () => accountGroupRelations,
  accountGroups: () => accountGroups,
  accountRelations: () => accountRelations,
  accounts: () => accounts,
  activities: () => activities,
  activityRelations: () => activityRelations,
  alertHistory: () => alertHistory,
  alertSeverityEnum: () => alertSeverityEnum,
  alertStatusEnum: () => alertStatusEnum,
  anafCompanyData: () => anafCompanyData,
  anafCompanyDataRelations: () => anafCompanyDataRelations,
  anafExportLogs: () => anafExportLogs,
  analyticAccountRelations: () => analyticAccountRelations,
  analyticAccounts: () => analyticAccounts,
  analyticsAlerts: () => analyticsAlerts,
  analyticsDashboards: () => analyticsDashboards,
  analyticsMetrics: () => analyticsMetrics,
  analyticsReports: () => analyticsReports,
  auditLogRelations: () => auditLogRelations,
  auditLogs: () => auditLogs,
  biBusinessUnits: () => biBusinessUnits,
  biCostAllocations: () => biCostAllocations,
  biCostCenters: () => biCostCenters,
  chartOfAccounts: () => chartOfAccounts,
  chartOfAccountsRelations: () => chartOfAccountsRelations,
  collaborationActivities: () => collaborationActivities,
  collaborationMessages: () => collaborationMessages,
  collaborationNotes: () => collaborationNotes,
  collaborationNotifications: () => collaborationNotifications,
  collaborationTasks: () => collaborationTasks,
  collaborationThreads: () => collaborationThreads,
  commissionStructures: () => commissionStructures,
  companies: () => companies,
  contactRelations: () => contactRelations,
  contacts: () => contacts,
  costAllocationHistory: () => costAllocationHistory,
  createNirDocumentSchema: () => createNirDocumentSchema,
  createNirItemSchema: () => createNirItemSchema,
  createPurchaseOrderItemSchema: () => createPurchaseOrderItemSchema,
  createPurchaseOrderSchema: () => createPurchaseOrderSchema,
  createStockReservationSchema: () => createStockReservationSchema,
  createTransferDocumentSchema: () => createTransferDocumentSchema,
  createTransferItemSchema: () => createTransferItemSchema,
  createWarehouseSchema: () => createWarehouseSchema,
  crmCompaniesRelations: () => crmCompaniesRelations,
  crm_companies: () => crm_companies,
  customerRelations: () => customerRelations,
  customerTagRelations: () => customerTagRelations,
  customerTags: () => customerTags,
  customers: () => customers,
  dashboardViews: () => dashboardViews,
  dealRelations: () => dealRelations,
  dealStageHistory: () => dealStageHistory,
  dealStageHistoryRelations: () => dealStageHistoryRelations,
  dealTagRelations: () => dealTagRelations,
  dealTags: () => dealTags,
  deals: () => deals,
  departments: () => departments,
  documentRelations: () => documentRelations,
  documentVersionRelations: () => documentVersionRelations,
  documentVersions: () => documentVersions,
  documents: () => documents,
  emailTemplateRelations: () => emailTemplateRelations,
  emailTemplates: () => emailTemplates,
  employeeCommissions: () => employeeCommissions,
  employees: () => employees,
  employmentContracts: () => employmentContracts,
  fiscalPeriods: () => fiscalPeriods,
  fx_rates: () => fx_rates,
  gestiuneTypeEnum: () => gestiuneTypeEnum,
  insertAccountClassSchema: () => insertAccountClassSchema,
  insertAccountGroupSchema: () => insertAccountGroupSchema,
  insertAccountSchema: () => insertAccountSchema,
  insertAnafCompanyDataSchema: () => insertAnafCompanyDataSchema,
  insertAnalyticAccountSchema: () => insertAnalyticAccountSchema,
  insertAuditLogSchema: () => insertAuditLogSchema,
  insertCollaborationMessageSchema: () => insertCollaborationMessageSchema,
  insertCollaborationNoteSchema: () => insertCollaborationNoteSchema,
  insertCollaborationTaskSchema: () => insertCollaborationTaskSchema,
  insertCollaborationThreadSchema: () => insertCollaborationThreadSchema,
  insertCompanySchema: () => insertCompanySchema,
  insertContactSchema: () => insertContactSchema,
  insertCustomerSchema: () => insertCustomerSchema,
  insertCustomerTagSchema: () => insertCustomerTagSchema,
  insertDealSchema: () => insertDealSchema,
  insertDealStageHistorySchema: () => insertDealStageHistorySchema,
  insertDealTagSchema: () => insertDealTagSchema,
  insertDocumentSchema: () => insertDocumentSchema,
  insertDocumentVersionSchema: () => insertDocumentVersionSchema,
  insertEmailTemplateSchema: () => insertEmailTemplateSchema,
  insertFxRateSchema: () => insertFxRateSchema,
  insertIntegrationSchema: () => insertIntegrationSchema,
  insertInventoryProductSchema: () => insertInventoryProductSchema,
  insertInventoryStockMovementSchema: () => insertInventoryStockMovementSchema,
  insertInvoiceDetailSchema: () => insertInvoiceDetailSchema,
  insertInvoiceLineSchema: () => insertInvoiceLineSchema,
  insertInvoiceNumberingSettingsSchema: () => insertInvoiceNumberingSettingsSchema,
  insertInvoiceSchema: () => insertInvoiceSchema,
  insertJournalEntrySchema: () => insertJournalEntrySchema,
  insertJournalLineSchema: () => insertJournalLineSchema,
  insertNirDocumentSchema: () => insertNirDocumentSchema,
  insertNirItemSchema: () => insertNirItemSchema,
  insertNotificationSchema: () => insertNotificationSchema,
  insertOrderItemSchema: () => insertOrderItemSchema,
  insertOrderSchema: () => insertOrderSchema,
  insertPermissionSchema: () => insertPermissionSchema,
  insertPipelineSchema: () => insertPipelineSchema,
  insertPipelineStageSchema: () => insertPipelineStageSchema,
  insertPurchaseOrderItemSchema: () => insertPurchaseOrderItemSchema,
  insertPurchaseOrderSchema: () => insertPurchaseOrderSchema,
  insertRevenueForecastSchema: () => insertRevenueForecastSchema,
  insertRolePermissionSchema: () => insertRolePermissionSchema,
  insertRoleSchema: () => insertRoleSchema,
  insertSalesQuotaSchema: () => insertSalesQuotaSchema,
  insertScoringRuleSchema: () => insertScoringRuleSchema,
  insertSegmentSchema: () => insertSegmentSchema,
  insertShopifyCollectionSchema: () => insertShopifyCollectionSchema,
  insertShopifyProductSchema: () => insertShopifyProductSchema,
  insertShopifyVariantSchema: () => insertShopifyVariantSchema,
  insertStockReservationSchema: () => insertStockReservationSchema,
  insertSyntheticAccountSchema: () => insertSyntheticAccountSchema,
  insertTagSchema: () => insertTagSchema,
  insertTaggedDocumentVersionSchema: () => insertTaggedDocumentVersionSchema,
  insertTaskWatcherSchema: () => insertTaskWatcherSchema,
  insertTransactionSchema: () => insertTransactionSchema,
  insertTransferDocumentSchema: () => insertTransferDocumentSchema,
  insertTransferItemSchema: () => insertTransferItemSchema,
  insertUserRoleSchema: () => insertUserRoleSchema,
  insertUserSchema: () => insertUserSchema,
  integrationProviderEnum: () => integrationProviderEnum,
  integrationStatusEnum: () => integrationStatusEnum,
  integrations: () => integrations,
  inventoryCategories: () => inventoryCategories,
  inventoryCategoryRelations: () => inventoryCategoryRelations,
  inventoryProductRelations: () => inventoryProductRelations,
  inventoryProducts: () => inventoryProducts,
  inventoryStock: () => inventoryStock,
  inventoryStockMovementRelations: () => inventoryStockMovementRelations,
  inventoryStockMovements: () => inventoryStockMovements,
  inventoryUnits: () => inventoryUnits,
  invoiceDetailRelations: () => invoiceDetailRelations,
  invoiceDetails: () => invoiceDetails,
  invoiceLineRelations: () => invoiceLineRelations,
  invoiceLines: () => invoiceLines,
  invoiceNumberingSettings: () => invoiceNumberingSettings,
  invoiceRelations: () => invoiceRelations,
  invoiceStatus: () => invoiceStatus,
  invoices: () => invoices,
  jobPositions: () => jobPositions,
  journalEntries: () => journalEntries,
  journalEntryRelations: () => journalEntryRelations,
  journalLineRelations: () => journalLineRelations,
  journalLines: () => journalLines,
  journalTypes: () => journalTypes,
  ledgerEntries: () => ledgerEntries,
  ledgerEntriesRelations: () => ledgerEntriesRelations,
  ledgerLines: () => ledgerLines,
  ledgerLinesRelations: () => ledgerLinesRelations,
  metricsHistory: () => metricsHistory,
  modelTrainingHistory: () => modelTrainingHistory,
  nirStatusEnum: () => nirStatusEnum,
  orderItemRelations: () => orderItemRelations,
  orderItems: () => orderItems,
  orderRelations: () => orderRelations,
  orderSourceEnum: () => orderSourceEnum,
  orderStatusEnum: () => orderStatusEnum,
  orders: () => orders,
  paymentMethodEnum: () => paymentMethodEnum,
  paymentStatusEnum: () => paymentStatusEnum,
  payrollLogs: () => payrollLogs,
  permissionRelations: () => permissionRelations,
  permissions: () => permissions,
  pipelineRelations: () => pipelineRelations,
  pipelineStageRelations: () => pipelineStageRelations,
  pipelineStages: () => pipelineStages,
  pipelines: () => pipelines,
  predictiveModelTypeEnum: () => predictiveModelTypeEnum,
  predictiveModels: () => predictiveModels,
  predictiveScenarioTypeEnum: () => predictiveScenarioTypeEnum,
  predictiveScenarios: () => predictiveScenarios,
  purchaseOrderStatusEnum: () => purchaseOrderStatusEnum,
  reportExecutionHistory: () => reportExecutionHistory,
  reportTypeEnum: () => reportTypeEnum,
  reservationSourceEnum: () => reservationSourceEnum,
  revenueForecastRelations: () => revenueForecastRelations,
  revenueForecasts: () => revenueForecasts,
  revisalExportLogs: () => revisalExportLogs,
  rolePermissionRelations: () => rolePermissionRelations,
  rolePermissions: () => rolePermissions,
  roleRelations: () => roleRelations,
  roles: () => roles,
  salesQuotaRelations: () => salesQuotaRelations,
  salesQuotas: () => salesQuotas,
  scenarioResults: () => scenarioResults,
  scoringRuleRelations: () => scoringRuleRelations,
  scoringRules: () => scoringRules,
  segmentRelations: () => segmentRelations,
  segments: () => segments,
  shopifyCollections: () => shopifyCollections,
  shopifyProductRelations: () => shopifyProductRelations,
  shopifyProducts: () => shopifyProducts,
  shopifyVariantRelations: () => shopifyVariantRelations,
  shopifyVariants: () => shopifyVariants,
  stockTrackingTypeEnum: () => stockTrackingTypeEnum,
  syntheticAccountRelations: () => syntheticAccountRelations,
  syntheticAccounts: () => syntheticAccounts,
  tagRelations: () => tagRelations,
  tags: () => tags,
  taskAssignmentHistory: () => taskAssignmentHistory,
  taskPriorityEnum: () => taskPriorityEnum,
  taskStatusEnum: () => taskStatusEnum,
  taskStatusHistory: () => taskStatusHistory,
  taskTypeEnum: () => taskTypeEnum,
  taskWatchers: () => taskWatchers,
  transactionRelations: () => transactionRelations,
  transactions: () => transactions,
  transferStatusEnum: () => transferStatusEnum,
  updateIntegrationSchema: () => updateIntegrationSchema,
  updateInvoiceNumberingSettingsSchema: () => updateInvoiceNumberingSettingsSchema,
  userRelations: () => userRelations,
  userRoleRelations: () => userRoleRelations,
  userRoles: () => userRoles,
  users: () => users,
  warehouseTypeEnum: () => warehouseTypeEnum,
  warehouseTypeEnumType: () => warehouseTypeEnumType,
  warehouses: () => warehouses,
  workSchedules: () => workSchedules
});
import { pgTable as pgTable10, text as text10, integer as integer6, boolean as boolean9, timestamp as timestamp10, uuid as uuid10, varchar as varchar5, decimal, jsonb as jsonb3, primaryKey as primaryKey5, index as index6, pgEnum as pgEnum7, unique as unique4, numeric as numeric5 } from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema7 } from "drizzle-zod";
import { z as z6 } from "zod";
import { relations as relations4 } from "drizzle-orm";
var users, roles, permissions, userRoles, rolePermissions, insertUserSchema, insertRoleSchema, insertPermissionSchema, insertUserRoleSchema, insertRolePermissionSchema, userRelations, roleRelations, permissionRelations, userRoleRelations, rolePermissionRelations, companies, insertCompanySchema, accountClasses, accountGroups, accountGroupRelations, syntheticAccounts, syntheticAccountRelations, analyticAccounts, analyticAccountRelations, accounts, accountRelations, accountBalances2, accountBalanceRelations, journalEntries, journalLines, journalEntryRelations, journalLineRelations, inventoryCategories, inventoryCategoryRelations, inventoryUnits, inventoryProducts, inventoryProductRelations, inventoryStockMovements, inventoryStockMovementRelations, inventoryStock, insertAccountClassSchema, insertAccountGroupSchema, insertSyntheticAccountSchema, insertAnalyticAccountSchema, insertAccountSchema, insertJournalEntrySchema, insertJournalLineSchema, insertInventoryProductSchema, insertInventoryStockMovementSchema, auditLogs, auditLogRelations, insertAuditLogSchema, invoiceStatus, invoices, invoiceLines, invoiceDetails, invoiceRelations, invoiceLineRelations, invoiceDetailRelations, insertInvoiceSchema, insertInvoiceLineSchema, insertInvoiceDetailSchema, fx_rates, insertFxRateSchema, documents, documentVersions, documentRelations, documentVersionRelations, insertDocumentSchema, insertDocumentVersionSchema, insertTaggedDocumentVersionSchema;
var init_schema4 = __esm({
  "shared/schema.ts"() {
    "use strict";
    init_crm_schema();
    init_hr_schema();
    init_schema();
    init_analytics_schema();
    init_integrations_schema();
    init_schema2();
    init_collaboration_schema();
    init_invoice_numbering_schema();
    init_warehouse();
    init_schema3();
    users = pgTable10("users", {
      id: uuid10("id").defaultRandom().primaryKey(),
      username: text10("username").notNull().unique(),
      password: text10("password").notNull(),
      email: text10("email").notNull().unique(),
      firstName: text10("first_name").notNull(),
      lastName: text10("last_name").notNull(),
      role: text10("role").notNull().default("user"),
      companyId: uuid10("company_id"),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    }, (users3) => ({
      companyIdx: index6("users_company_idx").on(users3.companyId)
    }));
    roles = pgTable10("roles", {
      id: uuid10("id").defaultRandom().primaryKey(),
      companyId: uuid10("company_id").notNull(),
      name: text10("name").notNull(),
      description: text10("description"),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    }, (roles3) => ({
      companyIdx: index6("roles_company_idx").on(roles3.companyId)
    }));
    permissions = pgTable10("permissions", {
      id: uuid10("id").defaultRandom().primaryKey(),
      name: text10("name").notNull().unique(),
      description: text10("description"),
      resource: text10("resource").notNull(),
      action: text10("action").notNull(),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    userRoles = pgTable10("user_roles", {
      userId: uuid10("user_id").notNull().references(() => users.id),
      roleId: uuid10("role_id").notNull().references(() => roles.id)
    }, (userRoles3) => ({
      pk: primaryKey5(userRoles3.userId, userRoles3.roleId)
    }));
    rolePermissions = pgTable10("role_permissions", {
      roleId: uuid10("role_id").notNull().references(() => roles.id),
      permissionId: uuid10("permission_id").notNull().references(() => permissions.id)
    }, (rolePermissions4) => ({
      pk: primaryKey5(rolePermissions4.roleId, rolePermissions4.permissionId)
    }));
    insertUserSchema = createInsertSchema7(users).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertRoleSchema = createInsertSchema7(roles).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertPermissionSchema = createInsertSchema7(permissions).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertUserRoleSchema = createInsertSchema7(userRoles);
    insertRolePermissionSchema = createInsertSchema7(rolePermissions);
    userRelations = relations4(users, ({ many, one }) => ({
      userRoles: many(userRoles),
      company: one(companies, {
        fields: [users.companyId],
        references: [companies.id]
      }),
      journalEntries: many(journalEntries)
    }));
    roleRelations = relations4(roles, ({ many, one }) => ({
      userRoles: many(userRoles),
      rolePermissions: many(rolePermissions),
      company: one(companies, {
        fields: [roles.companyId],
        references: [companies.id]
      })
    }));
    permissionRelations = relations4(permissions, ({ many }) => ({
      rolePermissions: many(rolePermissions)
    }));
    userRoleRelations = relations4(userRoles, ({ one }) => ({
      user: one(users, {
        fields: [userRoles.userId],
        references: [users.id]
      }),
      role: one(roles, {
        fields: [userRoles.roleId],
        references: [roles.id]
      })
    }));
    rolePermissionRelations = relations4(rolePermissions, ({ one }) => ({
      role: one(roles, {
        fields: [rolePermissions.roleId],
        references: [roles.id]
      }),
      permission: one(permissions, {
        fields: [rolePermissions.permissionId],
        references: [permissions.id]
      })
    }));
    companies = pgTable10("companies", {
      id: uuid10("id").defaultRandom().primaryKey(),
      name: text10("name").notNull(),
      fiscalCode: text10("fiscal_code").notNull().unique(),
      registrationNumber: text10("registration_number").notNull(),
      address: text10("address").notNull(),
      city: text10("city").notNull(),
      county: text10("county").notNull(),
      country: text10("country").notNull().default("Romania"),
      phone: text10("phone"),
      email: text10("email"),
      bankAccount: text10("bank_account"),
      bankName: text10("bank_name"),
      vatPayer: boolean9("vat_payer").default(true),
      vatRate: integer6("vat_rate").default(19),
      logoUrl: text10("logo_url"),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    insertCompanySchema = createInsertSchema7(companies).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    accountClasses = pgTable10("account_classes", {
      id: uuid10("id").defaultRandom().primaryKey(),
      code: varchar5("code", { length: 1 }).notNull().unique(),
      // Single digit (1-9)
      name: text10("name").notNull(),
      description: text10("description"),
      // Default account function for accounts in this class: 
      // - A (Activ/Asset/Debit): Class with primarily debit balance accounts
      // - P (Pasiv/Liability/Credit): Class with primarily credit balance accounts
      // - B (Bifunctional/Mixed): Class with mixed account types
      defaultAccountFunction: text10("default_account_function").notNull(),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    accountGroups = pgTable10("account_groups", {
      id: uuid10("id").defaultRandom().primaryKey(),
      code: varchar5("code", { length: 2 }).notNull().unique(),
      // Two digits (e.g., 10, 11, 30)
      name: text10("name").notNull(),
      description: text10("description"),
      classId: uuid10("class_id").notNull().references(() => accountClasses.id),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    accountGroupRelations = relations4(accountGroups, ({ one, many }) => ({
      class: one(accountClasses, {
        fields: [accountGroups.classId],
        references: [accountClasses.id]
      }),
      syntheticAccounts: many(syntheticAccounts)
    }));
    syntheticAccounts = pgTable10("synthetic_accounts", {
      id: uuid10("id").defaultRandom().primaryKey(),
      code: varchar5("code", { length: 4 }).notNull().unique(),
      // 3-4 digits (e.g., 101, 1011)
      name: text10("name").notNull(),
      description: text10("description"),
      // Account function in Romanian accounting:
      // - A (Activ/Asset/Debit): Accounts with normal debit balance (assets, expenses)
      // - P (Pasiv/Liability/Credit): Accounts with normal credit balance (liabilities, equity, revenues)
      // - B (Bifunctional/A/P): Accounts that can have either debit or credit balance
      accountFunction: text10("account_function").notNull(),
      grade: integer6("grade").notNull(),
      // 1 (3 digits) or 2 (4 digits)
      groupId: uuid10("group_id").notNull().references(() => accountGroups.id),
      parentId: uuid10("parent_id").references(() => syntheticAccounts.id),
      // For Grade 2 accounts
      isActive: boolean9("is_active").default(true),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    syntheticAccountRelations = relations4(syntheticAccounts, ({ one, many }) => ({
      group: one(accountGroups, {
        fields: [syntheticAccounts.groupId],
        references: [accountGroups.id]
      }),
      parent: one(syntheticAccounts, {
        fields: [syntheticAccounts.parentId],
        references: [syntheticAccounts.id]
      }),
      children: many(syntheticAccounts),
      analyticAccounts: many(analyticAccounts)
    }));
    analyticAccounts = pgTable10("analytic_accounts", {
      id: uuid10("id").defaultRandom().primaryKey(),
      code: varchar5("code", { length: 20 }).notNull().unique(),
      // Extended code for detailed classification
      name: text10("name").notNull(),
      description: text10("description"),
      syntheticId: uuid10("synthetic_id").notNull().references(() => syntheticAccounts.id),
      // Account function in Romanian accounting:
      // - A (Activ/Asset/Debit): Accounts with normal debit balance (assets, expenses)
      // - P (Pasiv/Liability/Credit): Accounts with normal credit balance (liabilities, equity, revenues)
      // - B (Bifunctional/A/P): Accounts that can have either debit or credit balance
      accountFunction: text10("account_function").notNull(),
      isActive: boolean9("is_active").default(true),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    analyticAccountRelations = relations4(analyticAccounts, ({ one, many }) => ({
      syntheticAccount: one(syntheticAccounts, {
        fields: [analyticAccounts.syntheticId],
        references: [syntheticAccounts.id]
      }),
      balances: many(accountBalances2)
    }));
    accounts = pgTable10("accounts", {
      id: uuid10("id").defaultRandom().primaryKey(),
      code: varchar5("code", { length: 20 }).notNull().unique(),
      name: text10("name").notNull(),
      description: text10("description"),
      type: text10("type").notNull(),
      // A (Active), P (Passive), B (Bifunctional)
      classId: uuid10("class_id").notNull().references(() => accountClasses.id),
      parentId: uuid10("parent_id").references(() => accounts.id),
      isActive: boolean9("is_active").default(true),
      syntheticId: uuid10("synthetic_id").references(() => syntheticAccounts.id),
      analyticId: uuid10("analytic_id").references(() => analyticAccounts.id),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    accountRelations = relations4(accounts, ({ one, many }) => ({
      class: one(accountClasses, {
        fields: [accounts.classId],
        references: [accountClasses.id]
      }),
      parent: one(accounts, {
        fields: [accounts.parentId],
        references: [accounts.id]
      }),
      children: many(accounts),
      syntheticAccount: one(syntheticAccounts, {
        fields: [accounts.syntheticId],
        references: [syntheticAccounts.id]
      }),
      analyticAccount: one(analyticAccounts, {
        fields: [accounts.analyticId],
        references: [analyticAccounts.id]
      }),
      balances: many(accountBalances2)
    }));
    accountBalances2 = pgTable10("account_balances", {
      id: uuid10("id").defaultRandom().primaryKey(),
      accountId: uuid10("account_id").notNull().references(() => accounts.id),
      companyId: uuid10("company_id").notNull().references(() => companies.id),
      fiscalYear: integer6("fiscal_year").notNull(),
      fiscalMonth: integer6("fiscal_month").notNull(),
      openingDebit: decimal("opening_debit", { precision: 15, scale: 2 }).default("0").notNull(),
      openingCredit: decimal("opening_credit", { precision: 15, scale: 2 }).default("0").notNull(),
      periodDebit: decimal("period_debit", { precision: 15, scale: 2 }).default("0").notNull(),
      periodCredit: decimal("period_credit", { precision: 15, scale: 2 }).default("0").notNull(),
      closingDebit: decimal("closing_debit", { precision: 15, scale: 2 }).default("0").notNull(),
      closingCredit: decimal("closing_credit", { precision: 15, scale: 2 }).default("0").notNull(),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    accountBalanceRelations = relations4(accountBalances2, ({ one }) => ({
      account: one(accounts, {
        fields: [accountBalances2.accountId],
        references: [accounts.id]
      }),
      company: one(companies, {
        fields: [accountBalances2.companyId],
        references: [companies.id]
      })
    }));
    journalEntries = pgTable10("journal_entries", {
      id: uuid10("id").defaultRandom().primaryKey(),
      companyId: uuid10("company_id").notNull().references(() => companies.id),
      date: timestamp10("date").notNull(),
      number: text10("number"),
      reference: text10("reference"),
      description: text10("description"),
      totalDebit: decimal("total_debit", { precision: 15, scale: 2 }).default("0").notNull(),
      totalCredit: decimal("total_credit", { precision: 15, scale: 2 }).default("0").notNull(),
      createdBy: uuid10("created_by").notNull().references(() => users.id),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    journalLines = pgTable10("journal_lines", {
      id: uuid10("id").defaultRandom().primaryKey(),
      journalId: uuid10("journal_id").notNull().references(() => journalEntries.id),
      accountId: uuid10("account_id").notNull().references(() => accounts.id),
      description: text10("description"),
      debit: decimal("debit", { precision: 15, scale: 2 }).default("0").notNull(),
      credit: decimal("credit", { precision: 15, scale: 2 }).default("0").notNull(),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    journalEntryRelations = relations4(journalEntries, ({ one, many }) => ({
      company: one(companies, {
        fields: [journalEntries.companyId],
        references: [companies.id]
      }),
      createdByUser: one(users, {
        fields: [journalEntries.createdBy],
        references: [users.id]
      }),
      lines: many(journalLines)
    }));
    journalLineRelations = relations4(journalLines, ({ one }) => ({
      journalEntry: one(journalEntries, {
        fields: [journalLines.journalId],
        references: [journalEntries.id]
      }),
      account: one(accounts, {
        fields: [journalLines.accountId],
        references: [accounts.id]
      })
    }));
    inventoryCategories = pgTable10("inventory_categories", {
      id: uuid10("id").defaultRandom().primaryKey(),
      name: text10("name").notNull().unique(),
      // Adăugare constrângere de unicitate
      description: text10("description"),
      parentId: uuid10("parent_id").references(() => inventoryCategories.id),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    inventoryCategoryRelations = relations4(inventoryCategories, ({ one, many }) => ({
      parent: one(inventoryCategories, {
        fields: [inventoryCategories.parentId],
        references: [inventoryCategories.id]
      }),
      children: many(inventoryCategories),
      products: many(inventoryProducts)
    }));
    inventoryUnits = pgTable10("inventory_units", {
      id: uuid10("id").defaultRandom().primaryKey(),
      name: text10("name").notNull(),
      abbreviation: text10("abbreviation").notNull(),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    inventoryProducts = pgTable10("inventory_products", {
      id: uuid10("id").defaultRandom().primaryKey(),
      sku: text10("sku").notNull().unique(),
      // Înlocuim code cu sku (Stock Keeping Unit) - obligatoriu și unic
      name: text10("name").notNull().unique(),
      // Adăugare constrângere de unicitate pentru nume
      description: text10("description"),
      categoryId: uuid10("category_id").references(() => inventoryCategories.id),
      unitId: uuid10("unit_id").references(() => inventoryUnits.id),
      purchasePrice: decimal("purchase_price", { precision: 15, scale: 2 }).default("0").notNull(),
      sellingPrice: decimal("selling_price", { precision: 15, scale: 2 }).default("0").notNull(),
      priceIncludesVat: boolean9("price_includes_vat").default(true),
      // Preț cu TVA inclus
      vatRate: integer6("vat_rate").default(19),
      stockAlert: decimal("stock_alert", { precision: 15, scale: 2 }).default("0"),
      isActive: boolean9("is_active").default(true),
      // Adăugare câmp barcode pentru coduri EAN13
      barcode: text10("barcode").unique(),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    inventoryProductRelations = relations4(inventoryProducts, ({ one, many }) => ({
      category: one(inventoryCategories, {
        fields: [inventoryProducts.categoryId],
        references: [inventoryCategories.id]
      }),
      unit: one(inventoryUnits, {
        fields: [inventoryProducts.unitId],
        references: [inventoryUnits.id]
      }),
      stockMovements: many(inventoryStockMovements)
    }));
    inventoryStockMovements = pgTable10("inventory_stock_movements", {
      id: uuid10("id").defaultRandom().primaryKey(),
      productId: uuid10("product_id").notNull().references(() => inventoryProducts.id),
      date: timestamp10("date").notNull(),
      documentNumber: text10("document_number"),
      documentType: text10("document_type").notNull(),
      // RECEIPT, ISSUE, ADJUSTMENT
      quantity: decimal("quantity", { precision: 15, scale: 2 }).notNull(),
      unitPrice: decimal("unit_price", { precision: 15, scale: 2 }).notNull(),
      totalValue: decimal("total_value", { precision: 15, scale: 2 }).notNull(),
      notes: text10("notes"),
      createdBy: uuid10("created_by").notNull().references(() => users.id),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    inventoryStockMovementRelations = relations4(inventoryStockMovements, ({ one }) => ({
      product: one(inventoryProducts, {
        fields: [inventoryStockMovements.productId],
        references: [inventoryProducts.id]
      }),
      createdByUser: one(users, {
        fields: [inventoryStockMovements.createdBy],
        references: [users.id]
      })
    }));
    inventoryStock = pgTable10("inventory_stock", {
      id: uuid10("id").defaultRandom().primaryKey(),
      productId: uuid10("product_id").notNull().references(() => inventoryProducts.id),
      companyId: uuid10("company_id").notNull().references(() => companies.id),
      quantity: decimal("quantity", { precision: 15, scale: 2 }).default("0").notNull(),
      averageCost: decimal("average_cost", { precision: 15, scale: 2 }).default("0").notNull(),
      totalValue: decimal("total_value", { precision: 15, scale: 2 }).default("0").notNull(),
      lastUpdated: timestamp10("last_updated").defaultNow().notNull()
    });
    insertAccountClassSchema = createInsertSchema7(accountClasses).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAccountGroupSchema = createInsertSchema7(accountGroups).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertSyntheticAccountSchema = createInsertSchema7(syntheticAccounts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAnalyticAccountSchema = createInsertSchema7(analyticAccounts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAccountSchema = createInsertSchema7(accounts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertJournalEntrySchema = createInsertSchema7(journalEntries).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertJournalLineSchema = createInsertSchema7(journalLines).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertInventoryProductSchema = createInsertSchema7(inventoryProducts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertInventoryStockMovementSchema = createInsertSchema7(inventoryStockMovements).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    auditLogs = pgTable10("audit_logs", {
      id: uuid10("id").defaultRandom().primaryKey(),
      companyId: uuid10("company_id").notNull().references(() => companies.id),
      userId: uuid10("user_id").references(() => users.id),
      action: text10("action").notNull(),
      // e.g. 'CREATE_INVOICE'
      entity: text10("entity").notNull(),
      // e.g. 'invoice'
      entityId: uuid10("entity_id").notNull(),
      details: jsonb3("details").notNull(),
      // Any structured metadata
      createdAt: timestamp10("created_at").defaultNow().notNull()
    }, (table) => ({
      auditScopeIdx: index6("audit_scope_idx").on(table.companyId, table.createdAt),
      entityIdx: index6("audit_entity_idx").on(table.entity, table.entityId)
    }));
    auditLogRelations = relations4(auditLogs, ({ one }) => ({
      company: one(companies, {
        fields: [auditLogs.companyId],
        references: [companies.id]
      }),
      user: one(users, {
        fields: [auditLogs.userId],
        references: [users.id]
      })
    }));
    insertAuditLogSchema = createInsertSchema7(auditLogs).omit({
      id: true,
      createdAt: true
    });
    invoiceStatus = pgEnum7("invoice_status", ["draft", "issued", "sent", "canceled"]);
    invoices = pgTable10("invoices", {
      id: uuid10("id").defaultRandom().primaryKey(),
      companyId: uuid10("company_id").notNull().references(() => companies.id),
      franchiseId: uuid10("franchise_id"),
      series: varchar5("series", { length: 8 }),
      number: integer6("number"),
      // Allocated only when status = issued
      status: invoiceStatus("status").default("draft").notNull(),
      totalAmount: decimal("total_amount", { precision: 12, scale: 2 }).notNull(),
      currency: varchar5("currency", { length: 5 }).default("RON").notNull(),
      version: integer6("version").default(1).notNull(),
      // Accounting validation fields for Note Contabil generation
      isValidated: boolean9("is_validated").default(false).notNull(),
      validatedAt: timestamp10("validated_at"),
      ledgerEntryId: uuid10("ledger_entry_id"),
      // Reference to the accounting ledger entry (Note Contabil)
      // Standard audit fields
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull(),
      deletedAt: timestamp10("deleted_at")
      // Soft delete for audit purposes
    }, (table) => ({
      companyIndex: index6("invoice_company_idx").on(table.companyId, table.franchiseId, table.createdAt),
      uniqueSeriesNumber: unique4("invoice_series_number_unique").on(table.series, table.number),
      validationIndex: index6("invoice_validation_idx").on(table.isValidated, table.validatedAt)
    }));
    invoiceLines = pgTable10("invoice_lines", {
      id: uuid10("id").defaultRandom().primaryKey(),
      invoiceId: uuid10("invoice_id").notNull().references(() => invoices.id),
      productId: uuid10("product_id").references(() => inventoryProducts.id),
      description: text10("description").notNull(),
      quantity: decimal("quantity", { precision: 10, scale: 3 }).notNull(),
      unitPrice: decimal("unit_price", { precision: 12, scale: 2 }).notNull(),
      vatRate: integer6("vat_rate").default(19).notNull(),
      totalAmount: decimal("total_amount", { precision: 12, scale: 2 }).notNull(),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    invoiceDetails = pgTable10("invoice_details", {
      id: uuid10("id").defaultRandom().primaryKey(),
      invoiceId: uuid10("invoice_id").notNull().references(() => invoices.id),
      partnerId: uuid10("partner_id"),
      // References a partners table (to be added)
      partnerName: text10("partner_name").notNull(),
      partnerFiscalCode: text10("partner_fiscal_code").notNull(),
      partnerRegistrationNumber: text10("partner_registration_number"),
      partnerAddress: text10("partner_address").notNull(),
      partnerCity: text10("partner_city").notNull(),
      partnerCounty: text10("partner_county"),
      partnerCountry: text10("partner_country").default("Romania").notNull(),
      paymentMethod: text10("payment_method").notNull(),
      paymentDueDays: integer6("payment_due_days").default(30).notNull(),
      paymentDueDate: timestamp10("payment_due_date"),
      notes: text10("notes"),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    });
    invoiceRelations = relations4(invoices, ({ one, many }) => ({
      company: one(companies, {
        fields: [invoices.companyId],
        references: [companies.id]
      }),
      lines: many(invoiceLines),
      details: one(invoiceDetails)
    }));
    invoiceLineRelations = relations4(invoiceLines, ({ one }) => ({
      invoice: one(invoices, {
        fields: [invoiceLines.invoiceId],
        references: [invoices.id]
      }),
      product: one(inventoryProducts, {
        fields: [invoiceLines.productId],
        references: [inventoryProducts.id]
      })
    }));
    invoiceDetailRelations = relations4(invoiceDetails, ({ one }) => ({
      invoice: one(invoices, {
        fields: [invoiceDetails.invoiceId],
        references: [invoices.id]
      })
    }));
    insertInvoiceSchema = createInsertSchema7(invoices).omit({
      id: true,
      isValidated: true,
      // Don't allow setting validation status during insert
      validatedAt: true,
      // Don't allow setting validation timestamp during insert
      ledgerEntryId: true,
      // Don't allow setting ledger entry during insert
      createdAt: true,
      updatedAt: true,
      deletedAt: true
    });
    insertInvoiceLineSchema = createInsertSchema7(invoiceLines).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertInvoiceDetailSchema = createInsertSchema7(invoiceDetails).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    fx_rates = pgTable10("fx_rates", {
      id: uuid10("id").defaultRandom().primaryKey(),
      currency: varchar5("currency", { length: 5 }).notNull(),
      rate: numeric5("rate", { precision: 10, scale: 4 }).notNull(),
      // Source of the exchange rate (BNR = National Bank of Romania)
      source: varchar5("source", { length: 20 }).notNull().default("BNR"),
      // Base currency (typically RON for Romanian Leu)
      baseCurrency: varchar5("base_currency", { length: 5 }).notNull().default("RON"),
      date: timestamp10("date").notNull(),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    }, (table) => ({
      // Create a unique constraint on currency, date, and source to prevent duplicates
      uniqueRate: unique4().on(table.currency, table.date, table.source, table.baseCurrency)
    }));
    insertFxRateSchema = createInsertSchema7(fx_rates).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    documents = pgTable10("documents", {
      id: uuid10("id").defaultRandom().primaryKey(),
      companyId: uuid10("company_id").notNull().references(() => companies.id),
      franchiseId: uuid10("franchise_id").references(() => companies.id),
      filePath: text10("file_path").notNull(),
      type: varchar5("type", { length: 50 }).notNull(),
      ocrText: text10("ocr_text"),
      createdAt: timestamp10("created_at").defaultNow().notNull(),
      updatedAt: timestamp10("updated_at").defaultNow().notNull()
    }, (table) => ({
      orgIndex: index6("documents_idx").on(table.companyId, table.franchiseId, table.createdAt)
    }));
    documentVersions = pgTable10("document_versions", {
      id: uuid10("id").defaultRandom().primaryKey(),
      documentId: uuid10("document_id").notNull().references(() => documents.id),
      content: text10("content").notNull(),
      version: integer6("version").default(1).notNull(),
      tag: varchar5("tag", { length: 50 }),
      changeDescription: text10("change_description"),
      createdAt: timestamp10("created_at").defaultNow().notNull()
    }, (table) => ({
      docVersionIndex: index6("document_versions_idx").on(table.documentId, table.createdAt)
    }));
    documentRelations = relations4(documents, ({ one, many }) => ({
      company: one(companies, {
        fields: [documents.companyId],
        references: [companies.id]
      }),
      franchise: one(companies, {
        fields: [documents.franchiseId],
        references: [companies.id]
      }),
      versions: many(documentVersions)
    }));
    documentVersionRelations = relations4(documentVersions, ({ one }) => ({
      document: one(documents, {
        fields: [documentVersions.documentId],
        references: [documents.id]
      })
    }));
    insertDocumentSchema = createInsertSchema7(documents).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertDocumentVersionSchema = createInsertSchema7(documentVersions).omit({
      id: true,
      createdAt: true
    });
    insertTaggedDocumentVersionSchema = insertDocumentVersionSchema.extend({
      tag: z6.string().optional(),
      changeDescription: z6.string().optional()
    });
  }
});

// server/common/logger.ts
var DEFAULT_LOG_LEVEL, LOG_LEVEL_PRIORITY, LOG_LEVEL_COLORS, RESET_COLOR, Logger;
var init_logger = __esm({
  "server/common/logger.ts"() {
    "use strict";
    DEFAULT_LOG_LEVEL = process.env.NODE_ENV === "production" ? "INFO" /* INFO */ : "DEBUG" /* DEBUG */;
    LOG_LEVEL_PRIORITY = {
      ["ERROR" /* ERROR */]: 40,
      ["WARN" /* WARN */]: 30,
      ["INFO" /* INFO */]: 20,
      ["DEBUG" /* DEBUG */]: 10
    };
    LOG_LEVEL_COLORS = {
      ["ERROR" /* ERROR */]: "\x1B[31m",
      // red
      ["WARN" /* WARN */]: "\x1B[33m",
      // yellow
      ["INFO" /* INFO */]: "\x1B[36m",
      // cyan
      ["DEBUG" /* DEBUG */]: "\x1B[90m"
      // gray
    };
    RESET_COLOR = "\x1B[0m";
    Logger = class {
      /**
       * Create a new logger instance
       * @param serviceName Name of the service using this logger
       * @param logLevel Minimum log level to display
       */
      constructor(serviceName, logLevel = DEFAULT_LOG_LEVEL) {
        this.serviceName = serviceName;
        this.logLevel = logLevel;
      }
      /**
       * Format a log message with timestamp and service prefix
       * @param level Log level
       * @param message Log message
       * @returns Formatted message
       */
      formatMessage(level, message) {
        const timestamp24 = (/* @__PURE__ */ new Date()).toISOString();
        const color = LOG_LEVEL_COLORS[level];
        return `${color}[${timestamp24}] [${level}] [${this.serviceName}]${RESET_COLOR} ${message}`;
      }
      /**
       * Check if a log level should be displayed
       * @param level Log level to check
       * @returns Boolean indicating if log should be displayed
       */
      shouldLog(level) {
        return LOG_LEVEL_PRIORITY[level] >= LOG_LEVEL_PRIORITY[this.logLevel];
      }
      /**
       * Log an error message
       * @param message Message to log
       * @param error Optional error object
       */
      error(message, error) {
        if (this.shouldLog("ERROR" /* ERROR */)) {
          console.error(this.formatMessage("ERROR" /* ERROR */, message));
          if (error) {
            if (error instanceof Error) {
              console.error(error.stack || error.message);
            } else {
              console.error(error);
            }
          }
        }
      }
      /**
       * Log a warning message
       * @param message Message to log
       */
      warn(message) {
        if (this.shouldLog("WARN" /* WARN */)) {
          console.warn(this.formatMessage("WARN" /* WARN */, message));
        }
      }
      /**
       * Log an info message
       * @param message Message to log
       */
      info(message) {
        if (this.shouldLog("INFO" /* INFO */)) {
          console.info(this.formatMessage("INFO" /* INFO */, message));
        }
      }
      /**
       * Log a debug message
       * @param message Message to log
       */
      debug(message) {
        if (this.shouldLog("DEBUG" /* DEBUG */)) {
          console.debug(this.formatMessage("DEBUG" /* DEBUG */, message));
        }
      }
      /**
       * Set the log level
       * @param level New log level
       */
      setLogLevel(level) {
        this.logLevel = level;
      }
    };
  }
});

// server/common/drizzle/db.ts
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
function getPostgresClient() {
  if (pgClient) {
    return pgClient;
  }
  try {
    const connectionString = process.env.DATABASE_URL;
    if (!connectionString) {
      throw new Error("DATABASE_URL is not defined in environment variables");
    }
    pgClient = postgres(connectionString, {
      ssl: true,
      max: 10,
      idle_timeout: 20,
      connect_timeout: 10
    });
    logger.info("Database client initialized");
    return pgClient;
  } catch (error) {
    logger.error("Failed to initialize database client", error);
    throw error;
  }
}
function getDrizzleInstance() {
  if (drizzleInstance) {
    return drizzleInstance;
  }
  try {
    const client = getPostgresClient();
    drizzleInstance = drizzle(client, { schema: schema_exports });
    logger.info("Database ORM instance initialized with schema");
    return drizzleInstance;
  } catch (error) {
    logger.error("Failed to initialize database ORM", error);
    throw error;
  }
}
async function closeDatabase() {
  if (pgClient) {
    try {
      await pgClient.end();
      logger.info("Database connection closed");
    } catch (error) {
      logger.error("Error closing database connection", error);
    }
  }
}
var logger, pgClient, drizzleInstance, db_default;
var init_db = __esm({
  "server/common/drizzle/db.ts"() {
    "use strict";
    init_logger();
    init_schema4();
    logger = new Logger("DrizzleDB");
    db_default = {
      getPostgresClient,
      getDrizzleInstance,
      closeDatabase
    };
  }
});

// server/common/drizzle/modules/core/base-drizzle.service.ts
import { sql as sql6 } from "drizzle-orm";
var logger2, BaseDrizzleService;
var init_base_drizzle_service = __esm({
  "server/common/drizzle/modules/core/base-drizzle.service.ts"() {
    "use strict";
    init_logger();
    init_db();
    logger2 = new Logger("BaseDrizzleService");
    BaseDrizzleService = class {
      /**
       * Execute a function with the Drizzle database instance
       * 
       * @param queryFn Function that receives the DB instance and returns a result
       * @returns Promise resolving to the result of queryFn
       */
      async query(queryFn, context) {
        const ctx = context || "query";
        try {
          const db4 = getDrizzleInstance();
          if (!db4) {
            const error = new Error("Database instance is not initialized");
            logger2.error(`[${ctx}] Failed to get database instance`, error);
            throw error;
          }
          logger2.debug(`[${ctx}] Executing database query`);
          const result = await Promise.resolve(queryFn(db4));
          return result;
        } catch (error) {
          logger2.error(`[${ctx}] Error executing database query`, error);
          throw error;
        }
      }
      /**
       * Execute raw SQL directly
       * 
       * @param sqlQuery SQL query string or SQL tagged template
       * @param params Parameters for the query (only used with string queries)
       * @returns Query result of type T
       */
      async executeQuery(sqlQuery, params = []) {
        const ctx = "executeQuery";
        try {
          const db4 = getDrizzleInstance();
          if (!db4 || !db4.$client) {
            const error = new Error("Database client is not initialized");
            logger2.error(`[${ctx}] ${error.message}`, error);
            throw error;
          }
          const truncatedSql = typeof sqlQuery === "string" ? `${sqlQuery.substring(0, 100)}${sqlQuery.length > 100 ? "..." : ""}` : "SQL object (not string)";
          logger2.debug(`[${ctx}] Executing SQL: ${truncatedSql}`);
          if (params && params.length > 0) {
            logger2.debug(`[${ctx}] With params:`, params);
          }
          let result;
          if (typeof sqlQuery === "string") {
            result = await db4.$client.unsafe(sqlQuery, params);
          } else {
            result = await db4.execute(sqlQuery);
          }
          if (Array.isArray(result)) {
            logger2.debug(`[${ctx}] Query returned ${result.length} rows`);
          } else {
            logger2.debug(`[${ctx}] Query returned result of type ${typeof result}`);
          }
          return result || [];
        } catch (error) {
          logger2.error(`[${ctx}] SQL query failed:`, error);
          const sqlString = typeof sqlQuery === "string" ? sqlQuery : "SQL object (not string)";
          logger2.error(`[${ctx}] SQL: ${sqlString}`);
          logger2.error(`[${ctx}] Params:`, params);
          throw error;
        }
      }
      /**
       * Start a database transaction
       * 
       * @param transactionFn Function that receives a transaction and returns a result
       * @returns Promise resolving to the result of transactionFn
       */
      async transaction(transactionFn, context) {
        const ctx = context || "transaction";
        try {
          const db4 = getDrizzleInstance();
          if (!db4) {
            const error = new Error("Database instance is not initialized");
            logger2.error(`[${ctx}] Failed to get database instance`, error);
            throw error;
          }
          logger2.debug(`[${ctx}] Starting database transaction`);
          return await db4.transaction(async (tx) => {
            try {
              const result = await transactionFn(tx);
              logger2.debug(`[${ctx}] Transaction completed successfully`);
              return result;
            } catch (txError) {
              logger2.error(`[${ctx}] Transaction failed, will be rolled back`, txError);
              throw txError;
            }
          });
        } catch (error) {
          logger2.error(`[${ctx}] Error in transaction`, error);
          throw error;
        }
      }
      /**
       * Create a SQL condition from a string
       * Useful for creating dynamic WHERE clauses
       * 
       * @param condition SQL condition as string
       * @returns SQL fragment
       */
      sqlCondition(condition) {
        return sql6.raw(condition);
      }
      /**
       * Builds a parameterized WHERE condition
       * 
       * @param conditions Object with key-value pairs for conditions
       * @returns SQL fragment
       */
      buildWhereCondition(conditions) {
        const conditionFragments = [];
        Object.entries(conditions).forEach(([key, value]) => {
          if (value === null) {
            conditionFragments.push(sql6`${sql6.identifier(key)} IS NULL`);
          } else if (value === void 0) {
          } else if (Array.isArray(value)) {
            conditionFragments.push(sql6`${sql6.identifier(key)} IN (${value.join(", ")})`);
          } else {
            conditionFragments.push(sql6`${sql6.identifier(key)} = ${value}`);
          }
        });
        if (conditionFragments.length === 0) {
          return sql6`TRUE`;
        }
        return sql6.join(conditionFragments, sql6` AND `);
      }
    };
  }
});

// server/common/drizzle/modules/core/index.ts
var init_core = __esm({
  "server/common/drizzle/modules/core/index.ts"() {
    "use strict";
    init_base_drizzle_service();
  }
});

// server/common/drizzle/modules/company/company-query.service.ts
import { and, or, sql as sql7 } from "drizzle-orm";
var logger3, CompanyQueryService;
var init_company_query_service = __esm({
  "server/common/drizzle/modules/company/company-query.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_schema4();
    logger3 = new Logger("CompanyQueryService");
    CompanyQueryService = class extends BaseDrizzleService {
      /**
       * Get all companies with optional filtering
       * 
       * @param options Filter options
       * @returns Array of companies
       */
      async getCompanies(options = {}) {
        const context = "getCompanies";
        try {
          const { parentId, searchTerm, limit, type, withDeleted = false } = options;
          logger3.debug(`[${context}] Getting companies with options:`, options);
          return await this.query(async (db4) => {
            let query = db4.select({
              id: companies.id,
              name: companies.name,
              fiscalCode: companies.fiscalCode,
              registrationNumber: companies.registrationNumber,
              address: companies.address,
              city: companies.city,
              county: companies.county,
              country: companies.country,
              phone: companies.phone,
              email: companies.email,
              bankAccount: companies.bankAccount,
              bankName: companies.bankName,
              vatPayer: companies.vatPayer,
              vatRate: companies.vatRate,
              logoUrl: companies.logoUrl,
              parentId: sql7`parent_id`,
              type: sql7`type`,
              createdAt: companies.createdAt,
              updatedAt: companies.updatedAt,
              deletedAt: sql7`deleted_at`
            }).from(companies);
            const conditions = [];
            if (!withDeleted) {
              logger3.debug(`[${context}] Adding filter for non-deleted companies`);
              conditions.push(sql7`deleted_at IS NULL`);
            }
            if (parentId) {
              logger3.debug(`[${context}] Adding filter for parent ID: ${parentId}`);
              conditions.push(sql7`parent_id = ${parentId}`);
            }
            if (type) {
              logger3.debug(`[${context}] Adding filter for company type: ${type}`);
              conditions.push(sql7`type = ${type}`);
            }
            if (searchTerm) {
              logger3.debug(`[${context}] Adding search term filter: ${searchTerm}`);
              conditions.push(
                or(
                  sql7`name ILIKE ${`%${searchTerm}%`}`,
                  sql7`fiscal_code ILIKE ${`%${searchTerm}%`}`
                )
              );
            }
            if (conditions.length > 0) {
              query = query.where(and(...conditions));
            }
            if (limit) {
              logger3.debug(`[${context}] Applying limit: ${limit}`);
              query = query.limit(limit);
            }
            const result = await query;
            logger3.debug(`[${context}] Retrieved ${result.length} companies`);
            return result;
          }, context);
        } catch (error) {
          logger3.error(`[${context}] Failed to get companies with options:`, options, error);
          logger3.error(`[${context}] Error details: ${error.message}`);
          logger3.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve companies: ${error.message}`);
        }
      }
      /**
       * Get a company by ID
       * 
       * @param companyId Company ID
       * @returns Company object or null if not found
       */
      async getCompanyById(companyId) {
        const context = "getCompanyById";
        try {
          logger3.debug(`[${context}] Getting company by ID: ${companyId}`);
          return await this.query(async (db4) => {
            const result = await db4.select({
              id: companies.id,
              name: companies.name,
              fiscalCode: companies.fiscalCode,
              registrationNumber: companies.registrationNumber,
              address: companies.address,
              city: companies.city,
              county: companies.county,
              country: companies.country,
              phone: companies.phone,
              email: companies.email,
              bankAccount: companies.bankAccount,
              bankName: companies.bankName,
              vatPayer: companies.vatPayer,
              vatRate: companies.vatRate,
              logoUrl: companies.logoUrl,
              parentId: sql7`parent_id`,
              type: sql7`type`,
              createdAt: companies.createdAt,
              updatedAt: companies.updatedAt,
              deletedAt: sql7`deleted_at`
            }).from(companies).where(
              and(
                sql7`id = ${companyId}`,
                sql7`deleted_at IS NULL`
              )
            ).limit(1);
            if (!result || result.length === 0) {
              logger3.debug(`[${context}] No company found with ID: ${companyId}`);
              return null;
            }
            logger3.debug(`[${context}] Retrieved company: ${result[0].name}`);
            return result[0];
          }, context);
        } catch (error) {
          logger3.error(`[${context}] Failed to get company by ID: ${companyId}`, error);
          logger3.error(`[${context}] Error details: ${error.message}`);
          logger3.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve company: ${error.message}`);
        }
      }
      /**
       * Search for companies by name or fiscal code
       * 
       * @param searchTerm Search term
       * @param limit Maximum number of results to return
       * @returns Array of matching companies
       */
      async searchCompanies(searchTerm, limit = 10) {
        const context = "searchCompanies";
        try {
          logger3.debug(`[${context}] Searching companies with term: "${searchTerm}" (limit: ${limit})`);
          if (!searchTerm || searchTerm.trim() === "") {
            logger3.debug(`[${context}] Empty search term, returning empty result`);
            return [];
          }
          return await this.query(async (db4) => {
            const pattern = `%${searchTerm.trim()}%`;
            const result = await db4.select({
              id: companies.id,
              name: companies.name,
              fiscalCode: companies.fiscalCode,
              registrationNumber: companies.registrationNumber,
              parentId: sql7`parent_id`,
              type: sql7`type`
            }).from(companies).where(
              and(
                sql7`deleted_at IS NULL`,
                or(
                  sql7`name ILIKE ${pattern}`,
                  sql7`fiscal_code ILIKE ${pattern}`
                )
              )
            ).limit(limit);
            logger3.debug(`[${context}] Found ${result.length} companies matching "${searchTerm}"`);
            return result;
          }, context);
        } catch (error) {
          logger3.error(`[${context}] Failed to search companies with term: "${searchTerm}"`, error);
          logger3.error(`[${context}] Error details: ${error.message}`);
          logger3.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to search companies: ${error.message}`);
        }
      }
      /**
       * Get franchises, optionally filtering by parent company ID
       * 
       * @param parentId Optional parent company ID
       * @returns Array of franchise companies
       */
      async getFranchises(parentId) {
        const context = "getFranchises";
        try {
          logger3.debug(`[${context}] Getting franchises${parentId ? ` for parent company ${parentId}` : ""}`);
          return await this.query(async (db4) => {
            let conditions = [
              sql7`deleted_at IS NULL`,
              sql7`type = 'franchise'`
            ];
            if (parentId) {
              logger3.debug(`[${context}] Adding parent ID filter: ${parentId}`);
              conditions.push(sql7`parent_id = ${parentId}`);
            }
            const result = await db4.select({
              id: companies.id,
              name: companies.name,
              fiscalCode: companies.fiscalCode,
              parentId: sql7`parent_id`,
              type: sql7`type`
            }).from(companies).where(and(...conditions));
            logger3.debug(`[${context}] Retrieved ${result.length} franchises`);
            return result;
          }, context);
        } catch (error) {
          logger3.error(`[${context}] Failed to get franchises${parentId ? ` for parent ${parentId}` : ""}`, error);
          logger3.error(`[${context}] Error details: ${error.message}`);
          logger3.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve franchises: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/company/company-mutation.service.ts
import { sql as sql8 } from "drizzle-orm";
var logger4, CompanyMutationService;
var init_company_mutation_service = __esm({
  "server/common/drizzle/modules/company/company-mutation.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_schema4();
    init_company_query_service();
    logger4 = new Logger("CompanyMutationService");
    CompanyMutationService = class extends BaseDrizzleService {
      constructor() {
        super();
        this.companyQueryService = new CompanyQueryService();
      }
      /**
       * Create a new company
       * 
       * @param data Company data to insert
       * @param createdBy User ID of the creator
       * @returns Created company object
       */
      async createCompany(data, createdBy) {
        const context = "createCompany";
        try {
          logger4.debug(`[${context}] Creating company with data:`, { ...data, createdBy });
          if (!data.name || !data.fiscalCode) {
            const errorMessage = "Name and fiscal code are required for creating a company";
            logger4.error(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          return await this.transaction(async (tx) => {
            const result = await tx.insert(companies).values({
              name: data.name,
              fiscalCode: data.fiscalCode,
              registrationNumber: data.registrationNumber || "",
              address: data.address || "",
              city: data.city || "",
              county: data.county || "",
              country: data.country || "Romania",
              phone: data.phone,
              email: data.email,
              bankAccount: data.bankAccount,
              bankName: data.bankName,
              vatPayer: data.vatPayer !== void 0 ? data.vatPayer : true,
              vatRate: data.vatRate || 19,
              logoUrl: data.logoUrl,
              createdAt: /* @__PURE__ */ new Date()
            }).returning();
            if (result.length > 0) {
              const companyId = result[0].id;
              const additionalFields = {
                type: data.type || "company",
                parent_id: data.parentId || null,
                created_by: createdBy
              };
              const fieldsToUpdate = Object.entries(additionalFields).map(([key, value]) => `${key} = ${value === null ? "NULL" : `'${value}'`}`).join(", ");
              await tx.execute(sql8`
            UPDATE companies 
            SET ${sql8.raw(fieldsToUpdate)} 
            WHERE id = ${companyId}
          `);
              logger4.info(`[${context}] Company created successfully: ${data.name} (${companyId})`);
              const createdCompany = await this.companyQueryService.getCompanyById(companyId);
              return createdCompany;
            } else {
              throw new Error("Failed to create company, no result returned");
            }
          }, context);
        } catch (error) {
          logger4.error(`[${context}] Failed to create company`, error);
          logger4.error(`[${context}] Company data: ${JSON.stringify(data)}`);
          logger4.error(`[${context}] Error details: ${error.message}`);
          logger4.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to create company: ${error.message}`);
        }
      }
      /**
       * Update an existing company
       * 
       * @param companyId Company ID to update
       * @param data Updated company data
       * @param updatedBy User ID of the updater
       * @returns Updated company or null if not found
       */
      async updateCompany(companyId, data, updatedBy) {
        const context = "updateCompany";
        try {
          logger4.debug(`[${context}] Updating company ${companyId} with data:`, { ...data, updatedBy });
          const existingCompany = await this.companyQueryService.getCompanyById(companyId);
          if (!existingCompany) {
            logger4.warn(`[${context}] Company not found with ID: ${companyId}`);
            return null;
          }
          return await this.transaction(async (tx) => {
            const updates = {
              updatedAt: /* @__PURE__ */ new Date()
            };
            if (data.name !== void 0) updates.name = data.name;
            if (data.fiscalCode !== void 0) updates.fiscalCode = data.fiscalCode;
            if (data.registrationNumber !== void 0) updates.registrationNumber = data.registrationNumber;
            if (data.address !== void 0) updates.address = data.address;
            if (data.city !== void 0) updates.city = data.city;
            if (data.county !== void 0) updates.county = data.county;
            if (data.country !== void 0) updates.country = data.country;
            if (data.phone !== void 0) updates.phone = data.phone;
            if (data.email !== void 0) updates.email = data.email;
            if (data.bankAccount !== void 0) updates.bankAccount = data.bankAccount;
            if (data.bankName !== void 0) updates.bankName = data.bankName;
            if (data.vatPayer !== void 0) updates.vatPayer = data.vatPayer;
            if (data.vatRate !== void 0) updates.vatRate = data.vatRate;
            if (data.logoUrl !== void 0) updates.logoUrl = data.logoUrl;
            if (Object.keys(updates).length > 1) {
              await tx.update(companies).set(updates).where(sql8`id = ${companyId} AND deleted_at IS NULL`);
            }
            const customUpdates = {};
            if (data.type !== void 0) customUpdates.type = data.type;
            if (data.parentId !== void 0) customUpdates.parent_id = data.parentId;
            customUpdates.updated_by = updatedBy;
            if (Object.keys(customUpdates).length > 0) {
              const fieldsToUpdate = Object.entries(customUpdates).map(([key, value]) => `${key} = ${value === null ? "NULL" : `'${value}'`}`).join(", ");
              await tx.execute(sql8`
            UPDATE companies 
            SET ${sql8.raw(fieldsToUpdate)} 
            WHERE id = ${companyId} AND deleted_at IS NULL
          `);
            }
            logger4.info(`[${context}] Company updated successfully: ${companyId}`);
            const updatedCompany = await this.companyQueryService.getCompanyById(companyId);
            return updatedCompany;
          }, context);
        } catch (error) {
          logger4.error(`[${context}] Failed to update company ${companyId}`, error);
          logger4.error(`[${context}] Update data: ${JSON.stringify(data)}`);
          logger4.error(`[${context}] Error details: ${error.message}`);
          logger4.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to update company: ${error.message}`);
        }
      }
      /**
       * Soft delete a company
       * 
       * @param companyId Company ID to delete
       * @param deletedBy User ID performing the deletion
       * @returns True if successful, false if company not found
       */
      async deleteCompany(companyId, deletedBy) {
        const context = "deleteCompany";
        try {
          logger4.debug(`[${context}] Soft deleting company ${companyId} by user ${deletedBy}`);
          const existingCompany = await this.companyQueryService.getCompanyById(companyId);
          if (!existingCompany) {
            logger4.warn(`[${context}] Company not found with ID: ${companyId}`);
            return false;
          }
          return await this.transaction(async (tx) => {
            await tx.execute(sql8`
          UPDATE companies
          SET 
            deleted_at = NOW(),
            deleted_by = ${deletedBy},
            updated_at = NOW()
          WHERE id = ${companyId} AND deleted_at IS NULL
        `);
            logger4.info(`[${context}] Company ${companyId} soft deleted successfully`);
            return true;
          }, context);
        } catch (error) {
          logger4.error(`[${context}] Failed to delete company ${companyId}`, error);
          logger4.error(`[${context}] Error details: ${error.message}`);
          logger4.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to delete company: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/company/company-hierarchy.service.ts
import { sql as sql9, or as or2, and as and2 } from "drizzle-orm";
var logger5, CompanyHierarchyService;
var init_company_hierarchy_service = __esm({
  "server/common/drizzle/modules/company/company-hierarchy.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_schema4();
    logger5 = new Logger("CompanyHierarchyService");
    CompanyHierarchyService = class extends BaseDrizzleService {
      /**
       * Get the full company hierarchy
       * 
       * @returns Hierarchical structure of companies
       */
      async getCompanyHierarchy() {
        const context = "getCompanyHierarchy";
        try {
          logger5.debug(`[${context}] Getting complete company hierarchy`);
          return await this.query(async (db4) => {
            logger5.debug(`[${context}] Retrieving parent companies`);
            const parentCompanies = await db4.select({
              id: companies.id,
              name: companies.name,
              fiscalCode: companies.fiscalCode,
              parentId: sql9`parent_id`,
              type: sql9`type`,
              createdAt: companies.createdAt,
              updatedAt: companies.updatedAt
            }).from(companies).where(
              and2(
                sql9`deleted_at IS NULL`,
                or2(
                  sql9`parent_id IS NULL`,
                  sql9`parent_id = ''`
                )
              )
            );
            logger5.debug(`[${context}] Found ${parentCompanies.length} parent companies`);
            if (!parentCompanies || parentCompanies.length === 0) {
              return [];
            }
            logger5.debug(`[${context}] Retrieving subsidiaries for each parent company`);
            const result = await Promise.all(parentCompanies.map(async (parent) => {
              try {
                const subsidiaries = await db4.select({
                  id: companies.id,
                  name: companies.name,
                  fiscalCode: companies.fiscalCode,
                  parentId: sql9`parent_id`,
                  type: sql9`type`,
                  createdAt: companies.createdAt,
                  updatedAt: companies.updatedAt
                }).from(companies).where(
                  and2(
                    sql9`deleted_at IS NULL`,
                    sql9`parent_id = ${parent.id}`
                  )
                );
                logger5.debug(`[${context}] Found ${subsidiaries.length} subsidiaries for parent company ${parent.id}`);
                return {
                  ...parent,
                  subsidiaries: subsidiaries || []
                };
              } catch (subError) {
                logger5.error(`[${context}] Error retrieving subsidiaries for parent ${parent.id}:`, subError);
                return {
                  ...parent,
                  subsidiaries: []
                };
              }
            }));
            logger5.info(`[${context}] Retrieved complete company hierarchy with ${result.length} parent companies`);
            return result;
          }, context);
        } catch (error) {
          logger5.error(`[${context}] Failed to get company hierarchy`, error);
          logger5.error(`[${context}] Error details: ${error.message}`);
          logger5.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve company hierarchy: ${error.message}`);
        }
      }
      /**
       * Get child companies for a specific parent
       * 
       * @param parentId Parent company ID
       * @returns Array of child companies
       */
      async getChildCompanies(parentId) {
        const context = "getChildCompanies";
        try {
          logger5.debug(`[${context}] Getting child companies for parent: ${parentId}`);
          if (!parentId) {
            const errorMessage = "Parent ID is required";
            logger5.error(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          return await this.query(async (db4) => {
            const children = await db4.select({
              id: companies.id,
              name: companies.name,
              fiscalCode: companies.fiscalCode,
              registrationNumber: companies.registrationNumber,
              parentId: sql9`parent_id`,
              type: sql9`type`,
              createdAt: companies.createdAt,
              updatedAt: companies.updatedAt
            }).from(companies).where(
              and2(
                sql9`deleted_at IS NULL`,
                sql9`parent_id = ${parentId}`
              )
            );
            logger5.debug(`[${context}] Found ${children.length} child companies for parent ${parentId}`);
            return children;
          }, context);
        } catch (error) {
          logger5.error(`[${context}] Failed to get child companies for parent ${parentId}`, error);
          logger5.error(`[${context}] Error details: ${error.message}`);
          logger5.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve child companies: ${error.message}`);
        }
      }
      /**
       * Check if a company has children
       * 
       * @param companyId Company ID to check
       * @returns Boolean indicating if the company has children
       */
      async hasChildren(companyId) {
        const context = "hasChildren";
        try {
          logger5.debug(`[${context}] Checking if company ${companyId} has children`);
          return await this.query(async (db4) => {
            const result = await db4.select({ count: sql9`count(*)` }).from(companies).where(
              and2(
                sql9`deleted_at IS NULL`,
                sql9`parent_id = ${companyId}`
              )
            );
            const hasChildren = result[0].count > 0;
            logger5.debug(`[${context}] Company ${companyId} ${hasChildren ? "has" : "does not have"} children`);
            return hasChildren;
          }, context);
        } catch (error) {
          logger5.error(`[${context}] Failed to check if company ${companyId} has children`, error);
          logger5.error(`[${context}] Error details: ${error.message}`);
          logger5.error(`[${context}] Stack trace: ${error.stack}`);
          return false;
        }
      }
      /**
       * Update parent-child relationship between companies
       * 
       * @param childId Child company ID
       * @param parentId Parent company ID (null to remove relationship)
       * @param updatedBy User ID making the change
       * @returns Boolean indicating success
       */
      async updateCompanyParent(childId, parentId, updatedBy) {
        const context = "updateCompanyParent";
        try {
          logger5.debug(`[${context}] Updating parent of company ${childId} to ${parentId || "NULL"}`);
          if (!childId) {
            const errorMessage = "Child company ID is required";
            logger5.error(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          if (parentId && parentId === childId) {
            const errorMessage = "Cannot set a company as its own parent";
            logger5.error(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          return await this.transaction(async (tx) => {
            const childExists = await tx.select({ id: companies.id }).from(companies).where(
              and2(
                sql9`id = ${childId}`,
                sql9`deleted_at IS NULL`
              )
            );
            if (!childExists || childExists.length === 0) {
              logger5.error(`[${context}] Child company ${childId} not found`);
              return false;
            }
            if (parentId) {
              const parentExists = await tx.select({ id: companies.id }).from(companies).where(
                and2(
                  sql9`id = ${parentId}`,
                  sql9`deleted_at IS NULL`
                )
              );
              if (!parentExists || parentExists.length === 0) {
                logger5.error(`[${context}] Parent company ${parentId} not found`);
                return false;
              }
            }
            await tx.execute(sql9`
          UPDATE companies
          SET 
            parent_id = ${parentId === null ? sql9`NULL` : sql9`${parentId}`},
            updated_at = NOW(),
            updated_by = ${updatedBy}
          WHERE id = ${childId} AND deleted_at IS NULL
        `);
            logger5.info(`[${context}] Updated parent of company ${childId} to ${parentId || "NULL"}`);
            return true;
          }, context);
        } catch (error) {
          logger5.error(`[${context}] Failed to update parent of company ${childId}`, error);
          logger5.error(`[${context}] Error details: ${error.message}`);
          logger5.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to update company parent: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/company/company-drizzle.service.ts
var logger6, CompanyDrizzleService;
var init_company_drizzle_service = __esm({
  "server/common/drizzle/modules/company/company-drizzle.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_company_query_service();
    init_company_mutation_service();
    init_company_hierarchy_service();
    logger6 = new Logger("CompanyDrizzleService");
    CompanyDrizzleService = class extends BaseDrizzleService {
      constructor() {
        super();
        this.companyQueryService = new CompanyQueryService();
        this.companyMutationService = new CompanyMutationService();
        this.companyHierarchyService = new CompanyHierarchyService();
        logger6.info("CompanyDrizzleService initialized with all specialized services");
      }
      /**
       * Fetch companies from the database
       * 
       * @param options Query options for filtering companies
       * @returns Array of companies
       */
      async getCompanies(options = {}) {
        const context = "getCompanies";
        try {
          logger6.debug(`[${context}] Delegating to CompanyQueryService`);
          return await this.companyQueryService.getCompanies(options);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get company by ID
       * 
       * @param companyId Company ID
       * @returns Company or null if not found
       */
      async getCompanyById(companyId) {
        const context = "getCompanyById";
        try {
          logger6.debug(`[${context}] Delegating to CompanyQueryService`);
          return await this.companyQueryService.getCompanyById(companyId);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get franchises, optionally filtering by parent company ID
       * 
       * @param parentId Optional parent company ID
       * @returns Array of franchise companies
       */
      async getFranchises(parentId) {
        const context = "getFranchises";
        try {
          logger6.debug(`[${context}] Delegating to CompanyQueryService`);
          return await this.companyQueryService.getFranchises(parentId);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Create a new company
       * 
       * @param data Company data to insert
       * @param createdBy User ID of the creator
       * @returns Created company
       */
      async createCompany(data, createdBy) {
        const context = "createCompany";
        try {
          logger6.debug(`[${context}] Delegating to CompanyMutationService`);
          return await this.companyMutationService.createCompany(data, createdBy);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Update an existing company
       * 
       * @param companyId Company ID to update
       * @param data Company data to update
       * @param updatedBy User ID of the updater
       * @returns Updated company or null if not found
       */
      async updateCompany(companyId, data, updatedBy) {
        const context = "updateCompany";
        try {
          logger6.debug(`[${context}] Delegating to CompanyMutationService`);
          return await this.companyMutationService.updateCompany(companyId, data, updatedBy);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Soft delete a company
       * 
       * @param companyId Company ID to delete
       * @param deletedBy User ID of the person performing the deletion
       * @returns True if successful, false if company not found
       */
      async deleteCompany(companyId, deletedBy) {
        const context = "deleteCompany";
        try {
          logger6.debug(`[${context}] Delegating to CompanyMutationService`);
          return await this.companyMutationService.deleteCompany(companyId, deletedBy);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get companies with their subsidiaries
       * 
       * @returns Array of companies with subsidiaries
       */
      async getCompanyHierarchy() {
        const context = "getCompanyHierarchy";
        try {
          logger6.debug(`[${context}] Delegating to CompanyHierarchyService`);
          return await this.companyHierarchyService.getCompanyHierarchy();
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Search for companies by name or fiscal code
       * 
       * @param searchTerm Search term to look for
       * @param limit Maximum number of results
       * @returns Matching companies
       */
      async searchCompanies(searchTerm, limit = 10) {
        const context = "searchCompanies";
        try {
          logger6.debug(`[${context}] Delegating to CompanyQueryService`);
          return await this.companyQueryService.searchCompanies(searchTerm, limit);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Update parent-child relationship between companies
       * 
       * @param childId Child company ID
       * @param parentId Parent company ID (null to remove relationship)
       * @param updatedBy User ID making the change
       * @returns Boolean indicating success
       */
      async updateCompanyParent(childId, parentId, updatedBy) {
        const context = "updateCompanyParent";
        try {
          logger6.debug(`[${context}] Delegating to CompanyHierarchyService`);
          return await this.companyHierarchyService.updateCompanyParent(childId, parentId, updatedBy);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get child companies for a specific parent
       * 
       * @param parentId Parent company ID
       * @returns Array of child companies
       */
      async getChildCompanies(parentId) {
        const context = "getChildCompanies";
        try {
          logger6.debug(`[${context}] Delegating to CompanyHierarchyService`);
          return await this.companyHierarchyService.getChildCompanies(parentId);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Check if a company has children
       * 
       * @param companyId Company ID
       * @returns Boolean indicating if the company has children
       */
      async hasChildren(companyId) {
        const context = "hasChildren";
        try {
          logger6.debug(`[${context}] Delegating to CompanyHierarchyService`);
          return await this.companyHierarchyService.hasChildren(companyId);
        } catch (error) {
          logger6.error(`[${context}] Error in CompanyDrizzleService wrapper`, error);
          throw error;
        }
      }
    };
  }
});

// server/common/drizzle/modules/company/index.ts
var init_company = __esm({
  "server/common/drizzle/modules/company/index.ts"() {
    "use strict";
    init_company_drizzle_service();
  }
});

// server/common/drizzle/modules/invoicing/invoicing-drizzle.service.ts
var logger7, InvoicingDrizzleService;
var init_invoicing_drizzle_service = __esm({
  "server/common/drizzle/modules/invoicing/invoicing-drizzle.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    logger7 = new Logger("InvoicingDrizzleService");
    InvoicingDrizzleService = class extends BaseDrizzleService {
      /**
       * Get all invoice numbering settings
       * 
       * @returns Array of invoice numbering settings
       */
      async getInvoiceNumberingSettings() {
        try {
          logger7.debug("Getting all invoice numbering settings");
          const query = `
        SELECT 
          id,
          name,
          series,
          start_number as "startNumber",
          current_number as "currentNumber",
          prefix,
          suffix,
          digits,
          company_id as "companyId",
          warehouse_id as "warehouseId",
          type,
          is_default as "isDefault",
          created_at as "createdAt",
          updated_at as "updatedAt"
        FROM invoice_numbering_settings
        WHERE deleted_at IS NULL
        ORDER BY created_at DESC
      `;
          return this.executeQuery(query, [], "getInvoiceNumberingSettings");
        } catch (error) {
          logger7.error("Failed to get invoice numbering settings", error);
          throw new Error("Failed to retrieve invoice numbering settings");
        }
      }
      /**
       * Get invoice numbering setting by ID
       * 
       * @param id Invoice numbering setting ID
       * @returns Invoice numbering setting or null if not found
       */
      async getInvoiceNumberingSettingById(id) {
        try {
          logger7.debug(`Getting invoice numbering setting by ID: ${id}`);
          const query = `
        SELECT 
          id,
          name,
          series,
          start_number as "startNumber",
          current_number as "currentNumber",
          prefix,
          suffix,
          digits,
          company_id as "companyId",
          warehouse_id as "warehouseId",
          type,
          is_default as "isDefault",
          created_at as "createdAt",
          updated_at as "updatedAt"
        FROM invoice_numbering_settings
        WHERE id = $1 AND deleted_at IS NULL
      `;
          const results = await this.executeQuery(query, [id], "getInvoiceNumberingSettingById");
          if (!results || results.length === 0) {
            return null;
          }
          return results[0];
        } catch (error) {
          logger7.error(`Failed to get invoice numbering setting by ID ${id}`, error);
          throw new Error("Failed to retrieve invoice numbering setting");
        }
      }
      /**
       * Create a new invoice numbering setting
       * 
       * @param data Invoice numbering setting data
       * @param createdBy User ID of the creator
       * @returns Created invoice numbering setting
       */
      async createInvoiceNumberingSetting(data, createdBy) {
        try {
          logger7.debug("Creating invoice numbering setting with data:", data);
          return await this.transaction(async (tx) => {
            if (data.isDefault) {
              const unsetDefaultQuery = `
            UPDATE invoice_numbering_settings
            SET 
              is_default = FALSE,
              updated_at = NOW(),
              updated_by = $1
            WHERE 
              type = $2 
              AND is_default = TRUE
              AND deleted_at IS NULL
          `;
              await tx.$client.unsafe(unsetDefaultQuery, [createdBy, data.type]);
            }
            const insertQuery = `
          INSERT INTO invoice_numbering_settings (
            name,
            series,
            start_number,
            current_number,
            prefix,
            suffix,
            digits,
            company_id,
            warehouse_id,
            type,
            is_default,
            created_by
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
          RETURNING 
            id,
            name,
            series,
            start_number as "startNumber",
            current_number as "currentNumber",
            prefix,
            suffix,
            digits,
            company_id as "companyId",
            warehouse_id as "warehouseId",
            type,
            is_default as "isDefault",
            created_at as "createdAt",
            updated_at as "updatedAt"
        `;
            const params = [
              data.name,
              data.series,
              data.startNumber || 1,
              data.currentNumber || data.startNumber || 1,
              data.prefix || "",
              data.suffix || "",
              data.digits || 5,
              data.companyId || null,
              data.warehouseId || null,
              data.type || "invoice",
              data.isDefault || false,
              createdBy
            ];
            const result = await tx.$client.unsafe(insertQuery, params);
            if (!result || result.length === 0) {
              throw new Error("Failed to create invoice numbering setting");
            }
            return result[0];
          }, "createInvoiceNumberingSetting");
        } catch (error) {
          logger7.error("Failed to create invoice numbering setting", error);
          throw new Error("Failed to create invoice numbering setting");
        }
      }
      /**
       * Update an existing invoice numbering setting
       * 
       * @param id Invoice numbering setting ID
       * @param data Data to update
       * @param updatedBy User ID of the updater
       * @returns Updated invoice numbering setting or null if not found
       */
      async updateInvoiceNumberingSetting(id, data, updatedBy) {
        try {
          logger7.debug(`Updating invoice numbering setting ${id} with data:`, data);
          const setting = await this.getInvoiceNumberingSettingById(id);
          if (!setting) {
            logger7.warn(`Invoice numbering setting ${id} not found for update`);
            return null;
          }
          return await this.transaction(async (tx) => {
            if (data.isDefault) {
              const unsetDefaultQuery = `
            UPDATE invoice_numbering_settings
            SET 
              is_default = FALSE,
              updated_at = NOW(),
              updated_by = $1
            WHERE 
              id != $2
              AND type = $3 
              AND is_default = TRUE
              AND deleted_at IS NULL
          `;
              await tx.$client.unsafe(unsetDefaultQuery, [
                updatedBy,
                id,
                data.type || setting.type
              ]);
            }
            const updateFields = [];
            const params = [];
            let paramIndex = 1;
            if (data.name !== void 0) {
              updateFields.push(`name = $${paramIndex++}`);
              params.push(data.name);
            }
            if (data.series !== void 0) {
              updateFields.push(`series = $${paramIndex++}`);
              params.push(data.series);
            }
            if (data.startNumber !== void 0) {
              updateFields.push(`start_number = $${paramIndex++}`);
              params.push(data.startNumber);
            }
            if (data.currentNumber !== void 0) {
              updateFields.push(`current_number = $${paramIndex++}`);
              params.push(data.currentNumber);
            }
            if (data.prefix !== void 0) {
              updateFields.push(`prefix = $${paramIndex++}`);
              params.push(data.prefix);
            }
            if (data.suffix !== void 0) {
              updateFields.push(`suffix = $${paramIndex++}`);
              params.push(data.suffix);
            }
            if (data.digits !== void 0) {
              updateFields.push(`digits = $${paramIndex++}`);
              params.push(data.digits);
            }
            if (data.companyId !== void 0) {
              updateFields.push(`company_id = $${paramIndex++}`);
              params.push(data.companyId);
            }
            if (data.warehouseId !== void 0) {
              updateFields.push(`warehouse_id = $${paramIndex++}`);
              params.push(data.warehouseId);
            }
            if (data.type !== void 0) {
              updateFields.push(`type = $${paramIndex++}`);
              params.push(data.type);
            }
            if (data.isDefault !== void 0) {
              updateFields.push(`is_default = $${paramIndex++}`);
              params.push(data.isDefault);
            }
            updateFields.push(`updated_by = $${paramIndex++}`);
            params.push(updatedBy);
            updateFields.push(`updated_at = NOW()`);
            params.push(id);
            if (updateFields.length === 0) {
              logger7.warn(`No fields to update for invoice numbering setting ${id}`);
              return setting;
            }
            const updateQuery = `
          UPDATE invoice_numbering_settings
          SET ${updateFields.join(", ")}
          WHERE id = $${paramIndex} AND deleted_at IS NULL
          RETURNING 
            id,
            name,
            series,
            start_number as "startNumber",
            current_number as "currentNumber",
            prefix,
            suffix,
            digits,
            company_id as "companyId",
            warehouse_id as "warehouseId",
            type,
            is_default as "isDefault",
            created_at as "createdAt",
            updated_at as "updatedAt"
        `;
            const result = await tx.$client.unsafe(updateQuery, params);
            if (!result || result.length === 0) {
              throw new Error(`Failed to update invoice numbering setting ${id}`);
            }
            return result[0];
          }, "updateInvoiceNumberingSetting");
        } catch (error) {
          logger7.error(`Failed to update invoice numbering setting ${id}`, error);
          throw new Error("Failed to update invoice numbering setting");
        }
      }
      /**
       * Soft delete an invoice numbering setting
       * 
       * @param id Invoice numbering setting ID
       * @param deletedBy User ID of the person performing the deletion
       * @returns True if successful, false if setting not found
       */
      async deleteInvoiceNumberingSetting(id, deletedBy) {
        try {
          logger7.debug(`Soft deleting invoice numbering setting ${id}`);
          const setting = await this.getInvoiceNumberingSettingById(id);
          if (!setting) {
            logger7.warn(`Invoice numbering setting ${id} not found for deletion`);
            return false;
          }
          return await this.transaction(async (tx) => {
            const deleteQuery = `
          UPDATE invoice_numbering_settings
          SET 
            deleted_at = NOW(),
            deleted_by = $1,
            updated_at = NOW()
          WHERE id = $2 AND deleted_at IS NULL
        `;
            await tx.$client.unsafe(deleteQuery, [deletedBy, id]);
            return true;
          }, "deleteInvoiceNumberingSetting");
        } catch (error) {
          logger7.error(`Failed to delete invoice numbering setting ${id}`, error);
          throw new Error("Failed to delete invoice numbering setting");
        }
      }
      /**
       * Get the next invoice number for a specific setting
       * 
       * @param settingId Invoice numbering setting ID
       * @returns Next formatted invoice number and incremented current number
       */
      async getNextInvoiceNumber(settingId) {
        try {
          logger7.debug(`Getting next invoice number for setting ${settingId}`);
          return await this.transaction(async (tx) => {
            const getSettingQuery = `
          SELECT 
            series,
            current_number as "currentNumber",
            prefix,
            suffix,
            digits
          FROM invoice_numbering_settings
          WHERE id = $1 AND deleted_at IS NULL
          FOR UPDATE
        `;
            const settings = await tx.$client.unsafe(getSettingQuery, [settingId]);
            if (!settings || settings.length === 0) {
              throw new Error(`Invoice numbering setting ${settingId} not found`);
            }
            const setting = settings[0];
            const currentNumber = setting.currentNumber;
            const nextNumber = currentNumber + 1;
            const paddedNumber = String(currentNumber).padStart(setting.digits, "0");
            const formattedNumber = `${setting.prefix || ""}${setting.series}${paddedNumber}${setting.suffix || ""}`;
            const updateQuery = `
          UPDATE invoice_numbering_settings
          SET 
            current_number = $1,
            updated_at = NOW()
          WHERE id = $2
        `;
            await tx.$client.unsafe(updateQuery, [nextNumber, settingId]);
            return {
              formattedNumber,
              currentNumber: nextNumber
            };
          }, "getNextInvoiceNumber");
        } catch (error) {
          logger7.error(`Failed to get next invoice number for setting ${settingId}`, error);
          throw new Error("Failed to get next invoice number");
        }
      }
      /**
       * Get default invoice numbering setting for a specific type
       * 
       * @param type Invoice type (invoice, proforma, etc.)
       * @param companyId Optional company ID to filter by
       * @returns Default invoice numbering setting or null if not found
       */
      async getDefaultInvoiceNumberingSetting(type, companyId) {
        try {
          logger7.debug(`Getting default invoice numbering setting for type ${type}${companyId ? ` and company ${companyId}` : ""}`);
          let query = `
        SELECT 
          id,
          name,
          series,
          start_number as "startNumber",
          current_number as "currentNumber",
          prefix,
          suffix,
          digits,
          company_id as "companyId",
          warehouse_id as "warehouseId",
          type,
          is_default as "isDefault",
          created_at as "createdAt",
          updated_at as "updatedAt"
        FROM invoice_numbering_settings
        WHERE type = $1 AND is_default = TRUE AND deleted_at IS NULL
      `;
          const params = [type];
          if (companyId) {
            query += ` AND (company_id IS NULL OR company_id = $2)`;
            params.push(companyId);
            query += ` ORDER BY CASE WHEN company_id = $2 THEN 0 ELSE 1 END LIMIT 1`;
          } else {
            query += ` LIMIT 1`;
          }
          const results = await this.executeQuery(query, params, "getDefaultInvoiceNumberingSetting");
          if (!results || results.length === 0) {
            return null;
          }
          return results[0];
        } catch (error) {
          logger7.error(`Failed to get default invoice numbering setting for type ${type}`, error);
          throw new Error("Failed to retrieve default invoice numbering setting");
        }
      }
    };
  }
});

// server/common/drizzle/modules/invoicing/invoice-service.ts
var logger8;
var init_invoice_service = __esm({
  "server/common/drizzle/modules/invoicing/invoice-service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    logger8 = new Logger("InvoiceService");
  }
});

// server/common/drizzle/modules/invoicing/invoice-mutation.service.ts
var logger9;
var init_invoice_mutation_service = __esm({
  "server/common/drizzle/modules/invoicing/invoice-mutation.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    logger9 = new Logger("InvoiceMutationService");
  }
});

// server/common/drizzle/modules/invoicing/invoice-numbering-service.ts
var logger10;
var init_invoice_numbering_service = __esm({
  "server/common/drizzle/modules/invoicing/invoice-numbering-service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    logger10 = new Logger("InvoiceNumberingService");
  }
});

// server/common/drizzle/modules/invoicing/invoice-numbering-mutation.service.ts
var logger11;
var init_invoice_numbering_mutation_service = __esm({
  "server/common/drizzle/modules/invoicing/invoice-numbering-mutation.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    logger11 = new Logger("InvoiceNumberingMutationService");
  }
});

// server/common/drizzle/modules/invoicing/index.ts
var init_invoicing = __esm({
  "server/common/drizzle/modules/invoicing/index.ts"() {
    "use strict";
    init_invoicing_drizzle_service();
    init_invoice_service();
    init_invoice_mutation_service();
    init_invoice_numbering_service();
    init_invoice_numbering_mutation_service();
  }
});

// shared/schema/admin.schema.ts
import {
  pgTable as pgTable11,
  uuid as uuid11,
  varchar as varchar6,
  timestamp as timestamp11,
  boolean as boolean10,
  json as json6,
  integer as integer7,
  text as text11,
  primaryKey as primaryKey6
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema8 } from "drizzle-zod";
var setup_steps, health_checks, api_keys, system_configs, admin_actions, licenses, company_licenses, users2, roles2, userRoles2, permissions2, rolePermissions2, configurations, insertSetupStepSchema, insertHealthCheckSchema, insertApiKeySchema, insertSystemConfigSchema, insertAdminActionSchema, insertCompanyLicenseSchema, insertConfigurationSchema, insertLicenseSchema, insertPermissionSchema2, insertRolePermissionSchema2;
var init_admin_schema = __esm({
  "shared/schema/admin.schema.ts"() {
    "use strict";
    setup_steps = pgTable11("setup_steps", {
      id: uuid11("id").primaryKey().defaultRandom(),
      company_id: varchar6("company_id", { length: 36 }).notNull(),
      franchise_id: varchar6("franchise_id", { length: 36 }),
      step: varchar6("step", { length: 100 }).notNull(),
      status: varchar6("status", { length: 20 }).default("pending"),
      created_at: timestamp11("created_at").defaultNow().notNull(),
      updated_at: timestamp11("updated_at").defaultNow().notNull()
    });
    health_checks = pgTable11("health_checks", {
      id: uuid11("id").primaryKey().defaultRandom(),
      check_type: varchar6("check_type", { length: 50 }).notNull(),
      // e.g., 'database', 'redis', 'storage'
      status: varchar6("status", { length: 20 }).notNull(),
      // 'ok', 'warning', 'error', 'degraded'
      details: json6("details"),
      performed_at: timestamp11("performed_at").defaultNow().notNull(),
      performed_by: varchar6("performed_by", { length: 36 })
      // user ID if manually triggered
    });
    api_keys = pgTable11("api_keys", {
      id: uuid11("id").primaryKey().defaultRandom(),
      company_id: varchar6("company_id", { length: 36 }).notNull(),
      name: varchar6("name", { length: 100 }).notNull(),
      service: varchar6("service", { length: 100 }).notNull(),
      // e.g., 'stripe', 'twilio'
      key_identifier: varchar6("key_identifier", { length: 255 }).notNull(),
      // partial/masked identifier
      is_active: boolean10("is_active").default(true),
      expires_at: timestamp11("expires_at"),
      created_at: timestamp11("created_at").defaultNow().notNull(),
      created_by: varchar6("created_by", { length: 36 }).notNull(),
      last_used_at: timestamp11("last_used_at"),
      last_rotated_at: timestamp11("last_rotated_at")
    });
    system_configs = pgTable11("system_configs", {
      id: uuid11("id").primaryKey().defaultRandom(),
      company_id: varchar6("company_id", { length: 36 }),
      module: varchar6("module", { length: 100 }).notNull(),
      key: varchar6("key", { length: 255 }).notNull(),
      value: json6("value").notNull(),
      is_encrypted: boolean10("is_encrypted").default(false),
      description: varchar6("description", { length: 500 }),
      created_at: timestamp11("created_at").defaultNow().notNull(),
      updated_at: timestamp11("updated_at").defaultNow().notNull(),
      created_by: varchar6("created_by", { length: 36 }).notNull(),
      updated_by: varchar6("updated_by", { length: 36 }).notNull()
    });
    admin_actions = pgTable11("admin_actions", {
      id: uuid11("id").primaryKey().defaultRandom(),
      action_type: varchar6("action_type", { length: 100 }).notNull(),
      // e.g., 'user_impersonation', 'config_change'
      performed_by: varchar6("performed_by", { length: 36 }).notNull(),
      company_id: varchar6("company_id", { length: 36 }),
      target_resource: varchar6("target_resource", { length: 255 }),
      target_id: varchar6("target_id", { length: 36 }),
      details: json6("details"),
      performed_at: timestamp11("performed_at").defaultNow().notNull(),
      ip_address: varchar6("ip_address", { length: 50 })
    });
    licenses = pgTable11("licenses", {
      id: uuid11("id").primaryKey().defaultRandom(),
      license_key: varchar6("license_key", { length: 100 }).notNull().unique(),
      edition: varchar6("edition", { length: 50 }).default("standard").notNull(),
      status: varchar6("status", { length: 20 }).default("active").notNull(),
      issued_to: varchar6("issued_to", { length: 255 }).notNull(),
      issued_email: varchar6("issued_email", { length: 255 }).notNull(),
      max_activations: integer7("max_activations").default(1).notNull(),
      current_activations: integer7("current_activations").default(0).notNull(),
      features: json6("features").default({}).notNull(),
      activation_code: varchar6("activation_code", { length: 100 }),
      issued_at: timestamp11("issued_at").defaultNow().notNull(),
      expires_at: timestamp11("expires_at"),
      last_verified: timestamp11("last_verified"),
      created_at: timestamp11("created_at").defaultNow().notNull(),
      updated_at: timestamp11("updated_at").defaultNow().notNull()
    });
    company_licenses = pgTable11("company_licenses", {
      id: uuid11("id").primaryKey().defaultRandom(),
      company_id: varchar6("company_id", { length: 36 }).notNull(),
      license_type: varchar6("license_type", { length: 100 }).notNull(),
      // 'standard', 'professional', 'enterprise'
      max_users: integer7("max_users"),
      features: json6("features"),
      // enabled features
      is_active: boolean10("is_active").default(true),
      starts_at: timestamp11("starts_at").notNull(),
      expires_at: timestamp11("expires_at"),
      created_at: timestamp11("created_at").defaultNow().notNull(),
      updated_at: timestamp11("updated_at").defaultNow().notNull(),
      created_by: varchar6("created_by", { length: 36 }).notNull(),
      updated_by: varchar6("updated_by", { length: 36 }).notNull()
    });
    users2 = pgTable11("users", {
      id: uuid11("id").primaryKey().defaultRandom(),
      username: varchar6("username", { length: 100 }).notNull().unique(),
      email: varchar6("email", { length: 255 }).notNull().unique(),
      password: varchar6("password", { length: 255 }).notNull(),
      first_name: varchar6("first_name", { length: 100 }),
      last_name: varchar6("last_name", { length: 100 }),
      role: text11("role").notNull().default("user"),
      // Adăugare câmp role care există în baza de date
      status: varchar6("status", { length: 20 }).default("active" /* ACTIVE */).notNull(),
      company_id: varchar6("company_id", { length: 36 }),
      // franchise_id a fost eliminat, deoarece nu există în baza de date reală
      // last_login_at a fost eliminat, deoarece nu există în baza de date reală
      created_at: timestamp11("created_at").defaultNow().notNull(),
      updated_at: timestamp11("updated_at").defaultNow().notNull()
    });
    roles2 = pgTable11("roles", {
      id: uuid11("id").primaryKey().defaultRandom(),
      company_id: uuid11("company_id").notNull(),
      // Câmp obligatoriu care exista deja în BD
      name: varchar6("name", { length: 100 }).notNull(),
      description: varchar6("description", { length: 255 }),
      is_system: boolean10("is_system").default(false),
      created_at: timestamp11("created_at").defaultNow().notNull(),
      updated_at: timestamp11("updated_at").defaultNow().notNull()
    });
    userRoles2 = pgTable11("user_roles", {
      id: uuid11("id").primaryKey().defaultRandom(),
      user_id: varchar6("user_id", { length: 36 }).notNull(),
      role_id: varchar6("role_id", { length: 36 }).notNull(),
      assigned_at: timestamp11("assigned_at").defaultNow().notNull(),
      assigned_by: varchar6("assigned_by", { length: 36 }).notNull()
    });
    permissions2 = pgTable11("permissions", {
      id: uuid11("id").primaryKey().defaultRandom(),
      name: text11("name").notNull().unique(),
      description: text11("description"),
      resource: text11("resource").notNull(),
      action: text11("action").notNull(),
      created_at: timestamp11("created_at").defaultNow().notNull(),
      updated_at: timestamp11("updated_at").defaultNow().notNull()
    });
    rolePermissions2 = pgTable11("role_permissions", {
      role_id: uuid11("role_id").notNull().references(() => roles2.id, { onDelete: "cascade" }),
      permission_id: uuid11("permission_id").notNull().references(() => permissions2.id, { onDelete: "cascade" })
    }, (table) => {
      return {
        pk: primaryKey6({ columns: [table.role_id, table.permission_id] })
      };
    });
    configurations = pgTable11("configurations", {
      id: uuid11("id").primaryKey().defaultRandom(),
      key: varchar6("key", { length: 255 }).notNull(),
      value: json6("value").notNull(),
      scope: varchar6("scope", { length: 50 }).notNull().default("global"),
      // 'global', 'company', 'user', 'module'
      company_id: varchar6("company_id", { length: 36 }),
      user_id: varchar6("user_id", { length: 36 }),
      module: varchar6("module", { length: 100 }),
      description: varchar6("description", { length: 500 }),
      is_encrypted: boolean10("is_encrypted").default(false),
      created_at: timestamp11("created_at").defaultNow().notNull(),
      updated_at: timestamp11("updated_at").defaultNow().notNull(),
      created_by: varchar6("created_by", { length: 36 }),
      updated_by: varchar6("updated_by", { length: 36 })
    });
    insertSetupStepSchema = createInsertSchema8(setup_steps).omit({
      id: true,
      created_at: true,
      updated_at: true
    });
    insertHealthCheckSchema = createInsertSchema8(health_checks).omit({
      id: true,
      performed_at: true
    });
    insertApiKeySchema = createInsertSchema8(api_keys).omit({
      id: true,
      created_at: true,
      last_used_at: true,
      last_rotated_at: true
    });
    insertSystemConfigSchema = createInsertSchema8(system_configs).omit({
      id: true,
      created_at: true,
      updated_at: true
    });
    insertAdminActionSchema = createInsertSchema8(admin_actions).omit({
      id: true,
      performed_at: true
    });
    insertCompanyLicenseSchema = createInsertSchema8(company_licenses).omit({
      id: true,
      created_at: true,
      updated_at: true
    });
    insertConfigurationSchema = createInsertSchema8(configurations).omit({
      id: true,
      created_at: true,
      updated_at: true
    });
    insertLicenseSchema = createInsertSchema8(licenses).omit({
      id: true,
      created_at: true,
      updated_at: true,
      last_verified: true,
      issued_at: true
    });
    insertPermissionSchema2 = createInsertSchema8(permissions2).omit({
      id: true,
      created_at: true,
      updated_at: true
    });
    insertRolePermissionSchema2 = createInsertSchema8(rolePermissions2);
  }
});

// server/common/drizzle/modules/auth/users/user-query.service.ts
import { eq as eq2, and as and3 } from "drizzle-orm";
var logger12, UserQueryService;
var init_user_query_service = __esm({
  "server/common/drizzle/modules/auth/users/user-query.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_admin_schema();
    logger12 = new Logger("UserQueryService");
    UserQueryService = class extends BaseDrizzleService {
      /**
       * Get user by username
       * 
       * @param username Username to search for
       * @returns User object or null if not found
       */
      async getUserByUsername(username) {
        const context = "getUserByUsername";
        try {
          logger12.debug(`[${context}] Getting user by username: ${username}`);
          return await this.query(async (db4) => {
            logger12.debug(`[${context}] Preparing query for username: ${username}`);
            const result = await db4.select().from(users2).where(eq2(users2.username, username)).limit(1);
            if (!result || result.length === 0) {
              logger12.debug(`[${context}] No user found with username: ${username}`);
              return null;
            }
            logger12.debug(`[${context}] User found with username: ${username}, ID: ${result[0].id}`);
            return result[0];
          }, context);
        } catch (error) {
          logger12.error(`[${context}] Failed to get user by username: ${username}`, error);
          logger12.error(`[${context}] Error details: ${error.message}`);
          logger12.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve user by username: ${error.message}`);
        }
      }
      /**
       * Get user by ID
       * 
       * @param userId User ID to search for
       * @returns User object or null if not found
       */
      async getUserById(userId) {
        const context = "getUserById";
        try {
          logger12.debug(`[${context}] Getting user by ID: ${userId}`);
          return await this.query(async (db4) => {
            logger12.debug(`[${context}] Preparing query for user ID: ${userId}`);
            const result = await db4.select().from(users2).where(eq2(users2.id, userId)).limit(1);
            if (!result || result.length === 0) {
              logger12.debug(`[${context}] No user found with ID: ${userId}`);
              return null;
            }
            logger12.debug(`[${context}] User found with ID: ${userId}, username: ${result[0].username}`);
            return result[0];
          }, context);
        } catch (error) {
          logger12.error(`[${context}] Failed to get user by ID: ${userId}`, error);
          logger12.error(`[${context}] Error details: ${error.message}`);
          logger12.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve user by ID: ${error.message}`);
        }
      }
      /**
       * Get all users with optional filtering
       * 
       * @param options Filter options
       * @returns Array of users
       */
      async getUsers(options = {}) {
        const context = "getUsers";
        try {
          const { companyId, status, limit = 100, offset = 0 } = options;
          logger12.debug(`[${context}] Getting users with options:`, options);
          return await this.query(async (db4) => {
            logger12.debug(`[${context}] Building query with filters: companyId=${companyId}, status=${status}`);
            let query = db4.select().from(users2);
            const conditions = [];
            if (companyId) {
              logger12.debug(`[${context}] Adding company filter: ${companyId}`);
              conditions.push(eq2(users2.company_id, companyId));
            }
            if (status) {
              logger12.debug(`[${context}] Adding status filter: ${status}`);
              conditions.push(eq2(users2.status, status));
            }
            if (conditions.length > 0) {
              query = query.where(and3(...conditions));
            }
            logger12.debug(`[${context}] Applying pagination: limit=${limit}, offset=${offset}`);
            query = query.limit(limit).offset(offset);
            const result = await query;
            logger12.debug(`[${context}] Retrieved ${result.length} users`);
            return result;
          }, context);
        } catch (error) {
          logger12.error(`[${context}] Failed to get users with options:`, options, error);
          logger12.error(`[${context}] Error details: ${error.message}`);
          logger12.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve users: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/users/user-mutation.service.ts
import { eq as eq3 } from "drizzle-orm";
var logger13, UserMutationService;
var init_user_mutation_service = __esm({
  "server/common/drizzle/modules/auth/users/user-mutation.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_admin_schema();
    init_admin_schema();
    init_user_query_service();
    logger13 = new Logger("UserMutationService");
    UserMutationService = class extends BaseDrizzleService {
      constructor() {
        super();
        this.userQueryService = new UserQueryService();
      }
      /**
       * Create a new user
       * 
       * @param userData User data to insert with hashed password
       * @returns Created user object
       */
      async createUser(userData) {
        const context = "createUser";
        try {
          if (!userData.username) {
            const error = new Error("Username is required");
            logger13.error(`[${context}] Validation error: ${error.message}`);
            throw error;
          }
          logger13.debug(`[${context}] Creating new user with username: ${userData.username}`);
          const existingUser = await this.userQueryService.getUserByUsername(userData.username);
          if (existingUser) {
            const errorMessage = `Username already exists: ${userData.username}`;
            logger13.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          if (!userData.password || !userData.email) {
            const errorMessage = "Password and email are required";
            logger13.warn(`[${context}] Validation error: ${errorMessage}`);
            throw new Error(errorMessage);
          }
          logger13.debug(`[${context}] Inserting user into database`);
          return await this.query(async (db4) => {
            const [newUser] = await db4.insert(users2).values({
              ...userData,
              status: userData.status || "active" /* ACTIVE */,
              created_at: /* @__PURE__ */ new Date(),
              updated_at: /* @__PURE__ */ new Date()
            }).returning();
            logger13.info(`[${context}] User created successfully with ID: ${newUser.id}`);
            logger13.debug(`[${context}] Created user details: username=${newUser.username}, email=${newUser.email}`);
            return newUser;
          }, context);
        } catch (error) {
          logger13.error(`[${context}] Failed to create user`, error);
          logger13.error(`[${context}] User data: ${JSON.stringify({ ...userData, password: "[REDACTED]" })}`);
          logger13.error(`[${context}] Error details: ${error.message}`);
          logger13.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to create user: ${error.message}`);
        }
      }
      /**
       * Update an existing user
       * 
       * @param userId User ID to update
       * @param userData User data to update (partial)
       * @returns Updated user object
       */
      async updateUser(userId, userData) {
        const context = "updateUser";
        try {
          logger13.debug(`[${context}] Updating user with ID: ${userId}`);
          const existingUser = await this.userQueryService.getUserById(userId);
          if (!existingUser) {
            const errorMessage = `User not found with ID: ${userId}`;
            logger13.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          logger13.debug(`[${context}] Updating user in database: ${userId}`);
          return await this.query(async (db4) => {
            const [updatedUser] = await db4.update(users2).set({
              ...userData,
              updated_at: /* @__PURE__ */ new Date()
            }).where(eq3(users2.id, userId)).returning();
            logger13.info(`[${context}] User updated successfully with ID: ${updatedUser.id}`);
            logger13.debug(`[${context}] Updated user details: username=${updatedUser.username}`);
            return updatedUser;
          }, context);
        } catch (error) {
          logger13.error(`[${context}] Failed to update user with ID: ${userId}`, error);
          logger13.error(`[${context}] Update data: ${JSON.stringify({ ...userData, password: userData.password ? "[REDACTED]" : void 0 })}`);
          logger13.error(`[${context}] Error details: ${error.message}`);
          logger13.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to update user: ${error.message}`);
        }
      }
      /**
       * Update user's password
       * 
       * @param userId User ID
       * @param hashedPassword Already hashed password
       * @returns Updated user
       */
      async updatePassword(userId, hashedPassword) {
        const context = "updatePassword";
        try {
          logger13.debug(`[${context}] Updating password for user with ID: ${userId}`);
          const updatedUser = await this.updateUser(userId, { password: hashedPassword });
          logger13.info(`[${context}] Password updated successfully for user ${userId}`);
          return updatedUser;
        } catch (error) {
          logger13.error(`[${context}] Failed to update password for user with ID: ${userId}`, error);
          logger13.error(`[${context}] Error details: ${error.message}`);
          logger13.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to update password: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/auth-drizzle.service.ts
var logger14, AuthDrizzleService;
var init_auth_drizzle_service = __esm({
  "server/common/drizzle/modules/auth/auth-drizzle.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_user_query_service();
    init_user_mutation_service();
    logger14 = new Logger("AuthDrizzleService");
    AuthDrizzleService = class extends BaseDrizzleService {
      constructor() {
        super();
        this.userQueryService = new UserQueryService();
        this.userMutationService = new UserMutationService();
      }
      /**
       * Get user by username
       * 
       * @param username Username to search for
       * @returns User object or null if not found
       */
      async getUserByUsername(username) {
        const context = "getUserByUsername";
        try {
          logger14.debug(`[${context}] Delegating to UserQueryService`);
          return await this.userQueryService.getUserByUsername(username);
        } catch (error) {
          logger14.error(`[${context}] Error in AuthDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get user by ID
       * 
       * @param userId User ID to search for
       * @returns User object or null if not found
       */
      async getUserById(userId) {
        const context = "getUserById";
        try {
          logger14.debug(`[${context}] Delegating to UserQueryService`);
          return await this.userQueryService.getUserById(userId);
        } catch (error) {
          logger14.error(`[${context}] Error in AuthDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Create a new user
       * 
       * @param userData User data to insert with hashed password
       * @returns Created user object
       */
      async createUser(userData) {
        const context = "createUser";
        try {
          logger14.debug(`[${context}] Delegating to UserMutationService`);
          return await this.userMutationService.createUser(userData);
        } catch (error) {
          logger14.error(`[${context}] Error in AuthDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Update an existing user
       * 
       * @param userId User ID to update
       * @param userData User data to update (partial)
       * @returns Updated user object
       */
      async updateUser(userId, userData) {
        const context = "updateUser";
        try {
          logger14.debug(`[${context}] Delegating to UserMutationService`);
          return await this.userMutationService.updateUser(userId, userData);
        } catch (error) {
          logger14.error(`[${context}] Error in AuthDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Update user's password
       * 
       * @param userId User ID
       * @param hashedPassword Already hashed password
       * @returns Updated user
       */
      async updatePassword(userId, hashedPassword) {
        const context = "updatePassword";
        try {
          logger14.debug(`[${context}] Delegating to UserMutationService`);
          return await this.userMutationService.updatePassword(userId, hashedPassword);
        } catch (error) {
          logger14.error(`[${context}] Error in AuthDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get all users with optional filtering
       * 
       * @param options Filter options
       * @returns Array of users
       */
      async getUsers(options = {}) {
        const context = "getUsers";
        try {
          logger14.debug(`[${context}] Delegating to UserQueryService`);
          return await this.userQueryService.getUsers(options);
        } catch (error) {
          logger14.error(`[${context}] Error in AuthDrizzleService wrapper`, error);
          throw error;
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/roles/role-query.service.ts
import { eq as eq4, and as and4 } from "drizzle-orm";
var logger15, RoleQueryService;
var init_role_query_service = __esm({
  "server/common/drizzle/modules/auth/roles/role-query.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_admin_schema();
    logger15 = new Logger("RoleQueryService");
    RoleQueryService = class extends BaseDrizzleService {
      /**
       * Get all roles, optionally filtered by company ID
       * 
       * @param companyId Optional company ID filter
       * @returns Array of roles
       */
      async getRoles(companyId) {
        const context = "getRoles";
        try {
          logger15.debug(`[${context}] Getting roles${companyId ? ` for company ${companyId}` : ""}`);
          return await this.query(async (db4) => {
            logger15.debug(`[${context}] Building query${companyId ? ` with company filter: ${companyId}` : ""}`);
            let query = db4.select().from(roles2);
            if (companyId) {
              query = query.where(eq4(roles2.company_id, companyId));
            }
            const result = await query;
            logger15.debug(`[${context}] Retrieved ${result.length} roles`);
            return result;
          }, context);
        } catch (error) {
          logger15.error(`[${context}] Failed to get roles${companyId ? ` for company ${companyId}` : ""}`, error);
          logger15.error(`[${context}] Error details: ${error.message}`);
          logger15.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve roles: ${error.message}`);
        }
      }
      /**
       * Get a role by ID
       * 
       * @param roleId Role ID
       * @returns Role object or null if not found
       */
      async getRoleById(roleId) {
        const context = "getRoleById";
        try {
          logger15.debug(`[${context}] Getting role by ID: ${roleId}`);
          return await this.query(async (db4) => {
            logger15.debug(`[${context}] Preparing query for role ID: ${roleId}`);
            const result = await db4.select().from(roles2).where(eq4(roles2.id, roleId)).limit(1);
            if (!result || result.length === 0) {
              logger15.debug(`[${context}] No role found with ID: ${roleId}`);
              return null;
            }
            logger15.debug(`[${context}] Role found with ID: ${roleId}, name: ${result[0].name}`);
            return result[0];
          }, context);
        } catch (error) {
          logger15.error(`[${context}] Failed to get role by ID: ${roleId}`, error);
          logger15.error(`[${context}] Error details: ${error.message}`);
          logger15.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve role: ${error.message}`);
        }
      }
      /**
       * Get a role by name and company ID
       * 
       * @param name Role name
       * @param companyId Company ID
       * @returns Role object or null if not found
       */
      async getRoleByName(name, companyId) {
        const context = "getRoleByName";
        try {
          logger15.debug(`[${context}] Getting role by name: ${name} for company: ${companyId}`);
          return await this.query(async (db4) => {
            logger15.debug(`[${context}] Preparing query for role name: ${name}, company: ${companyId}`);
            const result = await db4.select().from(roles2).where(
              and4(
                eq4(roles2.name, name),
                eq4(roles2.company_id, companyId)
              )
            ).limit(1);
            if (!result || result.length === 0) {
              logger15.debug(`[${context}] No role found with name: ${name} for company: ${companyId}`);
              return null;
            }
            logger15.debug(`[${context}] Role found with name: ${name}, ID: ${result[0].id}`);
            return result[0];
          }, context);
        } catch (error) {
          logger15.error(`[${context}] Failed to get role by name: ${name} for company: ${companyId}`, error);
          logger15.error(`[${context}] Error details: ${error.message}`);
          logger15.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve role by name: ${error.message}`);
        }
      }
      /**
       * Get all roles assigned to a user
       * 
       * @param userId User ID
       * @returns Array of roles
       */
      async getUserRoles(userId) {
        const context = "getUserRoles";
        try {
          logger15.debug(`[${context}] Getting roles for user with ID: ${userId}`);
          return await this.query(async (db4) => {
            logger15.debug(`[${context}] Preparing join query for user roles: ${userId}`);
            const result = await db4.select({
              id: roles2.id,
              name: roles2.name,
              description: roles2.description,
              company_id: roles2.company_id,
              is_system: roles2.is_system,
              created_at: roles2.created_at,
              updated_at: roles2.updated_at
            }).from(userRoles2).innerJoin(roles2, eq4(userRoles2.role_id, roles2.id)).where(eq4(userRoles2.user_id, userId));
            logger15.debug(`[${context}] Retrieved ${result.length} roles for user ${userId}`);
            return result;
          }, context);
        } catch (error) {
          logger15.error(`[${context}] Failed to get roles for user with ID: ${userId}`, error);
          logger15.error(`[${context}] Error details: ${error.message}`);
          logger15.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve user roles: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/roles/role-mutation.service.ts
import { eq as eq5 } from "drizzle-orm";
var logger16, RoleMutationService;
var init_role_mutation_service = __esm({
  "server/common/drizzle/modules/auth/roles/role-mutation.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_admin_schema();
    init_role_query_service();
    logger16 = new Logger("RoleMutationService");
    RoleMutationService = class extends BaseDrizzleService {
      constructor() {
        super();
        this.roleQueryService = new RoleQueryService();
      }
      /**
       * Create a new role
       * 
       * @param roleData Role data
       * @returns Created role
       */
      async createRole(roleData) {
        const context = "createRole";
        try {
          if (!roleData.name || !roleData.company_id) {
            const errorMessage = "Role name and company_id are required";
            logger16.error(`[${context}] Validation error: ${errorMessage}`);
            throw new Error(errorMessage);
          }
          logger16.debug(`[${context}] Creating new role: ${roleData.name} for company: ${roleData.company_id}`);
          const existingRole = await this.roleQueryService.getRoleByName(roleData.name, roleData.company_id);
          if (existingRole) {
            const errorMessage = `Role with name ${roleData.name} already exists for company ${roleData.company_id}`;
            logger16.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          logger16.debug(`[${context}] Inserting role into database`);
          return await this.query(async (db4) => {
            const [newRole] = await db4.insert(roles2).values({
              ...roleData,
              created_at: /* @__PURE__ */ new Date(),
              updated_at: /* @__PURE__ */ new Date()
            }).returning();
            logger16.info(`[${context}] Role created successfully with ID: ${newRole.id}`);
            logger16.debug(`[${context}] Created role details: name=${newRole.name}, company=${newRole.company_id}`);
            return newRole;
          }, context);
        } catch (error) {
          logger16.error(`[${context}] Failed to create role`, error);
          logger16.error(`[${context}] Role data: ${JSON.stringify(roleData)}`);
          logger16.error(`[${context}] Error details: ${error.message}`);
          logger16.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to create role: ${error.message}`);
        }
      }
      /**
       * Update an existing role
       * 
       * @param roleId Role ID
       * @param roleData Role data to update
       * @returns Updated role
       */
      async updateRole(roleId, roleData) {
        const context = "updateRole";
        try {
          logger16.debug(`[${context}] Updating role with ID: ${roleId}`);
          const existingRole = await this.roleQueryService.getRoleById(roleId);
          if (!existingRole) {
            const errorMessage = `Role not found with ID: ${roleId}`;
            logger16.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          if (roleData.name && roleData.name !== existingRole.name) {
            logger16.debug(`[${context}] Checking for duplicate role name: ${roleData.name}`);
            const duplicateRole = await this.roleQueryService.getRoleByName(
              roleData.name,
              roleData.company_id || existingRole.company_id
            );
            if (duplicateRole && duplicateRole.id !== roleId) {
              const errorMessage = `Role with name ${roleData.name} already exists for this company`;
              logger16.warn(`[${context}] ${errorMessage}`);
              throw new Error(errorMessage);
            }
          }
          logger16.debug(`[${context}] Updating role in database: ${roleId}`);
          return await this.query(async (db4) => {
            const [updatedRole] = await db4.update(roles2).set({
              ...roleData,
              updated_at: /* @__PURE__ */ new Date()
            }).where(eq5(roles2.id, roleId)).returning();
            logger16.info(`[${context}] Role updated successfully with ID: ${updatedRole.id}`);
            logger16.debug(`[${context}] Updated role details: name=${updatedRole.name}`);
            return updatedRole;
          }, context);
        } catch (error) {
          logger16.error(`[${context}] Failed to update role with ID: ${roleId}`, error);
          logger16.error(`[${context}] Update data: ${JSON.stringify(roleData)}`);
          logger16.error(`[${context}] Error details: ${error.message}`);
          logger16.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to update role: ${error.message}`);
        }
      }
      /**
       * Delete a role
       * 
       * @param roleId Role ID
       * @returns Success indicator
       */
      async deleteRole(roleId) {
        const context = "deleteRole";
        try {
          logger16.debug(`[${context}] Deleting role with ID: ${roleId}`);
          const existingRole = await this.roleQueryService.getRoleById(roleId);
          if (!existingRole) {
            const errorMessage = `Role not found with ID: ${roleId}`;
            logger16.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          return await this.transaction(async (tx) => {
            logger16.debug(`[${context}] Removing all user associations for role: ${roleId}`);
            await tx.delete(userRoles2).where(eq5(userRoles2.role_id, roleId));
            logger16.debug(`[${context}] Deleting role from database: ${roleId}`);
            const deleteResult = await tx.delete(roles2).where(eq5(roles2.id, roleId)).returning({ id: roles2.id });
            const success = deleteResult.length > 0;
            if (success) {
              logger16.info(`[${context}] Role deleted successfully with ID: ${roleId}`);
            } else {
              logger16.warn(`[${context}] No role was deleted with ID: ${roleId}`);
            }
            return success;
          }, context);
        } catch (error) {
          logger16.error(`[${context}] Failed to delete role with ID: ${roleId}`, error);
          logger16.error(`[${context}] Error details: ${error.message}`);
          logger16.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to delete role: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/roles/user-role.service.ts
import { eq as eq6, and as and6 } from "drizzle-orm";
var logger17, UserRoleService;
var init_user_role_service = __esm({
  "server/common/drizzle/modules/auth/roles/user-role.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_admin_schema();
    init_user_query_service();
    init_role_query_service();
    logger17 = new Logger("UserRoleService");
    UserRoleService = class extends BaseDrizzleService {
      constructor() {
        super();
        this.userQueryService = new UserQueryService();
        this.roleQueryService = new RoleQueryService();
      }
      /**
       * Assign a role to a user
       * 
       * @param userId User ID
       * @param roleId Role ID
       */
      async assignRoleToUser(userId, roleId) {
        const context = "assignRoleToUser";
        try {
          logger17.debug(`[${context}] Assigning role ${roleId} to user ${userId}`);
          const user = await this.userQueryService.getUserById(userId);
          if (!user) {
            const errorMessage = `User not found with ID: ${userId}`;
            logger17.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          const role = await this.roleQueryService.getRoleById(roleId);
          if (!role) {
            const errorMessage = `Role not found with ID: ${roleId}`;
            logger17.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          logger17.debug(`[${context}] Checking if role ${roleId} is already assigned to user ${userId}`);
          const existingAssignment = await this.query(async (db4) => {
            const result = await db4.select().from(userRoles2).where(
              and6(
                eq6(userRoles2.user_id, userId),
                eq6(userRoles2.role_id, roleId)
              )
            ).limit(1);
            return result.length > 0;
          }, context);
          if (existingAssignment) {
            logger17.debug(`[${context}] Role ${roleId} already assigned to user ${userId}`);
            return;
          }
          logger17.debug(`[${context}] Creating new role assignment in database`);
          await this.query(async (db4) => {
            await db4.insert(userRoles2).values({
              user_id: userId,
              role_id: roleId
            });
            logger17.info(`[${context}] Role ${roleId} assigned to user ${userId}`);
          }, context);
        } catch (error) {
          logger17.error(`[${context}] Failed to assign role ${roleId} to user ${userId}`, error);
          logger17.error(`[${context}] Error details: ${error.message}`);
          logger17.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to assign role to user: ${error.message}`);
        }
      }
      /**
       * Remove a role from a user
       * 
       * @param userId User ID
       * @param roleId Role ID
       */
      async removeRoleFromUser(userId, roleId) {
        const context = "removeRoleFromUser";
        try {
          logger17.debug(`[${context}] Removing role ${roleId} from user ${userId}`);
          const hasRole = await this.query(async (db4) => {
            const result = await db4.select().from(userRoles2).where(
              and6(
                eq6(userRoles2.user_id, userId),
                eq6(userRoles2.role_id, roleId)
              )
            ).limit(1);
            return result.length > 0;
          }, context);
          if (!hasRole) {
            logger17.debug(`[${context}] Role ${roleId} is not assigned to user ${userId}`);
            return;
          }
          logger17.debug(`[${context}] Removing role assignment from database`);
          await this.query(async (db4) => {
            await db4.delete(userRoles2).where(
              and6(
                eq6(userRoles2.user_id, userId),
                eq6(userRoles2.role_id, roleId)
              )
            );
            logger17.info(`[${context}] Role ${roleId} removed from user ${userId}`);
          }, context);
        } catch (error) {
          logger17.error(`[${context}] Failed to remove role ${roleId} from user ${userId}`, error);
          logger17.error(`[${context}] Error details: ${error.message}`);
          logger17.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to remove role from user: ${error.message}`);
        }
      }
      /**
       * Get all users assigned to a role
       * 
       * @param roleId Role ID
       * @returns Array of user IDs
       */
      async getRoleUsers(roleId) {
        const context = "getRoleUsers";
        try {
          logger17.debug(`[${context}] Getting users for role with ID: ${roleId}`);
          const role = await this.roleQueryService.getRoleById(roleId);
          if (!role) {
            const errorMessage = `Role not found with ID: ${roleId}`;
            logger17.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          return await this.query(async (db4) => {
            const result = await db4.select({ user_id: userRoles2.user_id }).from(userRoles2).where(eq6(userRoles2.role_id, roleId));
            const userIds = result.map((r) => r.user_id);
            logger17.debug(`[${context}] Retrieved ${userIds.length} users for role ${roleId}`);
            return userIds;
          }, context);
        } catch (error) {
          logger17.error(`[${context}] Failed to get users for role with ID: ${roleId}`, error);
          logger17.error(`[${context}] Error details: ${error.message}`);
          logger17.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve role users: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/permissions/permission-query.service.ts
import { eq as eq7, and as and7 } from "drizzle-orm";
var logger18, PermissionQueryService;
var init_permission_query_service = __esm({
  "server/common/drizzle/modules/auth/permissions/permission-query.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_admin_schema();
    logger18 = new Logger("PermissionQueryService");
    PermissionQueryService = class extends BaseDrizzleService {
      /**
       * Get all permissions
       * 
       * @returns Array of permissions
       */
      async getPermissions() {
        const context = "getPermissions";
        try {
          logger18.debug(`[${context}] Getting all permissions`);
          return await this.query(async (db4) => {
            const result = await db4.select().from(permissions2);
            logger18.debug(`[${context}] Retrieved ${result.length} permissions`);
            return result;
          }, context);
        } catch (error) {
          logger18.error(`[${context}] Failed to get permissions`, error);
          logger18.error(`[${context}] Error details: ${error.message}`);
          logger18.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve permissions: ${error.message}`);
        }
      }
      /**
       * Get permission by ID
       * 
       * @param permissionId Permission ID
       * @returns Permission object or null if not found
       */
      async getPermissionById(permissionId) {
        const context = "getPermissionById";
        try {
          logger18.debug(`[${context}] Getting permission by ID: ${permissionId}`);
          return await this.query(async (db4) => {
            const result = await db4.select().from(permissions2).where(eq7(permissions2.id, permissionId)).limit(1);
            if (!result || result.length === 0) {
              logger18.debug(`[${context}] No permission found with ID: ${permissionId}`);
              return null;
            }
            logger18.debug(`[${context}] Permission found with ID: ${permissionId}`);
            return result[0];
          }, context);
        } catch (error) {
          logger18.error(`[${context}] Failed to get permission by ID: ${permissionId}`, error);
          logger18.error(`[${context}] Error details: ${error.message}`);
          logger18.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve permission: ${error.message}`);
        }
      }
      /**
       * Get permission by resource and action
       * 
       * @param resource Resource name
       * @param action Action name
       * @returns Permission object or null if not found
       */
      async getPermissionByResourceAction(resource, action) {
        const context = "getPermissionByResourceAction";
        try {
          logger18.debug(`[${context}] Getting permission for resource: ${resource}, action: ${action}`);
          return await this.query(async (db4) => {
            const result = await db4.select().from(permissions2).where(
              and7(
                eq7(permissions2.resource, resource),
                eq7(permissions2.action, action)
              )
            ).limit(1);
            if (!result || result.length === 0) {
              logger18.debug(`[${context}] No permission found for resource: ${resource}, action: ${action}`);
              return null;
            }
            logger18.debug(`[${context}] Permission found for resource: ${resource}, action: ${action}`);
            return result[0];
          }, context);
        } catch (error) {
          logger18.error(`[${context}] Failed to get permission for resource: ${resource}, action: ${action}`, error);
          logger18.error(`[${context}] Error details: ${error.message}`);
          logger18.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve permission by resource and action: ${error.message}`);
        }
      }
      /**
       * Get permissions by resource
       * 
       * @param resource Resource name
       * @returns Array of permissions
       */
      async getPermissionsByResource(resource) {
        const context = "getPermissionsByResource";
        try {
          logger18.debug(`[${context}] Getting permissions for resource: ${resource}`);
          return await this.query(async (db4) => {
            const result = await db4.select().from(permissions2).where(eq7(permissions2.resource, resource));
            logger18.debug(`[${context}] Retrieved ${result.length} permissions for resource: ${resource}`);
            return result;
          }, context);
        } catch (error) {
          logger18.error(`[${context}] Failed to get permissions for resource: ${resource}`, error);
          logger18.error(`[${context}] Error details: ${error.message}`);
          logger18.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve permissions by resource: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/permissions/permission-mutation.service.ts
import { eq as eq8 } from "drizzle-orm";
var logger19, PermissionMutationService;
var init_permission_mutation_service = __esm({
  "server/common/drizzle/modules/auth/permissions/permission-mutation.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_admin_schema();
    init_permission_query_service();
    logger19 = new Logger("PermissionMutationService");
    PermissionMutationService = class extends BaseDrizzleService {
      constructor() {
        super();
        this.permissionQueryService = new PermissionQueryService();
      }
      /**
       * Create a new permission
       * 
       * @param permissionData Permission data
       * @returns Created permission
       */
      async createPermission(permissionData) {
        const context = "createPermission";
        try {
          if (!permissionData.name || !permissionData.resource || !permissionData.action) {
            const errorMessage = "Permission name, resource, and action are required";
            logger19.error(`[${context}] Validation error: ${errorMessage}`);
            throw new Error(errorMessage);
          }
          logger19.debug(`[${context}] Creating new permission: ${permissionData.name} for resource: ${permissionData.resource}, action: ${permissionData.action}`);
          const existingPermission = await this.permissionQueryService.getPermissionByResourceAction(
            permissionData.resource,
            permissionData.action
          );
          if (existingPermission) {
            const errorMessage = `Permission already exists for resource: ${permissionData.resource}, action: ${permissionData.action}`;
            logger19.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          logger19.debug(`[${context}] Inserting permission into database`);
          return await this.query(async (db4) => {
            const [newPermission] = await db4.insert(permissions2).values({
              ...permissionData,
              created_at: /* @__PURE__ */ new Date(),
              updated_at: /* @__PURE__ */ new Date()
            }).returning();
            logger19.info(`[${context}] Permission created successfully with ID: ${newPermission.id}`);
            logger19.debug(`[${context}] Created permission details: name=${newPermission.name}, resource=${newPermission.resource}, action=${newPermission.action}`);
            return newPermission;
          }, context);
        } catch (error) {
          logger19.error(`[${context}] Failed to create permission`, error);
          logger19.error(`[${context}] Permission data: ${JSON.stringify(permissionData)}`);
          logger19.error(`[${context}] Error details: ${error.message}`);
          logger19.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to create permission: ${error.message}`);
        }
      }
      /**
       * Update an existing permission
       * 
       * @param permissionId Permission ID
       * @param permissionData Permission data to update
       * @returns Updated permission
       */
      async updatePermission(permissionId, permissionData) {
        const context = "updatePermission";
        try {
          logger19.debug(`[${context}] Updating permission with ID: ${permissionId}`);
          const existingPermission = await this.permissionQueryService.getPermissionById(permissionId);
          if (!existingPermission) {
            const errorMessage = `Permission not found with ID: ${permissionId}`;
            logger19.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          if (permissionData.resource && permissionData.action && (permissionData.resource !== existingPermission.resource || permissionData.action !== existingPermission.action)) {
            logger19.debug(`[${context}] Checking for duplicate permission: resource=${permissionData.resource}, action=${permissionData.action}`);
            const duplicatePermission = await this.permissionQueryService.getPermissionByResourceAction(
              permissionData.resource,
              permissionData.action
            );
            if (duplicatePermission && duplicatePermission.id !== permissionId) {
              const errorMessage = `Permission already exists for resource: ${permissionData.resource}, action: ${permissionData.action}`;
              logger19.warn(`[${context}] ${errorMessage}`);
              throw new Error(errorMessage);
            }
          }
          logger19.debug(`[${context}] Updating permission in database: ${permissionId}`);
          return await this.query(async (db4) => {
            const [updatedPermission] = await db4.update(permissions2).set({
              ...permissionData,
              updated_at: /* @__PURE__ */ new Date()
            }).where(eq8(permissions2.id, permissionId)).returning();
            logger19.info(`[${context}] Permission updated successfully with ID: ${updatedPermission.id}`);
            logger19.debug(`[${context}] Updated permission details: name=${updatedPermission.name}, resource=${updatedPermission.resource}, action=${updatedPermission.action}`);
            return updatedPermission;
          }, context);
        } catch (error) {
          logger19.error(`[${context}] Failed to update permission with ID: ${permissionId}`, error);
          logger19.error(`[${context}] Update data: ${JSON.stringify(permissionData)}`);
          logger19.error(`[${context}] Error details: ${error.message}`);
          logger19.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to update permission: ${error.message}`);
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/permissions/role-permission.service.ts
import { eq as eq9, and as and9, sql as sql11 } from "drizzle-orm";
var logger20, RolePermissionService;
var init_role_permission_service = __esm({
  "server/common/drizzle/modules/auth/permissions/role-permission.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_admin_schema();
    init_role_query_service();
    init_permission_query_service();
    logger20 = new Logger("RolePermissionService");
    RolePermissionService = class extends BaseDrizzleService {
      constructor() {
        super();
        this.roleQueryService = new RoleQueryService();
        this.permissionQueryService = new PermissionQueryService();
      }
      /**
       * Get all permissions assigned to a role
       * 
       * @param roleId Role ID
       * @returns Array of permissions
       */
      async getRolePermissions(roleId) {
        const context = "getRolePermissions";
        try {
          logger20.debug(`[${context}] Getting permissions for role with ID: ${roleId}`);
          const role = await this.roleQueryService.getRoleById(roleId);
          if (!role) {
            const errorMessage = `Role not found with ID: ${roleId}`;
            logger20.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          logger20.debug(`[${context}] Preparing join query for role permissions: ${roleId}`);
          return await this.query(async (db4) => {
            const result = await db4.select({
              id: permissions2.id,
              name: permissions2.name,
              description: permissions2.description,
              resource: permissions2.resource,
              action: permissions2.action,
              created_at: permissions2.created_at,
              updated_at: permissions2.updated_at
            }).from(rolePermissions2).innerJoin(permissions2, eq9(rolePermissions2.permission_id, permissions2.id)).where(eq9(rolePermissions2.role_id, roleId));
            logger20.debug(`[${context}] Retrieved ${result.length} permissions for role ${roleId}`);
            return result;
          }, context);
        } catch (error) {
          logger20.error(`[${context}] Failed to get permissions for role with ID: ${roleId}`, error);
          logger20.error(`[${context}] Error details: ${error.message}`);
          logger20.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to retrieve role permissions: ${error.message}`);
        }
      }
      /**
       * Assign a permission to a role
       * 
       * @param roleId Role ID
       * @param permissionId Permission ID
       */
      async assignPermissionToRole(roleId, permissionId) {
        const context = "assignPermissionToRole";
        try {
          logger20.debug(`[${context}] Assigning permission ${permissionId} to role ${roleId}`);
          const role = await this.roleQueryService.getRoleById(roleId);
          if (!role) {
            const errorMessage = `Role not found with ID: ${roleId}`;
            logger20.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          const permission = await this.permissionQueryService.getPermissionById(permissionId);
          if (!permission) {
            const errorMessage = `Permission not found with ID: ${permissionId}`;
            logger20.warn(`[${context}] ${errorMessage}`);
            throw new Error(errorMessage);
          }
          logger20.debug(`[${context}] Checking if permission is already assigned to role`);
          const existingAssignment = await this.query(async (db4) => {
            const result = await db4.select().from(rolePermissions2).where(
              and9(
                eq9(rolePermissions2.role_id, roleId),
                eq9(rolePermissions2.permission_id, permissionId)
              )
            ).limit(1);
            return result.length > 0;
          }, context);
          if (existingAssignment) {
            logger20.debug(`[${context}] Permission ${permissionId} already assigned to role ${roleId}`);
            return;
          }
          logger20.debug(`[${context}] Creating new permission assignment in database`);
          await this.query(async (db4) => {
            await db4.insert(rolePermissions2).values({
              role_id: roleId,
              permission_id: permissionId
            });
            logger20.info(`[${context}] Permission ${permissionId} assigned to role ${roleId}`);
          }, context);
        } catch (error) {
          logger20.error(`[${context}] Failed to assign permission ${permissionId} to role ${roleId}`, error);
          logger20.error(`[${context}] Error details: ${error.message}`);
          logger20.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to assign permission to role: ${error.message}`);
        }
      }
      /**
       * Remove a permission from a role
       * 
       * @param roleId Role ID
       * @param permissionId Permission ID
       */
      async removePermissionFromRole(roleId, permissionId) {
        const context = "removePermissionFromRole";
        try {
          logger20.debug(`[${context}] Removing permission ${permissionId} from role ${roleId}`);
          const hasPermission = await this.query(async (db4) => {
            const result = await db4.select().from(rolePermissions2).where(
              and9(
                eq9(rolePermissions2.role_id, roleId),
                eq9(rolePermissions2.permission_id, permissionId)
              )
            ).limit(1);
            return result.length > 0;
          }, context);
          if (!hasPermission) {
            logger20.debug(`[${context}] Permission ${permissionId} is not assigned to role ${roleId}`);
            return;
          }
          logger20.debug(`[${context}] Removing permission assignment from database`);
          await this.query(async (db4) => {
            await db4.delete(rolePermissions2).where(
              and9(
                eq9(rolePermissions2.role_id, roleId),
                eq9(rolePermissions2.permission_id, permissionId)
              )
            );
            logger20.info(`[${context}] Permission ${permissionId} removed from role ${roleId}`);
          }, context);
        } catch (error) {
          logger20.error(`[${context}] Failed to remove permission ${permissionId} from role ${roleId}`, error);
          logger20.error(`[${context}] Error details: ${error.message}`);
          logger20.error(`[${context}] Stack trace: ${error.stack}`);
          throw new Error(`Failed to remove permission from role: ${error.message}`);
        }
      }
      /**
       * Check if a user has a specific permission
       * 
       * @param userId User ID
       * @param resource Resource name
       * @param action Action name (read, write, etc.)
       * @returns Boolean indicating whether the user has the permission
       */
      async hasPermission(userId, resource, action) {
        const context = "hasPermission";
        try {
          logger20.debug(`[${context}] Checking if user ${userId} has permission ${action} on ${resource}`);
          return await this.query(async (db4) => {
            const result = await db4.select({ count: sql11`count(*)` }).from(userRoles2).innerJoin(rolePermissions2, eq9(userRoles2.role_id, rolePermissions2.role_id)).innerJoin(permissions2, eq9(rolePermissions2.permission_id, permissions2.id)).where(
              and9(
                eq9(userRoles2.user_id, userId),
                eq9(permissions2.resource, resource),
                eq9(permissions2.action, action)
              )
            );
            const hasPermission = result[0].count > 0;
            logger20.debug(`[${context}] User ${userId} ${hasPermission ? "has" : "does not have"} permission ${action} on ${resource}`);
            return hasPermission;
          }, context);
        } catch (error) {
          logger20.error(`[${context}] Failed to check permission for user ${userId}`, error);
          logger20.error(`[${context}] Resource: ${resource}, Action: ${action}`);
          logger20.error(`[${context}] Error details: ${error.message}`);
          logger20.error(`[${context}] Stack trace: ${error.stack}`);
          return false;
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/rbac-drizzle.service.ts
var logger21, RbacDrizzleService;
var init_rbac_drizzle_service = __esm({
  "server/common/drizzle/modules/auth/rbac-drizzle.service.ts"() {
    "use strict";
    init_logger();
    init_base_drizzle_service();
    init_role_query_service();
    init_role_mutation_service();
    init_user_role_service();
    init_permission_query_service();
    init_permission_mutation_service();
    init_role_permission_service();
    logger21 = new Logger("RbacDrizzleService");
    RbacDrizzleService = class extends BaseDrizzleService {
      constructor() {
        super();
        this.roleQueryService = new RoleQueryService();
        this.roleMutationService = new RoleMutationService();
        this.userRoleService = new UserRoleService();
        this.permissionQueryService = new PermissionQueryService();
        this.permissionMutationService = new PermissionMutationService();
        this.rolePermissionService = new RolePermissionService();
      }
      /**
       * Get all roles, optionally filtered by company ID
       * 
       * @param companyId Optional company ID filter
       * @returns Array of roles
       */
      async getRoles(companyId) {
        const context = "getRoles";
        try {
          logger21.debug(`[${context}] Delegating to RoleQueryService`);
          return await this.roleQueryService.getRoles(companyId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get a role by ID
       * 
       * @param roleId Role ID
       * @returns Role object or null if not found
       */
      async getRoleById(roleId) {
        const context = "getRoleById";
        try {
          logger21.debug(`[${context}] Delegating to RoleQueryService`);
          return await this.roleQueryService.getRoleById(roleId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get a role by name and company ID
       * 
       * @param name Role name
       * @param companyId Company ID
       * @returns Role object or null if not found
       */
      async getRoleByName(name, companyId) {
        const context = "getRoleByName";
        try {
          logger21.debug(`[${context}] Delegating to RoleQueryService`);
          return await this.roleQueryService.getRoleByName(name, companyId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Create a new role
       * 
       * @param roleData Role data
       * @returns Created role
       */
      async createRole(roleData) {
        const context = "createRole";
        try {
          logger21.debug(`[${context}] Delegating to RoleMutationService`);
          return await this.roleMutationService.createRole(roleData);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get all permissions
       * 
       * @returns Array of permissions
       */
      async getPermissions() {
        const context = "getPermissions";
        try {
          logger21.debug(`[${context}] Delegating to PermissionQueryService`);
          return await this.permissionQueryService.getPermissions();
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get permission by ID
       * 
       * @param permissionId Permission ID
       * @returns Permission object or null if not found
       */
      async getPermissionById(permissionId) {
        const context = "getPermissionById";
        try {
          logger21.debug(`[${context}] Delegating to PermissionQueryService`);
          return await this.permissionQueryService.getPermissionById(permissionId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get all roles assigned to a user
       * 
       * @param userId User ID
       * @returns Array of roles
       */
      async getUserRoles(userId) {
        const context = "getUserRoles";
        try {
          logger21.debug(`[${context}] Delegating to RoleQueryService`);
          return await this.roleQueryService.getUserRoles(userId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Assign a role to a user
       * 
       * @param userId User ID
       * @param roleId Role ID
       */
      async assignRoleToUser(userId, roleId) {
        const context = "assignRoleToUser";
        try {
          logger21.debug(`[${context}] Delegating to UserRoleService`);
          return await this.userRoleService.assignRoleToUser(userId, roleId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Remove a role from a user
       * 
       * @param userId User ID
       * @param roleId Role ID
       */
      async removeRoleFromUser(userId, roleId) {
        const context = "removeRoleFromUser";
        try {
          logger21.debug(`[${context}] Delegating to UserRoleService`);
          return await this.userRoleService.removeRoleFromUser(userId, roleId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Get all permissions assigned to a role
       * 
       * @param roleId Role ID
       * @returns Array of permissions
       */
      async getRolePermissions(roleId) {
        const context = "getRolePermissions";
        try {
          logger21.debug(`[${context}] Delegating to RolePermissionService`);
          return await this.rolePermissionService.getRolePermissions(roleId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Assign a permission to a role
       * 
       * @param roleId Role ID
       * @param permissionId Permission ID
       */
      async assignPermissionToRole(roleId, permissionId) {
        const context = "assignPermissionToRole";
        try {
          logger21.debug(`[${context}] Delegating to RolePermissionService`);
          return await this.rolePermissionService.assignPermissionToRole(roleId, permissionId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Remove a permission from a role
       * 
       * @param roleId Role ID
       * @param permissionId Permission ID
       */
      async removePermissionFromRole(roleId, permissionId) {
        const context = "removePermissionFromRole";
        try {
          logger21.debug(`[${context}] Delegating to RolePermissionService`);
          return await this.rolePermissionService.removePermissionFromRole(roleId, permissionId);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          throw error;
        }
      }
      /**
       * Check if a user has a specific permission
       * 
       * @param userId User ID
       * @param resource Resource name
       * @param action Action name (read, write, etc.)
       * @returns Boolean indicating whether the user has the permission
       */
      async hasPermission(userId, resource, action) {
        const context = "hasPermission";
        try {
          logger21.debug(`[${context}] Delegating to RolePermissionService`);
          return await this.rolePermissionService.hasPermission(userId, resource, action);
        } catch (error) {
          logger21.error(`[${context}] Error in RbacDrizzleService wrapper`, error);
          return false;
        }
      }
    };
  }
});

// server/common/drizzle/modules/auth/index.ts
var init_auth = __esm({
  "server/common/drizzle/modules/auth/index.ts"() {
    "use strict";
    init_auth_drizzle_service();
    init_rbac_drizzle_service();
  }
});

// server/common/drizzle/modules/collab/thread-service.ts
import { eq as eq10, and as and10, desc, sql as sql12, or as or5, like } from "drizzle-orm";
import { randomUUID as randomUUID2 } from "crypto";
var logger22, ThreadDrizzleService;
var init_thread_service = __esm({
  "server/common/drizzle/modules/collab/thread-service.ts"() {
    "use strict";
    init_base_drizzle_service();
    init_collaboration_schema();
    init_logger();
    logger22 = new Logger("ThreadDrizzleService");
    ThreadDrizzleService = class extends BaseDrizzleService {
      /**
       * Create a new discussion thread
       * 
       * @param thread Thread data
       * @param userId User ID creating the thread
       * @returns Created thread
       */
      async createThread(thread, userId) {
        const context = "createThread";
        try {
          logger22.debug(`[${context}] Creating new thread "${thread.title}" by user ${userId}`);
          const threadId = thread.id || randomUUID2();
          const now = /* @__PURE__ */ new Date();
          return await this.query(async (db4) => {
            const createdThreads = await db4.insert(collaborationThreads).values({
              ...thread,
              id: threadId,
              createdBy: userId,
              createdAt: now,
              updatedAt: now,
              lastMessageAt: now
            }).returning();
            if (createdThreads.length === 0) {
              const error = new Error("Failed to create thread");
              logger22.error(`[${context}] ${error.message} for title "${thread.title}"`);
              throw error;
            }
            logger22.info(`[${context}] Thread ${threadId} created successfully with title "${thread.title}"`);
            return createdThreads[0];
          });
        } catch (error) {
          logger22.error(`[${context}] Error creating thread: ${error instanceof Error ? error.message : String(error)}`);
          logger22.error(`[${context}] Thread details: ${JSON.stringify({ ...thread, title: thread.title })}`);
          throw error;
        }
      }
      /**
       * Get a thread by ID
       * 
       * @param threadId Thread ID
       * @param companyId Company ID
       * @returns Thread or null if not found
       */
      async getThreadById(threadId, companyId) {
        const context = "getThreadById";
        try {
          logger22.debug(`[${context}] Fetching thread ${threadId} for company ${companyId}`);
          return await this.query(async (db4) => {
            const threads = await db4.select().from(collaborationThreads).where(and10(
              eq10(collaborationThreads.id, threadId),
              eq10(collaborationThreads.companyId, companyId)
            ));
            const thread = threads.length > 0 ? threads[0] : null;
            if (thread) {
              logger22.info(`[${context}] Found thread ${threadId} with title "${thread.title}"`);
            } else {
              logger22.info(`[${context}] Thread ${threadId} not found for company ${companyId}`);
            }
            return thread;
          });
        } catch (error) {
          logger22.error(`[${context}] Error fetching thread ${threadId} for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Get threads for a company
       * 
       * @param companyId Company ID
       * @param options Query options (limit, offset, search, category)
       * @returns List of threads and total count
       */
      async getThreads(companyId, options = {}) {
        const context = "getThreads";
        try {
          const {
            limit = 10,
            offset = 0,
            search,
            category,
            isPrivate,
            isClosed,
            sort = "newest",
            tags: tags2 = []
          } = options;
          logger22.debug(`[${context}] Fetching threads for company ${companyId} with options:`, options);
          return await this.query(async (db4) => {
            let conditions = [
              eq10(collaborationThreads.companyId, companyId)
            ];
            if (search) {
              conditions.push(
                or5(
                  like(collaborationThreads.title, `%${search}%`),
                  like(collaborationThreads.description, `%${search}%`)
                )
              );
            }
            if (category) {
              conditions.push(eq10(collaborationThreads.category, category));
            }
            if (isPrivate !== void 0) {
              conditions.push(eq10(collaborationThreads.isPrivate, isPrivate));
            }
            if (isClosed !== void 0) {
              conditions.push(eq10(collaborationThreads.isClosed, isClosed));
            }
            const whereCondition = and10(...conditions);
            let orderByClause;
            switch (sort) {
              case "newest":
                orderByClause = desc(collaborationThreads.createdAt);
                break;
              case "oldest":
                orderByClause = collaborationThreads.createdAt;
                break;
              case "lastActivity":
                orderByClause = desc(collaborationThreads.lastMessageAt);
                break;
              default:
                orderByClause = desc(collaborationThreads.createdAt);
            }
            const threadsResult = await db4.select().from(collaborationThreads).where(whereCondition).orderBy(orderByClause).limit(limit).offset(offset);
            let filteredThreads = threadsResult;
            if (tags2.length > 0) {
              filteredThreads = threadsResult.filter((thread) => {
                const threadTags = thread.tags || [];
                return tags2.some((tag) => threadTags.includes(tag));
              });
            }
            const totalResult = await db4.select({
              count: sql12`count(*)`
            }).from(collaborationThreads).where(whereCondition);
            const total = Number(totalResult[0]?.count || 0);
            logger22.info(`[${context}] Found ${filteredThreads.length} threads for company ${companyId}, total: ${total}`);
            return {
              threads: filteredThreads,
              total
            };
          });
        } catch (error) {
          logger22.error(`[${context}] Error fetching threads for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
          logger22.error(`[${context}] Query options: ${JSON.stringify(options)}`);
          throw error;
        }
      }
      /**
       * Update a thread
       * 
       * @param threadId Thread ID
       * @param companyId Company ID
       * @param updates Thread updates
       * @param userId User ID making the update
       * @returns Updated thread
       */
      async updateThread(threadId, companyId, updates, userId) {
        const context = "updateThread";
        try {
          logger22.debug(`[${context}] Updating thread ${threadId} for company ${companyId} by user ${userId}`);
          logger22.debug(`[${context}] Update fields: ${Object.keys(updates).join(", ")}`);
          return await this.query(async (db4) => {
            const updatedThreads = await db4.update(collaborationThreads).set({
              ...updates,
              updatedAt: /* @__PURE__ */ new Date(),
              updatedBy: userId
            }).where(and10(
              eq10(collaborationThreads.id, threadId),
              eq10(collaborationThreads.companyId, companyId)
            )).returning();
            if (updatedThreads.length === 0) {
              const error = new Error(`Thread not found: ${threadId}`);
              logger22.error(`[${context}] ${error.message} for company ${companyId}`);
              throw error;
            }
            logger22.info(`[${context}] Thread ${threadId} updated successfully by user ${userId}`);
            return updatedThreads[0];
          });
        } catch (error) {
          logger22.error(`[${context}] Error updating thread ${threadId} for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Delete a thread
       * 
       * @param threadId Thread ID
       * @param companyId Company ID
       * @returns True if deleted
       */
      async deleteThread(threadId, companyId) {
        const context = "deleteThread";
        try {
          logger22.debug(`[${context}] Deleting thread ${threadId} for company ${companyId}`);
          return await this.transaction(async (tx) => {
            await tx.delete(collaborationMessages).where(and10(
              eq10(collaborationMessages.threadId, threadId),
              eq10(collaborationMessages.companyId, companyId)
            ));
            const result = await tx.delete(collaborationThreads).where(and10(
              eq10(collaborationThreads.id, threadId),
              eq10(collaborationThreads.companyId, companyId)
            )).returning();
            const deleted = result.length > 0;
            if (deleted) {
              logger22.info(`[${context}] Thread ${threadId} and all its messages deleted successfully for company ${companyId}`);
            } else {
              logger22.info(`[${context}] No thread with ID ${threadId} found to delete for company ${companyId}`);
            }
            return deleted;
          });
        } catch (error) {
          logger22.error(`[${context}] Error deleting thread ${threadId} for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Update the last message timestamp for a thread
       * 
       * @param threadId Thread ID
       * @param companyId Company ID
       * @returns Success flag
       */
      async updateLastMessageTimestamp(threadId, companyId) {
        const context = "updateLastMessageTimestamp";
        try {
          logger22.debug(`[${context}] Updating last message timestamp for thread ${threadId}`);
          return await this.query(async (db4) => {
            const now = /* @__PURE__ */ new Date();
            const result = await db4.update(collaborationThreads).set({
              lastMessageAt: now,
              updatedAt: now
            }).where(and10(
              eq10(collaborationThreads.id, threadId),
              eq10(collaborationThreads.companyId, companyId)
            )).returning();
            const success = result.length > 0;
            if (success) {
              logger22.info(`[${context}] Last message timestamp updated successfully for thread ${threadId}`);
            } else {
              logger22.warn(`[${context}] Failed to update last message timestamp: Thread not found with ID ${threadId}`);
            }
            return success;
          });
        } catch (error) {
          logger22.error(`[${context}] Error updating last message timestamp for thread ${threadId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Get message count for a thread
       * 
       * @param threadId Thread ID
       * @param companyId Company ID
       * @returns Message count
       */
      async getMessageCount(threadId, companyId) {
        const context = "getMessageCount";
        try {
          logger22.debug(`[${context}] Counting messages for thread ${threadId} in company ${companyId}`);
          return await this.query(async (db4) => {
            const result = await db4.select({
              count: sql12`count(*)`
            }).from(collaborationMessages).where(and10(
              eq10(collaborationMessages.threadId, threadId),
              eq10(collaborationMessages.companyId, companyId)
            ));
            const count5 = Number(result[0]?.count || 0);
            logger22.info(`[${context}] Thread ${threadId} has ${count5} messages`);
            return count5;
          });
        } catch (error) {
          logger22.error(`[${context}] Error counting messages for thread ${threadId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Add a participant to a thread
       * 
       * @param threadId Thread ID
       * @param companyId Company ID
       * @param userId User ID to add as participant
       * @returns Updated thread
       */
      async addParticipant(threadId, companyId, userId) {
        const context = "addParticipant";
        try {
          logger22.debug(`[${context}] Adding user ${userId} as participant to thread ${threadId}`);
          return await this.query(async (db4) => {
            const threads = await db4.select().from(collaborationThreads).where(and10(
              eq10(collaborationThreads.id, threadId),
              eq10(collaborationThreads.companyId, companyId)
            ));
            if (threads.length === 0) {
              const error = new Error(`Thread not found: ${threadId}`);
              logger22.error(`[${context}] ${error.message} for company ${companyId}`);
              throw error;
            }
            const thread = threads[0];
            const participants = thread.participants || [];
            if (!participants.includes(userId)) {
              const updatedParticipants = [...participants, userId];
              const updatedThreads = await db4.update(collaborationThreads).set({
                participants: updatedParticipants,
                updatedAt: /* @__PURE__ */ new Date()
              }).where(and10(
                eq10(collaborationThreads.id, threadId),
                eq10(collaborationThreads.companyId, companyId)
              )).returning();
              logger22.info(`[${context}] User ${userId} added as participant to thread ${threadId}`);
              return updatedThreads[0];
            }
            logger22.info(`[${context}] User ${userId} is already a participant in thread ${threadId}`);
            return thread;
          });
        } catch (error) {
          logger22.error(`[${context}] Error adding participant to thread: ${error instanceof Error ? error.message : String(error)}`);
          logger22.error(`[${context}] Details: threadId=${threadId}, userId=${userId}, companyId=${companyId}`);
          throw error;
        }
      }
    };
  }
});

// server/common/drizzle/modules/collab/message-service.ts
import { eq as eq11, and as and11, desc as desc2, sql as sql13 } from "drizzle-orm";
import { randomUUID as randomUUID3 } from "crypto";
var logger23, MessageDrizzleService;
var init_message_service = __esm({
  "server/common/drizzle/modules/collab/message-service.ts"() {
    "use strict";
    init_base_drizzle_service();
    init_collaboration_schema();
    init_logger();
    init_thread_service();
    logger23 = new Logger("MessageDrizzleService");
    MessageDrizzleService = class extends BaseDrizzleService {
      /**
       * Constructor initializes the thread service dependency
       */
      constructor() {
        super();
        this.threadService = new ThreadDrizzleService();
      }
      /**
       * Create a new message in a thread
       * 
       * @param message Message data
       * @param userId User ID creating the message
       * @returns Created message
       */
      async createMessage(message, userId) {
        const context = "createMessage";
        try {
          logger23.debug(`[${context}] Creating new message for thread ${message.threadId} by user ${userId}`);
          const messageId = message.id || randomUUID3();
          const now = /* @__PURE__ */ new Date();
          return await this.transaction(async (tx) => {
            const createdMessages = await tx.insert(collaborationMessages).values({
              ...message,
              id: messageId,
              userId,
              createdAt: now,
              updatedAt: now
            }).returning();
            if (createdMessages.length === 0) {
              const error = new Error("Failed to create message");
              logger23.error(`[${context}] ${error.message} for thread ${message.threadId}`);
              throw error;
            }
            await this.threadService.updateLastMessageTimestamp(message.threadId, message.companyId);
            logger23.info(`[${context}] Message created successfully with ID ${messageId} for thread ${message.threadId}`);
            return createdMessages[0];
          });
        } catch (error) {
          logger23.error(`[${context}] Error creating message for thread ${message.threadId}: ${error instanceof Error ? error.message : String(error)}`);
          logger23.error(`[${context}] Message details: ${JSON.stringify({ ...message, content: message.content?.substring(0, 50) + "..." })}`);
          throw error;
        }
      }
      /**
       * Get a message by ID
       * 
       * @param messageId Message ID
       * @param companyId Company ID
       * @returns Message or null if not found
       */
      async getMessageById(messageId, companyId) {
        const context = "getMessageById";
        try {
          logger23.debug(`[${context}] Fetching message ${messageId} for company ${companyId}`);
          return await this.query(async (db4) => {
            const messages2 = await db4.select().from(collaborationMessages).where(and11(
              eq11(collaborationMessages.id, messageId),
              eq11(collaborationMessages.companyId, companyId)
            ));
            const message = messages2.length > 0 ? messages2[0] : null;
            if (message) {
              logger23.info(`[${context}] Found message ${messageId} for company ${companyId}`);
            } else {
              logger23.info(`[${context}] Message ${messageId} not found for company ${companyId}`);
            }
            return message;
          });
        } catch (error) {
          logger23.error(`[${context}] Error fetching message ${messageId} for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Get all messages for a thread
       * 
       * @param threadId Thread ID
       * @param companyId Company ID
       * @param options Query options (limit, offset, sort)
       * @returns List of messages
       */
      async getMessagesByThreadId(threadId, companyId, options = {}) {
        const context = "getMessagesByThreadId";
        try {
          const {
            limit = 50,
            offset = 0,
            sortOrder = "asc"
            // Default to oldest first
          } = options;
          logger23.debug(`[${context}] Fetching messages for thread ${threadId} in company ${companyId} with options:`, options);
          return await this.query(async (db4) => {
            const whereCondition = and11(
              eq11(collaborationMessages.threadId, threadId),
              eq11(collaborationMessages.companyId, companyId)
            );
            const messagesResult = sortOrder === "asc" ? await db4.select().from(collaborationMessages).where(whereCondition).orderBy(collaborationMessages.createdAt).limit(limit).offset(offset) : await db4.select().from(collaborationMessages).where(whereCondition).orderBy(desc2(collaborationMessages.createdAt)).limit(limit).offset(offset);
            const totalResult = await db4.select({
              count: sql13`count(*)`
            }).from(collaborationMessages).where(whereCondition);
            const total = Number(totalResult[0]?.count || 0);
            logger23.info(`[${context}] Found ${messagesResult.length} messages for thread ${threadId}, total: ${total}`);
            return {
              messages: messagesResult,
              total
            };
          });
        } catch (error) {
          logger23.error(`[${context}] Error fetching messages for thread ${threadId} in company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Update a message
       * 
       * @param messageId Message ID
       * @param companyId Company ID
       * @param updates Message updates
       * @param userId User ID making the update
       * @returns Updated message
       */
      async updateMessage(messageId, companyId, updates, userId) {
        const context = "updateMessage";
        try {
          logger23.debug(`[${context}] Updating message ${messageId} for company ${companyId} by user ${userId}`);
          return await this.query(async (db4) => {
            const updatedMessages = await db4.update(collaborationMessages).set({
              ...updates,
              isEdited: true,
              updatedAt: /* @__PURE__ */ new Date(),
              editedBy: userId
            }).where(and11(
              eq11(collaborationMessages.id, messageId),
              eq11(collaborationMessages.companyId, companyId)
            )).returning();
            if (updatedMessages.length === 0) {
              const error = new Error(`Message not found: ${messageId}`);
              logger23.error(`[${context}] ${error.message} for company ${companyId}`);
              throw error;
            }
            logger23.info(`[${context}] Message ${messageId} updated successfully by user ${userId}`);
            return updatedMessages[0];
          });
        } catch (error) {
          logger23.error(`[${context}] Error updating message ${messageId} for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Delete a message
       * 
       * @param messageId Message ID
       * @param companyId Company ID
       * @returns True if deleted
       */
      async deleteMessage(messageId, companyId) {
        const context = "deleteMessage";
        try {
          logger23.debug(`[${context}] Deleting message ${messageId} for company ${companyId}`);
          return await this.query(async (db4) => {
            const result = await db4.delete(collaborationMessages).where(and11(
              eq11(collaborationMessages.id, messageId),
              eq11(collaborationMessages.companyId, companyId)
            )).returning();
            const deleted = result.length > 0;
            if (deleted) {
              logger23.info(`[${context}] Message ${messageId} deleted successfully for company ${companyId}`);
            } else {
              logger23.info(`[${context}] No message with ID ${messageId} found to delete for company ${companyId}`);
            }
            return deleted;
          });
        } catch (error) {
          logger23.error(`[${context}] Error deleting message ${messageId} for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
      /**
       * Get replies to a specific message
       * 
       * @param messageId Message ID to find replies for
       * @param companyId Company ID
       * @returns List of reply messages
       */
      async getReplies(messageId, companyId) {
        const context = "getReplies";
        try {
          logger23.debug(`[${context}] Fetching replies for message ${messageId} in company ${companyId}`);
          return await this.query(async (db4) => {
            const replies = await db4.select().from(collaborationMessages).where(and11(
              eq11(collaborationMessages.replyToId, messageId),
              eq11(collaborationMessages.companyId, companyId)
            )).orderBy(collaborationMessages.createdAt);
            logger23.info(`[${context}] Found ${replies.length} replies for message ${messageId} in company ${companyId}`);
            return replies;
          });
        } catch (error) {
          logger23.error(`[${context}] Error fetching replies for message ${messageId} in company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
          throw error;
        }
      }
    };
  }
});

// server/common/drizzle/modules/collab/watcher-service.ts
import { eq as eq12, and as and12 } from "drizzle-orm";
import { randomUUID as randomUUID4 } from "crypto";
function normalizeNotificationPreference(pref) {
  if (typeof pref === "object" && pref !== null) {
    return pref;
  }
  return { enabled: true };
}
var logger24, WatcherDrizzleService;
var init_watcher_service = __esm({
  "server/common/drizzle/modules/collab/watcher-service.ts"() {
    "use strict";
    init_base_drizzle_service();
    init_collaboration_schema();
    init_logger();
    logger24 = new Logger("WatcherDrizzleService");
    WatcherDrizzleService = class extends BaseDrizzleService {
      /**
       * Add a watcher to a task
       * 
       * @param taskId Task ID
       * @param companyId Company ID
       * @param userId User ID to add as a watcher
       * @param notificationPreference Notification preferences
       * @returns Created watcher record
       */
      async addWatcher(taskId, companyId, userId, notificationPreference = { enabled: true }) {
        const context = "addWatcher";
        try {
          logger24.debug(`[${context}] Adding user ${userId} as watcher for task ${taskId} in company ${companyId}`);
          return await this.query(async (db4) => {
            const existingWatchers = await db4.select().from(taskWatchers).where(and12(
              eq12(taskWatchers.taskId, taskId),
              eq12(taskWatchers.companyId, companyId),
              eq12(taskWatchers.userId, userId)
            ));
            if (existingWatchers.length > 0) {
              const watcher2 = existingWatchers[0];
              logger24.info(`[${context}] User ${userId} is already watching task ${taskId}, returning existing record`);
              return {
                ...watcher2,
                notificationPreference: normalizeNotificationPreference(watcher2.notificationPreference)
              };
            }
            const newWatcherId = randomUUID4();
            const createdWatchers = await db4.insert(taskWatchers).values({
              id: newWatcherId,
              taskId,
              companyId,
              userId,
              notificationPreference,
              createdAt: /* @__PURE__ */ new Date()
            }).returning();
            if (createdWatchers.length === 0) {
              const error = new Error("Failed to add watcher");
              logger24.error(`[${context}] ${error.message} for task ${taskId} and user ${userId}`);
              throw error;
            }
            const watcher = createdWatchers[0];
            logger24.info(`[${context}] Added user ${userId} as watcher for task ${taskId} with ID ${newWatcherId}`);
            return {
              ...watcher,
              notificationPreference: normalizeNotificationPreference(watcher.notificationPreference)
            };
          });
        } catch (error) {
          logger24.error(`[${context}] Error adding watcher: ${error instanceof Error ? error.message : String(error)}`);
          logger24.error(`[${context}] Details: taskId=${taskId}, userId=${userId}, companyId=${companyId}`);
          throw error;
        }
      }
      /**
       * Remove a watcher from a task
       * 
       * @param taskId Task ID
       * @param companyId Company ID
       * @param userId User ID to remove as a watcher
       * @returns Success status
       */
      async removeWatcher(taskId, companyId, userId) {
        const context = "removeWatcher";
        try {
          logger24.debug(`[${context}] Removing user ${userId} as watcher from task ${taskId} in company ${companyId}`);
          return await this.query(async (db4) => {
            const result = await db4.delete(taskWatchers).where(and12(
              eq12(taskWatchers.taskId, taskId),
              eq12(taskWatchers.companyId, companyId),
              eq12(taskWatchers.userId, userId)
            )).returning();
            const removed = result.length > 0;
            if (removed) {
              logger24.info(`[${context}] Successfully removed user ${userId} as watcher from task ${taskId}`);
            } else {
              logger24.info(`[${context}] No watcher found for user ${userId} and task ${taskId} to remove`);
            }
            return removed;
          });
        } catch (error) {
          logger24.error(`[${context}] Error removing watcher: ${error instanceof Error ? error.message : String(error)}`);
          logger24.error(`[${context}] Details: taskId=${taskId}, userId=${userId}, companyId=${companyId}`);
          throw error;
        }
      }
      /**
       * Get all watchers for a task
       * 
       * @param taskId Task ID
       * @param companyId Company ID
       * @returns List of watchers
       */
      async getWatchersByTaskId(taskId, companyId) {
        const context = "getWatchersByTaskId";
        try {
          logger24.debug(`[${context}] Fetching watchers for task ${taskId} in company ${companyId}`);
          return await this.query(async (db4) => {
            const watchers = await db4.select().from(taskWatchers).where(and12(
              eq12(taskWatchers.taskId, taskId),
              eq12(taskWatchers.companyId, companyId)
            ));
            logger24.info(`[${context}] Found ${watchers.length} watchers for task ${taskId}`);
            return watchers.map((watcher) => ({
              ...watcher,
              notificationPreference: normalizeNotificationPreference(watcher.notificationPreference)
            }));
          });
        } catch (error) {
          logger24.error(`[${context}] Error fetching watchers by task ID: ${error instanceof Error ? error.message : String(error)}`);
          logger24.error(`[${context}] Details: taskId=${taskId}, companyId=${companyId}`);
          throw error;
        }
      }
      /**
       * Get all tasks watched by a user
       * 
       * @param userId User ID
       * @param companyId Company ID
       * @returns List of task IDs being watched
       */
      async getWatchedTaskIds(userId, companyId) {
        const context = "getWatchedTaskIds";
        try {
          logger24.debug(`[${context}] Fetching tasks watched by user ${userId} in company ${companyId}`);
          return await this.query(async (db4) => {
            const watchers = await db4.select({
              taskId: taskWatchers.taskId
            }).from(taskWatchers).where(and12(
              eq12(taskWatchers.userId, userId),
              eq12(taskWatchers.companyId, companyId)
            ));
            const taskIds = watchers.map((w) => w.taskId);
            logger24.info(`[${context}] Found ${taskIds.length} tasks watched by user ${userId}`);
            return taskIds;
          });
        } catch (error) {
          logger24.error(`[${context}] Error fetching watched task IDs: ${error instanceof Error ? error.message : String(error)}`);
          logger24.error(`[${context}] Details: userId=${userId}, companyId=${companyId}`);
          throw error;
        }
      }
      /**
       * Update watcher notification preferences
       * 
       * @param taskId Task ID
       * @param companyId Company ID
       * @param userId User ID
       * @param notificationPreference Updated notification preferences
       * @returns Updated watcher record or null if not found
       */
      async updateWatcherPreferences(taskId, companyId, userId, notificationPreference) {
        const context = "updateWatcherPreferences";
        try {
          logger24.debug(`[${context}] Updating notification preferences for user ${userId} on task ${taskId}`);
          return await this.query(async (db4) => {
            const updatedWatchers = await db4.update(taskWatchers).set({
              notificationPreference
            }).where(and12(
              eq12(taskWatchers.taskId, taskId),
              eq12(taskWatchers.companyId, companyId),
              eq12(taskWatchers.userId, userId)
            )).returning();
            if (updatedWatchers.length === 0) {
              logger24.info(`[${context}] No watcher found for user ${userId} and task ${taskId} to update`);
              return null;
            }
            const watcher = updatedWatchers[0];
            logger24.info(`[${context}] Successfully updated notification preferences for user ${userId} on task ${taskId}`);
            return {
              ...watcher,
              notificationPreference: normalizeNotificationPreference(watcher.notificationPreference)
            };
          });
        } catch (error) {
          logger24.error(`[${context}] Error updating watcher preferences: ${error instanceof Error ? error.message : String(error)}`);
          logger24.error(`[${context}] Details: taskId=${taskId}, userId=${userId}, companyId=${companyId}`);
          throw error;
        }
      }
      /**
       * Check if a user is watching a task
       * 
       * @param taskId Task ID
       * @param companyId Company ID
       * @param userId User ID
       * @returns Boolean indicating if the user is watching the task
       */
      async isWatching(taskId, companyId, userId) {
        const context = "isWatching";
        try {
          logger24.debug(`[${context}] Checking if user ${userId} is watching task ${taskId} in company ${companyId}`);
          return await this.query(async (db4) => {
            const watchers = await db4.select().from(taskWatchers).where(and12(
              eq12(taskWatchers.taskId, taskId),
              eq12(taskWatchers.companyId, companyId),
              eq12(taskWatchers.userId, userId)
            ));
            const isWatching = watchers.length > 0;
            logger24.info(`[${context}] User ${userId} ${isWatching ? "is" : "is not"} watching task ${taskId}`);
            return isWatching;
          });
        } catch (error) {
          logger24.error(`[${context}] Error checking if user is watching task: ${error instanceof Error ? error.message : String(error)}`);
          logger24.error(`[${context}] Details: taskId=${taskId}, userId=${userId}, companyId=${companyId}`);
          throw error;
        }
      }
    };
  }
});

// server/common/drizzle/modules/collab/collab-drizzle.service.ts
var logger25, CollabDrizzleService;
var init_collab_drizzle_service = __esm({
  "server/common/drizzle/modules/collab/collab-drizzle.service.ts"() {
    "use strict";
    init_base_drizzle_service();
    init_logger();
    init_thread_service();
    init_message_service();
    init_watcher_service();
    logger25 = new Logger("CollabDrizzleService");
    CollabDrizzleService = class extends BaseDrizzleService {
      /**
       * Constructor initializes all collaboration services
       */
      constructor() {
        super();
        logger25.debug("Initializing CollabDrizzleService");
        try {
          this.threadService = new ThreadDrizzleService();
          logger25.debug("ThreadDrizzleService initialized");
          this.messageService = new MessageDrizzleService();
          logger25.debug("MessageDrizzleService initialized");
          this.watcherService = new WatcherDrizzleService();
          logger25.debug("WatcherDrizzleService initialized");
          logger25.info("CollabDrizzleService initialized successfully with all services");
        } catch (error) {
          logger25.error("Failed to initialize CollabDrizzleService", error);
          throw error;
        }
      }
      /**
       * Get all collaboration services
       * 
       * @returns Object containing all collaboration services
       */
      getServices() {
        return {
          threadService: this.threadService,
          messageService: this.messageService,
          watcherService: this.watcherService
        };
      }
    };
  }
});

// server/common/drizzle/modules/collab/index.ts
var init_collab = __esm({
  "server/common/drizzle/modules/collab/index.ts"() {
    "use strict";
    init_thread_service();
    init_message_service();
    init_watcher_service();
    init_collab_drizzle_service();
  }
});

// server/common/drizzle/modules/index.ts
var init_modules = __esm({
  "server/common/drizzle/modules/index.ts"() {
    "use strict";
    init_core();
    init_company();
    init_invoicing();
    init_auth();
    init_collab();
  }
});

// server/common/drizzle/drizzle.service.ts
var logger26, DrizzleService;
var init_drizzle_service = __esm({
  "server/common/drizzle/drizzle.service.ts"() {
    "use strict";
    init_logger();
    init_modules();
    logger26 = new Logger("DrizzleService");
    DrizzleService = class {
      constructor() {
        this.baseService = new BaseDrizzleService();
        this.companyService = new CompanyDrizzleService();
        this.invoicingService = new InvoicingDrizzleService();
        this.authService = new AuthDrizzleService();
        this.rbacService = new RbacDrizzleService();
        this.collabService = new CollabDrizzleService();
        logger26.info("DrizzleService initialized with all module services");
      }
      /**
       * Get the base drizzle service
       */
      get base() {
        return this.baseService;
      }
      /**
       * Get the company drizzle service
       */
      get company() {
        return this.companyService;
      }
      /**
       * Get the invoicing drizzle service
       */
      get invoicing() {
        return this.invoicingService;
      }
      /**
       * Get the auth drizzle service
       */
      get auth() {
        return this.authService;
      }
      /**
       * Get the RBAC drizzle service
       */
      get rbac() {
        return this.rbacService;
      }
      /**
       * Get the Collaboration drizzle service
       */
      get collab() {
        return this.collabService;
      }
      /**
       * Execute a function with the Drizzle database instance
       * This is a convenience method that delegates to the base service
       * 
       * @param queryFn Function that receives the DB instance and returns a result
       * @returns Promise resolving to the result of queryFn
       */
      async query(queryFn) {
        try {
          return await this.baseService.query(queryFn, "DrizzleService.query");
        } catch (error) {
          logger26.error("Error in query operation", error);
          throw error;
        }
      }
      /**
       * Execute raw SQL directly
       * This is a convenience method that delegates to the base service
       * 
       * @param sql SQL query to execute (string or SQL object)
       * @param params Parameters for the query (only used with string queries)
       * @returns Query result
       */
      async executeQuery(sql57, params = []) {
        try {
          return await this.baseService.executeQuery(sql57, params);
        } catch (error) {
          logger26.error("Error in executeQuery operation", error);
          throw error;
        }
      }
      /**
       * Start a database transaction
       * This is a convenience method that delegates to the base service
       * 
       * @param transactionFn Function that receives a transaction and returns a result
       * @returns Promise resolving to the result of transactionFn
       */
      async transaction(transactionFn) {
        try {
          return await this.baseService.transaction(transactionFn, "DrizzleService.transaction");
        } catch (error) {
          logger26.error("Error in transaction operation", error);
          throw error;
        }
      }
    };
  }
});

// server/common/drizzle/index.ts
var getDrizzle, getClient;
var init_drizzle = __esm({
  "server/common/drizzle/index.ts"() {
    "use strict";
    init_db();
    init_drizzle_service();
    getDrizzle = getDrizzleInstance;
    getClient = getPostgresClient;
  }
});

// server/storage.ts
import { eq as eq13, and as and13, desc as desc3, sql as sql14, gte, lte, max } from "drizzle-orm";
import session from "express-session";
import createMemoryStore from "memorystore";
var drizzleService, MemoryStore, DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema4();
    init_drizzle();
    drizzleService = {
      executeQuery: async (callback) => {
        const db4 = getDrizzle();
        return await callback(db4);
      }
    };
    MemoryStore = createMemoryStore(session);
    DatabaseStorage = class {
      constructor() {
        this.sessionStore = new MemoryStore({
          checkPeriod: 864e5
          // prune expired entries every 24h
        });
      }
      // User Management
      async getUsers() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(users).orderBy(users.username);
        });
      }
      async getUser(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [user] = await db4.select().from(users).where(eq13(users.id, id));
          return user || void 0;
        });
      }
      async getUserByUsername(username) {
        return drizzleService.executeQuery(async (db4) => {
          const [user] = await db4.select().from(users).where(eq13(users.username, username));
          return user || void 0;
        });
      }
      async createUser(user) {
        return drizzleService.executeQuery(async (db4) => {
          const [newUser] = await db4.insert(users).values(user).returning();
          return newUser;
        });
      }
      async updateUser(id, userData) {
        return drizzleService.executeQuery(async (db4) => {
          const [updatedUser] = await db4.update(users).set(userData).where(eq13(users.id, id)).returning();
          return updatedUser;
        });
      }
      // RBAC - Roles Management
      async getRoles(companyId) {
        return drizzleService.executeQuery(async (db4) => {
          if (companyId) {
            return await db4.select().from(roles).where(eq13(roles.companyId, companyId)).orderBy(roles.name);
          }
          return await db4.select().from(roles).orderBy(roles.name);
        });
      }
      async getRole(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [role] = await db4.select().from(roles).where(eq13(roles.id, id));
          return role || void 0;
        });
      }
      async getRoleByName(name, companyId) {
        return drizzleService.executeQuery(async (db4) => {
          const [role] = await db4.select().from(roles).where(and13(eq13(roles.name, name), eq13(roles.companyId, companyId)));
          return role || void 0;
        });
      }
      async createRole(role) {
        return drizzleService.executeQuery(async (db4) => {
          const [newRole] = await db4.insert(roles).values(role).returning();
          return newRole;
        });
      }
      async updateRole(id, roleData) {
        return drizzleService.executeQuery(async (db4) => {
          const [updatedRole] = await db4.update(roles).set(roleData).where(eq13(roles.id, id)).returning();
          return updatedRole;
        });
      }
      async deleteRole(id) {
        return drizzleService.executeQuery(async (db4) => {
          await db4.delete(roles).where(eq13(roles.id, id));
        });
      }
      // RBAC - Permissions Management
      async getPermissions() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(permissions).orderBy(permissions.name);
        });
      }
      async getPermission(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [permission] = await db4.select().from(permissions).where(eq13(permissions.id, id));
          return permission || void 0;
        });
      }
      async getPermissionByName(name) {
        return drizzleService.executeQuery(async (db4) => {
          const [permission] = await db4.select().from(permissions).where(eq13(permissions.name, name));
          return permission || void 0;
        });
      }
      async createPermission(permission) {
        return drizzleService.executeQuery(async (db4) => {
          const [newPermission] = await db4.insert(permissions).values(permission).returning();
          return newPermission;
        });
      }
      // RBAC - User-Role Assignment
      async getUserRoles(userId) {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select({
            id: roles.id,
            name: roles.name,
            companyId: roles.companyId,
            description: roles.description,
            createdAt: roles.createdAt,
            updatedAt: roles.updatedAt
          }).from(userRoles).innerJoin(roles, eq13(userRoles.roleId, roles.id)).where(eq13(userRoles.userId, userId));
        });
      }
      async assignRoleToUser(userId, roleId) {
        return drizzleService.executeQuery(async (db4) => {
          await db4.insert(userRoles).values({ userId, roleId }).onConflictDoNothing();
        });
      }
      async removeRoleFromUser(userId, roleId) {
        return drizzleService.executeQuery(async (db4) => {
          await db4.delete(userRoles).where(and13(eq13(userRoles.userId, userId), eq13(userRoles.roleId, roleId)));
        });
      }
      // RBAC - Role-Permission Assignment
      async getRolePermissions(roleId) {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select({
            id: permissions.id,
            name: permissions.name,
            description: permissions.description,
            resource: permissions.resource,
            action: permissions.action,
            createdAt: permissions.createdAt,
            updatedAt: permissions.updatedAt
          }).from(rolePermissions).innerJoin(permissions, eq13(rolePermissions.permissionId, permissions.id)).where(eq13(rolePermissions.roleId, roleId));
        });
      }
      async assignPermissionToRole(roleId, permissionId) {
        return drizzleService.executeQuery(async (db4) => {
          await db4.insert(rolePermissions).values({ roleId, permissionId }).onConflictDoNothing();
        });
      }
      async removePermissionFromRole(roleId, permissionId) {
        return drizzleService.executeQuery(async (db4) => {
          await db4.delete(rolePermissions).where(and13(eq13(rolePermissions.roleId, roleId), eq13(rolePermissions.permissionId, permissionId)));
        });
      }
      // Company Settings
      async getCompany() {
        return drizzleService.executeQuery(async (db4) => {
          const [company] = await db4.select().from(companies).limit(1);
          return company || void 0;
        });
      }
      async createCompany(company) {
        return drizzleService.executeQuery(async (db4) => {
          const [newCompany] = await db4.insert(companies).values(company).returning();
          return newCompany;
        });
      }
      async updateCompany(id, companyData) {
        return drizzleService.executeQuery(async (db4) => {
          const [updatedCompany] = await db4.update(companies).set(companyData).where(eq13(companies.id, id)).returning();
          return updatedCompany;
        });
      }
      // Romanian Chart of Accounts
      // 1. Account Classes (top level)
      async getAccountClasses() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(accountClasses).orderBy(accountClasses.code);
        });
      }
      async getAccountClass(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [accountClass] = await db4.select().from(accountClasses).where(eq13(accountClasses.id, id));
          return accountClass || void 0;
        });
      }
      async getAccountClassByCode(code) {
        return drizzleService.executeQuery(async (db4) => {
          const [accountClass] = await db4.select().from(accountClasses).where(eq13(accountClasses.code, code));
          return accountClass || void 0;
        });
      }
      async createAccountClass(accountClass) {
        return drizzleService.executeQuery(async (db4) => {
          const [newAccountClass] = await db4.insert(accountClasses).values(accountClass).returning();
          return newAccountClass;
        });
      }
      async updateAccountClass(id, accountClassData) {
        return drizzleService.executeQuery(async (db4) => {
          const [updatedAccountClass] = await db4.update(accountClasses).set(accountClassData).where(eq13(accountClasses.id, id)).returning();
          return updatedAccountClass;
        });
      }
      // 2. Account Groups (second level)
      async getAccountGroups() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(accountGroups).orderBy(accountGroups.code);
        });
      }
      async getAccountGroupsByClass(classId) {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(accountGroups).where(eq13(accountGroups.classId, classId)).orderBy(accountGroups.code);
        });
      }
      async getAccountGroup(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [accountGroup] = await db4.select().from(accountGroups).where(eq13(accountGroups.id, id));
          return accountGroup || void 0;
        });
      }
      async getAccountGroupByCode(code) {
        return drizzleService.executeQuery(async (db4) => {
          const [accountGroup] = await db4.select().from(accountGroups).where(eq13(accountGroups.code, code));
          return accountGroup || void 0;
        });
      }
      async createAccountGroup(accountGroup) {
        return drizzleService.executeQuery(async (db4) => {
          const [newAccountGroup] = await db4.insert(accountGroups).values(accountGroup).returning();
          return newAccountGroup;
        });
      }
      async updateAccountGroup(id, accountGroupData) {
        return drizzleService.executeQuery(async (db4) => {
          const [updatedAccountGroup] = await db4.update(accountGroups).set(accountGroupData).where(eq13(accountGroups.id, id)).returning();
          return updatedAccountGroup;
        });
      }
      // 3. Synthetic Accounts (third level - Grade 1 and 2)
      async getSyntheticAccounts() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(syntheticAccounts).orderBy(syntheticAccounts.code);
        });
      }
      async getSyntheticAccountsByGroup(groupId) {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(syntheticAccounts).where(eq13(syntheticAccounts.groupId, groupId)).orderBy(syntheticAccounts.code);
        });
      }
      async getSyntheticAccountsByGrade(grade) {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(syntheticAccounts).where(eq13(syntheticAccounts.grade, grade)).orderBy(syntheticAccounts.code);
        });
      }
      async getSyntheticAccount(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [syntheticAccount] = await db4.select().from(syntheticAccounts).where(eq13(syntheticAccounts.id, id));
          return syntheticAccount || void 0;
        });
      }
      async getSyntheticAccountByCode(code) {
        return drizzleService.executeQuery(async (db4) => {
          const [syntheticAccount] = await db4.select().from(syntheticAccounts).where(eq13(syntheticAccounts.code, code));
          return syntheticAccount || void 0;
        });
      }
      async createSyntheticAccount(syntheticAccount) {
        return drizzleService.executeQuery(async (db4) => {
          const [newSyntheticAccount] = await db4.insert(syntheticAccounts).values(syntheticAccount).returning();
          return newSyntheticAccount;
        });
      }
      async updateSyntheticAccount(id, syntheticAccountData) {
        return drizzleService.executeQuery(async (db4) => {
          const [updatedSyntheticAccount] = await db4.update(syntheticAccounts).set(syntheticAccountData).where(eq13(syntheticAccounts.id, id)).returning();
          return updatedSyntheticAccount;
        });
      }
      // 4. Analytic Accounts (fourth level - most detailed)
      async getAnalyticAccounts() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(analyticAccounts).orderBy(analyticAccounts.code);
        });
      }
      async getAnalyticAccountsBySynthetic(syntheticId) {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(analyticAccounts).where(eq13(analyticAccounts.syntheticId, syntheticId)).orderBy(analyticAccounts.code);
        });
      }
      async getAnalyticAccount(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [analyticAccount] = await db4.select().from(analyticAccounts).where(eq13(analyticAccounts.id, id));
          return analyticAccount || void 0;
        });
      }
      async getAnalyticAccountByCode(code) {
        return drizzleService.executeQuery(async (db4) => {
          const [analyticAccount] = await db4.select().from(analyticAccounts).where(eq13(analyticAccounts.code, code));
          return analyticAccount || void 0;
        });
      }
      async createAnalyticAccount(analyticAccount) {
        return drizzleService.executeQuery(async (db4) => {
          const [newAnalyticAccount] = await db4.insert(analyticAccounts).values(analyticAccount).returning();
          return newAnalyticAccount;
        });
      }
      async updateAnalyticAccount(id, analyticAccountData) {
        return drizzleService.executeQuery(async (db4) => {
          const [updatedAnalyticAccount] = await db4.update(analyticAccounts).set(analyticAccountData).where(eq13(analyticAccounts.id, id)).returning();
          return updatedAnalyticAccount;
        });
      }
      // Legacy Chart of Accounts - maintained for compatibility
      async getAccounts() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(accounts).orderBy(accounts.code);
        });
      }
      async getAccountsByClass(classCode) {
        return drizzleService.executeQuery(async (db4) => {
          const [accountClass] = await db4.select().from(accountClasses).where(eq13(accountClasses.code, classCode));
          if (!accountClass) {
            return [];
          }
          return await db4.select().from(accounts).where(eq13(accounts.classId, accountClass.id)).orderBy(accounts.code);
        });
      }
      async getAccount(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [account] = await db4.select().from(accounts).where(eq13(accounts.id, id));
          return account || void 0;
        });
      }
      async createAccount(account) {
        return drizzleService.executeQuery(async (db4) => {
          const [newAccount] = await db4.insert(accounts).values(account).returning();
          return newAccount;
        });
      }
      async updateAccount(id, accountData) {
        return drizzleService.executeQuery(async (db4) => {
          const [updatedAccount] = await db4.update(accounts).set(accountData).where(eq13(accounts.id, id)).returning();
          return updatedAccount;
        });
      }
      // Journal Entries
      async getJournalEntries() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.query.journalEntries.findMany({
            with: {
              lines: true,
              createdByUser: true
            },
            orderBy: desc3(sql14`journal_entries.created_at`)
          });
        });
      }
      async getJournalEntry(id) {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.query.journalEntries.findFirst({
            where: eq13(sql14`journal_entries.id`, id),
            with: {
              lines: true,
              createdByUser: true
            }
          });
        });
      }
      async createJournalEntry(entry, lines) {
        return drizzleService.executeQuery(async (db4) => {
          const [journalEntry] = await db4.insert(sql14`journal_entries`).values(entry).returning();
          const linesWithJournalId = lines.map((line) => ({
            ...line,
            journalId: journalEntry.id
          }));
          await db4.insert(sql14`journal_lines`).values(linesWithJournalId);
          return await this.getJournalEntry(journalEntry.id);
        });
      }
      // Inventory
      async getProducts() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(inventoryProducts).orderBy(inventoryProducts.code);
        });
      }
      async getProduct(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [product] = await db4.select().from(inventoryProducts).where(eq13(inventoryProducts.id, id));
          return product || void 0;
        });
      }
      async createProduct(product) {
        return drizzleService.executeQuery(async (db4) => {
          const [newProduct] = await db4.insert(inventoryProducts).values(product).returning();
          return newProduct;
        });
      }
      async updateProduct(id, productData) {
        return drizzleService.executeQuery(async (db4) => {
          const [updatedProduct] = await db4.update(inventoryProducts).set(productData).where(eq13(inventoryProducts.id, id)).returning();
          return updatedProduct;
        });
      }
      async getCategories() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(inventoryCategories);
        });
      }
      async getUnits() {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.select().from(inventoryUnits);
        });
      }
      async createStockMovement(movement) {
        return drizzleService.executeQuery(async (db4) => {
          const [newMovement] = await db4.insert(sql14`inventory_stock_movements`).values(movement).returning();
          return newMovement;
        });
      }
      // Invoicing
      async getInvoices(companyId, filters) {
        return drizzleService.executeQuery(async (db4) => {
          let query = db4.select().from(invoices).where(eq13(invoices.companyId, companyId)).orderBy(desc3(invoices.createdAt));
          if (filters) {
            if (filters.status) {
              query = query.where(eq13(invoices.status, filters.status));
            }
            if (filters.series) {
              query = query.where(eq13(invoices.series, filters.series));
            }
            if (filters.fromDate) {
              query = query.where(gte(invoices.createdAt, filters.fromDate));
            }
            if (filters.toDate) {
              query = query.where(lte(invoices.createdAt, filters.toDate));
            }
            if (filters.limit) {
              query = query.limit(filters.limit);
            }
            if (filters.offset) {
              query = query.offset(filters.offset || 0);
            }
          }
          return await query;
        });
      }
      async getInvoice(id) {
        return drizzleService.executeQuery(async (db4) => {
          const [invoice] = await db4.select().from(invoices).where(eq13(invoices.id, id));
          return invoice || void 0;
        });
      }
      async getInvoiceBySeriesAndNumber(series, number) {
        return drizzleService.executeQuery(async (db4) => {
          const [invoice] = await db4.select().from(invoices).where(and13(
            eq13(invoices.series, series),
            eq13(invoices.number, number)
          ));
          return invoice || void 0;
        });
      }
      async createInvoice(invoice, details, lines) {
        return drizzleService.executeQuery(async (db4) => {
          return await db4.transaction(async (tx) => {
            const [newInvoice] = await tx.insert(invoices).values(invoice).returning();
            await tx.insert(invoiceDetails).values({
              ...details,
              invoiceId: newInvoice.id
            });
            for (const line of lines) {
              await tx.insert(invoiceLines).values({
                ...line,
                invoiceId: newInvoice.id
              });
            }
            return newInvoice;
          });
        });
      }
      async updateInvoice(id, invoiceData) {
        return drizzleService.executeQuery(async (db4) => {
          if ((invoiceData.series || invoiceData.number) && invoiceData.status !== "draft") {
            const currentInvoice = await this.getInvoice(id);
            if (currentInvoice && currentInvoice.status !== "draft") {
              throw new Error("Cannot change series or number of a non-draft invoice");
            }
          }
          const [updatedInvoice] = await db4.update(invoices).set({
            ...invoiceData,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq13(invoices.id, id)).returning();
          return updatedInvoice;
        });
      }
      async updateInvoiceStatus(id, status) {
        return drizzleService.executeQuery(async (db4) => {
          const currentInvoice = await this.getInvoice(id);
          if (!currentInvoice) {
            throw new Error("Invoice not found");
          }
          const currentStatus = currentInvoice.status;
          if (status === "issued" && currentStatus !== "draft") {
            throw new Error("Only draft invoices can be issued");
          } else if (status === "sent" && currentStatus !== "issued") {
            throw new Error("Only issued invoices can be sent");
          } else if (status === "canceled" && !["issued", "sent"].includes(currentStatus)) {
            throw new Error("Only issued or sent invoices can be canceled");
          } else if (status === "draft" && currentStatus !== "draft") {
            throw new Error("Cannot revert to draft status");
          }
          if (status === "issued" && currentStatus === "draft") {
            if (!currentInvoice.series) {
              throw new Error("Invoice series must be set before issuing");
            }
            const nextNumber = await this.getNextInvoiceNumber(currentInvoice.series);
            const [updatedInvoice] = await db4.update(invoices).set({
              status,
              number: nextNumber,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq13(invoices.id, id)).returning();
            return updatedInvoice;
          } else {
            const [updatedInvoice] = await db4.update(invoices).set({
              status,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq13(invoices.id, id)).returning();
            return updatedInvoice;
          }
        });
      }
      async deleteInvoice(id) {
        return drizzleService.executeQuery(async (db4) => {
          const invoice = await this.getInvoice(id);
          if (!invoice) {
            throw new Error("Invoice not found");
          }
          if (invoice.status === "draft") {
            await db4.update(invoices).set({
              deletedAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq13(invoices.id, id));
            return;
          }
          if (invoice.status === "issued") {
            const [latestInvoice] = await db4.select().from(invoices).where(eq13(invoices.series, invoice.series)).orderBy(desc3(invoices.number)).limit(1);
            if (latestInvoice && latestInvoice.id === invoice.id && !["sent", "canceled"].includes(invoice.status)) {
              await db4.update(invoices).set({
                deletedAt: /* @__PURE__ */ new Date(),
                updatedAt: /* @__PURE__ */ new Date()
              }).where(eq13(invoices.id, id));
              return;
            }
          }
          throw new Error(
            "Only draft invoices or the last issued invoice (if not sent or canceled) can be deleted"
          );
        });
      }
      async getNextInvoiceNumber(series) {
        return drizzleService.executeQuery(async (db4) => {
          const [result] = await db4.select({ maxNumber: max(invoices.number) }).from(invoices).where(eq13(invoices.series, series));
          return (result.maxNumber || 0) + 1;
        });
      }
      // Audit Logging
      async createAuditLog(auditLog) {
        return drizzleService.executeQuery(async (db4) => {
          const logEntry = {
            ...auditLog,
            createdAt: /* @__PURE__ */ new Date(),
            userId: auditLog.userId || null
          };
          const [newLog] = await db4.insert(auditLogs).values(logEntry).returning();
          return newLog;
        });
      }
      async getAuditLogs(options) {
        return drizzleService.executeQuery(async (db4) => {
          let query = db4.select().from(auditLogs).orderBy(desc3(auditLogs.createdAt));
          if (options) {
            const filters = [];
            if (options.companyId) {
              filters.push(eq13(auditLogs.companyId, options.companyId));
            }
            if (options.entity) {
              filters.push(eq13(auditLogs.entity, options.entity));
            }
            if (options.entityId) {
              filters.push(eq13(auditLogs.entityId, options.entityId));
            }
            if (options.action) {
              filters.push(eq13(auditLogs.action, options.action));
            }
            if (options.userId) {
              filters.push(eq13(auditLogs.userId, options.userId));
            }
            if (filters.length > 0) {
              query = query.where(and13(...filters));
            }
            if (options.limit) {
              query = query.limit(options.limit);
            }
            if (options.offset) {
              query = query.offset(options.offset);
            }
          }
          return await query;
        });
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/modules/auth/services/auth.service.ts
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import jwt from "jsonwebtoken";
import { eq as eq14 } from "drizzle-orm";
var scryptAsync, isDevelopment, JWT_SECRET, JWT_EXPIRES_IN, AuthService, authService;
var init_auth_service = __esm({
  "server/modules/auth/services/auth.service.ts"() {
    "use strict";
    init_storage();
    init_drizzle();
    init_schema4();
    scryptAsync = promisify(scrypt);
    isDevelopment = process.env.NODE_ENV === "development" || !process.env.NODE_ENV;
    JWT_SECRET = process.env.JWT_SECRET || (isDevelopment ? "dev_secret_key_for_local_development_only" : "");
    if (!JWT_SECRET) {
      console.error("[AuthService] ERROR: JWT_SECRET is not set in environment variables.");
      throw new Error("JWT_SECRET environment variable is required for authentication");
    }
    JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || "24h";
    console.log("[AuthService] JWT_SECRET exists and is being used");
    console.log("[AuthService] JWT_SECRET masked:", JWT_SECRET.substring(0, 3) + "..." + JWT_SECRET.substring(JWT_SECRET.length - 3));
    console.log("[AuthService] JWT_EXPIRES_IN:", JWT_EXPIRES_IN);
    AuthService = class {
      // Using any to bypass type checking for now
      constructor() {
        this.drizzleService = new DrizzleService();
        this.db = getDrizzle();
      }
      /**
       * Hash password using secure scrypt algorithm
       */
      async hashPassword(password) {
        const salt = randomBytes(16).toString("hex");
        const buf = await scryptAsync(password, salt, 64);
        return `${buf.toString("hex")}.${salt}`;
      }
      /**
       * Compare a supplied password against a stored hashed password
       */
      async comparePasswords(supplied, stored) {
        const [hashed, salt] = stored.split(".");
        const hashedBuf = Buffer.from(hashed, "hex");
        const suppliedBuf = await scryptAsync(supplied, salt, 64);
        return timingSafeEqual(hashedBuf, suppliedBuf);
      }
      /**
       * Generate a JWT token for a user
       */
      generateToken(user) {
        console.log("[AuthService] User object for token:", user);
        const companyId = user.companyId || user.company_id;
        const payload = {
          id: user.id,
          userId: user.id,
          // Alias pentru compatibilitate cu frontend
          username: user.username,
          role: user.role,
          roles: [user.role],
          companyId,
          company_id: companyId,
          // Pentru compatibilitate snake_case
          permissions: user.permissions || [],
          franchiseId: user.franchiseId || null,
          email: user.email || void 0,
          fullName: `${user.firstName || ""} ${user.lastName || ""}`.trim() || void 0
        };
        console.log("[AuthService] Generated token payload:", payload);
        return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
      }
      /**
       * Get user by username using DrizzleService
       */
      async getUserByUsername(username) {
        try {
          console.log("[AuthService] Getting user by username:", username);
          if (this.drizzleService.auth) {
            console.log("[AuthService] Using drizzleService.auth");
            const user2 = await this.drizzleService.auth.getUserByUsername(username);
            console.log("[AuthService] DrizzleService.auth result:", JSON.stringify(user2, null, 2));
            return user2;
          }
          console.log("[AuthService] Using direct database query");
          const result = await this.db.select().from(users).where(eq14(users.username, username)).limit(1);
          const user = result.length > 0 ? result[0] : null;
          console.log("[AuthService] Direct query result:", JSON.stringify(user, null, 2));
          return user;
        } catch (error) {
          console.error("Error in getUserByUsername:", error);
          console.log("[AuthService] Falling back to storage");
          const user = await storage.getUserByUsername(username);
          console.log("[AuthService] Storage fallback result:", JSON.stringify(user, null, 2));
          return user;
        }
      }
      /**
       * Get user by ID using DrizzleService
       */
      async getUserById(userId) {
        try {
          if (this.drizzleService.auth) {
            return await this.drizzleService.auth.getUserById(userId);
          }
          const result = await this.db.select().from(users).where(eq14(users.id, userId)).limit(1);
          return result.length > 0 ? result[0] : null;
        } catch (error) {
          console.error("Error in getUserById:", error);
          return storage.getUser(userId);
        }
      }
      /**
       * Register a new user
       */
      async registerUser(userData) {
        const existingUser = await this.getUserByUsername(userData.username);
        if (existingUser) {
          throw new Error("Numele de utilizator exist\u0103 deja");
        }
        const user = await storage.createUser({
          ...userData,
          password: await this.hashPassword(userData.password)
        });
        const token = this.generateToken(user);
        return { ...user, token };
      }
      /**
       * Authenticate a user by username and password
       */
      async authenticateUser(username, password) {
        const user = await this.getUserByUsername(username);
        console.log("[AuthService] User retrieved for authentication:", JSON.stringify(user, null, 2));
        if (!user || !await this.comparePasswords(password, user.password)) {
          throw new Error("Nume de utilizator sau parol\u0103 incorecte");
        }
        const token = this.generateToken(user);
        return { ...user, token };
      }
      /**
       * Verify JWT token and return user if valid
       */
      async verifyToken(token) {
        const payload = jwt.verify(token, JWT_SECRET);
        const user = await this.getUserById(payload.id);
        if (!user) {
          throw new Error("User not found");
        }
        return {
          ...user,
          roles: [user.role]
        };
      }
    };
    authService = new AuthService();
  }
});

// shared/types.ts
function Service() {
  return function(constructor) {
    return constructor;
  };
}
var init_types = __esm({
  "shared/types.ts"() {
    "use strict";
  }
});

// server/modules/auth/constants/auth-mode.enum.ts
var init_auth_mode_enum = __esm({
  "server/modules/auth/constants/auth-mode.enum.ts"() {
    "use strict";
  }
});

// server/modules/auth/guards/auth.guard.ts
import jwt2 from "jsonwebtoken";
var logger27, _AuthGuard_decorators, _init, _AuthGuard, AuthGuard, auth_guard_default;
var init_auth_guard = __esm({
  "server/modules/auth/guards/auth.guard.ts"() {
    "use strict";
    init_types();
    init_auth_mode_enum();
    init_auth_service();
    init_logger();
    logger27 = new Logger("AuthGuard");
    _AuthGuard_decorators = [Service()];
    _AuthGuard = class _AuthGuard {
      /**
       * Static method to protect a route with JWT authentication
       * This is kept for backward compatibility with existing code
       * 
       * @param mode Authentication mode (required or optional)
       * @returns Express middleware
       */
      static protect(mode = "required" /* REQUIRED */) {
        const instance = new _AuthGuard();
        return mode === "optional" /* OPTIONAL */ ? instance.optional() : instance.require();
      }
      /**
       * Static method to require specific roles to access the route
       * This is kept for backward compatibility with existing code
       * 
       * @param allowedRoles Array of allowed roles
       * @returns Express middleware
       */
      static roleGuard(allowedRoles) {
        const instance = new _AuthGuard();
        return instance.requireRoles(allowedRoles);
      }
      /**
       * Static method to require access to specific company
       * This is kept for backward compatibility with existing code
       * 
       * @param companyIdParam Name of the parameter containing company ID
       * @returns Express middleware
       */
      static companyGuard(companyIdParam) {
        const instance = new _AuthGuard();
        return instance.requireCompanyAccess(companyIdParam);
      }
      /**
       * Static method to require specific permissions to access the route
       * This is kept for backward compatibility with existing code
       * 
       * @param requiredPermissions String or array of required permissions
       * @returns Express middleware
       */
      static permissionGuard(requiredPermissions) {
        const instance = new _AuthGuard();
        return instance.requirePermissions(requiredPermissions);
      }
      /**
       * Require authentication to access the route
       * Alias for the require() method for better readability
       * 
       * @returns Express middleware
       */
      requireAuth() {
        return this.require();
      }
      /**
       * Require authentication to access the route
       * 
       * @returns Express middleware
       */
      require() {
        return (req, res, next) => {
          const token = this.extractToken(req);
          if (!token) {
            return res.status(401).json({ error: "Authentication required" });
          }
          try {
            const decoded = jwt2.verify(token, JWT_SECRET);
            if (decoded.companyId && !decoded.company_id) {
              decoded.company_id = decoded.companyId;
            } else if (decoded.company_id && !decoded.companyId) {
              decoded.companyId = decoded.company_id;
            }
            req.user = decoded;
            next();
          } catch (error) {
            return res.status(401).json({ error: "Invalid or expired token" });
          }
        };
      }
      /**
       * Make authentication optional for the route
       * Alias for the optional() method for better readability
       * 
       * @returns Express middleware
       */
      optionalAuth() {
        return this.optional();
      }
      /**
       * Make authentication optional for the route
       * 
       * @returns Express middleware
       */
      optional() {
        return (req, res, next) => {
          const token = this.extractToken(req);
          if (!token) {
            next();
            return;
          }
          try {
            const decoded = jwt2.verify(token, JWT_SECRET);
            if (decoded.companyId && !decoded.company_id) {
              decoded.company_id = decoded.companyId;
            } else if (decoded.company_id && !decoded.companyId) {
              decoded.companyId = decoded.company_id;
            }
            req.user = decoded;
          } catch (error) {
          }
          next();
        };
      }
      /**
       * Require specific roles to access the route
       * 
       * @param allowedRoles String or array of allowed roles
       * @returns Express middleware
       */
      requireRoles(allowedRoles) {
        return (req, res, next) => {
          const token = this.extractToken(req);
          if (!token) {
            return res.status(401).json({ error: "Authentication required" });
          }
          try {
            const decoded = jwt2.verify(token, JWT_SECRET);
            req.user = decoded;
            const userRoles3 = decoded.roles || [decoded.role];
            const requiredRoles = Array.isArray(allowedRoles) ? allowedRoles : [allowedRoles];
            if (userRoles3.includes("admin") || userRoles3.includes("ADMIN")) {
              logger27.debug("Admin role detected, granting access");
              return next();
            }
            const hasAllowedRole = userRoles3.some(
              (role) => requiredRoles.includes(role) || requiredRoles.includes(role.toLowerCase()) || requiredRoles.includes(role.toUpperCase())
            );
            if (hasAllowedRole) {
              logger27.debug("Role verification successful", {
                userId: decoded.id,
                userRoles: userRoles3,
                requiredRoles
              });
              next();
            } else {
              logger27.warn("Authorization failed - Missing required roles", {
                userId: decoded.id,
                userRoles: userRoles3,
                requiredRoles
              });
              return res.status(403).json({ error: "Insufficient permissions" });
            }
          } catch (error) {
            logger27.error("Role check error", error);
            return res.status(401).json({ error: "Invalid or expired token" });
          }
        };
      }
      /**
       * Require access to specific company to access the route
       * 
       * @param companyIdParam Name of the parameter containing company ID (defaults to 'companyId')
       * @returns Express middleware
       */
      requireCompanyAccess(companyIdParam = "companyId") {
        return (req, res, next) => {
          const token = this.extractToken(req);
          if (!token) {
            return res.status(401).json({ error: "Authentication required" });
          }
          try {
            const decoded = jwt2.verify(token, JWT_SECRET);
            req.user = decoded;
            const targetCompanyId = req.params[companyIdParam] || req.query[companyIdParam] || (req.body ? req.body[companyIdParam] : null);
            if (!targetCompanyId) {
              logger27.debug("No company ID specified in request, allowing access");
              return next();
            }
            const userRoles3 = decoded.roles || [decoded.role];
            if (userRoles3.some((role) => ["admin", "ADMIN", "system_admin", "SYSTEM_ADMIN"].includes(role))) {
              logger27.debug("Admin role detected, granting cross-company access");
              return next();
            }
            if (decoded.companyId === targetCompanyId) {
              logger27.debug("Company access check successful", {
                userId: decoded.id,
                companyId: decoded.companyId
              });
              next();
            } else {
              logger27.warn("Company access check failed - Cross-company access attempt", {
                userId: decoded.id,
                userCompanyId: decoded.companyId,
                attemptedCompanyId: targetCompanyId
              });
              return res.status(403).json({
                error: "Insufficient permissions to access this company"
              });
            }
          } catch (error) {
            logger27.error("Company check error", error);
            return res.status(401).json({ error: "Invalid or expired token" });
          }
        };
      }
      /**
       * Extract token from request
       * Looks for token in Authorization header, query params, or cookies
       * 
       * @param req Express request
       * @returns JWT token or null
       */
      extractToken(req) {
        const authHeader = req.headers.authorization;
        if (authHeader && authHeader.startsWith("Bearer ")) {
          return authHeader.substring(7);
        }
        if (req.query && req.query.token) {
          return req.query.token;
        }
        if (req.cookies && req.cookies.token) {
          return req.cookies.token;
        }
        return null;
      }
      /**
       * Require specific permissions to access the route
       * 
       * @param requiredPermissions String or array of required permissions
       * @returns Express middleware
       */
      requirePermissions(requiredPermissions) {
        return (req, res, next) => {
          const token = this.extractToken(req);
          if (!token) {
            return res.status(401).json({ error: "Authentication required" });
          }
          try {
            const decoded = jwt2.verify(token, JWT_SECRET);
            req.user = decoded;
            const userPermissions = decoded.permissions || [];
            const permissions4 = Array.isArray(requiredPermissions) ? requiredPermissions : [requiredPermissions];
            const userRoles3 = decoded.roles || [decoded.role];
            if (userRoles3.some((role) => ["admin", "ADMIN"].includes(role))) {
              logger27.debug("Admin role detected, granting access regardless of permissions");
              return next();
            }
            const hasAllPermissions = permissions4.every(
              (perm) => userPermissions.includes(perm)
            );
            if (hasAllPermissions) {
              logger27.debug("Permission check successful", {
                userId: decoded.id,
                requiredPermissions: permissions4
              });
              next();
            } else {
              logger27.warn("Permission check failed", {
                userId: decoded.id,
                userPermissions,
                requiredPermissions: permissions4
              });
              return res.status(403).json({
                error: "Insufficient permissions"
              });
            }
          } catch (error) {
            logger27.error("Permission check error", error);
            return res.status(401).json({ error: "Invalid or expired token" });
          }
        };
      }
    };
    _init = __decoratorStart(null);
    _AuthGuard = __decorateElement(_init, 0, "AuthGuard", _AuthGuard_decorators, _AuthGuard);
    __runInitializers(_init, 1, _AuthGuard);
    AuthGuard = _AuthGuard;
    auth_guard_default = new AuthGuard();
  }
});

// server/modules/audit/services/audit.service.ts
import { v4 as uuidv42 } from "uuid";
import { and as and16, eq as eq17, desc as desc5 } from "drizzle-orm";
var AuditAction, AuditService, audit_service_default;
var init_audit_service = __esm({
  "server/modules/audit/services/audit.service.ts"() {
    "use strict";
    init_drizzle();
    init_schema4();
    AuditAction = /* @__PURE__ */ ((AuditAction4) => {
      AuditAction4["CREATE"] = "CREATE";
      AuditAction4["UPDATE"] = "UPDATE";
      AuditAction4["DELETE"] = "DELETE";
      AuditAction4["VALIDATE"] = "VALIDATE";
      AuditAction4["DEVALIDATE"] = "DEVALIDATE";
      AuditAction4["LOGIN"] = "LOGIN";
      AuditAction4["LOGOUT"] = "LOGOUT";
      AuditAction4["EXPORT"] = "EXPORT";
      AuditAction4["IMPORT"] = "IMPORT";
      AuditAction4["APPROVE"] = "APPROVE";
      AuditAction4["REJECT"] = "REJECT";
      AuditAction4["VIEW"] = "VIEW";
      AuditAction4["INTEGRATION_ACTIVATE"] = "INTEGRATION_ACTIVATE";
      AuditAction4["BPM_PROCESS_ACTION"] = "BPM_PROCESS_ACTION";
      AuditAction4["BPM_PROCESS_VIEW"] = "BPM_PROCESS_VIEW";
      return AuditAction4;
    })(AuditAction || {});
    AuditService = class _AuditService {
      /**
       * Log an audit action (non-static instance method)
       * @param data Audit log data
       * @returns Promise that resolves to the log ID
       */
      async logAction(data) {
        return _AuditService.log(data);
      }
      /**
       * Log a system event (non-static instance method)
       * @param data Event log data
       * @returns Promise that resolves to the log ID
       */
      async logEvent(data) {
        const auditData = {
          userId: data.userId,
          companyId: data.companyId,
          action: data.eventType,
          entity: data.entityType || data.module,
          entityId: data.entityId,
          details: {
            module: data.module,
            description: data.description,
            ...data.data
          }
        };
        return _AuditService.log(auditData);
      }
      /**
       * Create an audit log entry
       * @param data Audit log data
       * @returns Created audit log entry ID
       * @deprecated Use AuditService.log instead
       */
      static createAuditLog(data) {
        console.warn("[AuditService] createAuditLog is deprecated, use log instead");
        return this.log(data);
      }
      /**
       * Log an audit event from a request
       * @param req Express request object
       * @param data Partial audit log data
       * @returns Created audit log entry ID
       */
      static async logFromRequest(req, data) {
        const user = req.user || {};
        const userId = user.id || "anonymous";
        const companyId = user.companyId || data.companyId || "unknown";
        const ipAddress = req.ip || req.connection?.remoteAddress || "";
        const userAgent = req.headers?.["user-agent"] || "";
        return _AuditService.log({
          userId,
          companyId,
          action: data.action || "UNKNOWN",
          entity: data.entity || "unknown",
          entityId: data.entityId || "unknown",
          details: {
            ...data.details,
            requestId: req.id,
            method: req.method,
            path: req.path
          },
          ipAddress,
          userAgent,
          ...data
        });
      }
      /**
       * Validates if a string is a valid UUID
       * @param str String to validate
       * @returns True if valid UUID, false otherwise
       */
      static isValidUuid(str) {
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return uuidRegex.test(str);
      }
      /**
       * Ensures a value is a valid UUID or generates a fallback
       * @param id The ID to validate
       * @param source Description of the ID for logging
       * @returns A valid UUID string
       */
      static ensureUuid(id, source) {
        if (!id) {
          const fallbackId = uuidv42();
          console.warn(`[AuditService] Missing ${source}, using generated UUID: ${fallbackId}`);
          return fallbackId;
        }
        if (this.isValidUuid(id)) {
          return id;
        }
        try {
          const namespacedId = uuidv42();
          console.warn(`[AuditService] Non-UUID format ${source}: "${id}", using deterministic mapping`);
          return namespacedId;
        } catch (err) {
          return uuidv42();
        }
      }
      /**
       * Log an audit event
       * @param data Audit log data
       * @returns Created audit log entry ID
       */
      /**
       * Check if environment is development/test by examining environment variables
       * @returns True if in development/test mode
       */
      static isDevelopmentMode() {
        const nodeEnv = process.env.NODE_ENV?.toLowerCase() || "";
        return nodeEnv === "development" || nodeEnv === "test" || nodeEnv === "dev" || !!process.env.REPLIT_ENVIRONMENT || // Check if running on Replit
        !!process.env.IS_TEST_ENV;
      }
      /**
       * Check if the provided ID is likely a test/demo ID
       * @param id The ID to check
       * @returns True if it appears to be a test ID
       */
      static isTestId(id) {
        return /^(test|demo|example|123|000)/.test(id) || /^[0-9]{1,10}$/.test(id) || // Simple numeric IDs like "1234567890"
        id.includes("_test_") || id.includes("_demo_") || id.includes("_example_") || id.includes("comp_") || // IDs with "comp_" prefix
        id === "anonymous";
      }
      static async log(data) {
        const {
          userId,
          companyId,
          franchiseId,
          action,
          entity,
          entityId,
          details,
          ipAddress,
          userAgent
        } = data;
        if (!companyId) {
          console.error("[AuditService] Company ID is required");
          return "";
        }
        const now = /* @__PURE__ */ new Date();
        const auditLogId = uuidv42();
        const isDev = this.isDevelopmentMode();
        const isTestData = this.isTestId(userId) || this.isTestId(companyId);
        if (isDev || isTestData) {
          console.log(`[AuditService] Test/Dev mode: Skipping DB insertion for audit log`);
          console.log(`[AuditService] Audit event: ${action} on ${entity} by user ${userId} in company ${companyId}`);
          return auditLogId;
        }
        try {
          const drizzleService5 = new DrizzleService();
          const validUserId = this.ensureUuid(userId, "userId");
          const validCompanyId = this.ensureUuid(companyId, "companyId");
          const validEntityId = entityId ? this.ensureUuid(entityId, "entityId") : null;
          const enrichedDetails = {
            ...details,
            _originalIds: {
              ...userId !== validUserId && { userId },
              ...companyId !== validCompanyId && { companyId },
              ...entityId && entityId !== validEntityId && { entityId }
            }
          };
          const auditData = {
            id: auditLogId,
            userId: validUserId,
            companyId: validCompanyId,
            // Remove franchiseId as it doesn't exist in the current schema
            action: action.toString(),
            entity,
            entityId: validEntityId || void 0,
            // Use undefined for null entityId
            details: enrichedDetails,
            // Remove ipAddress, userAgent as they may not exist in the current schema
            createdAt: now
            // updatedAt may not exist in the current schema, remove it
          };
          await drizzleService5.db.insert(auditLogs).values(auditData);
          return auditLogId;
        } catch (error) {
          console.error(`[AuditService] Error logging audit event: ${error.message}`);
          return "";
        }
      }
      /**
       * Get audit logs for an entity
       * @param entityType Entity type
       * @param entityId Entity ID
       * @param companyId Company ID
       * @param limit Maximum number of logs to return
       * @returns Array of audit logs
       */
      static async getEntityLogs(entityType, entityId, companyId, limit = 50) {
        try {
          const drizzleService5 = new DrizzleService();
          const logs = await drizzleService5.db.select().from(auditLogs).where(
            and16(
              eq17(auditLogs.entity, entityType),
              eq17(auditLogs.entityId, entityId),
              eq17(auditLogs.companyId, companyId)
            )
          ).orderBy(desc5(auditLogs.createdAt)).limit(limit);
          return logs;
        } catch (error) {
          console.error(`[AuditService] Error fetching entity logs: ${error.message}`);
          return [];
        }
      }
      /**
       * Get audit logs for a user
       * @param userId User ID
       * @param companyId Company ID
       * @param limit Maximum number of logs to return
       * @returns Array of audit logs
       */
      static async getUserLogs(userId, companyId, limit = 50) {
        try {
          const drizzleService5 = new DrizzleService();
          const logs = await drizzleService5.db.select().from(auditLogs).where(
            and16(
              eq17(auditLogs.userId, userId),
              eq17(auditLogs.companyId, companyId)
            )
          ).orderBy(desc5(auditLogs.createdAt)).limit(limit);
          return logs;
        } catch (error) {
          console.error(`[AuditService] Error fetching user logs: ${error.message}`);
          return [];
        }
      }
    };
    audit_service_default = AuditService;
  }
});

// server/modules/admin/controllers/admin.controller.ts
var admin_controller_exports = {};
__export(admin_controller_exports, {
  registerAdminControllerRoutes: () => registerAdminControllerRoutes
});
import { z as z7 } from "zod";
function registerAdminControllerRoutes(app2, userService2) {
  const BASE_PATH = "/api/admin";
  app2.post(`${BASE_PATH}/users`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const validationResult = createUserSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Validation error",
          errors: validationResult.error.errors
        });
      }
      const userData = validationResult.data;
      const user = await userService2.createUser({
        email: userData.email,
        password: userData.password,
        firstName: userData.firstName,
        lastName: userData.lastName,
        companyId: userData.companyId,
        roleIds: userData.roleIds
      });
      const { password, ...userWithoutPassword } = user;
      logger28.info(`User created: ${user.email} by admin: ${req.user?.id}`);
      return res.status(201).json({
        success: true,
        message: "User created successfully",
        data: userWithoutPassword
      });
    } catch (error) {
      logger28.error("Error creating user", error);
      if (error.message && error.message.includes("already exists")) {
        return res.status(409).json({
          success: false,
          message: error.message
        });
      }
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/users`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const page = req.query.page ? parseInt(req.query.page) : 1;
      const limit = req.query.limit ? parseInt(req.query.limit) : 10;
      const companyId = req.query.companyId;
      const status = req.query.status;
      const sortBy = req.query.sortBy;
      const sortDirection = req.query.sortDirection;
      const result = await userService2.getUsers({
        page,
        limit,
        companyId: companyId === "null" ? null : companyId,
        status,
        sortBy,
        sortDirection
      });
      const sanitizedUsers = result.data.map((user) => {
        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
      });
      return res.status(200).json({
        success: true,
        data: sanitizedUsers,
        pagination: result.pagination
      });
    } catch (error) {
      logger28.error("Error retrieving users", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/users/:id`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const userId = req.params.id;
      const user = await userService2.findUserById(userId);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found"
        });
      }
      const { password, ...userWithoutPassword } = user;
      const roles3 = await userService2.getUserRoles(userId);
      return res.status(200).json({
        success: true,
        data: {
          ...userWithoutPassword,
          roles: roles3
        }
      });
    } catch (error) {
      logger28.error(`Error retrieving user with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.patch(`${BASE_PATH}/users/:id`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const userId = req.params.id;
      const existingUser = await userService2.findUserById(userId);
      if (!existingUser) {
        return res.status(404).json({
          success: false,
          message: "User not found"
        });
      }
      const updatedUser = await userService2.updateUser(userId, req.body);
      if (req.body.roleIds && Array.isArray(req.body.roleIds)) {
        await userService2.assignRolesToUser(userId, req.body.roleIds);
      }
      const { password, ...userWithoutPassword } = updatedUser;
      logger28.info(`User updated: ${updatedUser.email} by admin: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "User updated successfully",
        data: userWithoutPassword
      });
    } catch (error) {
      logger28.error(`Error updating user with ID ${req.params.id}`, error);
      if (error.message && error.message.includes("already exists")) {
        return res.status(409).json({
          success: false,
          message: error.message
        });
      }
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.delete(`${BASE_PATH}/users/:id`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const userId = req.params.id;
      const existingUser = await userService2.findUserById(userId);
      if (!existingUser) {
        return res.status(404).json({
          success: false,
          message: "User not found"
        });
      }
      if (userId === req.user?.id) {
        return res.status(403).json({
          success: false,
          message: "Cannot delete your own account"
        });
      }
      const deletedUser = await userService2.softDeleteUser(userId);
      logger28.info(`User deleted: ${deletedUser.email} by admin: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "User deleted successfully"
      });
    } catch (error) {
      logger28.error(`Error deleting user with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/users/:id/roles`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const userId = req.params.id;
      const { roleIds } = req.body;
      if (!roleIds || !Array.isArray(roleIds)) {
        return res.status(400).json({
          success: false,
          message: "Role IDs must be provided as an array"
        });
      }
      const existingUser = await userService2.findUserById(userId);
      if (!existingUser) {
        return res.status(404).json({
          success: false,
          message: "User not found"
        });
      }
      await userService2.assignRolesToUser(userId, roleIds);
      const roles3 = await userService2.getUserRoles(userId);
      logger28.info(`Roles assigned to user: ${existingUser.email} by admin: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Roles assigned successfully",
        data: roles3
      });
    } catch (error) {
      logger28.error(`Error assigning roles to user with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/users/:id/change-password`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const userId = req.params.id;
      const { password } = req.body;
      if (!password || typeof password !== "string" || password.length < 8) {
        return res.status(400).json({
          success: false,
          message: "Password must be at least 8 characters"
        });
      }
      const existingUser = await userService2.findUserById(userId);
      if (!existingUser) {
        return res.status(404).json({
          success: false,
          message: "User not found"
        });
      }
      await userService2.changePassword(userId, password);
      logger28.info(`Password changed for user: ${existingUser.email} by admin: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Password changed successfully"
      });
    } catch (error) {
      logger28.error(`Error changing password for user with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  logger28.info("Admin controller routes registered");
}
var createUserSchema, logger28;
var init_admin_controller = __esm({
  "server/modules/admin/controllers/admin.controller.ts"() {
    "use strict";
    init_logger();
    init_auth_guard();
    init_auth_mode_enum();
    createUserSchema = z7.object({
      email: z7.string().email("Invalid email format"),
      password: z7.string().min(8, "Password must be at least 8 characters"),
      firstName: z7.string().optional(),
      lastName: z7.string().optional(),
      companyId: z7.string().uuid("Invalid company ID format").optional().nullable(),
      roleIds: z7.array(z7.string().uuid("Invalid role ID format")).optional()
    });
    logger28 = new Logger("AdminController");
  }
});

// server/common/guards/roles.guard.ts
var logger29, RolesGuard;
var init_roles_guard = __esm({
  "server/common/guards/roles.guard.ts"() {
    "use strict";
    init_logger();
    logger29 = new Logger("RolesGuard");
    RolesGuard = class {
      constructor(reflector2) {
        this.reflector = reflector2;
      }
      /**
       * Check if the user has the required roles to access the route
       * @param req Express Request object
       * @param res Express Response object
       * @param next Express NextFunction
       */
      canActivate(req, res, next) {
        const requiredRoles = this.reflector.get("roles", req.route?.path);
        if (!requiredRoles || requiredRoles.length === 0) {
          return next();
        }
        if (!req.user) {
          logger29.warn(`Access denied: No user found in request`);
          return res.status(401).json({ success: false, message: "Authentication required" });
        }
        const userRole = req.user.role;
        const userRoles3 = req.user.roles || [userRole];
        const hasRequiredRole = requiredRoles.some((role) => userRoles3.includes(role));
        if (hasRequiredRole) {
          return next();
        }
        logger29.warn(`Access denied: User ${req.user.username} with roles [${userRoles3.join(", ")}] does not have required roles [${requiredRoles.join(", ")}]`);
        return res.status(403).json({ success: false, message: "Insufficient permissions" });
      }
      /**
       * Create middleware function that can be used in Express routes
       */
      createMiddleware() {
        return (req, res, next) => {
          this.canActivate(req, res, next);
        };
      }
    };
  }
});

// server/common/guards/index.ts
var init_guards = __esm({
  "server/common/guards/index.ts"() {
    "use strict";
    init_roles_guard();
  }
});

// server/common/reflector/reflector.ts
var Reflector;
var init_reflector = __esm({
  "server/common/reflector/reflector.ts"() {
    "use strict";
    Reflector = class {
      constructor() {
        this.metadata = /* @__PURE__ */ new Map();
      }
      /**
       * Get metadata for a given key
       * 
       * This method is overridden by the RolesGuard when used in Express routes
       * to provide dynamic access to metadata.
       * 
       * @param metadataKey The metadata key to retrieve
       * @param target The target object or function
       */
      get(metadataKey, target) {
        return this.metadata.get(metadataKey);
      }
      /**
       * Set metadata for a given key and target
       * 
       * @param metadataKey The metadata key
       * @param metadataValue The metadata value
       * @param target The target object or function
       */
      set(metadataKey, metadataValue, target) {
        const key = this.getKeyForTarget(target, metadataKey);
        this.metadata.set(key, metadataValue);
      }
      /**
       * Generate a unique key for the target and metadata key
       */
      getKeyForTarget(target, metadataKey) {
        const targetId = target.constructor?.name || target.name || "unknown";
        return `${targetId}_${metadataKey}`;
      }
    };
  }
});

// server/common/decorators/set-metadata.ts
function SetMetadata(key, value) {
  return function(target, propertyKey, descriptor) {
    reflector.set(key, value, target.constructor || target);
    return descriptor;
  };
}
var reflector;
var init_set_metadata = __esm({
  "server/common/decorators/set-metadata.ts"() {
    "use strict";
    init_reflector();
    reflector = new Reflector();
  }
});

// server/common/decorators/roles.decorator.ts
function Roles(...roles3) {
  return (target, key, descriptor) => {
    return SetMetadata("roles", roles3)(target, key, descriptor);
  };
}
var init_roles_decorator = __esm({
  "server/common/decorators/roles.decorator.ts"() {
    "use strict";
    init_set_metadata();
  }
});

// server/common/decorators/index.ts
var init_decorators = __esm({
  "server/common/decorators/index.ts"() {
    "use strict";
    init_roles_decorator();
  }
});

// server/modules/admin/controllers/user.controller.ts
var user_controller_exports = {};
__export(user_controller_exports, {
  UserController: () => UserController2,
  registerUserControllerRoutes: () => registerUserControllerRoutes
});
import { z as z8 } from "zod";
function registerUserControllerRoutes(app2, userService2) {
  const userController = new UserController2(userService2);
  userController.registerRoutes(app2);
}
var createUserSchema2, logger30, _changePassword_dec, _assignRoles_dec, _deleteUser_dec, _updateUser_dec, _getUserById_dec, _getUsers_dec, _createUser_dec, _init2, UserController2;
var init_user_controller = __esm({
  "server/modules/admin/controllers/user.controller.ts"() {
    "use strict";
    init_logger();
    init_auth_guard();
    init_auth_mode_enum();
    init_guards();
    init_decorators();
    init_reflector();
    createUserSchema2 = z8.object({
      email: z8.string().email("Invalid email format"),
      password: z8.string().min(8, "Password must be at least 8 characters"),
      firstName: z8.string().optional(),
      lastName: z8.string().optional(),
      companyId: z8.string().uuid("Invalid company ID format").optional().nullable(),
      roleIds: z8.array(z8.string().uuid("Invalid role ID format")).optional()
    });
    logger30 = new Logger("UserController");
    _createUser_dec = [Roles("admin")], _getUsers_dec = [Roles("admin", "manager")], _getUserById_dec = [Roles("admin", "manager")], _updateUser_dec = [Roles("admin")], _deleteUser_dec = [Roles("admin")], _assignRoles_dec = [Roles("admin")], _changePassword_dec = [Roles("admin")];
    UserController2 = class {
      constructor(userService2) {
        this.userService = userService2;
        __runInitializers(_init2, 5, this);
        this.reflector = void 0;
        this.rolesGuard = void 0;
        this.reflector = new Reflector();
        this.rolesGuard = new RolesGuard(this.reflector);
      }
      /**
       * Create a middleware function that applies the RolesGuard with specified roles
       */
      applyRoles(roles3) {
        return [
          AuthGuard.protect("required" /* REQUIRED */),
          (req, res, next) => {
            this.reflector.get = function() {
              return roles3;
            };
            this.rolesGuard.canActivate(req, res, next);
          }
        ];
      }
      async createUser(req, res) {
        try {
          const validationResult = createUserSchema2.safeParse(req.body);
          if (!validationResult.success) {
            return res.status(400).json({
              success: false,
              message: "Validation error",
              errors: validationResult.error.errors
            });
          }
          const userData = validationResult.data;
          const user = await this.userService.createUser({
            email: userData.email,
            password: userData.password,
            firstName: userData.firstName,
            lastName: userData.lastName,
            companyId: userData.companyId,
            roleIds: userData.roleIds
          });
          const { password, ...userWithoutPassword } = user;
          logger30.info(`User created: ${user.email} by admin: ${req.user?.id}`);
          return res.status(201).json({
            success: true,
            message: "User created successfully",
            data: userWithoutPassword
          });
        } catch (error) {
          logger30.error("Error creating user", error);
          if (error.message && error.message.includes("already exists")) {
            return res.status(409).json({
              success: false,
              message: error.message
            });
          }
          return res.status(500).json({
            success: false,
            message: "Internal server error"
          });
        }
      }
      async getUsers(req, res) {
        try {
          const page = req.query.page ? parseInt(req.query.page) : 1;
          const limit = req.query.limit ? parseInt(req.query.limit) : 10;
          const companyId = req.query.companyId;
          const status = req.query.status;
          const sortBy = req.query.sortBy;
          const sortDirection = req.query.sortDirection;
          const result = await this.userService.getUsers({
            page,
            limit,
            companyId: companyId === "null" ? null : companyId,
            status,
            sortBy,
            sortDirection
          });
          const sanitizedUsers = result.data.map((user) => {
            const { password, ...userWithoutPassword } = user;
            return userWithoutPassword;
          });
          return res.status(200).json({
            success: true,
            data: sanitizedUsers,
            pagination: result.pagination
          });
        } catch (error) {
          logger30.error("Error retrieving users", error);
          return res.status(500).json({
            success: false,
            message: "Internal server error"
          });
        }
      }
      async getUserById(req, res) {
        try {
          const userId = req.params.id;
          const user = await this.userService.findUserById(userId);
          if (!user) {
            return res.status(404).json({
              success: false,
              message: "User not found"
            });
          }
          const { password, ...userWithoutPassword } = user;
          const roles3 = await this.userService.getUserRoles(userId);
          return res.status(200).json({
            success: true,
            data: {
              ...userWithoutPassword,
              roles: roles3
            }
          });
        } catch (error) {
          logger30.error(`Error retrieving user with ID ${req.params.id}`, error);
          return res.status(500).json({
            success: false,
            message: "Internal server error"
          });
        }
      }
      async updateUser(req, res) {
        try {
          const userId = req.params.id;
          const existingUser = await this.userService.findUserById(userId);
          if (!existingUser) {
            return res.status(404).json({
              success: false,
              message: "User not found"
            });
          }
          const updatedUser = await this.userService.updateUser(userId, req.body);
          if (req.body.roleIds && Array.isArray(req.body.roleIds)) {
            await this.userService.assignRolesToUser(userId, req.body.roleIds);
          }
          const { password, ...userWithoutPassword } = updatedUser;
          logger30.info(`User updated: ${updatedUser.email} by admin: ${req.user?.id}`);
          return res.status(200).json({
            success: true,
            message: "User updated successfully",
            data: userWithoutPassword
          });
        } catch (error) {
          logger30.error(`Error updating user with ID ${req.params.id}`, error);
          if (error.message && error.message.includes("already exists")) {
            return res.status(409).json({
              success: false,
              message: error.message
            });
          }
          return res.status(500).json({
            success: false,
            message: "Internal server error"
          });
        }
      }
      async deleteUser(req, res) {
        try {
          const userId = req.params.id;
          const existingUser = await this.userService.findUserById(userId);
          if (!existingUser) {
            return res.status(404).json({
              success: false,
              message: "User not found"
            });
          }
          if (userId === req.user?.id) {
            return res.status(403).json({
              success: false,
              message: "Cannot delete your own account"
            });
          }
          const deletedUser = await this.userService.softDeleteUser(userId);
          logger30.info(`User deleted: ${deletedUser.email} by admin: ${req.user?.id}`);
          return res.status(200).json({
            success: true,
            message: "User deleted successfully"
          });
        } catch (error) {
          logger30.error(`Error deleting user with ID ${req.params.id}`, error);
          return res.status(500).json({
            success: false,
            message: "Internal server error"
          });
        }
      }
      async assignRoles(req, res) {
        try {
          const userId = req.params.id;
          const { roleIds } = req.body;
          if (!roleIds || !Array.isArray(roleIds)) {
            return res.status(400).json({
              success: false,
              message: "Role IDs must be provided as an array"
            });
          }
          const existingUser = await this.userService.findUserById(userId);
          if (!existingUser) {
            return res.status(404).json({
              success: false,
              message: "User not found"
            });
          }
          await this.userService.assignRolesToUser(userId, roleIds);
          const roles3 = await this.userService.getUserRoles(userId);
          logger30.info(`Roles assigned to user: ${existingUser.email} by admin: ${req.user?.id}`);
          return res.status(200).json({
            success: true,
            message: "Roles assigned successfully",
            data: roles3
          });
        } catch (error) {
          logger30.error(`Error assigning roles to user with ID ${req.params.id}`, error);
          return res.status(500).json({
            success: false,
            message: "Internal server error"
          });
        }
      }
      async changePassword(req, res) {
        try {
          const userId = req.params.id;
          const { password } = req.body;
          if (!password || typeof password !== "string" || password.length < 8) {
            return res.status(400).json({
              success: false,
              message: "Password must be at least 8 characters"
            });
          }
          const existingUser = await this.userService.findUserById(userId);
          if (!existingUser) {
            return res.status(404).json({
              success: false,
              message: "User not found"
            });
          }
          await this.userService.changePassword(userId, password);
          logger30.info(`Password changed for user: ${existingUser.email} by admin: ${req.user?.id}`);
          return res.status(200).json({
            success: true,
            message: "Password changed successfully"
          });
        } catch (error) {
          logger30.error(`Error changing password for user with ID ${req.params.id}`, error);
          return res.status(500).json({
            success: false,
            message: "Internal server error"
          });
        }
      }
      /**
       * Register the user controller routes with the Express application
       * @param app Express application
       */
      registerRoutes(app2) {
        const BASE_PATH = "/api/admin";
        app2.post(
          `${BASE_PATH}/users`,
          ...this.applyRoles(["admin"]),
          this.createUser.bind(this)
        );
        app2.get(
          `${BASE_PATH}/users`,
          ...this.applyRoles(["admin", "manager"]),
          this.getUsers.bind(this)
        );
        app2.get(
          `${BASE_PATH}/users/:id`,
          ...this.applyRoles(["admin", "manager"]),
          this.getUserById.bind(this)
        );
        app2.patch(
          `${BASE_PATH}/users/:id`,
          ...this.applyRoles(["admin"]),
          this.updateUser.bind(this)
        );
        app2.delete(
          `${BASE_PATH}/users/:id`,
          ...this.applyRoles(["admin"]),
          this.deleteUser.bind(this)
        );
        app2.post(
          `${BASE_PATH}/users/:id/roles`,
          ...this.applyRoles(["admin"]),
          this.assignRoles.bind(this)
        );
        app2.post(
          `${BASE_PATH}/users/:id/change-password`,
          ...this.applyRoles(["admin"]),
          this.changePassword.bind(this)
        );
        logger30.info("User controller routes registered with @Roles() decorator");
      }
    };
    _init2 = __decoratorStart(null);
    __decorateElement(_init2, 1, "createUser", _createUser_dec, UserController2);
    __decorateElement(_init2, 1, "getUsers", _getUsers_dec, UserController2);
    __decorateElement(_init2, 1, "getUserById", _getUserById_dec, UserController2);
    __decorateElement(_init2, 1, "updateUser", _updateUser_dec, UserController2);
    __decorateElement(_init2, 1, "deleteUser", _deleteUser_dec, UserController2);
    __decorateElement(_init2, 1, "assignRoles", _assignRoles_dec, UserController2);
    __decorateElement(_init2, 1, "changePassword", _changePassword_dec, UserController2);
    __decoratorMetadata(_init2, UserController2);
  }
});

// server/modules/admin/controllers/role.controller.ts
var role_controller_exports = {};
__export(role_controller_exports, {
  registerRoleControllerRoutes: () => registerRoleControllerRoutes
});
import { z as z9 } from "zod";
import { drizzle as drizzle2 } from "drizzle-orm/postgres-js";
import postgres2 from "postgres";
function registerRoleControllerRoutes(app2, roleService) {
  const BASE_PATH = "/api/admin/roles";
  app2.get(BASE_PATH, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const page = req.query.page ? parseInt(req.query.page) : 1;
      const limit = req.query.limit ? parseInt(req.query.limit) : 100;
      const search = req.query.search;
      const roles3 = await roleService.findRoles(page, limit, search);
      return res.status(200).json({
        success: true,
        data: roles3.data,
        pagination: roles3.pagination
      });
    } catch (error) {
      logger31.error("Error retrieving roles", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/:companyId`, AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
    try {
      const companyId = req.params.companyId;
      logger31.info(`Getting roles for company ${companyId}`);
      const roles3 = await roleService.getRolesByCompany(companyId);
      return res.status(200).json({
        success: true,
        data: roles3
      });
    } catch (error) {
      logger31.error(`Error retrieving roles for company ${req.params.companyId}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/:id`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const roleId = req.params.id;
      const role = await roleService.findRoleById(roleId);
      if (!role) {
        return res.status(404).json({
          success: false,
          message: "Role not found"
        });
      }
      const permissions4 = await roleService.getRolePermissions(roleId);
      return res.status(200).json({
        success: true,
        data: {
          ...role,
          permissions: permissions4
        }
      });
    } catch (error) {
      logger31.error(`Error retrieving role with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(BASE_PATH, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const validationResult = createRoleSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Validation error",
          errors: validationResult.error.errors
        });
      }
      const roleData = validationResult.data;
      const role = await roleService.createRole({
        name: roleData.name,
        description: roleData.description || ""
      });
      if (roleData.permissionIds && roleData.permissionIds.length > 0) {
        await roleService.assignPermissionsToRole(role.id, roleData.permissionIds);
      }
      const createdRole = await roleService.findRoleById(role.id);
      const permissions4 = await roleService.getRolePermissions(role.id);
      logger31.info(`Role created: ${role.name} by user: ${req.user?.id}`);
      return res.status(201).json({
        success: true,
        message: "Role created successfully",
        data: {
          ...createdRole,
          permissions: permissions4
        }
      });
    } catch (error) {
      logger31.error("Error creating role", error);
      if (error.message && error.message.includes("already exists")) {
        return res.status(409).json({
          success: false,
          message: error.message
        });
      }
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.patch(`${BASE_PATH}/:id`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const roleId = req.params.id;
      const validationResult = updateRoleSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Validation error",
          errors: validationResult.error.errors
        });
      }
      const existingRole = await roleService.findRoleById(roleId);
      if (!existingRole) {
        return res.status(404).json({
          success: false,
          message: "Role not found"
        });
      }
      if (existingRole.isSystem) {
        return res.status(403).json({
          success: false,
          message: "System roles cannot be modified"
        });
      }
      const roleData = validationResult.data;
      const updatedRole = await roleService.updateRole(roleId, {
        name: roleData.name,
        description: roleData.description
      });
      if (roleData.permissionIds !== void 0) {
        await roleService.assignPermissionsToRole(roleId, roleData.permissionIds);
      }
      const roleWithPermissions = await roleService.findRoleById(roleId);
      const permissions4 = await roleService.getRolePermissions(roleId);
      logger31.info(`Role updated: ${updatedRole.name} by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Role updated successfully",
        data: {
          ...roleWithPermissions,
          permissions: permissions4
        }
      });
    } catch (error) {
      logger31.error(`Error updating role with ID ${req.params.id}`, error);
      if (error.message && error.message.includes("already exists")) {
        return res.status(409).json({
          success: false,
          message: error.message
        });
      }
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.delete(`${BASE_PATH}/:id`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const roleId = req.params.id;
      const existingRole = await roleService.findRoleById(roleId);
      if (!existingRole) {
        return res.status(404).json({
          success: false,
          message: "Role not found"
        });
      }
      if (existingRole.isSystem) {
        return res.status(403).json({
          success: false,
          message: "System roles cannot be deleted"
        });
      }
      const roleUsers = await roleService.getRoleUsers(roleId);
      if (roleUsers.length > 0) {
        return res.status(409).json({
          success: false,
          message: "Cannot delete role that is assigned to users",
          data: {
            userCount: roleUsers.length
          }
        });
      }
      await roleService.deleteRole(roleId);
      logger31.info(`Role deleted: ${existingRole.name} by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Role deleted successfully"
      });
    } catch (error) {
      logger31.error(`Error deleting role with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get("/api/admin/permissions", AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const connectionString = process.env.DATABASE_URL || "";
      const client = postgres2(connectionString);
      const db4 = drizzle2(client);
      logger31.debug("Getting permissions directly from database");
      const permissions4 = await db4.execute(
        "SELECT id, name, description, resource, action, created_at, updated_at FROM permissions"
      );
      logger31.debug(`Retrieved ${permissions4.length} permissions`);
      await client.end();
      return res.status(200).json({
        success: true,
        data: permissions4
      });
    } catch (error) {
      logger31.error("Error retrieving permissions", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/:id/permissions`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const roleId = req.params.id;
      const { permissionIds } = req.body;
      if (!permissionIds || !Array.isArray(permissionIds)) {
        return res.status(400).json({
          success: false,
          message: "Permission IDs must be provided as an array"
        });
      }
      const existingRole = await roleService.findRoleById(roleId);
      if (!existingRole) {
        return res.status(404).json({
          success: false,
          message: "Role not found"
        });
      }
      if (existingRole.isSystem) {
        return res.status(403).json({
          success: false,
          message: "Permissions for system roles cannot be modified"
        });
      }
      await roleService.assignPermissionsToRole(roleId, permissionIds);
      const permissions4 = await roleService.getRolePermissions(roleId);
      logger31.info(`Permissions assigned to role: ${existingRole.name} by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Permissions assigned successfully",
        data: permissions4
      });
    } catch (error) {
      logger31.error(`Error assigning permissions to role with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/:id/users`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const roleId = req.params.id;
      const existingRole = await roleService.findRoleById(roleId);
      if (!existingRole) {
        return res.status(404).json({
          success: false,
          message: "Role not found"
        });
      }
      const users3 = await roleService.getRoleUsers(roleId);
      const sanitizedUsers = users3.map((user) => {
        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
      });
      return res.status(200).json({
        success: true,
        data: sanitizedUsers
      });
    } catch (error) {
      logger31.error(`Error retrieving users for role with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  logger31.info("Role controller routes registered");
}
var createRoleSchema, updateRoleSchema, logger31;
var init_role_controller = __esm({
  "server/modules/admin/controllers/role.controller.ts"() {
    "use strict";
    init_logger();
    init_auth_guard();
    init_auth_mode_enum();
    createRoleSchema = z9.object({
      name: z9.string().min(2, "Role name must be at least 2 characters"),
      description: z9.string().optional(),
      permissionIds: z9.array(z9.string().uuid("Invalid permission ID format")).optional()
    });
    updateRoleSchema = z9.object({
      name: z9.string().min(2, "Role name must be at least 2 characters").optional(),
      description: z9.string().optional(),
      permissionIds: z9.array(z9.string().uuid("Invalid permission ID format")).optional()
    });
    logger31 = new Logger("RoleController");
  }
});

// server/modules/admin/controllers/api-key.controller.ts
var api_key_controller_exports = {};
__export(api_key_controller_exports, {
  registerApiKeyControllerRoutes: () => registerApiKeyControllerRoutes
});
import { z as z10 } from "zod";
function registerApiKeyControllerRoutes(app2, apiKeyService) {
  const BASE_PATH = "/api/admin/api-keys";
  app2.get(BASE_PATH, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const page = req.query.page ? parseInt(req.query.page) : 1;
      const limit = req.query.limit ? parseInt(req.query.limit) : 10;
      const companyId = req.query.companyId;
      const isActive = req.query.isActive ? req.query.isActive === "true" : void 0;
      const result = await apiKeyService.getApiKeys({
        page,
        limit,
        companyId: companyId === "null" ? null : companyId,
        isActive
      });
      return res.status(200).json({
        success: true,
        data: result.data,
        pagination: result.pagination
      });
    } catch (error) {
      logger32.error("Error retrieving API keys", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/:id`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const apiKeyId = req.params.id;
      const apiKey = await apiKeyService.getApiKeyById(apiKeyId);
      if (!apiKey) {
        return res.status(404).json({
          success: false,
          message: "API key not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: apiKey
      });
    } catch (error) {
      logger32.error(`Error retrieving API key with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(BASE_PATH, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const validationResult = createApiKeySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Validation error",
          errors: validationResult.error.errors
        });
      }
      const apiKeyData = validationResult.data;
      const createdApiKey = await apiKeyService.createApiKey({
        name: apiKeyData.name,
        description: apiKeyData.description || "",
        expiresAt: apiKeyData.expiresAt ? new Date(apiKeyData.expiresAt) : void 0,
        scopes: apiKeyData.scopes || [],
        companyId: apiKeyData.companyId,
        createdBy: req.user?.id || ""
      });
      logger32.info(`API key created: ${apiKeyData.name} by user: ${req.user?.id}`);
      return res.status(201).json({
        success: true,
        message: "API key created successfully",
        data: createdApiKey
      });
    } catch (error) {
      logger32.error("Error creating API key", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.patch(`${BASE_PATH}/:id`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const apiKeyId = req.params.id;
      const validationResult = updateApiKeySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Validation error",
          errors: validationResult.error.errors
        });
      }
      const existingApiKey = await apiKeyService.getApiKeyById(apiKeyId);
      if (!existingApiKey) {
        return res.status(404).json({
          success: false,
          message: "API key not found"
        });
      }
      const apiKeyData = validationResult.data;
      const updatedApiKey = await apiKeyService.updateApiKey(apiKeyId, {
        name: apiKeyData.name,
        description: apiKeyData.description,
        expiresAt: apiKeyData.expiresAt ? new Date(apiKeyData.expiresAt) : void 0,
        scopes: apiKeyData.scopes,
        isActive: apiKeyData.isActive
      });
      logger32.info(`API key updated: ${existingApiKey.name} by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "API key updated successfully",
        data: updatedApiKey
      });
    } catch (error) {
      logger32.error(`Error updating API key with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.delete(`${BASE_PATH}/:id`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const apiKeyId = req.params.id;
      const existingApiKey = await apiKeyService.getApiKeyById(apiKeyId);
      if (!existingApiKey) {
        return res.status(404).json({
          success: false,
          message: "API key not found"
        });
      }
      await apiKeyService.revokeApiKey(apiKeyId);
      logger32.info(`API key revoked: ${existingApiKey.name} by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "API key revoked successfully"
      });
    } catch (error) {
      logger32.error(`Error revoking API key with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/scopes`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const scopes = await apiKeyService.getAvailableScopes();
      return res.status(200).json({
        success: true,
        data: scopes
      });
    } catch (error) {
      logger32.error("Error retrieving API key scopes", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/:id/regenerate`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const apiKeyId = req.params.id;
      const existingApiKey = await apiKeyService.getApiKeyById(apiKeyId);
      if (!existingApiKey) {
        return res.status(404).json({
          success: false,
          message: "API key not found"
        });
      }
      const regeneratedApiKey = await apiKeyService.regenerateApiKey(apiKeyId);
      logger32.info(`API key regenerated: ${existingApiKey.name} by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "API key regenerated successfully",
        data: regeneratedApiKey
      });
    } catch (error) {
      logger32.error(`Error regenerating API key with ID ${req.params.id}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  logger32.info("API key controller routes registered");
}
var createApiKeySchema, updateApiKeySchema, logger32;
var init_api_key_controller = __esm({
  "server/modules/admin/controllers/api-key.controller.ts"() {
    "use strict";
    init_logger();
    init_auth_guard();
    init_auth_mode_enum();
    createApiKeySchema = z10.object({
      name: z10.string().min(2, "API key name must be at least 2 characters"),
      description: z10.string().optional(),
      expiresAt: z10.string().datetime().optional(),
      scopes: z10.array(z10.string()).optional(),
      companyId: z10.string().uuid("Invalid company ID format").optional().nullable()
    });
    updateApiKeySchema = z10.object({
      name: z10.string().min(2, "API key name must be at least 2 characters").optional(),
      description: z10.string().optional(),
      expiresAt: z10.string().datetime().optional(),
      scopes: z10.array(z10.string()).optional(),
      isActive: z10.boolean().optional()
    });
    logger32 = new Logger("ApiKeyController");
  }
});

// server/modules/admin/controllers/config.controller.ts
var config_controller_exports = {};
__export(config_controller_exports, {
  registerConfigControllerRoutes: () => registerConfigControllerRoutes
});
function registerConfigControllerRoutes(app2, configService) {
  const BASE_PATH = "/api/admin/config";
  app2.get(BASE_PATH, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const configs = await configService.getAllConfigs();
      return res.status(200).json({
        success: true,
        data: configs
      });
    } catch (error) {
      logger33.error("Error retrieving configuration settings", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/:key`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const key = req.params.key;
      const config3 = await configService.getConfig(key);
      if (!config3) {
        return res.status(404).json({
          success: false,
          message: "Configuration setting not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: config3
      });
    } catch (error) {
      logger33.error(`Error retrieving configuration setting with key ${req.params.key}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.put(`${BASE_PATH}/:key`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const key = req.params.key;
      const { value, description } = req.body;
      if (value === void 0) {
        return res.status(400).json({
          success: false,
          message: "Value is required"
        });
      }
      const updatedConfig = await configService.setConfig(key, value, description);
      logger33.info(`Configuration setting updated: ${key} by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Configuration setting updated successfully",
        data: updatedConfig
      });
    } catch (error) {
      logger33.error(`Error updating configuration setting with key ${req.params.key}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.delete(`${BASE_PATH}/:key`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const key = req.params.key;
      const existingConfig = await configService.getConfig(key);
      if (!existingConfig) {
        return res.status(404).json({
          success: false,
          message: "Configuration setting not found"
        });
      }
      await configService.deleteConfig(key);
      logger33.info(`Configuration setting deleted: ${key} by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Configuration setting deleted successfully"
      });
    } catch (error) {
      logger33.error(`Error deleting configuration setting with key ${req.params.key}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/category/:category`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const category = req.params.category;
      const configs = await configService.getConfigsByCategory(category);
      return res.status(200).json({
        success: true,
        data: configs
      });
    } catch (error) {
      logger33.error(`Error retrieving configuration settings for category ${req.params.category}`, error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.patch(`${BASE_PATH}/batch`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const { configs } = req.body;
      if (!configs || !Array.isArray(configs)) {
        return res.status(400).json({
          success: false,
          message: "Configs must be provided as an array"
        });
      }
      for (const config3 of configs) {
        if (!config3.key || config3.value === void 0) {
          return res.status(400).json({
            success: false,
            message: "Each config item must have a key and value"
          });
        }
      }
      const results = await Promise.all(
        configs.map((config3) => configService.setConfig(config3.key, config3.value, config3.description))
      );
      logger33.info(`Batch configuration update by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Configuration settings updated successfully",
        data: results
      });
    } catch (error) {
      logger33.error("Error updating configuration settings in batch", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/reset`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      await configService.resetToDefaults();
      logger33.info(`Configuration settings reset to defaults by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Configuration settings reset to defaults successfully"
      });
    } catch (error) {
      logger33.error("Error resetting configuration settings to defaults", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  logger33.info("Config controller routes registered");
}
var logger33;
var init_config_controller = __esm({
  "server/modules/admin/controllers/config.controller.ts"() {
    "use strict";
    init_logger();
    init_auth_guard();
    init_auth_mode_enum();
    logger33 = new Logger("ConfigController");
  }
});

// server/modules/admin/controllers/health-check.controller.ts
var health_check_controller_exports = {};
__export(health_check_controller_exports, {
  registerHealthCheckControllerRoutes: () => registerHealthCheckControllerRoutes
});
function registerHealthCheckControllerRoutes(app2, healthCheckService) {
  const BASE_PATH = "/api/admin/health";
  app2.get("/api/health", async (req, res) => {
    try {
      const health = await healthCheckService.getBasicHealthCheck();
      return res.status(health.status === "healthy" ? 200 : 503).json({
        status: health.status,
        timestamp: health.timestamp
      });
    } catch (error) {
      logger34.error("Error checking system health", error);
      return res.status(500).json({
        status: "error",
        message: "Failed to check system health"
      });
    }
  });
  app2.get(BASE_PATH, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const health = await healthCheckService.getDetailedHealthCheck();
      return res.status(health.status === "healthy" ? 200 : health.status === "degraded" ? 429 : 503).json(health);
    } catch (error) {
      logger34.error("Error checking detailed system health", error);
      return res.status(500).json({
        status: "error",
        message: "Failed to check system health"
      });
    }
  });
  app2.get(`${BASE_PATH}/:check`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const checkName = req.params.check;
      const checkResult = await healthCheckService.runHealthCheck(checkName);
      if (!checkResult) {
        return res.status(404).json({
          success: false,
          message: `Health check '${checkName}' not found`
        });
      }
      return res.status(checkResult.status === "healthy" ? 200 : 503).json(checkResult);
    } catch (error) {
      logger34.error(`Error running health check ${req.params.check}`, error);
      return res.status(500).json({
        status: "error",
        message: `Failed to run health check ${req.params.check}`
      });
    }
  });
  app2.get(`${BASE_PATH}/history`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit) : 10;
      const offset = req.query.offset ? parseInt(req.query.offset) : 0;
      const fromDate = req.query.fromDate ? new Date(req.query.fromDate) : void 0;
      const toDate = req.query.toDate ? new Date(req.query.toDate) : void 0;
      const history = await healthCheckService.getHealthCheckHistory(limit, offset, fromDate, toDate);
      return res.status(200).json({
        success: true,
        data: history
      });
    } catch (error) {
      logger34.error("Error retrieving health check history", error);
      return res.status(500).json({
        success: false,
        message: "Failed to retrieve health check history"
      });
    }
  });
  app2.get(`${BASE_PATH}/resources`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const resources = await healthCheckService.getSystemResourceUsage();
      return res.status(200).json({
        success: true,
        data: resources
      });
    } catch (error) {
      logger34.error("Error retrieving system resource usage", error);
      return res.status(500).json({
        success: false,
        message: "Failed to retrieve system resource usage"
      });
    }
  });
  app2.post(`${BASE_PATH}/check-all`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const results = await healthCheckService.runAllHealthChecks();
      return res.status(200).json({
        success: true,
        data: results
      });
    } catch (error) {
      logger34.error("Error running all health checks", error);
      return res.status(500).json({
        success: false,
        message: "Failed to run all health checks"
      });
    }
  });
  app2.get(`${BASE_PATH}/checks`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const checks = await healthCheckService.getAvailableHealthChecks();
      return res.status(200).json({
        success: true,
        data: checks
      });
    } catch (error) {
      logger34.error("Error retrieving available health checks", error);
      return res.status(500).json({
        success: false,
        message: "Failed to retrieve available health checks"
      });
    }
  });
  logger34.info("Health check controller routes registered");
}
var logger34;
var init_health_check_controller = __esm({
  "server/modules/admin/controllers/health-check.controller.ts"() {
    "use strict";
    init_logger();
    init_auth_guard();
    init_auth_mode_enum();
    logger34 = new Logger("HealthCheckController");
  }
});

// server/modules/admin/controllers/license.controller.ts
var license_controller_exports = {};
__export(license_controller_exports, {
  registerLicenseControllerRoutes: () => registerLicenseControllerRoutes
});
import { z as z11 } from "zod";
function registerLicenseControllerRoutes(app2, licenseService) {
  const BASE_PATH = "/api/admin/license";
  app2.get(BASE_PATH, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const license = await licenseService.getLicenseInfo();
      if (!license) {
        return res.status(404).json({
          success: false,
          message: "No license found"
        });
      }
      return res.status(200).json({
        success: true,
        data: license
      });
    } catch (error) {
      logger35.error("Error retrieving license information", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/activate`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const validationResult = activateLicenseSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Validation error",
          errors: validationResult.error.errors
        });
      }
      const { licenseKey, email, companyName } = validationResult.data;
      const activationResult = await licenseService.activateLicense(licenseKey, email, companyName);
      if (!activationResult.success) {
        return res.status(400).json({
          success: false,
          message: activationResult.message
        });
      }
      logger35.info(`License activated by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "License activated successfully",
        data: activationResult.license
      });
    } catch (error) {
      logger35.error("Error activating license", error);
      return res.status(500).json({
        success: false,
        message: error.message || "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/verify`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const verificationResult = await licenseService.verifyLicense();
      return res.status(200).json({
        success: true,
        data: verificationResult
      });
    } catch (error) {
      logger35.error("Error verifying license", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/deactivate`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const deactivationResult = await licenseService.deactivateLicense();
      if (!deactivationResult.success) {
        return res.status(400).json({
          success: false,
          message: deactivationResult.message
        });
      }
      logger35.info(`License deactivated by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "License deactivated successfully"
      });
    } catch (error) {
      logger35.error("Error deactivating license", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/usage`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const usage = await licenseService.getLicenseUsage();
      return res.status(200).json({
        success: true,
        data: usage
      });
    } catch (error) {
      logger35.error("Error retrieving license usage", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/features`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const features = await licenseService.getLicenseFeatures();
      return res.status(200).json({
        success: true,
        data: features
      });
    } catch (error) {
      logger35.error("Error retrieving license features", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/history`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const history = await licenseService.getLicenseHistory();
      return res.status(200).json({
        success: true,
        data: history
      });
    } catch (error) {
      logger35.error("Error retrieving license history", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  logger35.info("License controller routes registered");
}
var logger35, activateLicenseSchema;
var init_license_controller = __esm({
  "server/modules/admin/controllers/license.controller.ts"() {
    "use strict";
    init_logger();
    init_auth_guard();
    init_auth_mode_enum();
    logger35 = new Logger("LicenseController");
    activateLicenseSchema = z11.object({
      licenseKey: z11.string().min(1, "License key is required"),
      email: z11.string().email("Invalid email format"),
      companyName: z11.string().optional()
    });
  }
});

// server/modules/admin/controllers/setup.controller.ts
var setup_controller_exports = {};
__export(setup_controller_exports, {
  registerSetupControllerRoutes: () => registerSetupControllerRoutes
});
import { z as z12 } from "zod";
function registerSetupControllerRoutes(app2, setupService) {
  const BASE_PATH = "/api/admin/setup";
  app2.get(`${BASE_PATH}/status`, async (req, res) => {
    try {
      const status = await setupService.checkSetupStatus();
      return res.status(200).json({
        success: true,
        data: status
      });
    } catch (error) {
      logger36.error("Error checking setup status", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/initialize`, async (req, res) => {
    try {
      const status = await setupService.checkSetupStatus();
      if (status.isSetup) {
        return res.status(400).json({
          success: false,
          message: "System is already set up"
        });
      }
      const validationResult = initialSetupSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Validation error",
          errors: validationResult.error.errors
        });
      }
      const setupData = validationResult.data;
      const result = await setupService.performInitialSetup(
        setupData.adminUser,
        setupData.company,
        setupData.systemSettings
      );
      logger36.info("System successfully initialized");
      return res.status(200).json({
        success: true,
        message: "System successfully initialized",
        data: result
      });
    } catch (error) {
      logger36.error("Error during system initialization", error);
      return res.status(500).json({
        success: false,
        message: error.message || "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/database`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const status = await setupService.checkDatabaseStatus();
      return res.status(200).json({
        success: true,
        data: status
      });
    } catch (error) {
      logger36.error("Error checking database status", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/database/migrate`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const result = await setupService.runDatabaseMigrations();
      logger36.info(`Database migrations executed by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: "Database migrations executed successfully",
        data: result
      });
    } catch (error) {
      logger36.error("Error running database migrations", error);
      return res.status(500).json({
        success: false,
        message: error.message || "Internal server error"
      });
    }
  });
  app2.post(`${BASE_PATH}/database/seed`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const { dataset } = req.body;
      if (!dataset || typeof dataset !== "string") {
        return res.status(400).json({
          success: false,
          message: "Dataset parameter is required"
        });
      }
      const result = await setupService.seedDatabase(dataset);
      logger36.info(`Database seeded with ${dataset} data by user: ${req.user?.id}`);
      return res.status(200).json({
        success: true,
        message: `Database seeded with ${dataset} data successfully`,
        data: result
      });
    } catch (error) {
      logger36.error("Error seeding database", error);
      return res.status(500).json({
        success: false,
        message: error.message || "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/requirements`, async (req, res) => {
    try {
      const requirements = await setupService.checkSystemRequirements();
      return res.status(200).json({
        success: true,
        data: requirements
      });
    } catch (error) {
      logger36.error("Error checking system requirements", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/system-info`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const systemInfo = await setupService.getSystemInformation();
      return res.status(200).json({
        success: true,
        data: systemInfo
      });
    } catch (error) {
      logger36.error("Error retrieving system information", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  app2.get(`${BASE_PATH}/database/seed-datasets`, AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
    try {
      const datasets = await setupService.getAvailableSeedDatasets();
      return res.status(200).json({
        success: true,
        data: datasets
      });
    } catch (error) {
      logger36.error("Error retrieving available seed datasets", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error"
      });
    }
  });
  logger36.info("Setup controller routes registered");
}
var initialSetupSchema, logger36;
var init_setup_controller = __esm({
  "server/modules/admin/controllers/setup.controller.ts"() {
    "use strict";
    init_logger();
    init_auth_guard();
    init_auth_mode_enum();
    initialSetupSchema = z12.object({
      adminUser: z12.object({
        email: z12.string().email("Invalid email format"),
        password: z12.string().min(8, "Password must be at least 8 characters"),
        firstName: z12.string().optional(),
        lastName: z12.string().optional()
      }),
      company: z12.object({
        name: z12.string().min(1, "Company name is required"),
        fiscalCode: z12.string().optional(),
        registrationNumber: z12.string().optional(),
        address: z12.string().optional(),
        phone: z12.string().optional(),
        email: z12.string().email("Invalid email format").optional()
      }).optional(),
      systemSettings: z12.record(z12.any()).optional()
    });
    logger36 = new Logger("SetupController");
  }
});

// server/common/services/notification.service.ts
var NotificationService, notificationService;
var init_notification_service = __esm({
  "server/common/services/notification.service.ts"() {
    "use strict";
    init_logger();
    NotificationService = class {
      constructor() {
        this.logger = new Logger("NotificationService");
      }
      /**
       * Send a notification to a specific target
       * 
       * @param targetType The type of target (user, role, email, etc.)
       * @param targetId The ID of the target (user ID, role name, email address)
       * @param notification The notification payload
       * @returns Object indicating success or failure
       */
      async sendNotification(targetType, targetId, notification) {
        this.logger.info(
          `Notification sent to ${targetType}:${targetId}`,
          {
            title: notification.title,
            type: notification.type,
            priority: notification.priority || "medium" /* MEDIUM */
          }
        );
        this.logger.debug(
          `Notification content`,
          {
            ...notification,
            target: { type: targetType, id: targetId }
          }
        );
        return {
          success: true,
          id: `notification-${Date.now()}`,
          message: `Notification sent to ${targetType}:${targetId}`,
          timestamp: /* @__PURE__ */ new Date()
        };
      }
      /**
       * Send a notification to a user
       * 
       * @param userId The ID of the user
       * @param notification The notification payload
       * @returns Object indicating success or failure
       */
      async notifyUser(userId, notification) {
        return this.sendNotification("user" /* USER */, userId, notification);
      }
      /**
       * Send a notification to all users with a specific role
       * 
       * @param role The role name
       * @param notification The notification payload
       * @returns Object indicating success or failure
       */
      async notifyRole(role, notification) {
        return this.sendNotification("role" /* ROLE */, role, notification);
      }
      /**
       * Send a notification to all users in a company
       * 
       * @param companyId The company ID
       * @param notification The notification payload
       * @returns Object indicating success or failure
       */
      async notifyCompany(companyId, notification) {
        return this.sendNotification("company" /* COMPANY */, companyId, notification);
      }
      /**
       * Send a notification via email
       * 
       * @param email The email address
       * @param notification The notification payload
       * @returns Object indicating success or failure
       */
      async notifyByEmail(email, notification) {
        return this.sendNotification("email" /* EMAIL */, email, notification);
      }
      /**
       * Send a system notification (typically for admin users or logs)
       * 
       * @param notification The notification payload
       * @returns Object indicating success or failure
       */
      async notifySystem(notification) {
        return this.sendNotification("system" /* SYSTEM */, "system", notification);
      }
    };
    notificationService = new NotificationService();
  }
});

// server/common/services/registry.ts
function getNotificationService() {
  return Services.notification;
}
function getAuditService() {
  return Services.audit;
}
async function logAction(params) {
  return audit_service_default.log(params);
}
var auditServiceInstance, Services;
var init_registry = __esm({
  "server/common/services/registry.ts"() {
    "use strict";
    init_audit_service();
    init_drizzle();
    init_notification_service();
    auditServiceInstance = audit_service_default;
    Services = {
      /**
       * Centralized audit service for logging actions across the application
       */
      audit: auditServiceInstance,
      /**
       * Drizzle database service access
       */
      db: getDrizzle(),
      /**
       * Notification service for sending alerts across the application
       */
      notification: notificationService
    };
  }
});

// server/common/services/index.ts
var services_exports = {};
__export(services_exports, {
  Services: () => Services,
  getAuditService: () => getAuditService,
  getNotificationService: () => getNotificationService,
  logAction: () => logAction
});
var init_services = __esm({
  "server/common/services/index.ts"() {
    "use strict";
    init_registry();
  }
});

// server/monkey-patch.ts
var originalConsoleWarn = console.warn;
console.warn = function(...args) {
  if (args[0] && typeof args[0] === "string" && args[0].includes("Eviction policy")) {
    if (!global.__evictionPolicyWarned) {
      originalConsoleWarn("Redis Cloud note: Using volatile-lru policy instead of noeviction. Some features may be affected.");
      global.__evictionPolicyWarned = true;
    }
    return;
  }
  originalConsoleWarn.apply(console, args);
};
process.env.BULLMQ_IGNORE_EVICTION_POLICY = "true";
console.log("Applied Redis eviction policy warning suppression");

// server/index.ts
import * as dotenv3 from "dotenv";
import express9 from "express";
import { createServer } from "http";

// server/vite.ts
import express from "express";
import fs from "fs";
import path2, { dirname as dirname2 } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname(__filename);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client", "src"),
      "@shared": path.resolve(__dirname, "shared"),
      "@assets": path.resolve(__dirname, "attached_assets")
    }
  },
  root: path.resolve(__dirname, "client"),
  build: {
    outDir: path.resolve(__dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var __filename2 = fileURLToPath2(import.meta.url);
var __dirname2 = dirname2(__filename2);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        __dirname2,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(__dirname2, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (req, res) => {
    if (req.originalUrl.startsWith("/api/")) {
      return res.status(404).json({ error: "API endpoint not found" });
    }
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/modules/index.ts
init_storage();

// server/modules/auth/index.ts
import { Router as Router3 } from "express";

// server/modules/auth/routes/auth.routes.ts
init_auth_service();
init_auth_guard();
import { Router } from "express";
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Strategy as JwtStrategy, ExtractJwt } from "passport-jwt";
import session2 from "express-session";
init_drizzle();
init_schema4();
function setupAuthRoutes(app2, sessionStore) {
  const router14 = Router();
  const drizzleService5 = new DrizzleService();
  const sessionSettings = {
    secret: process.env.SESSION_SECRET || "default_geniuserp_session_secret",
    resave: false,
    saveUninitialized: false,
    store: sessionStore,
    cookie: {
      maxAge: 1e3 * 60 * 60 * 24,
      // 1 day
      secure: process.env.NODE_ENV === "production",
      httpOnly: true
    }
  };
  passport.use(
    new LocalStrategy(async (username, password, done) => {
      try {
        const user = await authService.getUserByUsername(username);
        if (!user || !await authService.comparePasswords(password, user.password)) {
          return done(null, false, { message: "Nume de utilizator sau parol\u0103 incorecte" });
        } else {
          return done(null, user);
        }
      } catch (error) {
        return done(error);
      }
    })
  );
  passport.use(
    new JwtStrategy(
      {
        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
        secretOrKey: process.env.JWT_SECRET
      },
      async (payload, done) => {
        try {
          const user = await authService.getUserById(payload.id);
          if (!user) {
            return done(null, false);
          }
          return done(null, user);
        } catch (error) {
          return done(error);
        }
      }
    )
  );
  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await authService.getUserById(id);
      done(null, user);
    } catch (error) {
      done(error, null);
    }
  });
  app2.use(session2(sessionSettings));
  app2.use(passport.initialize());
  app2.use(passport.session());
  router14.post("/register", async (req, res, next) => {
    try {
      const user = await authService.registerUser(req.body);
      res.status(201).json({ ...user, token: user.token });
    } catch (error) {
      if (error.message === "Numele de utilizator exist\u0103 deja") {
        return res.status(400).json({ message: error.message });
      }
      next(error);
    }
  });
  router14.post("/login", (req, res, next) => {
    passport.authenticate("local", (err, user, info) => {
      if (err) return next(err);
      if (!user) {
        return res.status(401).json({ message: info?.message || "Autentificare e\u0219uat\u0103" });
      }
      const token = authService.generateToken(user);
      return res.status(200).json({ ...user, token });
    })(req, res, next);
  });
  router14.post("/logout", (req, res) => {
    res.status(200).json({ message: "Logout successful" });
  });
  router14.post("/refresh", async (req, res, next) => {
    try {
      const token = req.headers.authorization?.replace("Bearer ", "");
      if (!token) {
        return res.status(401).json({ error: "Token required for refresh" });
      }
      const user = await authService.verifyToken(token);
      if (!user) {
        return res.status(401).json({ error: "Invalid token" });
      }
      const newToken = authService.generateToken(user);
      console.log(`[AuthRoutes] Token refreshed successfully for user: ${user.id}`);
      res.json({
        token: newToken,
        user: {
          id: user.id,
          username: user.username,
          role: user.role,
          companyId: user.company_id
        }
      });
    } catch (error) {
      console.error("[AuthRoutes] Token refresh error:", error.message);
      res.status(401).json({ error: "Token refresh failed" });
    }
  });
  router14.get(
    "/user",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res) => {
      res.json(req.user);
    }
  );
  router14.get(
    "/users",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(["admin" /* ADMIN */]),
    async (req, res) => {
      try {
        const usersData = await drizzleService5.db.select().from(users);
        res.json(usersData);
      } catch (error) {
        console.error("Error fetching users:", error);
        res.status(500).json({ error: "Failed to fetch users" });
      }
    }
  );
  router14.get("/test-token/:userId", async (req, res) => {
    try {
      const user = await authService.getUserById(req.params.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const token = authService.generateToken(user);
      return res.status(200).json({ token });
    } catch (error) {
      console.error("Error in test token endpoint:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  });
  router14.get("/verify-token", AuthGuard.protect("required" /* REQUIRED */), (req, res) => {
    return res.status(200).json({
      message: "Token verified successfully",
      user: req.user
    });
  });
  router14.get("/verify", AuthGuard.protect("required" /* REQUIRED */), (req, res) => {
    const roles3 = req.user?.roles || [];
    return res.status(200).json({
      message: "Authentication Verification Endpoint",
      user: req.user,
      isAdmin: req.user?.role === "admin" || roles3.includes("admin"),
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      note: "This endpoint verifies authentication and returns user details"
    });
  });
  return router14;
}

// server/modules/auth/middleware/auth.middleware.ts
init_auth_service();
import jwt3 from "jsonwebtoken";

// server/modules/auth/index.ts
init_auth_service();

// server/modules/auth/services/jwt.service.ts
init_auth_service();
import jwt4 from "jsonwebtoken";
var DEFAULT_EXPIRATION = "1h";
var JwtService = class {
  constructor() {
    this.secret = JWT_SECRET;
    this.refreshSecret = "";
    const refreshSecretEnv = process.env.JWT_REFRESH_SECRET;
    if (!refreshSecretEnv) {
      if (process.env.NODE_ENV === "production") {
        console.error("[JwtService] ERROR: JWT_REFRESH_SECRET is not set in production environment");
        throw new Error("JWT_REFRESH_SECRET environment variable is required in production");
      } else {
        this.refreshSecret = "dev-refresh-secret-key";
        console.warn("[JwtService] WARNING: Using default refresh secret in development environment");
      }
    } else {
      this.refreshSecret = refreshSecretEnv;
    }
  }
  /**
   * Generate a JWT token
   * @param payload User data to include in the token
   * @param expiresIn Token expiration time
   * @returns JWT token
   */
  generateToken(payload, expiresIn = DEFAULT_EXPIRATION) {
    return jwt4.sign(payload, this.secret, { expiresIn });
  }
  /**
   * Generate a refresh token
   * @param userId User ID to include in the token
   * @param expiresIn Token expiration time
   * @returns Refresh token
   */
  generateRefreshToken(userId, expiresIn = "7d") {
    return jwt4.sign({ id: userId }, this.refreshSecret, { expiresIn });
  }
  /**
   * Verify a JWT token
   * @param token JWT token to verify
   * @returns Decoded token payload or null if invalid
   */
  async verifyToken(token) {
    try {
      if (await this.isBlacklisted(token)) {
        throw new Error("Token has been revoked");
      }
      const decoded = jwt4.verify(token, this.secret);
      if (!decoded.id || !decoded.roles) {
        throw new Error("Invalid token payload");
      }
      return decoded;
    } catch (error) {
      console.error("JWT verification error:", error instanceof Error ? error.message : String(error));
      return null;
    }
  }
  /**
   * Verify a refresh token
   * @param token Refresh token to verify
   * @returns User ID from token or null if invalid
   */
  verifyRefreshToken(token) {
    try {
      return jwt4.verify(token, this.refreshSecret);
    } catch (error) {
      console.error("Refresh token verification error:", error instanceof Error ? error.message : String(error));
      return null;
    }
  }
  /**
   * Blacklist a token
   */
  async blacklistToken(token) {
    const decoded = jwt4.decode(token);
    if (decoded?.exp) {
      const ttl = decoded.exp - Math.floor(Date.now() / 1e3);
      console.log(`Token blacklisted for ${ttl} seconds`);
    }
  }
  /**
   * Check if token is blacklisted
   */
  async isBlacklisted(token) {
    return false;
  }
};
var jwtService = new JwtService();

// server/modules/auth/index.ts
init_auth_guard();

// server/modules/auth/examples/protected-routes.ts
init_auth_guard();
import { Router as Router2 } from "express";
function setupProtectedRoutes() {
  const router14 = Router2();
  router14.get(
    "/protected",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res) => {
      res.json({
        success: true,
        message: "You have accessed a protected route",
        user: req.user
      });
    }
  );
  router14.get(
    "/optional",
    AuthGuard.protect("optional" /* OPTIONAL */),
    (req, res) => {
      if (req.user) {
        res.json({
          success: true,
          message: "You are logged in",
          user: req.user
        });
      } else {
        res.json({
          success: true,
          message: "You are not logged in, but can still access this route"
        });
      }
    }
  );
  router14.get(
    "/admin-only",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(["admin" /* ADMIN */]),
    (req, res) => {
      res.json({
        success: true,
        message: "You have access to admin route",
        user: req.user
      });
    }
  );
  router14.get(
    "/company/:companyId/data",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard("companyId"),
    (req, res) => {
      const { companyId } = req.params;
      res.json({
        success: true,
        message: `You have access to company ${companyId} data`,
        user: req.user,
        companyId
      });
    }
  );
  return router14;
}

// server/modules/auth/index.ts
function initAuthModule(app2, sessionStore) {
  const router14 = Router3();
  const authRouter = setupAuthRoutes(router14, sessionStore);
  app2.use("/api/auth", authRouter);
  if (process.env.NODE_ENV !== "production") {
    const exampleRoutes = setupProtectedRoutes();
    app2.use("/api/examples", exampleRoutes);
    console.log("\u{1F510} AuthGuard example routes registered at /api/examples");
    console.log("Try: /api/examples/protected with Authorization header");
  }
  return router14;
}

// server/modules/users/users.module.ts
init_drizzle_service();
import { Router as Router4 } from "express";

// server/modules/users/services/user.service.ts
init_drizzle_service();
init_auth_service();
init_schema4();
init_logger();
import { eq as eq15, and as and14 } from "drizzle-orm";
var UserService = class _UserService {
  constructor(drizzleService5) {
    this.logger = new Logger("UserService");
    this.drizzle = drizzleService5 || new DrizzleService();
  }
  /**
   * Get the singleton instance of UserService
   */
  static getInstance(drizzleService5) {
    if (!_UserService.instance) {
      _UserService.instance = new _UserService(drizzleService5);
    }
    return _UserService.instance;
  }
  // User Management
  /**
   * Get all users
   * 
   * @returns Array of users
   */
  async getUsers() {
    try {
      this.logger.debug("Getting all users");
      const result = await this.drizzle.select().from(users);
      this.logger.debug(`Retrieved ${result.length} users`);
      return result;
    } catch (error) {
      this.logger.error("Error getting users:", error);
      throw error;
    }
  }
  /**
   * Get a user by ID
   * 
   * @param id User ID
   * @returns The user or undefined if not found
   */
  async getUser(id) {
    try {
      this.logger.debug(`Getting user with ID: ${id}`);
      const result = await this.drizzle.select().from(users).where(eq15(users.id, id)).limit(1);
      const user = result.length > 0 ? result[0] : void 0;
      this.logger.debug(user ? "User found" : "User not found");
      return user;
    } catch (error) {
      this.logger.error(`Error getting user with ID ${id}:`, error);
      throw error;
    }
  }
  /**
   * Get a user by username
   * 
   * @param username Username
   * @returns The user or undefined if not found
   */
  async getUserByUsername(username) {
    try {
      this.logger.debug(`Getting user with username: ${username}`);
      const result = await this.drizzle.select().from(users).where(eq15(users.username, username)).limit(1);
      const user = result.length > 0 ? result[0] : void 0;
      this.logger.debug(user ? "User found" : "User not found");
      return user;
    } catch (error) {
      this.logger.error(`Error getting user with username ${username}:`, error);
      throw error;
    }
  }
  /**
   * Create a new user
   * 
   * @param userData User data to create
   * @returns The created user
   */
  async createUser(userData) {
    try {
      this.logger.debug(`Creating new user with username: ${userData.username}`);
      const hashedPassword = await authService.hashPassword(userData.password);
      const user = {
        ...userData,
        password: hashedPassword
      };
      const result = await this.drizzle.insert(users).values(user).returning();
      this.logger.debug(`Created user with ID: ${result[0].id}`);
      return result[0];
    } catch (error) {
      this.logger.error(`Error creating user with username ${userData.username}:`, error);
      throw error;
    }
  }
  /**
   * Update a user
   * 
   * @param id User ID
   * @param userData User data to update
   * @returns The updated user
   */
  async updateUser(id, userData) {
    try {
      this.logger.debug(`Updating user with ID: ${id}`);
      if (userData.password) {
        userData.password = await authService.hashPassword(userData.password);
      }
      const updateData = {
        ...userData,
        updatedAt: /* @__PURE__ */ new Date()
      };
      const result = await this.drizzle.update(users).set(updateData).where(eq15(users.id, id)).returning();
      this.logger.debug(`Updated user with ID: ${id}`);
      return result[0];
    } catch (error) {
      this.logger.error(`Error updating user with ID ${id}:`, error);
      throw error;
    }
  }
  // Role Management
  /**
   * Get all roles, optionally filtered by company
   * 
   * @param companyId Optional company ID to filter roles
   * @returns Array of roles
   */
  async getRoles(companyId) {
    try {
      this.logger.debug(companyId ? `Getting roles for company ID: ${companyId}` : "Getting all roles");
      let query = this.drizzle.select().from(roles);
      if (companyId) {
        query = query.where(eq15(roles.companyId, companyId));
      }
      const result = await query;
      this.logger.debug(`Retrieved ${result.length} roles`);
      return result;
    } catch (error) {
      this.logger.error("Error getting roles:", error);
      throw error;
    }
  }
  /**
   * Get a role by ID
   * 
   * @param id Role ID
   * @returns The role or undefined if not found
   */
  async getRole(id) {
    try {
      this.logger.debug(`Getting role with ID: ${id}`);
      const result = await this.drizzle.select().from(roles).where(eq15(roles.id, id)).limit(1);
      const role = result.length > 0 ? result[0] : void 0;
      this.logger.debug(role ? "Role found" : "Role not found");
      return role;
    } catch (error) {
      this.logger.error(`Error getting role with ID ${id}:`, error);
      throw error;
    }
  }
  /**
   * Get a role by name and company ID
   * 
   * @param name Role name
   * @param companyId Company ID
   * @returns The role or undefined if not found
   */
  async getRoleByName(name, companyId) {
    try {
      this.logger.debug(`Getting role with name: ${name} for company: ${companyId}`);
      const result = await this.drizzle.select().from(roles).where(and14(
        eq15(roles.name, name),
        eq15(roles.companyId, companyId)
      )).limit(1);
      const role = result.length > 0 ? result[0] : void 0;
      this.logger.debug(role ? "Role found" : "Role not found");
      return role;
    } catch (error) {
      this.logger.error(`Error getting role with name ${name}:`, error);
      throw error;
    }
  }
  // User-Role Management
  /**
   * Get all roles for a user
   * 
   * @param userId User ID
   * @returns Array of roles
   */
  async getUserRoles(userId) {
    try {
      this.logger.debug(`Getting roles for user ID: ${userId}`);
      const result = await this.drizzle.select({
        role: roles
      }).from(userRoles).innerJoin(roles, eq15(userRoles.roleId, roles.id)).where(eq15(userRoles.userId, userId));
      const userRolesArray = result.map((r) => r.role);
      this.logger.debug(`Retrieved ${userRolesArray.length} roles for user ID: ${userId}`);
      return userRolesArray;
    } catch (error) {
      this.logger.error(`Error getting roles for user ID ${userId}:`, error);
      throw error;
    }
  }
  /**
   * Assign a role to a user
   * 
   * @param userId User ID
   * @param roleId Role ID
   */
  async assignRoleToUser(userId, roleId) {
    try {
      this.logger.debug(`Assigning role ID: ${roleId} to user ID: ${userId}`);
      await this.drizzle.insert(userRoles).values({
        userId,
        roleId
      }).onConflictDoNothing();
      this.logger.debug(`Assigned role ID: ${roleId} to user ID: ${userId}`);
    } catch (error) {
      this.logger.error(`Error assigning role ID ${roleId} to user ID ${userId}:`, error);
      throw error;
    }
  }
  /**
   * Remove a role from a user
   * 
   * @param userId User ID
   * @param roleId Role ID
   */
  async removeRoleFromUser(userId, roleId) {
    try {
      this.logger.debug(`Removing role ID: ${roleId} from user ID: ${userId}`);
      await this.drizzle.delete(userRoles).where(and14(
        eq15(userRoles.userId, userId),
        eq15(userRoles.roleId, roleId)
      ));
      this.logger.debug(`Removed role ID: ${roleId} from user ID: ${userId}`);
    } catch (error) {
      this.logger.error(`Error removing role ID ${roleId} from user ID ${userId}:`, error);
      throw error;
    }
  }
  // Permission Management
  /**
   * Get all permissions
   * 
   * @returns Array of permissions
   */
  async getPermissions() {
    try {
      this.logger.debug("Getting all permissions");
      const result = await this.drizzle.select().from(permissions);
      this.logger.debug(`Retrieved ${result.length} permissions`);
      return result;
    } catch (error) {
      this.logger.error("Error getting permissions:", error);
      throw error;
    }
  }
  /**
   * Get all permissions for a role
   * 
   * @param roleId Role ID
   * @returns Array of permissions
   */
  async getRolePermissions(roleId) {
    try {
      this.logger.debug(`Getting permissions for role ID: ${roleId}`);
      const result = await this.drizzle.select({
        permission: permissions
      }).from(rolePermissions).innerJoin(permissions, eq15(rolePermissions.permissionId, permissions.id)).where(eq15(rolePermissions.roleId, roleId));
      const rolePermissionsArray = result.map((r) => r.permission);
      this.logger.debug(`Retrieved ${rolePermissionsArray.length} permissions for role ID: ${roleId}`);
      return rolePermissionsArray;
    } catch (error) {
      this.logger.error(`Error getting permissions for role ID ${roleId}:`, error);
      throw error;
    }
  }
};

// server/modules/users/controllers/user.controller.ts
init_logger();
var UserController = class {
  constructor() {
    this.userService = UserService.getInstance();
    this.logger = new Logger("UserController");
  }
  /**
   * Get all users
   */
  async getUsers(req, res, next) {
    try {
      this.logger.debug("Getting all users");
      const users3 = await this.userService.getUsers();
      res.json(users3);
    } catch (error) {
      this.logger.error("Error getting users:", error);
      next(error);
    }
  }
  /**
   * Get user by ID
   */
  async getUserById(req, res, next) {
    try {
      const { id } = req.params;
      this.logger.debug(`Getting user with ID: ${id}`);
      if (req.user && id !== req.user.id && req.user.role !== "admin") {
        this.logger.warn(`Unauthorized access attempt to user profile ${id} by user ${req.user.id}`);
        return res.status(403).json({ message: "Forbidden" });
      }
      const user = await this.userService.getUser(id);
      if (!user) {
        this.logger.warn(`User not found with ID: ${id}`);
        return res.status(404).json({ message: "User not found" });
      }
      this.logger.debug(`Retrieved user with ID: ${id}`);
      res.json(user);
    } catch (error) {
      this.logger.error(`Error getting user with ID ${req.params.id}:`, error);
      next(error);
    }
  }
  /**
   * Create a new user
   */
  async createUser(req, res, next) {
    try {
      this.logger.debug("Creating new user");
      const user = await this.userService.createUser(req.body);
      this.logger.debug(`Created user with ID: ${user.id}`);
      res.status(201).json(user);
    } catch (error) {
      this.logger.error("Error creating user:", error);
      next(error);
    }
  }
  /**
   * Update user
   */
  async updateUser(req, res, next) {
    try {
      const { id } = req.params;
      this.logger.debug(`Updating user with ID: ${id}`);
      if (req.user && id !== req.user.id && req.user.role !== "admin") {
        this.logger.warn(`Unauthorized update attempt to user ${id} by user ${req.user.id}`);
        return res.status(403).json({ message: "Forbidden" });
      }
      if (req.user && id === req.user.id && req.user.role !== "admin" && req.body.role) {
        this.logger.warn(`User ${id} attempted to change their own role`);
        delete req.body.role;
      }
      const user = await this.userService.updateUser(id, req.body);
      this.logger.debug(`Updated user with ID: ${id}`);
      res.json(user);
    } catch (error) {
      this.logger.error(`Error updating user with ID ${req.params.id}:`, error);
      next(error);
    }
  }
  /**
   * Get all roles
   */
  async getRoles(req, res, next) {
    try {
      this.logger.debug("Getting all roles");
      const companyId = req.query.companyId;
      const roles3 = await this.userService.getRoles(companyId);
      this.logger.debug(`Retrieved ${roles3.length} roles`);
      res.json(roles3);
    } catch (error) {
      this.logger.error("Error getting roles:", error);
      next(error);
    }
  }
  /**
   * Get user's roles
   */
  async getUserRoles(req, res, next) {
    try {
      const { id } = req.params;
      this.logger.debug(`Getting roles for user ID: ${id}`);
      if (req.user && id !== req.user.id && req.user.role !== "admin") {
        this.logger.warn(`Unauthorized access attempt to user roles ${id} by user ${req.user.id}`);
        return res.status(403).json({ message: "Forbidden" });
      }
      const roles3 = await this.userService.getUserRoles(id);
      this.logger.debug(`Retrieved ${roles3.length} roles for user ID: ${id}`);
      res.json(roles3);
    } catch (error) {
      this.logger.error(`Error getting roles for user ID ${req.params.id}:`, error);
      next(error);
    }
  }
  /**
   * Assign role to user
   */
  async assignRoleToUser(req, res, next) {
    try {
      const { id, roleId } = req.params;
      this.logger.debug(`Assigning role ID: ${roleId} to user ID: ${id}`);
      await this.userService.assignRoleToUser(id, roleId);
      this.logger.debug(`Assigned role ID: ${roleId} to user ID: ${id}`);
      res.sendStatus(204);
    } catch (error) {
      this.logger.error(`Error assigning role ID ${req.params.roleId} to user ID ${req.params.id}:`, error);
      next(error);
    }
  }
  /**
   * Remove role from user
   */
  async removeRoleFromUser(req, res, next) {
    try {
      const { id, roleId } = req.params;
      this.logger.debug(`Removing role ID: ${roleId} from user ID: ${id}`);
      await this.userService.removeRoleFromUser(id, roleId);
      this.logger.debug(`Removed role ID: ${roleId} from user ID: ${id}`);
      res.sendStatus(204);
    } catch (error) {
      this.logger.error(`Error removing role ID ${req.params.roleId} from user ID ${req.params.id}:`, error);
      next(error);
    }
  }
  /**
   * Get all permissions
   */
  async getPermissions(req, res, next) {
    try {
      this.logger.debug("Getting all permissions");
      const permissions4 = await this.userService.getPermissions();
      this.logger.debug(`Retrieved ${permissions4.length} permissions`);
      res.json(permissions4);
    } catch (error) {
      this.logger.error("Error getting permissions:", error);
      next(error);
    }
  }
  /**
   * Get role permissions
   */
  async getRolePermissions(req, res, next) {
    try {
      const { id } = req.params;
      this.logger.debug(`Getting permissions for role ID: ${id}`);
      const permissions4 = await this.userService.getRolePermissions(id);
      this.logger.debug(`Retrieved ${permissions4.length} permissions for role ID: ${id}`);
      res.json(permissions4);
    } catch (error) {
      this.logger.error(`Error getting permissions for role ID ${req.params.id}:`, error);
      next(error);
    }
  }
};

// server/modules/users/users.module.ts
init_auth_guard();
init_auth_mode_enum();
var UsersModule = class {
  constructor() {
    this.drizzle = new DrizzleService();
    this.userController = new UserController();
  }
  /**
   * Initialize the users module and set up routes
   * 
   * @param app Express application
   * @returns The router that was set up
   */
  initRoutes(app2) {
    const router14 = Router4();
    router14.get(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */]),
      this.userController.getUsers.bind(this.userController)
    );
    router14.get(
      "/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      this.userController.getUserById.bind(this.userController)
    );
    router14.post(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */]),
      this.userController.createUser.bind(this.userController)
    );
    router14.put(
      "/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      this.userController.updateUser.bind(this.userController)
    );
    router14.get(
      "/roles/all",
      AuthGuard.protect("required" /* REQUIRED */),
      this.userController.getRoles.bind(this.userController)
    );
    router14.get(
      "/:id/roles",
      AuthGuard.protect("required" /* REQUIRED */),
      this.userController.getUserRoles.bind(this.userController)
    );
    router14.post(
      "/:id/roles/:roleId",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */]),
      this.userController.assignRoleToUser.bind(this.userController)
    );
    router14.delete(
      "/:id/roles/:roleId",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */]),
      this.userController.removeRoleFromUser.bind(this.userController)
    );
    router14.get(
      "/permissions/all",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */]),
      this.userController.getPermissions.bind(this.userController)
    );
    router14.get(
      "/roles/:id/permissions",
      AuthGuard.protect("required" /* REQUIRED */),
      this.userController.getRolePermissions.bind(this.userController)
    );
    app2.use("/api/users", router14);
    return router14;
  }
};
var usersModule = new UsersModule();

// server/modules/users/index.ts
function initUserModule(app2) {
  return usersModule.initRoutes(app2);
}
var userService = UserService.getInstance();

// server/modules/admin/init.ts
init_drizzle();

// server/modules/admin/admin.module.ts
init_logger();

// server/modules/admin/services/user.service.ts
init_logger();
init_admin_schema();
import { eq as eq16, and as and15, isNull as isNull4, asc, desc as desc4, sql as sql15 } from "drizzle-orm";
import * as bcrypt from "bcrypt";
import { v4 as uuidv4 } from "uuid";
var UserService2 = class {
  /**
   * Constructor for UserService
   * @param db Drizzle database instance
   */
  constructor(db4) {
    this.logger = new Logger("UserService");
    this.SALT_ROUNDS = 10;
    this.db = db4;
    this.logger.debug("UserService initialized");
  }
  /**
   * Create a new user with the provided details
   * @param params User creation parameters
   * @returns Created user record
   */
  async createUser(params) {
    try {
      this.logger.debug(`Creating user with email: ${params.email}`);
      const existingUser = await this.findUserByEmail(params.email);
      if (existingUser) {
        throw new Error(`User with email ${params.email} already exists`);
      }
      const hashedPassword = await this.hashPassword(params.password);
      const now = /* @__PURE__ */ new Date();
      const [newUser] = await this.db.insert(users2).values({
        username: params.email.toLowerCase(),
        // Using email as username
        email: params.email.toLowerCase(),
        first_name: params.firstName || null,
        last_name: params.lastName || null,
        password: hashedPassword,
        company_id: params.companyId || null,
        status: params.status || "active" /* ACTIVE */,
        created_at: now,
        updated_at: now
      }).returning();
      if (params.roleIds && params.roleIds.length > 0) {
        await this.assignRolesToUser(newUser.id, params.roleIds);
      }
      this.logger.info(`User created successfully: ${newUser.email}`);
      return newUser;
    } catch (error) {
      this.logger.error("Failed to create user:", error);
      throw error;
    }
  }
  /**
   * Update an existing user with the provided details
   * @param userId User ID
   * @param updates User updates
   * @returns Updated user record
   */
  async updateUser(userId, updates) {
    try {
      this.logger.debug(`Updating user with ID: ${userId}`);
      const updateData = { updated_at: /* @__PURE__ */ new Date() };
      if (updates.email !== void 0) {
        if (updates.email) {
          const existingUser = await this.findUserByEmail(updates.email);
          if (existingUser && existingUser.id !== userId) {
            throw new Error(`User with email ${updates.email} already exists`);
          }
          updateData.email = updates.email.toLowerCase();
        }
      }
      if (updates.firstName !== void 0) updateData.first_name = updates.firstName;
      if (updates.lastName !== void 0) updateData.last_name = updates.lastName;
      if (updates.status !== void 0) updateData.status = updates.status;
      if (updates.companyId !== void 0) updateData.company_id = updates.companyId;
      if (updates.password) {
        updateData.password = await this.hashPassword(updates.password);
      }
      const [updatedUser] = await this.db.update(users2).set(updateData).where(eq16(users2.id, userId)).returning();
      if (!updatedUser) {
        throw new Error(`User with ID ${userId} not found`);
      }
      this.logger.info(`User ${updatedUser.email} updated successfully`);
      return updatedUser;
    } catch (error) {
      this.logger.error(`Failed to update user with ID ${userId}:`, error);
      throw error;
    }
  }
  /**
   * Find a user by email
   * @param email User email
   * @returns User record or null if not found
   */
  async findUserByEmail(email) {
    try {
      this.logger.debug(`Finding user by email: ${email}`);
      const [user] = await this.db.select().from(users2).where(eq16(users2.email, email.toLowerCase())).limit(1);
      return user || null;
    } catch (error) {
      this.logger.error(`Failed to find user by email ${email}:`, error);
      throw error;
    }
  }
  /**
   * Find a user by ID
   * @param userId User ID
   * @returns User record or null if not found
   */
  async findUserById(userId) {
    try {
      this.logger.debug(`Finding user by ID: ${userId}`);
      const [user] = await this.db.select().from(users2).where(eq16(users2.id, userId)).limit(1);
      return user || null;
    } catch (error) {
      this.logger.error(`Failed to find user by ID ${userId}:`, error);
      throw error;
    }
  }
  /**
   * Get users with pagination and filtering
   * @param options Query options
   * @returns Paginated user records
   */
  async getUsers(options = {}) {
    try {
      this.logger.debug("Getting users with options:", options);
      const page = options.page || 1;
      const limit = options.limit || 10;
      const offset = (page - 1) * limit;
      let conditions = [];
      if (options.companyId !== void 0) {
        if (options.companyId === null) {
          conditions.push(isNull4(users2.company_id));
        } else {
          conditions.push(eq16(users2.company_id, options.companyId));
        }
      }
      if (options.status !== void 0) {
        conditions.push(eq16(users2.status, options.status));
      }
      const query = this.db.select().from(users2);
      if (conditions.length > 0) {
        query.where(and15(...conditions));
      }
      if (options.sortBy && options.sortBy in users2) {
        const column = users2[options.sortBy];
        query.orderBy(options.sortDirection === "desc" ? desc4(column) : asc(column));
      } else {
        query.orderBy(asc(users2.email));
      }
      query.limit(limit).offset(offset);
      const result = await query;
      const [{ count: total }] = await this.db.select({ count: sql15`count(*)` }).from(users2).where(conditions.length > 0 ? and15(...conditions) : void 0);
      return {
        data: result,
        pagination: {
          page,
          limit,
          total: Number(total),
          totalPages: Math.ceil(Number(total) / limit)
        }
      };
    } catch (error) {
      this.logger.error("Failed to get users:", error);
      throw error;
    }
  }
  /**
   * Delete a user (permanent deletion)
   * @param userId User ID
   * @returns Deleted user record
   */
  async deleteUser(userId) {
    try {
      this.logger.debug(`Deleting user with ID: ${userId}`);
      await this.db.delete(userRoles2).where(eq16(userRoles2.user_id, userId));
      const [deletedUser] = await this.db.delete(users2).where(eq16(users2.id, userId)).returning();
      if (!deletedUser) {
        throw new Error(`User with ID ${userId} not found`);
      }
      this.logger.info(`User ${deletedUser.email} deleted successfully`);
      return deletedUser;
    } catch (error) {
      this.logger.error(`Failed to delete user with ID ${userId}:`, error);
      throw error;
    }
  }
  /**
   * Soft delete a user by marking it as inactive
   * @param userId User ID
   * @returns Updated user record
   */
  async softDeleteUser(userId) {
    try {
      this.logger.debug(`Soft deleting user with ID: ${userId}`);
      const [updatedUser] = await this.db.update(users2).set({
        status: "inactive" /* INACTIVE */,
        updated_at: /* @__PURE__ */ new Date()
      }).where(eq16(users2.id, userId)).returning();
      if (!updatedUser) {
        throw new Error(`User with ID ${userId} not found`);
      }
      this.logger.info(`User ${updatedUser.email} soft-deleted successfully`);
      return updatedUser;
    } catch (error) {
      this.logger.error(`Failed to soft-delete user with ID ${userId}:`, error);
      throw error;
    }
  }
  /**
   * Verify a user's password
   * @param password Plain text password
   * @param hashedPassword Hashed password from the database
   * @returns True if password matches, false otherwise
   */
  async verifyPassword(password, hashedPassword) {
    return bcrypt.compare(password, hashedPassword);
  }
  /**
   * Assign roles to a user
   * @param userId User ID
   * @param roleIds Role IDs to assign
   */
  async assignRolesToUser(userId, roleIds) {
    try {
      this.logger.debug(`Assigning roles to user with ID: ${userId}`);
      const user = await this.findUserById(userId);
      if (!user) {
        throw new Error(`User with ID ${userId} not found`);
      }
      for (const roleId of roleIds) {
        const [role] = await this.db.select().from(roles2).where(eq16(roles2.id, roleId)).limit(1);
        if (!role) {
          throw new Error(`Role with ID ${roleId} not found`);
        }
      }
      await this.db.delete(userRoles2).where(eq16(userRoles2.user_id, userId));
      if (roleIds.length > 0) {
        const values = roleIds.map((roleId) => ({
          id: uuidv4(),
          user_id: userId,
          role_id: roleId,
          assigned_at: /* @__PURE__ */ new Date(),
          assigned_by: userId
          // Using the same user ID as assigned_by for simplicity
        }));
        await this.db.insert(userRoles2).values(values);
      }
      this.logger.info(`Roles assigned to user ${userId} successfully`);
    } catch (error) {
      this.logger.error(`Failed to assign roles to user ${userId}:`, error);
      throw error;
    }
  }
  /**
   * Get roles assigned to a user
   * @param userId User ID
   * @returns Array of role records
   */
  async getUserRoles(userId) {
    try {
      this.logger.debug(`Getting roles for user with ID: ${userId}`);
      const userRolesResult = await this.db.select({
        role: roles2
      }).from(userRoles2).leftJoin(roles2, eq16(userRoles2.role_id, roles2.id)).where(eq16(userRoles2.user_id, userId));
      return userRolesResult.map((item) => item.role);
    } catch (error) {
      this.logger.error(`Failed to get roles for user ${userId}:`, error);
      throw error;
    }
  }
  /**
   * Check if a user has a specific role
   * @param userId User ID
   * @param roleId Role ID or code to check
   * @returns True if user has the role, false otherwise
   */
  async userHasRole(userId, roleIdOrCode) {
    try {
      this.logger.debug(`Checking if user ${userId} has role ${roleIdOrCode}`);
      const userRoleRecord = await this.db.select().from(userRoles2).where(and15(
        eq16(userRoles2.user_id, userId),
        eq16(userRoles2.role_id, roleIdOrCode)
      )).limit(1);
      if (userRoleRecord.length > 0) {
        return true;
      }
      return false;
    } catch (error) {
      this.logger.error(`Failed to check if user ${userId} has role ${roleIdOrCode}:`, error);
      throw error;
    }
  }
  /**
   * Change a user's password
   * @param userId User ID
   * @param newPassword New password
   * @returns Updated user
   */
  async changePassword(userId, newPassword) {
    try {
      this.logger.debug(`Changing password for user with ID: ${userId}`);
      const hashedPassword = await this.hashPassword(newPassword);
      const [updatedUser] = await this.db.update(users2).set({
        password: hashedPassword,
        updated_at: /* @__PURE__ */ new Date()
      }).where(eq16(users2.id, userId)).returning();
      if (!updatedUser) {
        throw new Error(`User with ID ${userId} not found`);
      }
      this.logger.info(`Password changed successfully for user ${updatedUser.email}`);
      return updatedUser;
    } catch (error) {
      this.logger.error(`Failed to change password for user ${userId}:`, error);
      throw error;
    }
  }
  /**
   * Hash a password
   * @param password Password to hash
   * @returns Hashed password
   */
  async hashPassword(password) {
    return bcrypt.hash(password, this.SALT_ROUNDS);
  }
};

// server/modules/admin/services/role.service.ts
init_schema4();
init_auth_guard();
init_auth_mode_enum();
init_logger();
init_audit_service();
import { eq as eq18 } from "drizzle-orm";
import { Router as Router5 } from "express";
import { v4 as uuidv43 } from "uuid";
var RoleService = class {
  /**
   * Constructor for RoleService
   * @param db Drizzle database instance
   */
  constructor(db4) {
    this.logger = new Logger("RoleService");
    this.db = db4;
  }
  /**
   * Create a new role
   * @param roleData Role data including name, description, companyId
   * @returns Created role object
   */
  async createRole(roleData) {
    try {
      this.logger.info(`Creating new role: ${roleData.name}`);
      const roleId = uuidv43();
      const [role] = await this.db.insert(roles).values({
        id: roleId,
        name: roleData.name,
        description: roleData.description || null,
        companyId: roleData.companyId
      }).returning();
      return role;
    } catch (error) {
      this.logger.error("Error creating role:", error);
      throw error;
    }
  }
  /**
   * Get all roles for a company
   * @param companyId Company ID
   * @returns Array of role objects
   */
  async getRolesByCompany(companyId) {
    try {
      this.logger.info(`Fetching roles for company ${companyId}`);
      const result = await this.db.select().from(roles).where(eq18(roles.companyId, companyId));
      this.logger.info(`Found ${result.length} roles for company ${companyId}`);
      return result;
    } catch (error) {
      this.logger.error(`Error getting roles for company ${companyId}:`, error);
      throw error;
    }
  }
  /**
   * Get a role by ID
   * @param roleId Role ID
   * @returns Role object
   */
  async getRoleById(roleId) {
    try {
      const result = await this.db.execute(
        `SELECT * FROM roles WHERE id = $1 LIMIT 1`,
        [roleId]
      );
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      this.logger.error(`Error getting role ${roleId}:`, error);
      throw error;
    }
  }
  /**
   * Update a role
   * @param roleId Role ID
   * @param updates Fields to update (name, description)
   * @param actorId ID of the user making the change (for audit log)
   * @returns Updated role object
   */
  async updateRole(roleId, updates, actorId) {
    try {
      const role = await this.getRoleById(roleId);
      if (!role) {
        throw new Error(`Role with ID ${roleId} not found`);
      }
      const setClause = [];
      const params = [];
      let paramIndex = 1;
      if (updates.name) {
        setClause.push(`name = $${paramIndex}`);
        params.push(updates.name);
        paramIndex++;
      }
      if (updates.description) {
        setClause.push(`description = $${paramIndex}`);
        params.push(updates.description);
        paramIndex++;
      }
      setClause.push(`updated_at = $${paramIndex}`);
      params.push(/* @__PURE__ */ new Date());
      paramIndex++;
      params.push(roleId);
      if (setClause.length > 0) {
        const query = `
          UPDATE roles 
          SET ${setClause.join(", ")} 
          WHERE id = $${paramIndex}
          RETURNING *
        `;
        const result = await this.db.execute(query, params);
        if (result.length === 0) {
          throw new Error(`Role with ID ${roleId} could not be updated`);
        }
        const updatedRole = result[0];
        try {
          await AuditService.log({
            userId: actorId || "system",
            companyId: role.company_id,
            action: "UPDATE" /* UPDATE */,
            entity: "roles",
            entityId: roleId,
            details: {
              updates
            }
          });
        } catch (auditError) {
          this.logger.error("Failed to log audit event for role update:", auditError);
        }
        return updatedRole;
      } else {
        return role;
      }
    } catch (error) {
      this.logger.error(`Error updating role ${roleId}:`, error);
      throw error;
    }
  }
  /**
   * Delete a role
   * @param roleId Role ID
   * @param actorId ID of the user making the change (for audit log)
   * @returns Boolean indicating success
   */
  async deleteRole(roleId, actorId) {
    try {
      const role = await this.getRoleById(roleId);
      if (!role) {
        throw new Error(`Role with ID ${roleId} not found`);
      }
      await this.db.delete(rolePermissions).where(eq18(rolePermissions.roleId, roleId));
      await this.db.delete(roles).where(eq18(roles.id, roleId));
      await AuditService.log({
        userId: actorId,
        companyId: role.companyId,
        action: "DELETE" /* DELETE */,
        entity: "roles",
        entityId: roleId,
        details: {
          roleName: role.name
        }
      });
      return true;
    } catch (error) {
      this.logger.error(`Error deleting role ${roleId}:`, error);
      throw error;
    }
  }
  /**
   * Register API routes for role management
   * @param app Express application
   */
  registerRoutes(app2) {
    this.logger.info("Registering role management routes...");
    const router14 = Router5();
    const requireAuth = AuthGuard.protect("required" /* REQUIRED */);
    const requireAdmin = AuthGuard.protect("required" /* REQUIRED */);
    router14.get("/roles", requireAuth, async (req, res) => {
      try {
        this.logger.info("Fetching roles, user:", JSON.stringify(req.user || {}));
        const user = req.user;
        const companyId = user?.company_id || "7196288d-7314-4512-8b67-2c82449b5465";
        this.logger.info(`Using company ID: ${companyId}`);
        const roles3 = await this.getRolesByCompany(companyId);
        this.logger.info(`Found ${roles3.length} roles for company ${companyId}`);
        res.json({ success: true, data: roles3 });
      } catch (error) {
        this.logger.error("Error fetching roles:", error);
        res.status(500).json({
          success: false,
          message: "Failed to fetch roles",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    });
    router14.get("/roles/test-roles", async (req, res) => {
      try {
        const result = await this.db.execute(
          `SELECT * FROM roles WHERE company_id = $1`,
          ["7196288d-7314-4512-8b67-2c82449b5465"]
          // GeniusERP Demo Company
        );
        this.logger.info(`Obtained ${result.length} roles via test endpoint`);
        res.json({
          success: true,
          data: result,
          message: "Test endpoint successful"
        });
      } catch (error) {
        this.logger.error("Error in test roles endpoint:", error);
        res.status(500).json({
          success: false,
          message: "Failed to get test roles"
        });
      }
    });
    router14.get("/roles/:companyId", requireAuth, async (req, res) => {
      try {
        const { companyId } = req.params;
        const roles3 = await this.getRolesByCompany(companyId);
        res.json({ success: true, data: roles3 });
      } catch (error) {
        this.logger.error("Error fetching roles:", error);
        res.status(500).json({ success: false, message: "Failed to fetch roles" });
      }
    });
    router14.get("/roles/detail/:roleId", requireAuth, async (req, res) => {
      try {
        const { roleId } = req.params;
        const role = await this.getRoleById(roleId);
        if (!role) {
          return res.status(404).json({ success: false, message: "Role not found" });
        }
        res.json({ success: true, data: role });
      } catch (error) {
        this.logger.error("Error fetching role details:", error);
        res.status(500).json({ success: false, message: "Failed to fetch role details" });
      }
    });
    router14.post("/roles", requireAdmin, async (req, res) => {
      try {
        const { name, description, companyId } = req.body;
        if (!name || !companyId) {
          return res.status(400).json({
            success: false,
            message: "Missing required fields (name, companyId)"
          });
        }
        const role = await this.createRole({
          name,
          description,
          companyId
        });
        res.status(201).json({ success: true, data: role });
      } catch (error) {
        this.logger.error("Error creating role:", error);
        res.status(500).json({ success: false, message: "Failed to create role" });
      }
    });
    router14.put("/roles/:roleId", requireAdmin, async (req, res) => {
      try {
        const { roleId } = req.params;
        const { name, description } = req.body;
        if (!name && !description) {
          return res.status(400).json({
            success: false,
            message: "At least one field to update is required"
          });
        }
        const role = await this.updateRole(
          roleId,
          { name, description },
          req.user?.id
        );
        res.json({ success: true, data: role });
      } catch (error) {
        this.logger.error("Error updating role:", error);
        res.status(500).json({ success: false, message: "Failed to update role" });
      }
    });
    router14.delete("/roles/:roleId", requireAdmin, async (req, res) => {
      try {
        const { roleId } = req.params;
        await this.deleteRole(roleId, req.user?.id);
        res.json({ success: true });
      } catch (error) {
        this.logger.error("Error deleting role:", error);
        res.status(500).json({ success: false, message: "Failed to delete role" });
      }
    });
    app2.use("/api/admin", router14);
    this.logger.info("Role management routes registered successfully");
  }
};

// server/modules/admin/services/setup.service.ts
init_admin_schema();
init_auth_guard();
init_auth_mode_enum();
init_logger();
import { eq as eq19, and as and18 } from "drizzle-orm";
import { Router as Router6 } from "express";
var SetupService = class {
  constructor(db4) {
    this.logger = new Logger("SetupService");
    this.db = db4;
  }
  /**
   * Record a setup step for a company
   */
  async recordSetupStep(companyId, step, status = "completed", franchiseId) {
    try {
      const existingSteps = await this.db.select().from(setup_steps).where(
        and18(
          eq19(setup_steps.company_id, companyId),
          eq19(setup_steps.step, step),
          franchiseId ? eq19(setup_steps.franchise_id, franchiseId) : void 0
        )
      );
      if (existingSteps.length > 0) {
        await this.db.update(setup_steps).set({
          status,
          updated_at: /* @__PURE__ */ new Date()
        }).where(
          and18(
            eq19(setup_steps.company_id, companyId),
            eq19(setup_steps.step, step),
            franchiseId ? eq19(setup_steps.franchise_id, franchiseId) : void 0
          )
        );
        return existingSteps[0].id;
      } else {
        const [result] = await this.db.insert(setup_steps).values({
          company_id: companyId,
          franchise_id: franchiseId,
          step,
          status
        }).returning();
        return result.id;
      }
    } catch (error) {
      console.error("Error recording setup step:", error);
      throw error;
    }
  }
  /**
   * Get all setup steps for a company
   */
  async getCompanySetupSteps(companyId, franchiseId) {
    try {
      return await this.db.select().from(setup_steps).where(
        and18(
          eq19(setup_steps.company_id, companyId),
          franchiseId ? eq19(setup_steps.franchise_id, franchiseId) : void 0
        )
      );
    } catch (error) {
      console.error("Error getting company setup steps:", error);
      throw error;
    }
  }
  /**
   * Check if a specific step is completed
   */
  async isStepComplete(companyId, step, franchiseId) {
    try {
      const steps = await this.db.select().from(setup_steps).where(
        and18(
          eq19(setup_steps.company_id, companyId),
          eq19(setup_steps.step, step),
          eq19(setup_steps.status, "completed"),
          franchiseId ? eq19(setup_steps.franchise_id, franchiseId) : void 0
        )
      );
      return steps.length > 0;
    } catch (error) {
      console.error("Error checking step completion:", error);
      return false;
    }
  }
  /**
   * Get setup progress percentage
   */
  async getSetupProgress(companyId, franchiseId) {
    try {
      const totalSteps = await this.db.select().from(setup_steps).where(
        and18(
          eq19(setup_steps.company_id, companyId),
          franchiseId ? eq19(setup_steps.franchise_id, franchiseId) : void 0
        )
      );
      const completedSteps = totalSteps.filter(
        (step) => step.status === "completed" || step.status === "skipped"
      );
      if (totalSteps.length === 0) return 0;
      return Math.round(completedSteps.length / totalSteps.length * 100);
    } catch (error) {
      console.error("Error calculating setup progress:", error);
      return 0;
    }
  }
  /**
   * Register API routes for setup functionality
   */
  registerRoutes(app2) {
    this.logger.info("Registering setup routes...");
    const router14 = Router6();
    const requireAuth = AuthGuard.AuthGuard.protect("required" /* REQUIRED */);
    router14.get("/steps/:companyId", requireAuth, async (req, res) => {
      try {
        const { companyId } = req.params;
        const franchiseId = req.query.franchiseId;
        const steps = await this.getCompanySetupSteps(companyId, franchiseId);
        res.json({ success: true, data: steps });
      } catch (error) {
        this.logger.error("Error fetching setup steps:", error);
        res.status(500).json({ success: false, message: "Failed to fetch setup steps" });
      }
    });
    router14.post("/steps/:companyId", requireAuth, async (req, res) => {
      try {
        const { companyId } = req.params;
        const { step, status, franchiseId } = req.body;
        if (!step) {
          return res.status(400).json({ success: false, message: "Step name is required" });
        }
        const stepStatus = status || "completed";
        const id = await this.recordSetupStep(companyId, step, stepStatus, franchiseId);
        res.json({ success: true, data: { id, step, status: stepStatus } });
      } catch (error) {
        this.logger.error("Error recording setup step:", error);
        res.status(500).json({ success: false, message: "Failed to record setup step" });
      }
    });
    router14.get("/progress/:companyId", requireAuth, async (req, res) => {
      try {
        const { companyId } = req.params;
        const franchiseId = req.query.franchiseId;
        const progress = await this.getSetupProgress(companyId, franchiseId);
        res.json({ success: true, data: { progress } });
      } catch (error) {
        this.logger.error("Error calculating setup progress:", error);
        res.status(500).json({ success: false, message: "Failed to calculate setup progress" });
      }
    });
    router14.get("/completed/:companyId/:step", requireAuth, async (req, res) => {
      try {
        const { companyId, step } = req.params;
        const franchiseId = req.query.franchiseId;
        const isCompleted = await this.isStepComplete(companyId, step, franchiseId);
        res.json({ success: true, data: { completed: isCompleted } });
      } catch (error) {
        this.logger.error("Error checking step completion:", error);
        res.status(500).json({ success: false, message: "Failed to check step completion" });
      }
    });
    app2.use("/api/admin/setup", router14);
    this.logger.info("Setup routes registered successfully");
  }
};

// server/modules/admin/services/health-check.service.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
import { sql as sql16 } from "drizzle-orm";
import { Router as Router7 } from "express";
import * as os from "os";
import * as fs2 from "fs";
var HealthStatus = /* @__PURE__ */ ((HealthStatus2) => {
  HealthStatus2["HEALTHY"] = "healthy";
  HealthStatus2["UNHEALTHY"] = "unhealthy";
  HealthStatus2["DEGRADED"] = "degraded";
  return HealthStatus2;
})(HealthStatus || {});
var ServiceType = /* @__PURE__ */ ((ServiceType2) => {
  ServiceType2["DATABASE"] = "database";
  ServiceType2["EXTERNAL_API"] = "external_api";
  ServiceType2["SYSTEM"] = "system";
  ServiceType2["CACHE"] = "cache";
  ServiceType2["STORAGE"] = "storage";
  ServiceType2["MODULE"] = "module";
  return ServiceType2;
})(ServiceType || {});
var HealthCheckService = class {
  // This should come from a version file or environment variable
  /**
   * Constructor for HealthCheckService
   * @param db Drizzle database instance
   */
  constructor(db4) {
    this.logger = new Logger("HealthCheckService");
    this.components = /* @__PURE__ */ new Map();
    this.startTime = /* @__PURE__ */ new Date();
    this.version = "2.0.0";
    // Health check timer interval
    this.healthCheckTimer = null;
    this.healthCheckIntervalMs = 5 * 60 * 1e3;
    this.db = db4;
    this.registerDefaultChecks();
  }
  /**
   * Set config service reference
   * @param configService ConfigService instance
   */
  setConfigService(configService) {
    this.configService = configService;
  }
  /**
   * Register default health checks
   */
  registerDefaultChecks() {
    this.registerHealthCheck({
      name: "postgresql",
      type: "database" /* DATABASE */,
      status: "unhealthy" /* UNHEALTHY */,
      lastChecked: /* @__PURE__ */ new Date()
    });
    this.registerHealthCheck({
      name: "cpu",
      type: "system" /* SYSTEM */,
      status: "healthy" /* HEALTHY */,
      lastChecked: /* @__PURE__ */ new Date()
    });
    this.registerHealthCheck({
      name: "memory",
      type: "system" /* SYSTEM */,
      status: "healthy" /* HEALTHY */,
      lastChecked: /* @__PURE__ */ new Date()
    });
    this.registerHealthCheck({
      name: "disk",
      type: "system" /* SYSTEM */,
      status: "healthy" /* HEALTHY */,
      lastChecked: /* @__PURE__ */ new Date()
    });
  }
  /**
   * Register a health check component
   * @param component The health component to register
   */
  registerHealthCheck(component) {
    this.components.set(component.name, component);
    this.logger.debug(`Registered health check: ${component.name}`);
  }
  /**
   * Update a health check component
   * @param name Component name
   * @param status Health status
   * @param details Optional details
   */
  updateHealthCheck(name, status, details) {
    const component = this.components.get(name);
    if (component) {
      component.status = status;
      component.details = details;
      component.lastChecked = /* @__PURE__ */ new Date();
      this.components.set(name, component);
      if (status !== "healthy" /* HEALTHY */) {
        this.logger.warn(`Health check ${name} is ${status}: ${JSON.stringify(details)}`);
      } else {
        this.logger.debug(`Health check ${name} is ${status}`);
      }
    }
  }
  /**
   * Remove a health check component
   * @param name Component name
   */
  removeHealthCheck(name) {
    if (this.components.has(name)) {
      this.components.delete(name);
      this.logger.debug(`Removed health check: ${name}`);
    }
  }
  /**
   * Get all health check components
   * @returns Array of health check components
   */
  getHealthComponents() {
    return Array.from(this.components.values());
  }
  /**
   * Run all health checks
   * @returns Health check result
   */
  async runHealthChecks() {
    const components = this.getHealthComponents();
    await Promise.all(components.map((component) => this.runHealthCheck(component.name)));
    const updatedComponents = this.getHealthComponents();
    const hasUnhealthy = updatedComponents.some((c) => c.status === "unhealthy" /* UNHEALTHY */);
    const hasDegraded = updatedComponents.some((c) => c.status === "degraded" /* DEGRADED */);
    let overallStatus = "healthy" /* HEALTHY */;
    if (hasUnhealthy) {
      overallStatus = "unhealthy" /* UNHEALTHY */;
    } else if (hasDegraded) {
      overallStatus = "degraded" /* DEGRADED */;
    }
    return {
      status: overallStatus,
      components: updatedComponents,
      timestamp: /* @__PURE__ */ new Date(),
      uptime: Math.floor(((/* @__PURE__ */ new Date()).getTime() - this.startTime.getTime()) / 1e3),
      version: this.version
    };
  }
  /**
   * Run a specific health check
   * @param name Component name
   * @returns Health check component
   */
  async runHealthCheck(name) {
    const component = this.components.get(name);
    if (!component) {
      return null;
    }
    try {
      switch (name) {
        case "postgresql":
          await this.checkDatabase(component);
          break;
        case "cpu":
          await this.checkCpu(component);
          break;
        case "memory":
          await this.checkMemory(component);
          break;
        case "disk":
          await this.checkDisk(component);
          break;
        // Add other built-in checks here
        default:
          break;
      }
      return component;
    } catch (error) {
      this.logger.error(`Error running health check ${name}:`, error);
      this.updateHealthCheck(name, "unhealthy" /* UNHEALTHY */, { error: error.message });
      return component;
    }
  }
  /**
   * Check database health
   * @param component Health component
   */
  async checkDatabase(component) {
    try {
      const startTime = Date.now();
      await this.db.executeQuery(sql16`SELECT 1`);
      const responseTime = Date.now() - startTime;
      this.updateHealthCheck(component.name, "healthy" /* HEALTHY */, {
        responseTime: `${responseTime}ms`
      });
    } catch (error) {
      this.updateHealthCheck(component.name, "unhealthy" /* UNHEALTHY */, {
        error: error.message
      });
    }
  }
  /**
   * Check CPU health
   * @param component Health component
   */
  async checkCpu(component) {
    try {
      const cpus3 = os.cpus();
      const cpuUsage = this.getCpuUsage();
      let status = "healthy" /* HEALTHY */;
      if (cpuUsage > 80) {
        status = "degraded" /* DEGRADED */;
      }
      this.updateHealthCheck(component.name, status, {
        cores: cpus3.length,
        model: cpus3[0]?.model || "Unknown",
        usage: `${cpuUsage.toFixed(2)}%`
      });
    } catch (error) {
      this.updateHealthCheck(component.name, "unhealthy" /* UNHEALTHY */, {
        error: error.message
      });
    }
  }
  /**
   * Check memory health
   * @param component Health component
   */
  async checkMemory(component) {
    try {
      const totalMem = os.totalmem();
      const freeMem = os.freemem();
      const usedMem = totalMem - freeMem;
      const memUsagePercent = usedMem / totalMem * 100;
      let status = "healthy" /* HEALTHY */;
      if (memUsagePercent > 80) {
        status = "degraded" /* DEGRADED */;
      }
      this.updateHealthCheck(component.name, status, {
        total: this.formatBytes(totalMem),
        free: this.formatBytes(freeMem),
        used: this.formatBytes(usedMem),
        usage: `${memUsagePercent.toFixed(2)}%`
      });
    } catch (error) {
      this.updateHealthCheck(component.name, "unhealthy" /* UNHEALTHY */, {
        error: error.message
      });
    }
  }
  /**
   * Check disk health
   * @param component Health component
   */
  async checkDisk(component) {
    try {
      const rootDir = "/";
      const diskInfo = await this.getDiskInfo(rootDir);
      let status = "healthy" /* HEALTHY */;
      if (diskInfo.usagePercent > 80) {
        status = "degraded" /* DEGRADED */;
      }
      this.updateHealthCheck(component.name, status, {
        path: rootDir,
        total: this.formatBytes(diskInfo.total),
        free: this.formatBytes(diskInfo.free),
        used: this.formatBytes(diskInfo.used),
        usage: `${diskInfo.usagePercent.toFixed(2)}%`
      });
    } catch (error) {
      this.updateHealthCheck(component.name, "unhealthy" /* UNHEALTHY */, {
        error: error.message
      });
    }
  }
  /**
   * Get CPU usage (approximate)
   * @returns CPU usage percentage
   */
  getCpuUsage() {
    const cpus3 = os.cpus();
    let totalIdle = 0;
    let totalTick = 0;
    cpus3.forEach((cpu) => {
      for (const type in cpu.times) {
        totalTick += cpu.times[type];
      }
      totalIdle += cpu.times.idle;
    });
    return 100 - totalIdle / totalTick * 100;
  }
  /**
   * Get disk info
   * @param path Directory path
   * @returns Disk info with total, free, used, and usage percent
   */
  async getDiskInfo(path6) {
    try {
      const stats = await fs2.promises.statfs(path6);
      const total = stats.blocks * stats.bsize;
      const free = stats.bfree * stats.bsize;
      const used = total - free;
      const usagePercent = used / total * 100;
      return { total, free, used, usagePercent };
    } catch (error) {
      this.logger.warn("Could not get disk info, using fallback data");
      const tmpDir = os.tmpdir();
      const stats = await fs2.promises.stat(tmpDir);
      const total = 100 * 1024 * 1024 * 1024;
      const used = 30 * 1024 * 1024 * 1024;
      const free = total - used;
      const usagePercent = 30;
      return { total, free, used, usagePercent };
    }
  }
  /**
   * Format bytes to human-readable string
   * @param bytes Bytes
   * @returns Formatted string
   */
  formatBytes(bytes) {
    const units = ["B", "KB", "MB", "GB", "TB"];
    let value = bytes;
    let unitIndex = 0;
    while (value >= 1024 && unitIndex < units.length - 1) {
      value /= 1024;
      unitIndex++;
    }
    return `${value.toFixed(2)} ${units[unitIndex]}`;
  }
  // 5 minutes by default
  /**
   * Start periodic health checks
   * @param intervalMs Optional interval in milliseconds
   */
  startPeriodicChecks(intervalMs) {
    if (this.healthCheckTimer) {
      this.logger.warn("Periodic health checks already running");
      return;
    }
    if (intervalMs) {
      this.healthCheckIntervalMs = intervalMs;
    } else if (this.configService) {
      const configInterval = this.configService.getNumber("health.checkIntervalMs");
      if (configInterval) {
        this.healthCheckIntervalMs = configInterval;
      }
    }
    this.logger.info(`Starting periodic health checks every ${this.healthCheckIntervalMs / 1e3} seconds`);
    this.runHealthChecks().catch((error) => {
      this.logger.error("Error in initial health check:", error);
    });
    this.healthCheckTimer = setInterval(() => {
      this.runHealthChecks().catch((error) => {
        this.logger.error("Error in periodic health check:", error);
      });
    }, this.healthCheckIntervalMs);
  }
  /**
   * Stop periodic health checks
   */
  stopPeriodicChecks() {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = null;
      this.logger.info("Stopped periodic health checks");
    }
  }
  /**
   * Register API routes for health checks
   * @param app Express application
   */
  registerRoutes(app2) {
    this.logger.info("Registering health check routes...");
    const router14 = Router7();
    const requireAuth = AuthGuard.AuthGuard.protect("required" /* REQUIRED */);
    const requireAdmin = AuthGuard.requireRoles(["admin"]);
    router14.get("/health", async (req, res) => {
      try {
        let dbStatus = "unhealthy" /* UNHEALTHY */;
        try {
          await this.db.executeQuery(sql16`SELECT 1`);
          dbStatus = "healthy" /* HEALTHY */;
        } catch (error) {
          dbStatus = "unhealthy" /* UNHEALTHY */;
        }
        const isHealthy = dbStatus === "healthy" /* HEALTHY */;
        res.status(isHealthy ? 200 : 503).json({
          status: isHealthy ? "ok" : "error",
          timestamp: /* @__PURE__ */ new Date()
        });
      } catch (error) {
        this.logger.error("Error in basic health check:", error);
        res.status(503).json({
          status: "error",
          timestamp: /* @__PURE__ */ new Date()
        });
      }
    });
    router14.get("/health/details", requireAuth, async (req, res) => {
      try {
        const result = await this.runHealthChecks();
        let statusCode = 200;
        if (result.status === "degraded" /* DEGRADED */) {
          statusCode = 200;
        } else if (result.status === "unhealthy" /* UNHEALTHY */) {
          statusCode = 503;
        }
        res.status(statusCode).json({
          success: result.status !== "unhealthy" /* UNHEALTHY */,
          data: result
        });
      } catch (error) {
        this.logger.error("Error running detailed health checks:", error);
        res.status(500).json({
          success: false,
          message: "Failed to run health checks",
          error: error.message
        });
      }
    });
    router14.get("/health/check/:name", requireAdmin, async (req, res) => {
      try {
        const { name } = req.params;
        if (!this.components.has(name)) {
          return res.status(404).json({
            success: false,
            message: `Health check "${name}" not found`
          });
        }
        const result = await this.runHealthCheck(name);
        res.json({
          success: true,
          data: result
        });
      } catch (error) {
        this.logger.error(`Error running health check:`, error);
        res.status(500).json({
          success: false,
          message: "Failed to run health check",
          error: error.message
        });
      }
    });
    router14.post("/health/register", requireAdmin, async (req, res) => {
      try {
        const { name, type, status, details } = req.body;
        if (!name || !type || !status) {
          return res.status(400).json({
            success: false,
            message: "Name, type, and status are required"
          });
        }
        if (!Object.values(ServiceType).includes(type)) {
          return res.status(400).json({
            success: false,
            message: `Invalid type. Must be one of: ${Object.values(ServiceType).join(", ")}`
          });
        }
        if (!Object.values(HealthStatus).includes(status)) {
          return res.status(400).json({
            success: false,
            message: `Invalid status. Must be one of: ${Object.values(HealthStatus).join(", ")}`
          });
        }
        this.registerHealthCheck({
          name,
          type,
          status,
          details,
          lastChecked: /* @__PURE__ */ new Date()
        });
        res.status(201).json({
          success: true,
          message: `Health check "${name}" registered successfully`
        });
      } catch (error) {
        this.logger.error("Error registering health check:", error);
        res.status(500).json({
          success: false,
          message: "Failed to register health check",
          error: error.message
        });
      }
    });
    router14.delete("/health/register/:name", requireAdmin, async (req, res) => {
      try {
        const { name } = req.params;
        if (!this.components.has(name)) {
          return res.status(404).json({
            success: false,
            message: `Health check "${name}" not found`
          });
        }
        const builtInChecks = ["postgresql", "cpu", "memory", "disk"];
        if (builtInChecks.includes(name)) {
          return res.status(403).json({
            success: false,
            message: `Cannot remove built-in health check "${name}"`
          });
        }
        this.removeHealthCheck(name);
        res.json({
          success: true,
          message: `Health check "${name}" removed successfully`
        });
      } catch (error) {
        this.logger.error("Error removing health check:", error);
        res.status(500).json({
          success: false,
          message: "Failed to remove health check",
          error: error.message
        });
      }
    });
    app2.use("/api/admin", router14);
    this.logger.info("Health check routes registered successfully");
  }
};

// server/modules/admin/services/api-key.service.ts
init_admin_schema();
init_auth_guard();
init_auth_mode_enum();
init_logger();
init_audit_service();
import { and as and19, eq as eq20 } from "drizzle-orm";
import { Router as Router8 } from "express";
import { v4 as uuidv44 } from "uuid";
import * as crypto from "crypto";
var ApiKeyService = class {
  /**
   * Constructor for ApiKeyService
   * @param db Drizzle database instance
   */
  constructor(db4) {
    this.logger = new Logger("ApiKeyService");
    this.db = db4;
  }
  /**
   * Create a new API key
   * @param data API key data including name, expiration, and scope
   * @param createdBy ID of the user creating the key
   * @returns Created API key object with the full key (only shown once)
   */
  async createApiKey(data, createdBy) {
    try {
      this.logger.info(`Creating new API key: ${data.name}`);
      const id = uuidv44();
      const prefix = "geniusapi";
      const secretKey = this.generateSecretKey();
      const displayKey = `${prefix}_${secretKey.substring(0, 16)}`;
      const hashedKey = this.hashKey(secretKey);
      const [apiKey] = await this.db.insert(api_keys).values({
        id,
        name: data.name,
        description: data.description || null,
        prefix,
        key_hash: hashedKey,
        last_used_at: null,
        expires_at: data.expiresAt || null,
        scope: data.scope || null,
        status: "active" /* ACTIVE */,
        company_id: data.companyId,
        created_by: createdBy,
        updated_by: createdBy
      }).returning();
      return {
        ...apiKey,
        full_key: `${prefix}_${secretKey}`
        // This is only returned once
      };
    } catch (error) {
      this.logger.error("Error creating API key:", error);
      throw error;
    }
  }
  /**
   * Validate an API key
   * @param apiKey The full API key to validate
   * @returns API key record if valid, null otherwise
   */
  async validateApiKey(apiKey) {
    try {
      const [prefix, secretKey] = apiKey.split("_");
      if (!prefix || !secretKey) {
        return null;
      }
      const hashedKey = this.hashKey(secretKey);
      const [key] = await this.db.select().from(api_keys).where(
        and19(
          eq20(api_keys.prefix, prefix),
          eq20(api_keys.key_hash, hashedKey),
          eq20(api_keys.status, "active" /* ACTIVE */)
        )
      );
      if (!key) {
        return null;
      }
      if (key.expires_at && new Date(key.expires_at) < /* @__PURE__ */ new Date()) {
        await this.db.update(api_keys).set({
          status: "expired" /* EXPIRED */,
          updated_at: /* @__PURE__ */ new Date()
        }).where(eq20(api_keys.id, key.id));
        return null;
      }
      await this.db.update(api_keys).set({
        last_used_at: /* @__PURE__ */ new Date(),
        updated_at: /* @__PURE__ */ new Date()
      }).where(eq20(api_keys.id, key.id));
      return key;
    } catch (error) {
      this.logger.error("Error validating API key:", error);
      return null;
    }
  }
  /**
   * Get API keys for a company
   * @param companyId Company ID
   * @returns Array of API key objects
   */
  async getApiKeysByCompany(companyId) {
    try {
      return await this.db.select({
        id: api_keys.id,
        name: api_keys.name,
        description: api_keys.description,
        prefix: api_keys.prefix,
        lastUsedAt: api_keys.last_used_at,
        expiresAt: api_keys.expires_at,
        scope: api_keys.scope,
        status: api_keys.status,
        createdAt: api_keys.created_at,
        createdBy: api_keys.created_by
      }).from(api_keys).where(eq20(api_keys.company_id, companyId));
    } catch (error) {
      this.logger.error(`Error getting API keys for company ${companyId}:`, error);
      throw error;
    }
  }
  /**
   * Get an API key by ID
   * @param keyId API key ID
   * @returns API key object
   */
  async getApiKeyById(keyId) {
    try {
      const [key] = await this.db.select({
        id: api_keys.id,
        name: api_keys.name,
        description: api_keys.description,
        prefix: api_keys.prefix,
        lastUsedAt: api_keys.last_used_at,
        expiresAt: api_keys.expires_at,
        scope: api_keys.scope,
        status: api_keys.status,
        companyId: api_keys.company_id,
        createdAt: api_keys.created_at,
        createdBy: api_keys.created_by
      }).from(api_keys).where(eq20(api_keys.id, keyId));
      return key;
    } catch (error) {
      this.logger.error(`Error getting API key ${keyId}:`, error);
      throw error;
    }
  }
  /**
   * Update an API key
   * @param keyId API key ID
   * @param updates Fields to update (name, description, expiresAt, scope)
   * @param updatedBy ID of the user making the change
   * @returns Updated API key object
   */
  async updateApiKey(keyId, updates, updatedBy) {
    try {
      const updateData = {
        updated_at: /* @__PURE__ */ new Date(),
        updated_by: updatedBy
      };
      if (updates.name !== void 0) {
        updateData.name = updates.name;
      }
      if (updates.description !== void 0) {
        updateData.description = updates.description;
      }
      if (updates.expiresAt !== void 0) {
        updateData.expires_at = updates.expiresAt;
      }
      if (updates.scope !== void 0) {
        updateData.scope = updates.scope;
      }
      const [apiKey] = await this.db.update(api_keys).set(updateData).where(eq20(api_keys.id, keyId)).returning();
      if (!apiKey) {
        throw new Error(`API key with ID ${keyId} not found`);
      }
      await AuditService.log({
        userId: updatedBy,
        companyId: apiKey.company_id,
        action: "UPDATE" /* UPDATE */,
        entity: "api_keys",
        entityId: keyId,
        details: {
          updates: {
            ...updates,
            // Don't include the actual key in the audit log
            key: void 0
          }
        }
      });
      return {
        id: apiKey.id,
        name: apiKey.name,
        description: apiKey.description,
        prefix: apiKey.prefix,
        lastUsedAt: apiKey.last_used_at,
        expiresAt: apiKey.expires_at,
        scope: apiKey.scope,
        status: apiKey.status,
        companyId: apiKey.company_id,
        createdAt: apiKey.created_at,
        createdBy: apiKey.created_by
      };
    } catch (error) {
      this.logger.error(`Error updating API key ${keyId}:`, error);
      throw error;
    }
  }
  /**
   * Rotate an API key (generate a new secret but keep the same ID and metadata)
   * @param keyId API key ID
   * @param updatedBy ID of the user making the change
   * @returns Updated API key object with the new full key (only shown once)
   */
  async rotateApiKey(keyId, updatedBy) {
    try {
      const [existingKey] = await this.db.select().from(api_keys).where(eq20(api_keys.id, keyId));
      if (!existingKey) {
        throw new Error(`API key with ID ${keyId} not found`);
      }
      const secretKey = this.generateSecretKey();
      const hashedKey = this.hashKey(secretKey);
      const [apiKey] = await this.db.update(api_keys).set({
        key_hash: hashedKey,
        updated_at: /* @__PURE__ */ new Date(),
        updated_by: updatedBy
      }).where(eq20(api_keys.id, keyId)).returning();
      await AuditService.log({
        userId: updatedBy,
        companyId: apiKey.company_id,
        action: "UPDATE" /* UPDATE */,
        entity: "api_keys",
        entityId: keyId,
        details: {
          event: "api_key_rotation"
        }
      });
      return {
        ...apiKey,
        full_key: `${apiKey.prefix}_${secretKey}`
        // This is only returned once
      };
    } catch (error) {
      this.logger.error(`Error rotating API key ${keyId}:`, error);
      throw error;
    }
  }
  /**
   * Revoke an API key
   * @param keyId API key ID
   * @param updatedBy ID of the user making the change
   * @returns Boolean indicating success
   */
  async revokeApiKey(keyId, updatedBy) {
    try {
      const [existingKey] = await this.db.select().from(api_keys).where(eq20(api_keys.id, keyId));
      if (!existingKey) {
        throw new Error(`API key with ID ${keyId} not found`);
      }
      await this.db.update(api_keys).set({
        status: "revoked" /* REVOKED */,
        updated_at: /* @__PURE__ */ new Date(),
        updated_by: updatedBy
      }).where(eq20(api_keys.id, keyId));
      await AuditService.log({
        userId: updatedBy,
        companyId: existingKey.company_id,
        action: "UPDATE" /* UPDATE */,
        entity: "api_keys",
        entityId: keyId,
        details: {
          event: "api_key_revocation"
        }
      });
      return true;
    } catch (error) {
      this.logger.error(`Error revoking API key ${keyId}:`, error);
      throw error;
    }
  }
  /**
   * Generate a cryptographically secure random key
   * @returns Random key string
   */
  generateSecretKey() {
    return crypto.randomBytes(32).toString("hex");
  }
  /**
   * Hash an API key for storage
   * @param key The key to hash
   * @returns Hashed key
   */
  hashKey(key) {
    return crypto.createHash("sha256").update(key).digest("hex");
  }
  /**
   * Register API routes for API key management
   * @param app Express application
   */
  registerRoutes(app2) {
    this.logger.info("Registering API key management routes...");
    const router14 = Router8();
    const requireAuth = AuthGuard.AuthGuard.protect("required" /* REQUIRED */);
    const requireAdmin = AuthGuard.requireRoles(["admin"]);
    router14.get("/api-keys/:companyId", requireAuth, async (req, res) => {
      try {
        const { companyId } = req.params;
        const apiKeys = await this.getApiKeysByCompany(companyId);
        res.json({ success: true, data: apiKeys });
      } catch (error) {
        this.logger.error("Error fetching API keys:", error);
        res.status(500).json({ success: false, message: "Failed to fetch API keys" });
      }
    });
    router14.get("/api-keys/detail/:keyId", requireAuth, async (req, res) => {
      try {
        const { keyId } = req.params;
        const apiKey = await this.getApiKeyById(keyId);
        if (!apiKey) {
          return res.status(404).json({ success: false, message: "API key not found" });
        }
        res.json({ success: true, data: apiKey });
      } catch (error) {
        this.logger.error("Error fetching API key details:", error);
        res.status(500).json({ success: false, message: "Failed to fetch API key details" });
      }
    });
    router14.post("/api-keys", requireAdmin, async (req, res) => {
      try {
        const { name, description, expiresAt, scope, companyId } = req.body;
        if (!name || !companyId) {
          return res.status(400).json({
            success: false,
            message: "Missing required fields (name, companyId)"
          });
        }
        const parsedExpiresAt = expiresAt ? new Date(expiresAt) : void 0;
        const apiKey = await this.createApiKey(
          {
            name,
            description,
            expiresAt: parsedExpiresAt,
            scope,
            companyId
          },
          req.user?.id
        );
        res.status(201).json({ success: true, data: apiKey });
      } catch (error) {
        this.logger.error("Error creating API key:", error);
        res.status(500).json({ success: false, message: "Failed to create API key" });
      }
    });
    router14.put("/api-keys/:keyId", requireAdmin, async (req, res) => {
      try {
        const { keyId } = req.params;
        const { name, description, expiresAt, scope } = req.body;
        if (!name && description === void 0 && expiresAt === void 0 && scope === void 0) {
          return res.status(400).json({
            success: false,
            message: "At least one field to update is required"
          });
        }
        const parsedExpiresAt = expiresAt !== void 0 ? expiresAt ? new Date(expiresAt) : null : void 0;
        const apiKey = await this.updateApiKey(
          keyId,
          {
            name,
            description,
            expiresAt: parsedExpiresAt,
            scope: scope === void 0 ? void 0 : scope || null
          },
          req.user?.id
        );
        res.json({ success: true, data: apiKey });
      } catch (error) {
        this.logger.error("Error updating API key:", error);
        res.status(500).json({ success: false, message: "Failed to update API key" });
      }
    });
    router14.post("/api-keys/:keyId/rotate", requireAdmin, async (req, res) => {
      try {
        const { keyId } = req.params;
        const apiKey = await this.rotateApiKey(keyId, req.user?.id);
        res.json({
          success: true,
          data: apiKey,
          message: "API key rotated successfully. Please save the new key as it will not be shown again."
        });
      } catch (error) {
        this.logger.error("Error rotating API key:", error);
        res.status(500).json({ success: false, message: "Failed to rotate API key" });
      }
    });
    router14.post("/api-keys/:keyId/revoke", requireAdmin, async (req, res) => {
      try {
        const { keyId } = req.params;
        await this.revokeApiKey(keyId, req.user?.id);
        res.json({ success: true, message: "API key revoked successfully" });
      } catch (error) {
        this.logger.error("Error revoking API key:", error);
        res.status(500).json({ success: false, message: "Failed to revoke API key" });
      }
    });
    app2.use("/api/admin", router14);
    this.logger.info("API key management routes registered successfully");
  }
};

// server/modules/admin/services/config.service.ts
init_admin_schema();
init_auth_guard();
init_auth_mode_enum();
init_logger();
init_audit_service();
import { and as and20, eq as eq21, isNull as isNull5, sql as sql17 } from "drizzle-orm";
import { Router as Router9 } from "express";
import { v4 as uuidv45 } from "uuid";
var ConfigScope = /* @__PURE__ */ ((ConfigScope2) => {
  ConfigScope2["GLOBAL"] = "global";
  ConfigScope2["COMPANY"] = "company";
  ConfigScope2["USER"] = "user";
  ConfigScope2["MODULE"] = "module";
  return ConfigScope2;
})(ConfigScope || {});
var ConfigService = class {
  /**
   * Constructor for ConfigService
   * @param db Drizzle database instance
   */
  constructor(db4) {
    this.logger = new Logger("ConfigService");
    this.cache = /* @__PURE__ */ new Map();
    this.cacheTTL = 5 * 60 * 1e3;
    // 5 minutes
    this.cacheTimestamps = /* @__PURE__ */ new Map();
    this.db = db4;
  }
  /**
   * Set a configuration value
   * @param key Configuration key
   * @param value Configuration value (will be stored as JSON)
   * @param options Options including scope and IDs
   * @param actorId ID of the user making the change
   * @returns Created/updated configuration
   */
  async setConfig(key, value, options, actorId) {
    try {
      this.logger.debug(`Setting config: ${key} in scope ${options.scope}`);
      const { scope, companyId, userId, moduleId } = options;
      if (scope === "company" /* COMPANY */ && !companyId) {
        throw new Error("Company ID is required for company scope");
      }
      if (scope === "user" /* USER */ && (!userId || !companyId)) {
        throw new Error("User ID and Company ID are required for user scope");
      }
      if (scope === "module" /* MODULE */ && !moduleId) {
        throw new Error("Module ID is required for module scope");
      }
      const whereConditions = this.buildWhereConditions(key, options);
      const existingConfigs = await this.db.select().from(configurations).where(whereConditions);
      let config3;
      if (existingConfigs.length > 0) {
        const [updatedConfig] = await this.db.update(configurations).set({
          value_json: value,
          updated_at: /* @__PURE__ */ new Date(),
          updated_by: actorId
        }).where(whereConditions).returning();
        config3 = updatedConfig;
      } else {
        const [newConfig] = await this.db.insert(configurations).values({
          id: uuidv45(),
          key,
          value_json: value,
          scope,
          company_id: companyId || null,
          user_id: userId || null,
          module_id: moduleId || null,
          created_by: actorId,
          updated_by: actorId
        }).returning();
        config3 = newConfig;
      }
      this.invalidateCache(key, options);
      await AuditService.log({
        userId: actorId,
        companyId: companyId || null,
        action: "UPDATE" /* UPDATE */,
        entity: "configurations",
        entityId: config3.id,
        details: {
          key,
          scope,
          // Don't log sensitive values
          valueType: typeof value
        }
      });
      return config3;
    } catch (error) {
      this.logger.error(`Error setting config ${key}:`, error);
      throw error;
    }
  }
  /**
   * Get a configuration value
   * @param key Configuration key
   * @param options Options including scope and IDs
   * @returns Configuration value or null if not found
   */
  async getConfig(key, options) {
    try {
      const { scope, companyId, userId, moduleId, useCache = true } = options;
      const cacheKey = this.getCacheKey(key, options);
      if (useCache) {
        const cachedValue = this.getFromCache(cacheKey);
        if (cachedValue !== void 0) {
          return cachedValue;
        }
      }
      if (scope === "company" /* COMPANY */ && !companyId) {
        throw new Error("Company ID is required for company scope");
      }
      if (scope === "user" /* USER */ && (!userId || !companyId)) {
        throw new Error("User ID and Company ID are required for user scope");
      }
      if (scope === "module" /* MODULE */ && !moduleId) {
        throw new Error("Module ID is required for module scope");
      }
      const whereConditions = this.buildWhereConditions(key, options);
      const [config3] = await this.db.select().from(configurations).where(whereConditions);
      const value = config3 ? config3.value_json : null;
      if (useCache) {
        this.setInCache(cacheKey, value);
      }
      return value;
    } catch (error) {
      this.logger.error(`Error getting config ${key}:`, error);
      throw error;
    }
  }
  /**
   * Get configuration with cascading fallback
   * This tries to get a config in the following order:
   * 1. User-specific config
   * 2. Company-specific config
   * 3. Module-specific config
   * 4. Global config
   * 
   * @param key Configuration key
   * @param options Options with scope priority and IDs
   * @returns First found configuration value or null if not found at any level
   */
  async getConfigWithFallback(key, options) {
    const { userId, companyId, moduleId, useCache = true } = options;
    try {
      if (userId && companyId) {
        const userConfig = await this.getConfig(key, {
          scope: "user" /* USER */,
          userId,
          companyId,
          useCache
        }).catch(() => null);
        if (userConfig !== null) {
          return userConfig;
        }
      }
      if (companyId) {
        const companyConfig = await this.getConfig(key, {
          scope: "company" /* COMPANY */,
          companyId,
          useCache
        }).catch(() => null);
        if (companyConfig !== null) {
          return companyConfig;
        }
      }
      if (moduleId) {
        const moduleConfig = await this.getConfig(key, {
          scope: "module" /* MODULE */,
          moduleId,
          useCache
        }).catch(() => null);
        if (moduleConfig !== null) {
          return moduleConfig;
        }
      }
      return await this.getConfig(key, {
        scope: "global" /* GLOBAL */,
        useCache
      }).catch(() => null);
    } catch (error) {
      this.logger.error(`Error getting config with fallback ${key}:`, error);
      throw error;
    }
  }
  /**
   * Delete a configuration
   * @param key Configuration key
   * @param options Options including scope and IDs
   * @param actorId ID of the user making the change
   * @returns Boolean indicating success
   */
  async deleteConfig(key, options, actorId) {
    try {
      const { scope, companyId, userId, moduleId } = options;
      if (scope === "company" /* COMPANY */ && !companyId) {
        throw new Error("Company ID is required for company scope");
      }
      if (scope === "user" /* USER */ && (!userId || !companyId)) {
        throw new Error("User ID and Company ID are required for user scope");
      }
      if (scope === "module" /* MODULE */ && !moduleId) {
        throw new Error("Module ID is required for module scope");
      }
      const whereConditions = this.buildWhereConditions(key, options);
      const [config3] = await this.db.select().from(configurations).where(whereConditions);
      if (!config3) {
        return false;
      }
      await this.db.delete(configurations).where(whereConditions);
      this.invalidateCache(key, options);
      await AuditService.log({
        userId: actorId,
        companyId: companyId || null,
        action: "DELETE" /* DELETE */,
        entity: "configurations",
        entityId: config3.id,
        details: {
          key,
          scope
        }
      });
      return true;
    } catch (error) {
      this.logger.error(`Error deleting config ${key}:`, error);
      throw error;
    }
  }
  /**
   * List configurations by scope and optional filters
   * @param options Options for filtering
   * @returns Array of configuration objects
   */
  async listConfigurations(options = {}) {
    try {
      const { scope, companyId, userId, moduleId, keyPrefix, limit = 100, offset = 0 } = options;
      let query = this.db.select().from(configurations);
      const filters = [];
      if (scope) {
        filters.push(eq21(configurations.scope, scope));
      }
      if (companyId) {
        filters.push(eq21(configurations.company_id, companyId));
      } else if (companyId === null) {
        filters.push(isNull5(configurations.company_id));
      }
      if (userId) {
        filters.push(eq21(configurations.user_id, userId));
      } else if (userId === null) {
        filters.push(isNull5(configurations.user_id));
      }
      if (moduleId) {
        filters.push(eq21(configurations.module_id, moduleId));
      } else if (moduleId === null) {
        filters.push(isNull5(configurations.module_id));
      }
      if (keyPrefix) {
        filters.push(sql17`${configurations.key} LIKE ${keyPrefix + "%"}`);
      }
      if (filters.length > 0) {
        query = query.where(and20(...filters));
      }
      query = query.limit(limit).offset(offset).orderBy(configurations.key);
      return await query;
    } catch (error) {
      this.logger.error("Error listing configurations:", error);
      throw error;
    }
  }
  /**
   * Build the where conditions for a configuration query
   * @param key Configuration key
   * @param options Scope options
   * @returns SQL where conditions
   */
  buildWhereConditions(key, options) {
    const { scope, companyId, userId, moduleId } = options;
    const conditions = [
      eq21(configurations.key, key),
      eq21(configurations.scope, scope)
    ];
    if (scope === "company" /* COMPANY */) {
      conditions.push(eq21(configurations.company_id, companyId));
      conditions.push(isNull5(configurations.user_id));
      conditions.push(isNull5(configurations.module_id));
    } else if (scope === "user" /* USER */) {
      conditions.push(eq21(configurations.company_id, companyId));
      conditions.push(eq21(configurations.user_id, userId));
      conditions.push(isNull5(configurations.module_id));
    } else if (scope === "module" /* MODULE */) {
      conditions.push(isNull5(configurations.company_id));
      conditions.push(isNull5(configurations.user_id));
      conditions.push(eq21(configurations.module_id, moduleId));
    } else if (scope === "global" /* GLOBAL */) {
      conditions.push(isNull5(configurations.company_id));
      conditions.push(isNull5(configurations.user_id));
      conditions.push(isNull5(configurations.module_id));
    }
    return and20(...conditions);
  }
  /**
   * Get a cache key for a configuration
   * @param key Configuration key
   * @param options Scope options
   * @returns Cache key string
   */
  getCacheKey(key, options) {
    const { scope, companyId, userId, moduleId } = options;
    return `${scope}:${companyId || "null"}:${userId || "null"}:${moduleId || "null"}:${key}`;
  }
  /**
   * Get a value from the cache
   * @param cacheKey Cache key
   * @returns Cached value or undefined if not found or expired
   */
  getFromCache(cacheKey) {
    const timestamp24 = this.cacheTimestamps.get(cacheKey);
    if (timestamp24 && Date.now() - timestamp24 < this.cacheTTL) {
      return this.cache.get(cacheKey);
    }
    if (timestamp24) {
      this.cache.delete(cacheKey);
      this.cacheTimestamps.delete(cacheKey);
    }
    return void 0;
  }
  /**
   * Set a value in the cache
   * @param cacheKey Cache key
   * @param value Value to cache
   */
  setInCache(cacheKey, value) {
    this.cache.set(cacheKey, value);
    this.cacheTimestamps.set(cacheKey, Date.now());
  }
  /**
   * Invalidate cache for a specific key
   * @param key Configuration key
   * @param options Scope options
   */
  invalidateCache(key, options) {
    const cacheKey = this.getCacheKey(key, options);
    this.cache.delete(cacheKey);
    this.cacheTimestamps.delete(cacheKey);
  }
  /**
   * Clear the entire cache
   */
  clearCache() {
    this.cache.clear();
    this.cacheTimestamps.clear();
    this.logger.info("Config cache cleared");
  }
  /**
   * Register API routes for configuration management
   * @param app Express application
   */
  registerRoutes(app2) {
    this.logger.info("Registering configuration management routes...");
    const router14 = Router9();
    const requireAuth = AuthGuard.AuthGuard.protect("required" /* REQUIRED */);
    const requireAdmin = AuthGuard.requireRoles(["admin"]);
    router14.get("/config", requireAuth, async (req, res) => {
      try {
        const { key, userId, companyId, moduleId, useCache } = req.query;
        if (!key) {
          return res.status(400).json({
            success: false,
            message: "Key parameter is required"
          });
        }
        const value = await this.getConfigWithFallback(
          key,
          {
            userId,
            companyId,
            moduleId,
            useCache: useCache !== "false"
          }
        );
        res.json({ success: true, data: value });
      } catch (error) {
        this.logger.error("Error getting configuration:", error);
        res.status(500).json({ success: false, message: "Failed to get configuration" });
      }
    });
    router14.get("/config/scoped", requireAuth, async (req, res) => {
      try {
        const { key, scope, userId, companyId, moduleId, useCache } = req.query;
        if (!key || !scope) {
          return res.status(400).json({
            success: false,
            message: "Key and scope parameters are required"
          });
        }
        if (!Object.values(ConfigScope).includes(scope)) {
          return res.status(400).json({
            success: false,
            message: `Invalid scope. Must be one of: ${Object.values(ConfigScope).join(", ")}`
          });
        }
        const value = await this.getConfig(
          key,
          {
            scope,
            userId,
            companyId,
            moduleId,
            useCache: useCache !== "false"
          }
        );
        res.json({ success: true, data: value });
      } catch (error) {
        this.logger.error("Error getting scoped configuration:", error);
        res.status(500).json({ success: false, message: "Failed to get configuration" });
      }
    });
    router14.post("/config", requireAdmin, async (req, res) => {
      try {
        const { key, value, scope, userId, companyId, moduleId } = req.body;
        if (!key || value === void 0 || !scope) {
          return res.status(400).json({
            success: false,
            message: "Key, value, and scope are required"
          });
        }
        if (!Object.values(ConfigScope).includes(scope)) {
          return res.status(400).json({
            success: false,
            message: `Invalid scope. Must be one of: ${Object.values(ConfigScope).join(", ")}`
          });
        }
        const config3 = await this.setConfig(
          key,
          value,
          {
            scope,
            userId,
            companyId,
            moduleId
          },
          req.user?.id
        );
        res.json({ success: true, data: config3 });
      } catch (error) {
        this.logger.error("Error setting configuration:", error);
        res.status(500).json({
          success: false,
          message: "Failed to set configuration",
          error: error.message
        });
      }
    });
    router14.delete("/config", requireAdmin, async (req, res) => {
      try {
        const { key, scope, userId, companyId, moduleId } = req.query;
        if (!key || !scope) {
          return res.status(400).json({
            success: false,
            message: "Key and scope parameters are required"
          });
        }
        if (!Object.values(ConfigScope).includes(scope)) {
          return res.status(400).json({
            success: false,
            message: `Invalid scope. Must be one of: ${Object.values(ConfigScope).join(", ")}`
          });
        }
        const success = await this.deleteConfig(
          key,
          {
            scope,
            userId,
            companyId,
            moduleId
          },
          req.user?.id
        );
        if (success) {
          res.json({ success: true, message: "Configuration deleted successfully" });
        } else {
          res.status(404).json({ success: false, message: "Configuration not found" });
        }
      } catch (error) {
        this.logger.error("Error deleting configuration:", error);
        res.status(500).json({
          success: false,
          message: "Failed to delete configuration",
          error: error.message
        });
      }
    });
    router14.get("/config/list", requireAuth, async (req, res) => {
      try {
        const {
          scope,
          companyId,
          userId,
          moduleId,
          keyPrefix,
          limit,
          offset
        } = req.query;
        const configs = await this.listConfigurations({
          scope,
          companyId,
          userId,
          moduleId,
          keyPrefix,
          limit: limit ? parseInt(limit) : void 0,
          offset: offset ? parseInt(offset) : void 0
        });
        res.json({ success: true, data: configs });
      } catch (error) {
        this.logger.error("Error listing configurations:", error);
        res.status(500).json({ success: false, message: "Failed to list configurations" });
      }
    });
    router14.post("/config/clear-cache", requireAdmin, async (req, res) => {
      try {
        this.clearCache();
        res.json({ success: true, message: "Configuration cache cleared successfully" });
      } catch (error) {
        this.logger.error("Error clearing config cache:", error);
        res.status(500).json({ success: false, message: "Failed to clear configuration cache" });
      }
    });
    app2.use("/api/admin", router14);
    this.logger.info("Configuration management routes registered successfully");
  }
};

// server/modules/admin/services/license.service.ts
init_admin_schema();
init_auth_guard();
init_auth_mode_enum();
init_logger();
init_audit_service();
import { and as and21, eq as eq22, sql as sql18 } from "drizzle-orm";
import { Router as Router10 } from "express";
import { v4 as uuidv46 } from "uuid";
import * as crypto2 from "crypto";
import * as os2 from "os";
var LicenseService = class {
  /**
   * Constructor for LicenseService
   * @param db DrizzleService instance
   */
  constructor(db4) {
    this.db = db4;
    this.logger = new Logger("LicenseService");
    this.activeLicense = null;
    this.features = /* @__PURE__ */ new Map();
    this.maxUsers = 0;
    this.maxCompanies = 1;
    this.loadActiveLicense().catch((err) => {
      this.logger.error("Error loading active license:", err);
    });
  }
  /**
   * Load the active license from the database
   */
  async loadActiveLicense() {
    try {
      const [license] = await this.db.query(async (db4) => {
        return await db4.select().from(licenses).where(eq22(licenses.status, "active" /* ACTIVE */)).orderBy(licenses.created_at);
      });
      this.activeLicense = license || null;
      if (license) {
        this.maxUsers = license.max_activations || 5;
        this.maxCompanies = 1;
        this.features = new Map(Object.entries(license.features || {}));
        this.logger.info(`Active license loaded: ${license.license_key.substring(0, 8)}...`);
      } else {
        this.logger.warn("No active license found. Running in limited mode.");
        this.maxUsers = 2;
        this.maxCompanies = 1;
        this.features = /* @__PURE__ */ new Map();
      }
    } catch (error) {
      this.logger.error("Error loading active license:", error);
      this.activeLicense = null;
      this.maxUsers = 2;
      this.maxCompanies = 1;
      this.features = /* @__PURE__ */ new Map();
    }
  }
  /**
   * Get the active license
   * @returns Active license object or null if no active license
   */
  async getActiveLicense() {
    if (!this.activeLicense) {
      await this.loadActiveLicense();
    }
    return this.activeLicense;
  }
  /**
   * Check if a feature is enabled in the current license
   * @param featureKey Feature key to check
   * @returns Boolean indicating if the feature is enabled
   */
  async isFeatureEnabled(featureKey) {
    if (!this.activeLicense) {
      await this.loadActiveLicense();
    }
    if (featureKey.startsWith("core.")) {
      return true;
    }
    return this.features.get(featureKey) === true;
  }
  /**
   * Get the maximum number of users allowed by the license
   * @returns Maximum number of users
   */
  async getMaxUsers() {
    if (!this.activeLicense) {
      await this.loadActiveLicense();
    }
    return this.maxUsers;
  }
  /**
   * Get the maximum number of companies allowed by the license
   * @returns Maximum number of companies
   */
  async getMaxCompanies() {
    if (!this.activeLicense) {
      await this.loadActiveLicense();
    }
    return this.maxCompanies;
  }
  /**
   * Register a new license
   * @param licenseKey License key to register
   * @param actorId ID of the user registering the license
   * @returns Registered license object
   */
  async registerLicense(licenseKey, actorId) {
    try {
      this.logger.info("Registering new license");
      if (!/^[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(licenseKey)) {
        throw new Error("Invalid license key format");
      }
      const existingLicense = await this.db.query(async (db4) => {
        return await db4.select().from(licenses).where(eq22(licenses.license_key, this.hashLicenseKey(licenseKey))).limit(1);
      });
      if (existingLicense.length > 0) {
        throw new Error("This license key is already registered");
      }
      const edition = this.getLicenseEditionFromKey(licenseKey);
      const maxUsers = this.getMaxUsersForEdition(edition);
      const maxCompanies = this.getMaxCompaniesForEdition(edition);
      const features = this.getFeaturesForEdition(edition);
      const expiresAt = /* @__PURE__ */ new Date();
      expiresAt.setFullYear(expiresAt.getFullYear() + 1);
      const hardwareId = this.generateHardwareId();
      const [license] = await this.db.query(async (db4) => {
        return await db4.insert(licenses).values({
          id: uuidv46(),
          license_key: this.hashLicenseKey(licenseKey),
          key_identifier: this.generateKeyIdentifier(licenseKey),
          edition,
          status: "active" /* ACTIVE */,
          registered_at: /* @__PURE__ */ new Date(),
          activated_at: /* @__PURE__ */ new Date(),
          expires_at: expiresAt,
          max_users: maxUsers,
          max_companies: maxCompanies,
          features,
          hardware_id: hardwareId,
          registered_by: actorId,
          activated_by: actorId
        }).returning();
      });
      await AuditService.log({
        userId: actorId,
        companyId: null,
        action: "CREATE" /* CREATE */,
        entity: "licenses",
        entityId: license.id,
        details: {
          edition,
          keyIdentifier: license.key_identifier,
          event: "license_registration"
        }
      });
      this.activeLicense = license;
      this.maxUsers = maxUsers;
      this.maxCompanies = maxCompanies;
      this.features = new Map(Object.entries(features));
      return {
        id: license.id,
        keyIdentifier: license.key_identifier,
        edition: license.edition,
        status: license.status,
        registeredAt: license.registered_at,
        activatedAt: license.activated_at,
        expiresAt: license.expires_at,
        maxUsers: license.max_users,
        maxCompanies: license.max_companies,
        features: license.features
      };
    } catch (error) {
      this.logger.error("Error registering license:", error);
      throw error;
    }
  }
  /**
   * Activate a registered license
   * @param licenseId License ID to activate
   * @param actorId ID of the user activating the license
   * @returns Activated license object
   */
  async activateLicense(licenseId, actorId) {
    try {
      const [license] = await this.db.query(async (db4) => {
        return await db4.select().from(licenses).where(eq22(licenses.id, licenseId));
      });
      if (!license) {
        throw new Error("License not found");
      }
      if (license.status === "active" /* ACTIVE */) {
        return {
          id: license.id,
          keyIdentifier: license.key_identifier,
          edition: license.edition,
          status: license.status,
          registeredAt: license.registered_at,
          activatedAt: license.activated_at,
          expiresAt: license.expires_at,
          maxUsers: license.max_users,
          maxCompanies: license.max_companies,
          features: license.features
        };
      }
      if (license.status === "expired" /* EXPIRED */) {
        throw new Error("Cannot activate expired license");
      }
      if (license.status === "revoked" /* REVOKED */) {
        throw new Error("Cannot activate revoked license");
      }
      await this.db.query(async (db4) => {
        await db4.update(licenses).set({
          status: "pending" /* PENDING */,
          updated_at: /* @__PURE__ */ new Date()
        }).where(eq22(licenses.status, "active" /* ACTIVE */));
      });
      const [activatedLicense] = await this.db.query(async (db4) => {
        return await db4.update(licenses).set({
          status: "active" /* ACTIVE */,
          activated_at: /* @__PURE__ */ new Date(),
          activated_by: actorId,
          updated_at: /* @__PURE__ */ new Date()
        }).where(eq22(licenses.id, licenseId)).returning();
      });
      await AuditService.log({
        userId: actorId,
        companyId: null,
        action: "UPDATE" /* UPDATE */,
        entity: "licenses",
        entityId: licenseId,
        details: {
          event: "license_activation"
        }
      });
      this.activeLicense = activatedLicense;
      this.maxUsers = activatedLicense.max_users || 5;
      this.maxCompanies = activatedLicense.max_companies || 1;
      this.features = new Map(Object.entries(activatedLicense.features || {}));
      return {
        id: activatedLicense.id,
        keyIdentifier: activatedLicense.key_identifier,
        edition: activatedLicense.edition,
        status: activatedLicense.status,
        registeredAt: activatedLicense.registered_at,
        activatedAt: activatedLicense.activated_at,
        expiresAt: activatedLicense.expires_at,
        maxUsers: activatedLicense.max_users,
        maxCompanies: activatedLicense.max_companies,
        features: activatedLicense.features
      };
    } catch (error) {
      this.logger.error("Error activating license:", error);
      throw error;
    }
  }
  /**
   * Deactivate a license
   * @param licenseId License ID to deactivate
   * @param actorId ID of the user deactivating the license
   * @returns Boolean indicating success
   */
  async deactivateLicense(licenseId, actorId) {
    try {
      const [license] = await this.db.query(async (db4) => {
        return await db4.select().from(licenses).where(eq22(licenses.id, licenseId));
      });
      if (!license) {
        throw new Error("License not found");
      }
      if (license.status !== "active" /* ACTIVE */) {
        throw new Error("License is not active");
      }
      await this.db.query(async (db4) => {
        await db4.update(licenses).set({
          status: "pending" /* PENDING */,
          updated_at: /* @__PURE__ */ new Date()
        }).where(eq22(licenses.id, licenseId));
      });
      await AuditService.log({
        userId: actorId,
        companyId: null,
        action: "UPDATE" /* UPDATE */,
        entity: "licenses",
        entityId: licenseId,
        details: {
          event: "license_deactivation"
        }
      });
      if (this.activeLicense && this.activeLicense.id === licenseId) {
        await this.loadActiveLicense();
      }
      return true;
    } catch (error) {
      this.logger.error("Error deactivating license:", error);
      throw error;
    }
  }
  /**
   * Get all licenses
   * @returns Array of license objects
   */
  async getAllLicenses() {
    try {
      const result = await this.db.query(async (db4) => {
        return await db4.select({
          id: licenses.id,
          licenseKey: licenses.license_key,
          edition: licenses.edition,
          status: licenses.status,
          issuedTo: licenses.issued_to,
          issuedEmail: licenses.issued_email,
          maxActivations: licenses.max_activations,
          currentActivations: licenses.current_activations,
          features: licenses.features,
          expiresAt: licenses.expires_at,
          createdAt: licenses.created_at,
          updatedAt: licenses.updated_at
        }).from(licenses).orderBy(licenses.created_at);
      });
      return result;
    } catch (error) {
      this.logger.error("Error getting all licenses:", error);
      throw error;
    }
  }
  /**
   * Check for expired licenses and update their status
   */
  async checkExpiredLicenses() {
    try {
      const now = /* @__PURE__ */ new Date();
      const expiredLicenses = await this.db.query(async (db4) => {
        return await db4.select().from(licenses).where(
          and21(
            eq22(licenses.status, "active" /* ACTIVE */),
            sql18`${licenses.expires_at} < ${now}`
          )
        );
      });
      if (expiredLicenses.length === 0) {
        return;
      }
      for (const license of expiredLicenses) {
        await this.db.query(async (db4) => {
          await db4.update(licenses).set({
            status: "expired" /* EXPIRED */,
            updated_at: now
          }).where(eq22(licenses.id, license.id));
        });
        this.logger.info(`License ${license.key_identifier} has expired`);
        await AuditService.log({
          userId: "system",
          companyId: null,
          action: "UPDATE" /* UPDATE */,
          entity: "licenses",
          entityId: license.id,
          details: {
            event: "license_expiration"
          }
        });
      }
      const activeExpired = expiredLicenses.some(
        (license) => this.activeLicense && license.id === this.activeLicense.id
      );
      if (activeExpired) {
        await this.loadActiveLicense();
      }
    } catch (error) {
      this.logger.error("Error checking expired licenses:", error);
    }
  }
  /**
   * Hash a license key for storage
   * @param licenseKey License key to hash
   * @returns Hashed license key
   */
  hashLicenseKey(licenseKey) {
    return crypto2.createHash("sha256").update(licenseKey).digest("hex");
  }
  /**
   * Generate a key identifier from a license key
   * This creates a partial representation of the key that can be displayed without
   * revealing the full license key
   * @param licenseKey Full license key
   * @returns Partial key identifier
   */
  generateKeyIdentifier(licenseKey) {
    const parts = licenseKey.split("-");
    return `${parts[0]}-****-****-${parts[3]}`;
  }
  /**
   * Generate a hardware identifier for the current system
   * @returns Hardware identifier string
   */
  generateHardwareId() {
    try {
      const networkInterfaces2 = os2.networkInterfaces();
      const cpus3 = os2.cpus();
      const platform2 = os2.platform();
      const totalMem = os2.totalmem();
      const hwInfo = [
        platform2,
        totalMem.toString(),
        cpus3.length.toString(),
        cpus3[0]?.model || "",
        // Get MAC address from the first non-internal interface
        Object.values(networkInterfaces2).flat().filter((iface) => iface && !iface.internal && iface.mac !== "00:00:00:00:00:00").map((iface) => iface?.mac).filter(Boolean).shift() || "unknown"
      ].join("-");
      return crypto2.createHash("sha256").update(hwInfo).digest("hex");
    } catch (error) {
      this.logger.error("Error generating hardware ID:", error);
      return crypto2.randomBytes(32).toString("hex");
    }
  }
  /**
   * Get license edition from key
   * In a real implementation, this would be validated with a license server
   * @param licenseKey License key
   * @returns License edition
   */
  getLicenseEditionFromKey(licenseKey) {
    const firstChar = licenseKey.charAt(0);
    if (firstChar === "E") {
      return "enterprise" /* ENTERPRISE */;
    } else if (firstChar === "P") {
      return "professional" /* PROFESSIONAL */;
    } else if (firstChar === "T") {
      return "trial" /* TRIAL */;
    } else {
      return "basic" /* BASIC */;
    }
  }
  /**
   * Get maximum users for a license edition
   * @param edition License edition
   * @returns Maximum number of users
   */
  getMaxUsersForEdition(edition) {
    switch (edition) {
      case "enterprise" /* ENTERPRISE */:
        return 1e3;
      case "professional" /* PROFESSIONAL */:
        return 100;
      case "trial" /* TRIAL */:
        return 10;
      case "basic" /* BASIC */:
      default:
        return 5;
    }
  }
  /**
   * Get maximum companies for a license edition
   * @param edition License edition
   * @returns Maximum number of companies
   */
  getMaxCompaniesForEdition(edition) {
    switch (edition) {
      case "enterprise" /* ENTERPRISE */:
        return 100;
      case "professional" /* PROFESSIONAL */:
        return 10;
      case "trial" /* TRIAL */:
        return 2;
      case "basic" /* BASIC */:
      default:
        return 1;
    }
  }
  /**
   * Get features for a license edition
   * @param edition License edition
   * @returns Features object
   */
  getFeaturesForEdition(edition) {
    const baseFeatures = {
      "core.users": true,
      "core.companies": true,
      "core.documents": true,
      "module.accounting": true,
      "module.inventory": true,
      "api.basic": true
    };
    const professionalFeatures = {
      ...baseFeatures,
      "module.ecommerce": true,
      "module.crm": true,
      "module.hr": true,
      "api.advanced": true,
      "feature.customization": true,
      "feature.import_export": true
    };
    const enterpriseFeatures = {
      ...professionalFeatures,
      "module.business_intelligence": true,
      "module.predictive_analytics": true,
      "feature.white_label": true,
      "feature.advanced_security": true,
      "feature.multi_branch": true,
      "api.enterprise": true
    };
    const trialFeatures = {
      ...professionalFeatures,
      "module.business_intelligence": true,
      "feature.advanced_security": true
    };
    switch (edition) {
      case "enterprise" /* ENTERPRISE */:
        return enterpriseFeatures;
      case "professional" /* PROFESSIONAL */:
        return professionalFeatures;
      case "trial" /* TRIAL */:
        return trialFeatures;
      case "basic" /* BASIC */:
      default:
        return baseFeatures;
    }
  }
  /**
   * Register API routes for license management
   * @param app Express application
   */
  registerRoutes(app2) {
    this.logger.info("Registering license management routes...");
    const router14 = Router10();
    const requireAuth = AuthGuard.AuthGuard.protect("required" /* REQUIRED */);
    const requireAdmin = AuthGuard.requireRoles(["admin"]);
    router14.get("/licenses", requireAdmin, async (req, res) => {
      try {
        const licenses2 = await this.getAllLicenses();
        res.json({ success: true, data: licenses2 });
      } catch (error) {
        this.logger.error("Error getting licenses:", error);
        res.status(500).json({ success: false, message: "Failed to get licenses" });
      }
    });
    router14.get("/licenses/active", requireAuth, async (req, res) => {
      try {
        const license = await this.getActiveLicense();
        if (!license) {
          return res.json({
            success: true,
            data: {
              status: "none",
              edition: "free",
              maxUsers: 2,
              maxCompanies: 1,
              features: {}
            }
          });
        }
        res.json({
          success: true,
          data: {
            id: license.id,
            keyIdentifier: license.key_identifier,
            edition: license.edition,
            status: license.status,
            registeredAt: license.registered_at,
            activatedAt: license.activated_at,
            expiresAt: license.expires_at,
            maxUsers: license.max_users,
            maxCompanies: license.max_companies,
            features: license.features
          }
        });
      } catch (error) {
        this.logger.error("Error getting active license:", error);
        res.status(500).json({ success: false, message: "Failed to get active license" });
      }
    });
    router14.post("/licenses/register", requireAdmin, async (req, res) => {
      try {
        const { licenseKey } = req.body;
        if (!licenseKey) {
          return res.status(400).json({
            success: false,
            message: "License key is required"
          });
        }
        const license = await this.registerLicense(licenseKey, req.user?.id);
        res.status(201).json({
          success: true,
          data: license,
          message: "License registered and activated successfully"
        });
      } catch (error) {
        this.logger.error("Error registering license:", error);
        res.status(400).json({
          success: false,
          message: `Failed to register license: ${error.message}`
        });
      }
    });
    router14.post("/licenses/:licenseId/activate", requireAdmin, async (req, res) => {
      try {
        const { licenseId } = req.params;
        const license = await this.activateLicense(licenseId, req.user?.id);
        res.json({
          success: true,
          data: license,
          message: "License activated successfully"
        });
      } catch (error) {
        this.logger.error("Error activating license:", error);
        res.status(400).json({
          success: false,
          message: `Failed to activate license: ${error.message}`
        });
      }
    });
    router14.post("/licenses/:licenseId/deactivate", requireAdmin, async (req, res) => {
      try {
        const { licenseId } = req.params;
        await this.deactivateLicense(licenseId, req.user?.id);
        res.json({
          success: true,
          message: "License deactivated successfully"
        });
      } catch (error) {
        this.logger.error("Error deactivating license:", error);
        res.status(400).json({
          success: false,
          message: `Failed to deactivate license: ${error.message}`
        });
      }
    });
    router14.get("/licenses/check-features", requireAuth, async (req, res) => {
      try {
        const { features } = req.query;
        if (!features) {
          return res.status(400).json({
            success: false,
            message: "Features parameter is required"
          });
        }
        const featureList = features.split(",");
        const results = {};
        for (const feature of featureList) {
          results[feature] = await this.isFeatureEnabled(feature);
        }
        res.json({
          success: true,
          data: results
        });
      } catch (error) {
        this.logger.error("Error checking features:", error);
        res.status(500).json({ success: false, message: "Failed to check features" });
      }
    });
    app2.use("/api/admin", router14);
    this.logger.info("License management routes registered successfully");
  }
};

// server/modules/admin/admin.module.ts
var AdminModule = class _AdminModule {
  constructor() {
    this.logger = new Logger("AdminModule");
    this.initialized = false;
  }
  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!_AdminModule.instance) {
      _AdminModule.instance = new _AdminModule();
    }
    return _AdminModule.instance;
  }
  /**
   * Initialize the module with database connection
   */
  initialize(db4) {
    if (this.initialized) {
      this.logger.warn("AdminModule already initialized");
      return;
    }
    this.logger.info("Initializing AdminModule...");
    this.db = db4;
    this.setupService = new SetupService(this.db);
    this.userService = new UserService2(this.db);
    this.roleService = new RoleService(this.db);
    this.healthCheckService = new HealthCheckService(this.db);
    this.apiKeyService = new ApiKeyService(this.db);
    this.configService = new ConfigService(this.db);
    this.licenseService = new LicenseService(this.db);
    this.initialized = true;
    this.logger.info("AdminModule initialized successfully");
  }
  /**
   * Register routes with the Express application
   */
  registerRoutes(app2) {
    if (!this.initialized) {
      this.logger.error("Cannot register routes: AdminModule not initialized");
      return;
    }
    this.logger.info("Registering AdminModule routes...");
    try {
      Promise.resolve().then(() => (init_admin_controller(), admin_controller_exports)).then(({ registerAdminControllerRoutes: registerAdminControllerRoutes2 }) => {
        registerAdminControllerRoutes2(app2, this.userService);
        this.logger.info("Admin controller routes registered");
      }).catch((err) => {
        this.logger.error("Failed to import admin.controller:", err);
      });
      Promise.resolve().then(() => (init_user_controller(), user_controller_exports)).then(({ registerUserControllerRoutes: registerUserControllerRoutes2 }) => {
        registerUserControllerRoutes2(app2, this.userService);
        this.logger.info("User controller routes registered");
      }).catch((err) => {
        this.logger.error("Failed to import user.controller:", err);
      });
      Promise.resolve().then(() => (init_role_controller(), role_controller_exports)).then(({ registerRoleControllerRoutes: registerRoleControllerRoutes2 }) => {
        registerRoleControllerRoutes2(app2, this.roleService);
        this.logger.info("Role controller routes registered");
      }).catch((err) => {
        this.logger.error("Failed to import role.controller:", err);
      });
      Promise.resolve().then(() => (init_api_key_controller(), api_key_controller_exports)).then(({ registerApiKeyControllerRoutes: registerApiKeyControllerRoutes2 }) => {
        registerApiKeyControllerRoutes2(app2, this.apiKeyService);
        this.logger.info("API Key controller routes registered");
      }).catch((err) => {
        this.logger.error("Failed to import api-key.controller:", err);
      });
      Promise.resolve().then(() => (init_config_controller(), config_controller_exports)).then(({ registerConfigControllerRoutes: registerConfigControllerRoutes2 }) => {
        registerConfigControllerRoutes2(app2, this.configService);
        this.logger.info("Config controller routes registered");
      }).catch((err) => {
        this.logger.error("Failed to import config.controller:", err);
      });
      Promise.resolve().then(() => (init_health_check_controller(), health_check_controller_exports)).then(({ registerHealthCheckControllerRoutes: registerHealthCheckControllerRoutes2 }) => {
        registerHealthCheckControllerRoutes2(app2, this.healthCheckService);
        this.logger.info("Health Check controller routes registered");
      }).catch((err) => {
        this.logger.error("Failed to import health-check.controller:", err);
      });
      Promise.resolve().then(() => (init_license_controller(), license_controller_exports)).then(({ registerLicenseControllerRoutes: registerLicenseControllerRoutes2 }) => {
        registerLicenseControllerRoutes2(app2, this.licenseService);
        this.logger.info("License controller routes registered");
      }).catch((err) => {
        this.logger.error("Failed to import license.controller:", err);
      });
      Promise.resolve().then(() => (init_setup_controller(), setup_controller_exports)).then(({ registerSetupControllerRoutes: registerSetupControllerRoutes2 }) => {
        registerSetupControllerRoutes2(app2, this.setupService);
        this.logger.info("Setup controller routes registered");
      }).catch((err) => {
        this.logger.error("Failed to import setup.controller:", err);
      });
    } catch (error) {
      this.logger.error("Error while registering routes:", error);
    }
    this.logger.info("AdminModule routes registered successfully");
  }
  /**
   * Start any background processes or services
   */
  start() {
    if (!this.initialized) {
      this.logger.error("Cannot start: AdminModule not initialized");
      return;
    }
    this.logger.info("Starting AdminModule services...");
    this.healthCheckService.startPeriodicChecks();
    this.logger.info("AdminModule services started successfully");
  }
  /**
   * Stop any background processes or services (for graceful shutdown)
   */
  stop() {
    if (!this.initialized) {
      return;
    }
    this.logger.info("Stopping AdminModule services...");
    this.healthCheckService.stopPeriodicChecks();
    this.logger.info("AdminModule services stopped successfully");
  }
  /**
   * Get the Setup Service instance
   */
  getSetupService() {
    return this.setupService;
  }
  /**
   * Get the User Service instance
   */
  getUserService() {
    return this.userService;
  }
  /**
   * Get the Role Service instance
   */
  getRoleService() {
    return this.roleService;
  }
  /**
   * Get the Health Check Service instance
   */
  getHealthCheckService() {
    return this.healthCheckService;
  }
  /**
   * Get the API Key Service instance
   */
  getApiKeyService() {
    return this.apiKeyService;
  }
  /**
   * Get the Config Service instance
   */
  getConfigService() {
    return this.configService;
  }
  /**
   * Get the License Service instance
   */
  getLicenseService() {
    return this.licenseService;
  }
};

// server/modules/admin/init.ts
init_logger();
var logger37 = new Logger("AdminModuleInit");
function initAdminModule(app2) {
  logger37.info("Initializing Admin module...");
  try {
    const db4 = new DrizzleService();
    const adminModule = AdminModule.getInstance();
    adminModule.initialize(db4);
    adminModule.registerRoutes(app2);
    adminModule.start();
    logger37.info("Admin module initialized successfully.");
    return adminModule;
  } catch (error) {
    logger37.error("Failed to initialize Admin module:", error);
    throw error;
  }
}

// server/modules/index.ts
init_drizzle();

// server/modules/invoicing/invoices.module.ts
import { Router as Router13 } from "express";

// server/shared/libs/http-client.ts
import axios from "axios";
var HttpClient = class {
  constructor(config3 = {}) {
    const defaultRetryConfig = {
      retries: 3,
      retryDelay: 1e3,
      retryStatusCodes: [408, 429, 500, 502, 503, 504]
    };
    this.retryConfig = config3.retry || defaultRetryConfig;
    this.axiosInstance = axios.create({
      baseURL: config3.baseURL,
      timeout: config3.timeout || 1e4,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json",
        ...config3.headers || {}
      }
    });
    this.setupInterceptors();
  }
  /**
   * Set up request and response interceptors for logging and error handling
   */
  setupInterceptors() {
    this.axiosInstance.interceptors.request.use(
      (config3) => {
        log(`\u{1F310} HTTP Request: ${config3.method?.toUpperCase()} ${config3.url}`, "http-client");
        return config3;
      },
      (error) => {
        log(`\u274C HTTP Request Error: ${error.message}`, "http-client");
        return Promise.reject(error);
      }
    );
    this.axiosInstance.interceptors.response.use(
      (response) => {
        log(`\u2705 HTTP Response: ${response.status} from ${response.config.url}`, "http-client");
        return response;
      },
      async (error) => {
        const config3 = error.config;
        if (!config3) {
          log(`\u274C HTTP Response Error: No config available`, "http-client");
          return Promise.reject(error);
        }
        config3._retryCount = config3._retryCount || 0;
        const shouldRetry = config3._retryCount < this.retryConfig.retries && (error.response ? this.retryConfig.retryStatusCodes.includes(error.response.status) : true);
        if (shouldRetry) {
          config3._retryCount += 1;
          log(`\u{1F504} Retrying request (${config3._retryCount}/${this.retryConfig.retries}): ${config3.method?.toUpperCase()} ${config3.url}`, "http-client");
          await new Promise((resolve) => setTimeout(resolve, this.retryConfig.retryDelay));
          return this.axiosInstance(config3);
        }
        if (error.response) {
          log(`\u274C HTTP Response Error: ${error.response.status} from ${config3.url}`, "http-client");
          log(`Details: ${JSON.stringify(error.response.data)}`, "http-client");
        } else if (error.request) {
          log(`\u274C HTTP Request Failed: No response received from ${config3.url}`, "http-client");
        } else {
          log(`\u274C HTTP Setup Error: ${error.message}`, "http-client");
        }
        return Promise.reject(error);
      }
    );
  }
  /**
   * Generic request method
   */
  async request(config3) {
    try {
      return await this.axiosInstance.request(config3);
    } catch (error) {
      log(`\u274C HTTP Request Failed: ${error.message}`, "http-client");
      throw error;
    }
  }
  /**
   * GET request
   */
  async get(url, config3) {
    const response = await this.axiosInstance.get(url, config3);
    return response.data;
  }
  /**
   * POST request
   */
  async post(url, data, config3) {
    const response = await this.axiosInstance.post(url, data, config3);
    return response.data;
  }
  /**
   * PUT request
   */
  async put(url, data, config3) {
    const response = await this.axiosInstance.put(url, data, config3);
    return response.data;
  }
  /**
   * DELETE request
   */
  async delete(url, config3) {
    const response = await this.axiosInstance.delete(url, config3);
    return response.data;
  }
  /**
   * PATCH request
   */
  async patch(url, data, config3) {
    const response = await this.axiosInstance.patch(url, data, config3);
    return response.data;
  }
  /**
   * Set authentication token for future requests
   */
  setAuthToken(token) {
    this.axiosInstance.defaults.headers.common["Authorization"] = `Bearer ${token}`;
  }
  /**
   * Clear authentication token
   */
  clearAuthToken() {
    delete this.axiosInstance.defaults.headers.common["Authorization"];
  }
};
var httpClient = new HttpClient();
var createHttpClient = (config3) => {
  return new HttpClient(config3);
};

// server/modules/integrations/services/exchange-rate.service.ts
var ExchangeRateService = class {
  constructor(config3 = {}) {
    this.baseCurrency = config3.baseCurrency || "RON";
    this.httpClient = createHttpClient({
      baseURL: config3.apiBaseUrl || "https://open.er-api.com/v6",
      timeout: 1e4,
      headers: {
        ...config3.apiKey ? { "apikey": config3.apiKey } : {}
      }
    });
  }
  /**
   * Get latest exchange rates with RON as base currency
   */
  async getLatestRates(baseCurrency = this.baseCurrency) {
    try {
      log(`\u{1F4CA} Fetching latest exchange rates with base currency: ${baseCurrency}`, "exchange-rate");
      const response = await this.httpClient.get(`/latest/${baseCurrency}`);
      if (!response || response.result !== "success") {
        throw new Error("Failed to fetch exchange rates");
      }
      log(`\u2705 Successfully fetched exchange rates for ${Object.keys(response.rates).length} currencies`, "exchange-rate");
      return response.rates;
    } catch (error) {
      log(`\u274C Error fetching exchange rates: ${error.message}`, "exchange-rate");
      throw new Error(`Failed to fetch exchange rates: ${error.message}`);
    }
  }
  /**
   * Get historical exchange rate for a specific date
   */
  async getHistoricalRate(date5, from = this.baseCurrency, to = "EUR") {
    try {
      log(`\u{1F4CA} Fetching historical exchange rate for ${from} to ${to} on ${date5}`, "exchange-rate");
      const formattedDate = new Date(date5).toISOString().split("T")[0];
      const response = await this.httpClient.get(`/${formattedDate}/${from}`);
      if (!response || response.result !== "success" || !response.rates[to]) {
        throw new Error(`Failed to fetch historical exchange rate for ${to}`);
      }
      return response.rates[to];
    } catch (error) {
      log(`\u274C Error fetching historical exchange rate: ${error.message}`, "exchange-rate");
      throw new Error(`Failed to fetch historical exchange rate: ${error.message}`);
    }
  }
  /**
   * Convert amount from one currency to another
   */
  async convertCurrency(amount, from = this.baseCurrency, to = "EUR") {
    try {
      const rates = await this.getLatestRates(from);
      if (!rates[to]) {
        throw new Error(`Exchange rate not available for ${to}`);
      }
      const convertedAmount = amount * rates[to];
      log(`\u{1F4B1} Converted ${amount} ${from} to ${convertedAmount.toFixed(2)} ${to}`, "exchange-rate");
      return convertedAmount;
    } catch (error) {
      log(`\u274C Error converting currency: ${error.message}`, "exchange-rate");
      throw new Error(`Failed to convert currency: ${error.message}`);
    }
  }
  /**
   * Get the BNR (Romanian National Bank) reference exchange rate
   * This is often required for Romanian accounting documents
   */
  async getBNRReferenceRate(date5) {
    try {
      const formattedDate = date5 || (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      log(`\u{1F4CA} Fetching BNR reference exchange rate for ${formattedDate}`, "exchange-rate");
      const response = await this.httpClient.get(`/latest/RON`);
      if (!response || response.result !== "success") {
        throw new Error("Failed to fetch BNR reference exchange rate");
      }
      const relevantCurrencies = ["EUR", "USD", "GBP", "CHF"];
      const filteredRates = {};
      for (const currency of relevantCurrencies) {
        if (response.rates[currency]) {
          filteredRates[currency] = response.rates[currency];
        }
      }
      return filteredRates;
    } catch (error) {
      log(`\u274C Error fetching BNR reference rate: ${error.message}`, "exchange-rate");
      throw new Error(`Failed to fetch BNR reference rate: ${error.message}`);
    }
  }
};
var exchangeRateService = new ExchangeRateService();

// server/modules/invoicing/services/invoice.service.ts
init_drizzle_service();

// server/modules/invoicing/index.ts
import express2 from "express";

// server/modules/invoicing/routes/invoice.routes.ts
init_auth_guard();
import { Router as Router11 } from "express";
init_storage();
var router = Router11();
router.get(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
  async (req, res) => {
    try {
      const companyId = req.user?.companyId || "";
      const { page = "1", limit = "10", sortBy = "issueDate", sortDir = "desc" } = req.query;
      const pageNum = parseInt(page, 10);
      const limitNum = parseInt(limit, 10);
      const offset = (pageNum - 1) * limitNum;
      const result = await InvoiceService.getInvoicesForCompany(
        companyId,
        limitNum,
        offset,
        sortBy,
        sortDir
      );
      console.log(`Retrieved ${result.invoices.length} invoices with customer information`);
      res.json(result);
    } catch (error) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices" });
    }
  }
);
router.get(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const companyId = req.user?.companyId || "";
      const invoice = await InvoiceService.getInvoiceById(req.params.id, companyId);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }
      console.log(`Retrieved invoice ${req.params.id} with customer information`);
      res.json(invoice);
    } catch (error) {
      console.error("Error fetching invoice:", error);
      res.status(500).json({ message: "Failed to fetch invoice" });
    }
  }
);
router.put(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
  async (req, res) => {
    try {
      const updatedInvoice = await storage.updateInvoice(req.params.id, req.body);
      res.json(updatedInvoice);
    } catch (error) {
      console.error("Error updating invoice:", error);
      res.status(500).json({ message: "Failed to update invoice" });
    }
  }
);
router.delete(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["admin" /* ADMIN */, "finance_manager" /* FINANCE_MANAGER */]),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      await InvoiceService.deleteInvoice(req.params.id, userId);
      res.status(204).end();
    } catch (error) {
      console.error("Error deleting invoice:", error);
      res.status(500).json({ message: "Failed to delete invoice" });
    }
  }
);

// server/modules/invoicing/routes/customer.routes.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router12 } from "express";

// server/modules/invoicing/controllers/customer.controller.ts
init_logger();
init_drizzle_service();
import { sql as sql19 } from "drizzle-orm";
var CustomerController = class {
  constructor() {
    this.logger = new Logger("CustomerController");
    this.drizzle = new DrizzleService();
  }
  /**
   * Get customers for invoicing (company clients)
   */
  async getInvoiceCustomers(req, res, next) {
    try {
      const companyId = req.user?.companyId || req.user?.company_id;
      if (!companyId) {
        this.logger.warn("No company ID found in authenticated user");
        this.logger.debug(`User object debug: ${JSON.stringify(req.user)}`);
        res.status(400).json({
          error: "Lips\u0103 ID companie. V\u0103 rug\u0103m s\u0103 v\u0103 autentifica\u021Bi din nou."
        });
        return;
      }
      this.logger.debug(`Getting invoicing customers for company ${companyId}`);
      this.logger.debug(`Token info: userPresent=${!!req.user}, companyIdFormat=${typeof companyId}, hasAuth=${!!req.headers.authorization}`);
      const query = sql19`
        SELECT 
          id, 
          name, 
          vat_number AS "fiscalCode",
          registration_number AS "registrationNumber",
          address,
          city,
          postal_code AS county,
          country,
          email,
          phone
        FROM crm_companies 
        WHERE company_id = ${companyId}
        AND is_customer = true
      `;
      this.logger.debug(`Executing query for company ID: ${companyId}`);
      const customers2 = await this.drizzle.executeQuery(query);
      this.logger.debug(`Found ${customers2.length} customers for invoicing`);
      if (customers2.length > 0) {
        this.logger.debug(`First customer: ${JSON.stringify(customers2[0])}`);
      }
      res.status(200).json(customers2);
    } catch (error) {
      this.logger.error(`Error getting invoicing customers: ${error}`);
      res.status(500).json({
        error: "A ap\u0103rut o eroare la \xEEnc\u0103rcarea clien\u021Bilor. \xCEncerca\u021Bi din nou sau contacta\u021Bi administratorul."
      });
      next(error);
    }
  }
};

// server/modules/invoicing/routes/customer.routes.ts
var router2 = Router12();
var customerController = new CustomerController();
router2.get(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  customerController.getInvoiceCustomers.bind(customerController)
);

// server/modules/invoicing/index.ts
init_auth_guard();
init_auth_mode_enum();
var router3 = express2.Router();
router3.use(
  "/api/invoice-customers",
  AuthGuard.protect("required" /* REQUIRED */),
  // Require authentication for customer routes
  router2
);
router3.use(
  "/api/invoices",
  AuthGuard.protect("required" /* REQUIRED */),
  // Require authentication for all invoice routes
  router
);
var ENTITY_NAME = "invoice";

// server/modules/invoicing/services/invoice.service.ts
init_audit_service();

// server/modules/integrations/services/currency.service.ts
init_schema4();
init_drizzle();
import { eq as eq23, and as and22, desc as desc6 } from "drizzle-orm";
var CurrencyService = class {
  /**
   * Convert an amount between currencies using stored BNR exchange rates
   * 
   * @param amount The amount to convert
   * @param from Source currency code (e.g., 'RON', 'EUR')
   * @param to Target currency code
   * @returns The converted amount with 2 decimal precision
   */
  static async convert(amount, from, to) {
    if (from === to) return amount;
    try {
      const today = /* @__PURE__ */ new Date();
      const rateFrom = from === "RON" ? 1 : await this.getRate(from, today);
      const rateTo = to === "RON" ? 1 : await this.getRate(to, today);
      if (!rateFrom || !rateTo) {
        throw new Error(`Missing exchange rate for ${from} or ${to}`);
      }
      const ronAmount = from === "RON" ? amount : amount * rateFrom;
      const converted = to === "RON" ? ronAmount : ronAmount / rateTo;
      log(`\u{1F4B1} Converted ${amount} ${from} to ${converted.toFixed(2)} ${to} using BNR rates`, "currency");
      return parseFloat(converted.toFixed(2));
    } catch (error) {
      log(`\u274C Error converting currency: ${error.message}`, "currency");
      throw new Error(`Failed to convert currency: ${error.message}`);
    }
  }
  /**
   * Get the latest exchange rate for a currency
   * 
   * @param currency The currency code (e.g., 'EUR', 'USD')
   * @param date The reference date (defaults to today)
   * @returns The exchange rate value or null if not found
   */
  static async getRate(currency, date5 = /* @__PURE__ */ new Date()) {
    try {
      const db4 = getDrizzle();
      const result = await db4.select({
        rate: fx_rates.rate,
        source: fx_rates.source,
        date: fx_rates.date
      }).from(fx_rates).where(and22(
        eq23(fx_rates.currency, currency),
        eq23(fx_rates.baseCurrency, "RON")
      )).orderBy(desc6(fx_rates.date));
      if (!result.length) {
        log(`\u26A0\uFE0F No exchange rate found for ${currency}`, "currency");
        return null;
      }
      const rssRate = result.find((r) => r.source === "BNR_RSS");
      if (rssRate) {
        const rate2 = parseFloat(rssRate.rate.toString());
        log(`\u{1F4CA} Retrieved RSS rate for ${currency}: ${rate2}`, "currency");
        return rate2;
      }
      const bnrRate = result.find((r) => r.source === "BNR");
      if (bnrRate) {
        const rate2 = parseFloat(bnrRate.rate.toString());
        log(`\u{1F4CA} Retrieved BNR rate for ${currency}: ${rate2}`, "currency");
        return rate2;
      }
      const rate = parseFloat(result[0].rate.toString());
      log(`\u{1F4CA} Retrieved fallback rate for ${currency}: ${rate}`, "currency");
      return rate;
    } catch (error) {
      log(`\u274C Error getting exchange rate: ${error.message}`, "currency");
      return null;
    }
  }
  /**
   * Get available exchange rates for a specific date
   * 
   * @param date The reference date (defaults to today)
   * @returns Object with currency codes as keys and rates as values
   */
  static async getRates(date5 = /* @__PURE__ */ new Date()) {
    try {
      const db4 = getDrizzle();
      const formattedDate = new Date(date5);
      formattedDate.setHours(0, 0, 0, 0);
      const startOfDay = new Date(formattedDate);
      const endOfDay = new Date(formattedDate);
      endOfDay.setHours(23, 59, 59, 999);
      const result = await db4.select({
        currency: fx_rates.currency,
        rate: fx_rates.rate,
        source: fx_rates.source,
        date: fx_rates.date
      }).from(fx_rates).where(
        and22(
          eq23(fx_rates.baseCurrency, "RON")
        )
      ).orderBy(desc6(fx_rates.date));
      const rates = {};
      const usedCurrencies = /* @__PURE__ */ new Set();
      for (const row of result) {
        if (usedCurrencies.has(row.currency)) continue;
        if (row.source === "BNR_RSS") {
          rates[row.currency] = parseFloat(row.rate.toString());
          usedCurrencies.add(row.currency);
        }
      }
      for (const row of result) {
        if (usedCurrencies.has(row.currency)) continue;
        if (row.source === "BNR") {
          rates[row.currency] = parseFloat(row.rate.toString());
          usedCurrencies.add(row.currency);
        }
      }
      log(`\u{1F4C8} Retrieved ${Object.keys(rates).length} exchange rates (combined sources)`, "currency");
      return rates;
    } catch (error) {
      log(`\u274C Error getting exchange rates: ${error.message}`, "currency");
      return {};
    }
  }
};

// server/modules/invoicing/services/invoice.service.ts
init_schema4();
var InvoiceService = class {
  static {
    this.drizzle = new DrizzleService();
  }
  /**
   * Convert an amount from one currency to another using the CurrencyService
   * which uses locally stored BNR rates
   */
  static async convertCurrency(amount, fromCurrency, toCurrency, date5) {
    if (fromCurrency === toCurrency) {
      return amount;
    }
    return CurrencyService.convert(amount, fromCurrency, toCurrency);
  }
  /**
   * Create a new draft invoice
   */
  static async createDraftInvoice(invoice, details, lines, userId) {
    invoice.status = "draft";
    invoice.totalAmount = lines.reduce((sum2, line) => sum2 + Number(line.totalAmount), 0).toString();
    const transaction = await this.drizzle.transaction(async (tx) => {
      const [newInvoice] = await tx.insert(invoices).values(invoice).returning();
      await tx.insert(invoiceDetails).values({
        ...details,
        invoiceId: newInvoice.id
      });
      for (const line of lines) {
        await tx.insert(invoiceLines).values({
          ...line,
          invoiceId: newInvoice.id
        });
      }
      return newInvoice;
    });
    if (userId) {
      await AuditService.log({
        userId,
        companyId: invoice.companyId,
        action: "create" /* CREATE */,
        entity: ENTITY_NAME,
        entityId: transaction.id,
        details: {
          invoice: {
            series: invoice.series,
            totalAmount: invoice.totalAmount
          }
        }
      });
    }
    return transaction;
  }
  /**
   * Issue a draft invoice (allocates invoice number)
   */
  static async issueInvoice(invoiceId, userId) {
    const invoice = await this.getInvoice(invoiceId);
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    const nextNumber = await this.getNextInvoiceNumber(invoice.series || "INV");
    const updateQuery = `
      UPDATE invoices
      SET 
        status = 'issued',
        number = $1,
        issued_at = NOW(),
        updated_at = NOW()
      WHERE id = $2
      RETURNING *
    `;
    const updateResult = await this.drizzle.base.executeQuery(updateQuery, [nextNumber, invoiceId]);
    const updatedInvoice = updateResult.length > 0 ? updateResult[0] : null;
    if (!updatedInvoice) {
      throw new Error("Failed to update invoice status to issued");
    }
    if (userId) {
      await AuditService.log({
        userId,
        companyId: invoice.companyId,
        action: "update" /* UPDATE */,
        entity: ENTITY_NAME,
        entityId: invoiceId,
        details: {
          statusChange: {
            from: "draft",
            to: "issued",
            number: updatedInvoice.number
          }
        }
      });
    }
    return updatedInvoice;
  }
  /**
   * Mark an issued invoice as sent
   */
  static async markAsSent(invoiceId, userId) {
    const invoice = await this.getInvoice(invoiceId);
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    const updateQuery = `
      UPDATE invoices
      SET 
        status = 'sent',
        sent_at = NOW(),
        updated_at = NOW()
      WHERE id = $1
      RETURNING *
    `;
    const updateResult = await this.drizzle.base.executeQuery(updateQuery, [invoiceId]);
    const updatedInvoice = updateResult.length > 0 ? updateResult[0] : null;
    if (!updatedInvoice) {
      throw new Error("Failed to update invoice status to sent");
    }
    if (userId) {
      await AuditService.log({
        userId,
        companyId: invoice.companyId,
        action: "update" /* UPDATE */,
        entity: ENTITY_NAME,
        entityId: invoiceId,
        details: {
          statusChange: {
            from: invoice.status,
            to: "sent"
          }
        }
      });
    }
    return updatedInvoice;
  }
  /**
   * Cancel an invoice
   */
  static async cancelInvoice(invoiceId, userId, reason) {
    const invoice = await this.getInvoice(invoiceId);
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    const updateQuery = `
      UPDATE invoices
      SET 
        status = 'canceled',
        canceled_at = NOW(),
        cancel_reason = $1,
        updated_at = NOW()
      WHERE id = $2
      RETURNING *
    `;
    const updateResult = await this.drizzle.base.executeQuery(updateQuery, [reason || null, invoiceId]);
    const updatedInvoice = updateResult.length > 0 ? updateResult[0] : null;
    if (!updatedInvoice) {
      throw new Error("Failed to update invoice status to canceled");
    }
    if (userId) {
      await AuditService.log({
        userId,
        companyId: invoice.companyId,
        action: "update" /* UPDATE */,
        entity: ENTITY_NAME,
        entityId: invoiceId,
        details: {
          statusChange: {
            from: invoice.status,
            to: "canceled",
            reason
          }
        }
      });
    }
    return updatedInvoice;
  }
  /**
   * Delete an invoice (internal method)
   * Only draft invoices can be deleted, or the last issued invoice
   * @private
   */
  static async _deleteInvoiceInternal(invoiceId, invoice, userId) {
    if (invoice.status !== "draft") {
      const query = `
        SELECT *
        FROM invoices
        WHERE series = $1
        ORDER BY number DESC
        LIMIT 1
      `;
      const results = await this.drizzle.base.executeQuery(query, [invoice.series || ""]);
      const lastInvoice = results.length > 0 ? results[0] : null;
      if (!lastInvoice || lastInvoice.id !== invoice.id) {
        throw new Error("Only draft invoices or the last invoice in a series can be deleted");
      }
    }
    try {
      await this.drizzle.base.transaction(async (client) => {
        const deleteLinesQuery = `
          DELETE FROM invoice_lines 
          WHERE invoice_id = $1
        `;
        const deleteDetailsQuery = `
          DELETE FROM invoice_details
          WHERE invoice_id = $1
        `;
        const deleteInvoiceQuery = `
          DELETE FROM invoices
          WHERE id = $1
        `;
        await client.$client.unsafe(deleteLinesQuery, [invoiceId]);
        await client.$client.unsafe(deleteDetailsQuery, [invoiceId]);
        await client.$client.unsafe(deleteInvoiceQuery, [invoiceId]);
      }, "deleteInvoice");
    } catch (error) {
      console.error("[InvoiceService] Error deleting invoice:", error);
      throw new Error("Failed to delete invoice");
    }
    if (userId) {
      await AuditService.log({
        userId,
        companyId: invoice.companyId,
        action: "delete" /* DELETE */,
        entity: ENTITY_NAME,
        entityId: invoiceId,
        details: {
          invoice: {
            series: invoice.series,
            number: invoice.number,
            status: invoice.status
          }
        }
      });
    }
  }
  /**
   * Delete an invoice
   * Only draft invoices can be deleted, or the last issued invoice
   */
  static async deleteInvoice(invoiceId, userId) {
    const invoice = await this.getInvoice(invoiceId);
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    await this._deleteInvoiceInternal(invoiceId, invoice, userId);
  }
  /**
   * Get invoice by ID with optional related data
   */
  static async getInvoice(invoiceId) {
    try {
      const query = `
        SELECT i.* 
        FROM invoices i
        WHERE i.id = $1
        LIMIT 1
      `;
      const results = await this.drizzle.base.executeQuery(query, [invoiceId]);
      if (!results || results.length === 0) {
        return void 0;
      }
      const invoice = results[0];
      const detailsQuery = `
        SELECT * FROM invoice_details
        WHERE invoice_id = $1
      `;
      const linesQuery = `
        SELECT * FROM invoice_lines
        WHERE invoice_id = $1
        ORDER BY line_number ASC
      `;
      const [details, lines] = await Promise.all([
        this.drizzle.base.executeQuery(detailsQuery, [invoiceId]),
        this.drizzle.base.executeQuery(linesQuery, [invoiceId])
      ]);
      invoice.details = details.length > 0 ? details[0] : null;
      invoice.lines = lines;
      return invoice;
    } catch (error) {
      console.error("[InvoiceService] Error getting invoice by ID:", error);
      return void 0;
    }
  }
  /**
   * Generate a fiscal compliant invoice number
   */
  static async getNextInvoiceNumber(series) {
    try {
      const query = `
        SELECT number
        FROM invoices
        WHERE series = $1
        ORDER BY number DESC
        LIMIT 1
      `;
      const results = await this.drizzle.base.executeQuery(query, [series]);
      if (results && results.length > 0 && results[0].number) {
        return Number(results[0].number) + 1;
      }
      return 1;
    } catch (error) {
      console.error("[InvoiceService] Error getting next invoice number:", error);
      return 1;
    }
  }
  /**
   * Get all invoices for a company with pagination and sorting
   */
  static async getInvoicesForCompany(companyId, limit = 20, offset = 0, sortBy = "issueDate", sortDir = "desc") {
    try {
      let orderField = "created_at";
      switch (sortBy) {
        case "issueDate":
          orderField = "created_at";
          break;
        // We use created_at for issue date
        case "dueDate":
          orderField = "payment_due_date";
          break;
        case "amount":
          orderField = "total_amount";
          break;
        case "status":
          orderField = "status";
          break;
        case "number":
          orderField = "number";
          break;
        default:
          orderField = "created_at";
      }
      const query = `
        SELECT i.*, 
               d.partner_name as customer_name,
               d.partner_id as customer_id,
               d.partner_fiscal_code as customer_fiscal_code,
               d.payment_method,
               i.created_at as issued_at,
               d.payment_due_date as due_date
        FROM invoices i
        LEFT JOIN invoice_details d ON i.id = d.invoice_id
        WHERE i.company_id = '${companyId}'
        ORDER BY ${orderField === "payment_due_date" ? "d.payment_due_date" : "i." + orderField} ${sortDir === "asc" ? "ASC" : "DESC"}
        LIMIT ${limit} OFFSET ${offset}
      `;
      const results = await this.drizzle.base.executeQuery(query);
      const countQuery = `
        SELECT COUNT(*) AS count 
        FROM invoices 
        WHERE company_id = '${companyId}'
      `;
      const countResult = await this.drizzle.base.executeQuery(countQuery);
      const total = Number(countResult[0]?.count || 0);
      return {
        invoices: results,
        total,
        hasMore: offset + results.length < total
      };
    } catch (error) {
      console.error("[InvoiceService] Error getting invoices for company:", error);
      throw new Error("Failed to retrieve invoices");
    }
  }
  /**
   * Get invoices for a specific customer within a company
   */
  static async getCustomerInvoices(customerId, companyId, limit = 20, offset = 0) {
    try {
      const query = `
        SELECT i.*, 
               d.partner_name as customer_name,
               d.partner_id as customer_id,
               d.partner_fiscal_code as customer_fiscal_code,
               d.payment_method,
               i.created_at as issued_at,
               d.payment_due_date as due_date
        FROM invoices i
        LEFT JOIN invoice_details d ON i.id = d.invoice_id
        WHERE i.company_id = '${companyId}' AND (d.partner_id = '${customerId}' OR i.customer_id = '${customerId}')
        ORDER BY i.created_at DESC
        LIMIT ${limit} OFFSET ${offset}
      `;
      const results = await this.drizzle.base.executeQuery(query);
      const countQuery = `
        SELECT COUNT(*) AS count 
        FROM invoices i
        LEFT JOIN invoice_details d ON i.id = d.invoice_id
        WHERE i.company_id = '${companyId}' AND (d.partner_id = '${customerId}' OR i.customer_id = '${customerId}')
      `;
      const countResult = await this.drizzle.base.executeQuery(countQuery);
      const total = Number(countResult[0]?.count || 0);
      return {
        invoices: results,
        total,
        hasMore: offset + results.length < total
      };
    } catch (error) {
      console.error("[InvoiceService] Error getting customer invoices:", error);
      throw new Error("Failed to retrieve customer invoices");
    }
  }
  /**
   * Get invoice by ID with company check
   */
  static async getInvoiceById(id, companyId) {
    try {
      const query = `
        SELECT i.*, 
               d.partner_name as customer_name,
               d.partner_id as customer_id,
               d.partner_fiscal_code as customer_fiscal_code,
               d.payment_method,
               i.created_at as issued_at,
               d.payment_due_date as due_date
        FROM invoices i
        LEFT JOIN invoice_details d ON i.id = d.invoice_id
        WHERE i.id = '${id}' AND i.company_id = '${companyId}'
        LIMIT 1
      `;
      const results = await this.drizzle.base.executeQuery(query);
      if (!results || results.length === 0) {
        return null;
      }
      const invoice = results[0];
      const detailsQuery = `
        SELECT * FROM invoice_details
        WHERE invoice_id = '${id}'
      `;
      const linesQuery = `
        SELECT * FROM invoice_lines
        WHERE invoice_id = '${id}'
        ORDER BY line_number ASC
      `;
      const [details, lines] = await Promise.all([
        this.drizzle.base.executeQuery(detailsQuery),
        this.drizzle.base.executeQuery(linesQuery)
      ]);
      invoice.details = details.length > 0 ? details[0] : null;
      invoice.lines = lines;
      return invoice;
    } catch (error) {
      console.error("[InvoiceService] Error getting invoice by ID:", error);
      throw new Error("Failed to retrieve invoice details");
    }
  }
  /**
   * Get invoice statistics for a company
   */
  static async getInvoiceStats(companyId) {
    try {
      const statusQuery = `
        SELECT status, COUNT(*) as count
        FROM invoices
        WHERE company_id = '${companyId}'
        GROUP BY status
      `;
      const statusCounts = await this.drizzle.base.executeQuery(statusQuery);
      const recentQuery = `
        SELECT i.*, 
               d.partner_name as customer_name,
               d.partner_id as customer_id,
               d.partner_fiscal_code as customer_fiscal_code,
               i.created_at as issued_at,
               d.payment_due_date as due_date
        FROM invoices i
        LEFT JOIN invoice_details d ON i.id = d.invoice_id
        WHERE i.company_id = '${companyId}'
        ORDER BY i.created_at DESC
        LIMIT 5
      `;
      const recentInvoices = await this.drizzle.base.executeQuery(recentQuery);
      const stats = {
        total: 0,
        draft: 0,
        issued: 0,
        sent: 0,
        paid: 0,
        overdue: 0,
        canceled: 0,
        recentInvoices
      };
      if (statusCounts && statusCounts.length > 0) {
        statusCounts.forEach((item) => {
          const count5 = Number(item.count);
          stats.total += count5;
          switch (item.status) {
            case "draft":
              stats.draft = count5;
              break;
            case "issued":
              stats.issued = count5;
              break;
            case "sent":
              stats.sent = count5;
              break;
            case "paid":
              stats.paid = count5;
              break;
            case "overdue":
              stats.overdue = count5;
              break;
            case "canceled":
              stats.canceled = count5;
              break;
          }
        });
      }
      return stats;
    } catch (error) {
      console.error("[InvoiceService] Error getting invoice stats:", error);
      throw new Error("Failed to retrieve invoice statistics");
    }
  }
  /**
   * Check if an invoice can be deleted
   */
  static async canDeleteInvoice(id, companyId) {
    try {
      const invoice = await this.getInvoiceById(id, companyId);
      if (!invoice) {
        return { canDelete: false, reason: "Invoice not found" };
      }
      if (invoice.status !== "draft") {
        const lastInvoiceQuery = `
          SELECT *
          FROM invoices
          WHERE series = '${invoice.series || ""}'
          ORDER BY number DESC
          LIMIT 1
        `;
        const lastInvoiceResult = await this.drizzle.base.executeQuery(lastInvoiceQuery);
        const lastInvoice = lastInvoiceResult && lastInvoiceResult.length > 0 ? lastInvoiceResult[0] : null;
        if (!lastInvoice || lastInvoice.id !== invoice.id) {
          return {
            canDelete: false,
            reason: "Only draft invoices or the last invoice in a series can be deleted"
          };
        }
      }
      return { canDelete: true };
    } catch (error) {
      console.error("[InvoiceService] Error checking if invoice can be deleted:", error);
      throw new Error("Failed to check if invoice can be deleted");
    }
  }
  /**
   * Delete an invoice with company check
   */
  static async deleteInvoiceForCompany(id, companyId, userId) {
    try {
      const invoice = await this.getInvoiceById(id, companyId);
      if (!invoice) {
        return false;
      }
      const deleteLinesQuery = `
        DELETE FROM invoice_lines 
        WHERE invoice_id = '${id}'
      `;
      const deleteDetailsQuery = `
        DELETE FROM invoice_details
        WHERE invoice_id = '${id}'
      `;
      const deleteInvoiceQuery = `
        DELETE FROM invoices
        WHERE id = '${id}' AND company_id = '${companyId}'
      `;
      await this.drizzle.base.executeQuery(deleteLinesQuery);
      await this.drizzle.base.executeQuery(deleteDetailsQuery);
      await this.drizzle.base.executeQuery(deleteInvoiceQuery);
      if (userId) {
        await AuditService.log({
          userId,
          companyId,
          action: "DELETE",
          entity: ENTITY_NAME,
          entityId: id,
          details: {
            invoice: {
              series: invoice.series,
              number: invoice.number,
              status: invoice.status
            }
          }
        });
      }
      return true;
    } catch (error) {
      console.error("[InvoiceService] Error deleting invoice:", error);
      throw new Error("Failed to delete invoice");
    }
  }
  /**
   * Update an invoice with company check
   */
  static async updateInvoice(id, companyId, updates, userId) {
    try {
      const invoice = await this.getInvoiceById(id, companyId);
      if (!invoice) {
        return null;
      }
      if (invoice.status !== "draft") {
        throw new Error("Only draft invoices can be updated");
      }
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const updateFields = [];
      for (const [key, value] of Object.entries(updates)) {
        if (value === null) {
          updateFields.push(`${this.snakeCaseField(key)} = NULL`);
        } else if (typeof value === "string") {
          updateFields.push(`${this.snakeCaseField(key)} = '${value.replace(/'/g, "''")}'`);
        } else if (typeof value === "number") {
          updateFields.push(`${this.snakeCaseField(key)} = ${value}`);
        } else if (typeof value === "boolean") {
          updateFields.push(`${this.snakeCaseField(key)} = ${value ? "TRUE" : "FALSE"}`);
        } else if (value instanceof Date) {
          updateFields.push(`${this.snakeCaseField(key)} = '${value.toISOString()}'`);
        }
      }
      updateFields.push(`updated_at = '${now}'`);
      if (userId) {
        updateFields.push(`updated_by = '${userId}'`);
      }
      const updateQuery = `
        UPDATE invoices
        SET ${updateFields.join(", ")}
        WHERE id = '${id}' AND company_id = '${companyId}'
        RETURNING *
      `;
      const result = await this.drizzle.base.executeQuery(updateQuery);
      const updatedInvoice = result && result.length > 0 ? result[0] : null;
      return updatedInvoice;
    } catch (error) {
      console.error("[InvoiceService] Error updating invoice:", error);
      throw new Error("Failed to update invoice");
    }
  }
  /**
   * Helper method to convert camelCase to snake_case
   */
  static snakeCaseField(field) {
    return field.replace(/([A-Z])/g, "_$1").toLowerCase();
  }
  /**
   * Generate an invoice PDF
   */
  static async generateInvoicePdf(id, companyId) {
    try {
      const invoice = await this.getInvoiceById(id, companyId);
      if (!invoice) {
        return null;
      }
      const pdfContent = `Invoice ${invoice.series}${invoice.number || ""} - Generated ${(/* @__PURE__ */ new Date()).toISOString()}`;
      return Buffer.from(pdfContent);
    } catch (error) {
      console.error("[InvoiceService] Error generating invoice PDF:", error);
      throw new Error("Failed to generate invoice PDF");
    }
  }
};

// server/modules/invoicing/services/create-invoice.service.ts
init_drizzle_service();
init_schema4();
init_audit_service();
var CreateInvoiceService = class {
  static {
    this.drizzle = new DrizzleService();
  }
  /**
   * Execute the invoice creation process with optional currency conversion
   * @param input Invoice creation input data
   * @returns The created invoice
   */
  static async execute(input) {
    try {
      const {
        companyId,
        franchiseId,
        currency = "RON",
        convertTo,
        totalAmount,
        series,
        userId
      } = input;
      log(`\u{1F4DD} Creating invoice with currency ${currency}${convertTo ? ` (convert to ${convertTo})` : ""}`, "invoice-service");
      let finalAmount = totalAmount;
      let finalCurrency = currency;
      if (convertTo && convertTo !== currency) {
        log(`\u{1F4B1} Converting amount from ${currency} to ${convertTo}`, "invoice-service");
        finalAmount = await InvoiceService.convertCurrency(totalAmount, currency, convertTo);
        finalCurrency = convertTo;
        log(`\u{1F4B0} Converted amount: ${finalAmount.toFixed(2)} ${finalCurrency}`, "invoice-service");
      }
      const [newInvoice] = await this.drizzle.insert(invoices).values({
        companyId,
        franchiseId,
        currency: finalCurrency,
        totalAmount: finalAmount.toString(),
        status: "draft" /* DRAFT */,
        series,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      const result = newInvoice;
      if (userId) {
        await AuditService.log({
          userId,
          companyId,
          action: "create" /* CREATE */,
          entity: ENTITY_NAME,
          entityId: result.id,
          details: {
            status: "draft" /* DRAFT */,
            currency: finalCurrency,
            totalAmount: finalAmount,
            originalCurrency: currency !== finalCurrency ? currency : void 0,
            originalAmount: currency !== finalCurrency ? totalAmount : void 0
          }
        });
      }
      log(`\u2705 Invoice created successfully with ID: ${result.id}`, "invoice-service");
      return result;
    } catch (error) {
      log(`\u274C Error creating invoice: ${error.message}`, "invoice-service");
      throw new Error(`Failed to create invoice: ${error.message}`);
    }
  }
};

// server/modules/invoicing/services/validate-invoice.service.ts
init_drizzle_service();

// server/modules/invoicing/schema/invoice.schema.ts
import { pgTable as pgTable12, uuid as uuid12, text as text12, timestamp as timestamp12, numeric as numeric6, boolean as boolean11, integer as integer8 } from "drizzle-orm/pg-core";
import { relations as relations5 } from "drizzle-orm";
var invoices2 = pgTable12("invoices", {
  id: uuid12("id").primaryKey().notNull(),
  companyId: uuid12("company_id").notNull(),
  franchiseId: uuid12("franchise_id"),
  customerId: uuid12("customer_id").notNull(),
  invoiceNumber: text12("invoice_number").notNull(),
  fiscalReceiptNumber: text12("fiscal_receipt_number"),
  status: text12("status").notNull().default("draft"),
  issueDate: timestamp12("issue_date").notNull(),
  dueDate: timestamp12("due_date").notNull(),
  vatRate: numeric6("vat_rate").notNull().default("19"),
  netTotal: numeric6("net_total").notNull().default("0"),
  vatTotal: numeric6("vat_total").notNull().default("0"),
  grossTotal: numeric6("gross_total").notNull().default("0"),
  currency: text12("currency").notNull().default("RON"),
  exchangeRate: numeric6("exchange_rate"),
  paymentMethod: text12("payment_method"),
  paymentDetails: text12("payment_details"),
  notes: text12("notes"),
  // Validation fields for accounting note generation
  isValidated: boolean11("is_validated").notNull().default(false),
  validatedAt: timestamp12("validated_at"),
  validatedBy: uuid12("validated_by"),
  ledgerEntryId: uuid12("ledger_entry_id"),
  // Metadata
  createdAt: timestamp12("created_at").notNull(),
  updatedAt: timestamp12("updated_at").notNull(),
  createdBy: uuid12("created_by")
});
var invoiceItems = pgTable12("invoice_items", {
  id: uuid12("id").primaryKey().notNull(),
  invoiceId: uuid12("invoice_id").notNull().references(() => invoices2.id, { onDelete: "cascade" }),
  productId: uuid12("product_id"),
  productName: text12("product_name").notNull(),
  productCode: text12("product_code"),
  quantity: numeric6("quantity").notNull(),
  unitPrice: numeric6("unit_price").notNull(),
  netAmount: numeric6("net_amount").notNull(),
  vatAmount: numeric6("vat_amount").notNull(),
  vatRate: numeric6("vat_rate").notNull(),
  grossAmount: numeric6("gross_amount").notNull(),
  discount: numeric6("discount").default("0"),
  sequence: integer8("sequence").notNull().default(1),
  notes: text12("notes"),
  // Metadata
  createdAt: timestamp12("created_at").notNull(),
  updatedAt: timestamp12("updated_at").notNull()
});
var invoicesRelations = relations5(invoices2, ({ many }) => ({
  items: many(invoiceItems)
}));
var invoiceItemsRelations = relations5(invoiceItems, ({ one }) => ({
  invoice: one(invoices2, {
    fields: [invoiceItems.invoiceId],
    references: [invoices2.id]
  })
}));

// server/modules/invoicing/services/validate-invoice.service.ts
import { eq as eq26 } from "drizzle-orm";

// server/modules/accounting/services/journal.service.ts
init_drizzle();
init_accounting_schema();
init_audit_service();
import { v4 as uuidv47 } from "uuid";
import { eq as eq24 } from "drizzle-orm";
var LedgerEntryType = /* @__PURE__ */ ((LedgerEntryType4) => {
  LedgerEntryType4["SALES"] = "SALES";
  LedgerEntryType4["PURCHASE"] = "PURCHASE";
  LedgerEntryType4["BANK"] = "BANK";
  LedgerEntryType4["CASH"] = "CASH";
  LedgerEntryType4["GENERAL"] = "GENERAL";
  LedgerEntryType4["ADJUSTMENT"] = "ADJUSTMENT";
  LedgerEntryType4["REVERSAL"] = "REVERSAL";
  return LedgerEntryType4;
})(LedgerEntryType || {});
var JournalService = class {
  /**
   * Create a ledger entry with lines
   * @param options Ledger entry options
   * @returns Created entry data
   */
  async createLedgerEntry(options) {
    const {
      companyId,
      franchiseId,
      type,
      referenceNumber,
      amount,
      description,
      userId,
      lines
    } = options;
    console.log("[DEBUG] createLedgerEntry called with params:", JSON.stringify({
      companyId,
      franchiseId,
      type,
      referenceNumber,
      amount,
      description,
      userId,
      lines
    }, null, 2));
    if (!companyId) {
      throw new Error("Company ID is required");
    }
    if (!type) {
      throw new Error("Ledger entry type is required");
    }
    if (amount === void 0 || amount === null) {
      throw new Error("Amount is required");
    }
    if (!description) {
      throw new Error("Description is required");
    }
    if (!lines || !Array.isArray(lines) || lines.length === 0) {
      throw new Error("At least one ledger line is required");
    }
    this.validateBalancedLines(lines);
    const db4 = new DrizzleService();
    try {
      const entryId = uuidv47();
      const now = /* @__PURE__ */ new Date();
      const result = await (async () => {
        await db4.insert(ledgerEntries).values({
          id: entryId,
          companyId,
          franchiseId,
          type,
          referenceNumber,
          amount,
          description,
          createdAt: now.toISOString(),
          updatedAt: now.toISOString(),
          createdBy: userId
        });
        const lineEntities = lines.map((line) => {
          const lineId = uuidv47();
          return {
            id: lineId,
            ledgerEntryId: entryId,
            accountId: line.accountId,
            debitAmount: line.debitAmount || 0,
            creditAmount: line.creditAmount || 0,
            description: line.description || description,
            createdAt: now.toISOString(),
            updatedAt: now.toISOString()
          };
        });
        await db4.insert(ledgerLines).values(lineEntities);
        const entry = await db4.db.select().from(ledgerEntries).where(eq24(ledgerEntries.id, entryId)).leftJoin(ledgerLines, eq24(ledgerLines.ledgerEntryId, ledgerEntries.id)).execute().then((rows) => {
          if (rows.length === 0) return null;
          const entryData = {
            id: rows[0].ledger_entries.id,
            companyId: rows[0].ledger_entries.companyId,
            franchiseId: rows[0].ledger_entries.franchiseId,
            type: rows[0].ledger_entries.type,
            referenceNumber: rows[0].ledger_entries.referenceNumber,
            amount: rows[0].ledger_entries.amount,
            description: rows[0].ledger_entries.description,
            createdAt: rows[0].ledger_entries.createdAt,
            createdBy: rows[0].ledger_entries.createdBy,
            // Group the lines from the joined rows
            lines: rows.map((row) => ({
              id: row.ledger_lines.id,
              ledgerEntryId: row.ledger_lines.ledgerEntryId,
              accountId: row.ledger_lines.accountId,
              debitAmount: row.ledger_lines.debitAmount,
              creditAmount: row.ledger_lines.creditAmount,
              description: row.ledger_lines.description
            }))
          };
          return entryData;
        });
        console.log("[DEBUG] Database query result:", JSON.stringify(entry, null, 2));
        if (!entry) {
          console.error("[ERROR] No entry found with ID:", entryId);
          return {
            id: entryId,
            companyId,
            type,
            referenceNumber: referenceNumber || "",
            amount,
            description,
            createdAt: now.toISOString(),
            lines: []
          };
        }
        return entry;
      });
      await this.updateAccountBalances(lines);
      if (userId) {
        await AuditService.log({
          userId,
          companyId,
          franchiseId,
          action: "CREATE" /* CREATE */,
          entity: "ledger_entry",
          entityId: entryId,
          details: {
            type,
            amount,
            referenceNumber
          }
        });
      }
      console.log("[DEBUG] Result value:", result);
      if (!result) {
        console.log("[DEBUG] Creating default result object since result is undefined");
        return {
          id: entryId,
          companyId,
          type,
          referenceNumber: referenceNumber || "",
          amount: Number(amount),
          description,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          lines: lines.map((line) => ({
            id: "generated-id",
            // We don't have the actual IDs that would have been generated
            ledgerEntryId: entryId,
            accountId: line.accountId,
            debitAmount: Number(line.debitAmount || 0),
            creditAmount: Number(line.creditAmount || 0),
            description: line.description || description
          }))
        };
      }
      return {
        id: result.id,
        companyId: result.companyId,
        type: result.type,
        referenceNumber: result.referenceNumber,
        amount: Number(result.amount),
        description: result.description,
        createdAt: result.createdAt,
        lines: Array.isArray(result.lines) ? result.lines.map((line) => ({
          id: line.id,
          ledgerEntryId: line.ledgerEntryId,
          accountId: line.accountId,
          debitAmount: Number(line.debitAmount),
          creditAmount: Number(line.creditAmount),
          description: line.description
        })) : []
      };
    } catch (error) {
      console.error("[JournalService] Error creating ledger entry:", error instanceof Error ? error.message : String(error));
      throw new Error(`Failed to create ledger entry: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Reverse a ledger entry
   * @param ledgerEntryId ID of the ledger entry to reverse
   * @param reason Reason for the reversal
   * @returns Reversal ledger entry ID
   */
  async reverseLedgerEntry(ledgerEntryId, reason) {
    if (!ledgerEntryId) {
      throw new Error("Ledger entry ID is required");
    }
    if (!reason) {
      throw new Error("Reversal reason is required");
    }
    const db4 = new DrizzleService();
    const originalEntry = await db4.db.select().from(ledgerEntries).where(eq24(ledgerEntries.id, ledgerEntryId)).leftJoin(ledgerLines, eq24(ledgerLines.ledgerEntryId, ledgerEntries.id)).execute().then((rows) => {
      if (rows.length === 0) return null;
      const entryData = {
        id: rows[0].ledger_entries.id,
        companyId: rows[0].ledger_entries.companyId,
        franchiseId: rows[0].ledger_entries.franchiseId,
        type: rows[0].ledger_entries.type,
        referenceNumber: rows[0].ledger_entries.referenceNumber,
        amount: rows[0].ledger_entries.amount,
        description: rows[0].ledger_entries.description,
        createdAt: rows[0].ledger_entries.createdAt,
        createdBy: rows[0].ledger_entries.createdBy,
        // Group the lines from the joined rows
        lines: rows.map((row) => ({
          id: row.ledger_lines.id,
          ledgerEntryId: row.ledger_lines.ledgerEntryId,
          accountId: row.ledger_lines.accountId,
          debitAmount: row.ledger_lines.debitAmount,
          creditAmount: row.ledger_lines.creditAmount,
          description: row.ledger_lines.description
        }))
      };
      return entryData;
    });
    if (!originalEntry) {
      throw new Error(`Ledger entry with ID ${ledgerEntryId} not found`);
    }
    if (!Array.isArray(originalEntry.lines)) {
      throw new Error("Ledger entry is missing its associated lines");
    }
    const reversalLines = originalEntry.lines.map((line) => ({
      accountId: line.accountId,
      debitAmount: Number(line.creditAmount),
      creditAmount: Number(line.debitAmount),
      description: `Reversal: ${line.description}`
    }));
    const reversalEntry = await this.createLedgerEntry({
      companyId: originalEntry.companyId,
      franchiseId: originalEntry.franchiseId,
      type: "REVERSAL" /* REVERSAL */,
      referenceNumber: `REV-${originalEntry.referenceNumber || originalEntry.id}`,
      amount: Number(originalEntry.amount),
      description: `Reversal of entry ${originalEntry.id}: ${reason}`,
      userId: originalEntry.createdBy,
      lines: reversalLines
    });
    return reversalEntry.id;
  }
  /**
   * Validate that ledger lines are balanced (debits = credits)
   * @param lines Ledger lines to validate
   * @throws Error if lines are not balanced
   */
  validateBalancedLines(lines) {
    let totalDebits = 0;
    let totalCredits = 0;
    for (const line of lines) {
      totalDebits += Number(line.debitAmount || 0);
      totalCredits += Number(line.creditAmount || 0);
    }
    if (Math.abs(totalDebits - totalCredits) > 0.01) {
      throw new Error(`Ledger lines must be balanced (debits = credits). Current totals: debits = ${totalDebits}, credits = ${totalCredits}`);
    }
  }
  /**
   * Calculate account class and group from Romanian account number
   * @param accountId Account ID or number
   * @returns Account class and group
   */
  parseAccountNumber(accountId) {
    const accountNumber = accountId.toString().split("-")[0];
    const accountClass = parseInt(accountNumber.charAt(0));
    const accountGroup = accountNumber.length > 1 ? parseInt(accountNumber.substring(0, 2)) : accountClass * 10;
    return {
      class: accountClass,
      group: accountGroup
    };
  }
  /**
   * Update account balances after ledger entry creation
   * @param lines Ledger lines
   */
  async updateAccountBalances(lines) {
    try {
      const accountUpdates = {};
      for (const line of lines) {
        if (!accountUpdates[line.accountId]) {
          accountUpdates[line.accountId] = { debit: 0, credit: 0 };
        }
        accountUpdates[line.accountId].debit += Number(line.debitAmount || 0);
        accountUpdates[line.accountId].credit += Number(line.creditAmount || 0);
      }
    } catch (error) {
      console.error("[JournalService] Error updating account balances:", error);
    }
  }
  /**
   * Record a simple double-entry transaction (simplified ledger recording)
   * This provides a more direct way to create a ledger entry with just debit and credit accounts
   * 
   * @param options Transaction recording options
   * @returns The created ledger entry ID
   */
  async recordTransaction({
    companyId,
    franchiseId,
    debitAccount,
    creditAccount,
    amount,
    description,
    documentId,
    documentType,
    userId
  }) {
    if (!companyId) {
      throw new Error("Company ID is required");
    }
    if (!debitAccount) {
      throw new Error("Debit account is required");
    }
    if (!creditAccount) {
      throw new Error("Credit account is required");
    }
    if (amount === void 0 || amount === null || amount <= 0) {
      throw new Error("Amount must be a positive number");
    }
    if (!description) {
      throw new Error("Description is required");
    }
    const lines = [
      {
        accountId: debitAccount,
        debitAmount: amount,
        creditAmount: 0,
        description: `${description} (DR)`
      },
      {
        accountId: creditAccount,
        debitAmount: 0,
        creditAmount: amount,
        description: `${description} (CR)`
      }
    ];
    const ledgerEntry = await this.createLedgerEntry({
      companyId,
      franchiseId,
      type: documentType ? LedgerEntryType[documentType] || "GENERAL" /* GENERAL */ : "GENERAL" /* GENERAL */,
      referenceNumber: documentId,
      amount,
      description,
      userId,
      lines
    });
    return ledgerEntry.id;
  }
};
var journal_service_default = JournalService;

// server/modules/accounting/services/sales-journal.service.ts
init_drizzle();
init_schema4();
import { v4 as uuidv48 } from "uuid";
import { and as and24, desc as desc7, eq as eq25, gte as gte2, lte as lte2 } from "drizzle-orm";
var SALES_ACCOUNTS = {
  // Class 4 - Third Party Accounts
  CUSTOMER: "4111",
  // Clients
  VAT_COLLECTED: "4427",
  // VAT collected
  // Class 7 - Revenue Accounts
  REVENUE: "707",
  // Revenue from sale of goods
  REVENUE_SERVICES: "704",
  // Revenue from services
  // Currency accounts
  EXCHANGE_DIFF_INCOME: "765",
  // Foreign exchange gains
  EXCHANGE_DIFF_EXPENSE: "665"
  // Foreign exchange losses
};
var SalesJournalService = class {
  /**
   * Constructor
   */
  constructor() {
    this.journalService = new JournalService();
  }
  /**
   * Get all sales journal entries with pagination
   * @param companyId Company ID
   * @param page Page number
   * @param limit Entries per page
   * @returns Sales journal entries
   */
  async getSalesJournalEntries(companyId, page = 1, limit = 20) {
    try {
      const offset = (page - 1) * limit;
      const db4 = getDrizzle();
      const result = await db4.query.ledgerEntries.findMany({
        where: and24(
          eq25(invoices.companyId, companyId),
          eq25(invoices.type, "SALES" /* SALES */)
        ),
        with: {
          lines: true
        },
        orderBy: [desc7(invoices.createdAt)],
        limit,
        offset
      });
      const entries = result.map((entry) => this.mapToSalesJournalEntry(entry));
      const totalCount = await db4.query.ledgerEntries.findMany({
        where: and24(
          eq25(invoices.companyId, companyId),
          eq25(invoices.type, "SALES" /* SALES */)
        ),
        columns: {
          id: true
        }
      });
      return {
        entries,
        total: totalCount.length,
        page,
        limit
      };
    } catch (error) {
      console.error("Error getting sales journal entries:", error);
      throw new Error("Failed to retrieve sales journal entries");
    }
  }
  /**
   * Get a sales journal entry by ID
   * @param id Entry ID
   * @param companyId Company ID
   * @returns Sales journal entry or null if not found
   */
  async getSalesJournalEntry(id, companyId) {
    try {
      const db4 = getDrizzle();
      const entry = await db4.query.ledgerEntries.findFirst({
        where: and24(
          eq25(invoices.id, id),
          eq25(invoices.companyId, companyId),
          eq25(invoices.type, "SALES" /* SALES */)
        ),
        with: {
          lines: true
        }
      });
      if (!entry) {
        return null;
      }
      return this.mapToSalesJournalEntry(entry);
    } catch (error) {
      console.error("Error getting sales journal entry:", error);
      throw new Error("Failed to retrieve sales journal entry");
    }
  }
  /**
   * Create a sales invoice in the journal
   * @param invoiceData Invoice data
   * @param customer Customer data
   * @param items Invoice items
   * @param taxRates Tax rates
   * @param paymentTerms Payment terms
   * @param notes Notes
   * @returns Created entry ID
   */
  async createSalesInvoice(invoiceData, customer, items, taxRates, paymentTerms, notes) {
    try {
      const validation = this.validateSalesInvoice(invoiceData);
      if (!validation.valid) {
        throw new Error(`Invoice validation failed: ${validation.errors.join(", ")}`);
      }
      const netAmount = items.reduce((sum2, item) => sum2 + Number(item.netAmount), 0);
      const vatAmount = items.reduce((sum2, item) => sum2 + Number(item.vatAmount), 0);
      const grossAmount = netAmount + vatAmount;
      const entryData = {
        companyId: invoiceData.companyId,
        franchiseId: invoiceData.franchiseId,
        invoiceNumber: invoiceData.invoiceNumber,
        invoiceId: invoiceData.id || uuidv48(),
        customerId: customer.id,
        customerName: customer.name,
        amount: grossAmount,
        netAmount,
        vatAmount,
        vatRate: taxRates.standard || 19,
        // Default Romanian VAT rate
        currency: invoiceData.currency || "RON",
        exchangeRate: invoiceData.exchangeRate || 1,
        issueDate: new Date(invoiceData.issueDate),
        dueDate: new Date(invoiceData.dueDate),
        description: notes || `Invoice ${invoiceData.invoiceNumber} to ${customer.name}`,
        userId: invoiceData.userId
      };
      const entry = await this.createSalesInvoiceEntry(entryData);
      const db4 = getDrizzle();
      await db4.insert(invoices).values({
        id: entryData.invoiceId,
        companyId: entryData.companyId,
        franchiseId: entryData.franchiseId,
        invoiceNumber: entryData.invoiceNumber,
        customerId: entryData.customerId,
        amount: entryData.amount,
        currency: entryData.currency,
        exchangeRate: entryData.exchangeRate,
        issueDate: entryData.issueDate,
        dueDate: entryData.dueDate,
        status: "VALIDATED",
        ledgerEntryId: entry.id,
        createdBy: entryData.userId || "system",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).onConflictDoUpdate({
        target: invoices.id,
        set: {
          status: "VALIDATED",
          ledgerEntryId: entry.id,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      for (const item of items) {
        await db4.insert(invoiceLines).values({
          id: item.id || uuidv48(),
          invoiceId: entryData.invoiceId,
          productId: item.productId,
          productName: item.productName,
          quantity: Number(item.quantity),
          unitPrice: Number(item.unitPrice),
          netAmount: Number(item.netAmount),
          vatRate: Number(item.vatRate),
          vatAmount: Number(item.vatAmount),
          grossAmount: Number(item.grossAmount),
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).onConflictDoUpdate({
          target: invoiceLines.id,
          set: {
            quantity: Number(item.quantity),
            unitPrice: Number(item.unitPrice),
            netAmount: Number(item.netAmount),
            vatRate: Number(item.vatRate),
            vatAmount: Number(item.vatAmount),
            grossAmount: Number(item.grossAmount),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
      }
      return entry.id;
    } catch (error) {
      console.error("Error creating sales invoice:", error);
      throw new Error(`Failed to create sales invoice: ${error.message}`);
    }
  }
  /**
   * Create a credit note (sales return)
   * @param creditNoteData Credit note data
   * @param relatedInvoiceId Related invoice ID
   * @param customer Customer data
   * @param items Credit note items
   * @param taxRates Tax rates
   * @param reason Reason for credit note
   * @param notes Notes
   * @returns Created entry ID
   */
  async createCreditNote(creditNoteData, relatedInvoiceId, customer, items, taxRates, reason, notes) {
    try {
      const db4 = getDrizzle();
      const invoice = await db4.query.invoices.findFirst({
        where: eq25(invoices.id, relatedInvoiceId),
        with: {
          lines: true
        }
      });
      if (!invoice) {
        throw new Error(`Original invoice not found: ${relatedInvoiceId}`);
      }
      const netAmount = items.reduce((sum2, item) => sum2 + Number(item.netAmount), 0);
      const vatAmount = items.reduce((sum2, item) => sum2 + Number(item.vatAmount), 0);
      const grossAmount = netAmount + vatAmount;
      const entryData = {
        companyId: creditNoteData.companyId,
        franchiseId: creditNoteData.franchiseId,
        invoiceNumber: creditNoteData.creditNoteNumber,
        invoiceId: creditNoteData.id || uuidv48(),
        customerId: customer.id,
        customerName: customer.name,
        amount: grossAmount,
        netAmount,
        vatAmount,
        vatRate: taxRates.standard || 19,
        // Default Romanian VAT rate
        currency: creditNoteData.currency || "RON",
        exchangeRate: creditNoteData.exchangeRate || 1,
        issueDate: new Date(creditNoteData.issueDate),
        dueDate: new Date(creditNoteData.dueDate || creditNoteData.issueDate),
        description: `Credit note ${creditNoteData.creditNoteNumber} for invoice ${invoice.invoiceNumber}: ${reason}`,
        userId: creditNoteData.userId
      };
      const entry = await this.createSalesCreditNoteEntry(entryData, creditNoteData.creditNoteNumber, reason);
      await db4.insert(invoices).values({
        id: entryData.invoiceId,
        companyId: entryData.companyId,
        franchiseId: entryData.franchiseId,
        invoiceNumber: entryData.invoiceNumber,
        customerId: entryData.customerId,
        amount: entryData.amount,
        currency: entryData.currency,
        exchangeRate: entryData.exchangeRate,
        issueDate: entryData.issueDate,
        dueDate: entryData.dueDate,
        status: "CREDIT_NOTE",
        relatedInvoiceId,
        ledgerEntryId: entry.id,
        createdBy: entryData.userId || "system",
        description: entryData.description,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
      for (const item of items) {
        await db4.insert(invoiceLines).values({
          id: uuidv48(),
          invoiceId: entryData.invoiceId,
          productId: item.productId,
          productName: item.productName,
          quantity: Number(item.quantity),
          unitPrice: Number(item.unitPrice),
          netAmount: Number(item.netAmount),
          vatRate: Number(item.vatRate),
          vatAmount: Number(item.vatAmount),
          grossAmount: Number(item.grossAmount),
          originalItemId: item.originalItemId,
          // Reference to original invoice item
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        });
      }
      return entry.id;
    } catch (error) {
      console.error("Error creating credit note:", error);
      throw new Error(`Failed to create credit note: ${error.message}`);
    }
  }
  /**
   * Generate sales report for a period
   * @param companyId Company ID
   * @param fiscalYear Fiscal year
   * @param fiscalMonth Fiscal month (optional)
   * @returns Sales report
   */
  async generateSalesReport(companyId, fiscalYear, fiscalMonth) {
    try {
      const db4 = getDrizzle();
      let startDate, endDate;
      let periodLabel;
      if (fiscalMonth) {
        startDate = new Date(fiscalYear, fiscalMonth - 1, 1);
        endDate = new Date(fiscalYear, fiscalMonth, 0);
        periodLabel = `${startDate.toLocaleString("default", { month: "long" })} ${fiscalYear}`;
      } else {
        startDate = new Date(fiscalYear, 0, 1);
        endDate = new Date(fiscalYear, 11, 31);
        periodLabel = `${fiscalYear}`;
      }
      const entries = await db4.query.ledgerEntries.findMany({
        where: and24(
          eq25(invoices.companyId, companyId),
          eq25(invoices.type, "SALES" /* SALES */),
          gte2(invoices.createdAt, startDate),
          lte2(invoices.createdAt, endDate)
        ),
        with: {
          lines: true
        },
        orderBy: [desc7(invoices.createdAt)]
      });
      let totalAmount = 0;
      let totalVat = 0;
      for (const entry of entries) {
        totalAmount += Number(entry.amount);
        const vatLines = entry.lines.filter(
          (line) => line.accountId === SALES_ACCOUNTS.VAT_COLLECTED
        );
        for (const vatLine of vatLines) {
          totalVat += Number(vatLine.creditAmount) - Number(vatLine.debitAmount);
        }
      }
      const mappedEntries = entries.map((entry) => this.mapToSalesJournalEntry(entry));
      const report = {
        period: periodLabel,
        totalSales: totalAmount,
        totalVat,
        netSales: totalAmount - totalVat,
        invoiceCount: entries.length,
        entries: mappedEntries
      };
      return report;
    } catch (error) {
      console.error("Error generating sales report:", error);
      throw new Error("Failed to generate sales report");
    }
  }
  /**
   * Generate customer sales report
   * @param companyId Company ID
   * @param customerId Customer ID
   * @param fiscalYear Fiscal year
   * @returns Sales report for the customer
   */
  async generateCustomerSalesReport(companyId, customerId, fiscalYear) {
    try {
      const db4 = getDrizzle();
      const startDate = new Date(fiscalYear, 0, 1);
      const endDate = new Date(fiscalYear, 11, 31);
      const invoiceEntries = await db4.query.invoices.findMany({
        where: and24(
          eq25(invoices.companyId, companyId),
          eq25(invoices.customerId, customerId),
          gte2(invoices.issueDate, startDate),
          lte2(invoices.issueDate, endDate)
        ),
        with: {
          lines: true
        },
        orderBy: [desc7(invoices.issueDate)]
      });
      const ledgerEntryIds = invoiceEntries.map((inv) => inv.ledgerEntryId).filter(Boolean);
      const ledgerEntries2 = await Promise.all(
        ledgerEntryIds.map(async (ledgerEntryId) => {
          if (!ledgerEntryId) return null;
          return this.journalService.getLedgerEntry(ledgerEntryId, companyId);
        })
      );
      const validLedgerEntries = ledgerEntries2.filter(Boolean);
      let totalAmount = 0;
      let totalVat = 0;
      for (const invoice of invoiceEntries) {
        if (invoice.status === "CREDIT_NOTE") {
          totalAmount -= Number(invoice.amount);
          for (const item of invoice.lines) {
            totalVat -= Number(item.vatAmount);
          }
        } else {
          totalAmount += Number(invoice.amount);
          for (const item of invoice.lines) {
            totalVat += Number(item.vatAmount);
          }
        }
      }
      const customer = invoiceEntries.length > 0 ? { name: await this.getCustomerName(customerId) } : { name: "Unknown Customer" };
      const mappedEntries = validLedgerEntries.map((entry) => {
        if (!entry) return null;
        return this.mapToSalesJournalEntry(entry);
      }).filter(Boolean);
      const report = {
        period: `${fiscalYear} - ${customer.name}`,
        totalSales: totalAmount,
        totalVat,
        netSales: totalAmount - totalVat,
        invoiceCount: invoiceEntries.length,
        entries: mappedEntries
      };
      return report;
    } catch (error) {
      console.error("Error generating customer sales report:", error);
      throw new Error("Failed to generate customer sales report");
    }
  }
  /**
   * Get customer name by ID
   * @param customerId Customer ID
   * @returns Customer name or 'Unknown Customer' if not found
   */
  async getCustomerName(customerId) {
    try {
      const db4 = getDrizzle();
      const customer = await db4.query.customers.findFirst({
        where: eq25(db4.customers.id, customerId),
        columns: {
          name: true
        }
      });
      return customer?.name || "Unknown Customer";
    } catch (error) {
      console.error("Error getting customer name:", error);
      return "Unknown Customer";
    }
  }
  /**
   * Create a sales invoice entry
   * @param data Sales invoice data
   * @returns Created ledger entry
   */
  async createSalesInvoiceEntry(data) {
    const {
      companyId,
      franchiseId,
      invoiceNumber,
      invoiceId,
      customerId,
      customerName,
      amount,
      netAmount,
      vatAmount,
      vatRate,
      currency,
      exchangeRate,
      issueDate,
      dueDate,
      description,
      userId
    } = data;
    const ledgerLines2 = [];
    ledgerLines2.push({
      accountId: SALES_ACCOUNTS.CUSTOMER,
      debitAmount: amount,
      creditAmount: 0,
      description: `Customer: ${customerName}`
    });
    if (vatAmount > 0) {
      ledgerLines2.push({
        accountId: SALES_ACCOUNTS.VAT_COLLECTED,
        debitAmount: 0,
        creditAmount: vatAmount,
        description: `VAT ${vatRate}%: ${invoiceNumber}`
      });
    }
    ledgerLines2.push({
      accountId: SALES_ACCOUNTS.REVENUE,
      debitAmount: 0,
      creditAmount: netAmount,
      description: `Sales revenue: ${invoiceNumber}`
    });
    if (currency !== "RON" && exchangeRate !== 1) {
    }
    const entry = await this.journalService.createLedgerEntry({
      companyId,
      franchiseId,
      type: "SALES" /* SALES */,
      referenceNumber: invoiceNumber,
      amount,
      description: description || `Sales invoice ${invoiceNumber} to ${customerName}`,
      userId,
      lines: ledgerLines2
    });
    return entry;
  }
  /**
   * Create a sales credit note entry (return/refund)
   * This would reverse the sales entry
   */
  async createSalesCreditNoteEntry(invoiceData, creditNoteNumber, reason) {
    const creditNoteData = {
      ...invoiceData,
      invoiceNumber: creditNoteNumber,
      description: `Credit note ${creditNoteNumber} for invoice ${invoiceData.invoiceNumber}: ${reason}`
    };
    const ledgerLines2 = [];
    ledgerLines2.push({
      accountId: SALES_ACCOUNTS.CUSTOMER,
      debitAmount: 0,
      creditAmount: creditNoteData.amount,
      description: `Credit to customer: ${creditNoteData.customerName}`
    });
    if (creditNoteData.vatAmount > 0) {
      ledgerLines2.push({
        accountId: SALES_ACCOUNTS.VAT_COLLECTED,
        debitAmount: creditNoteData.vatAmount,
        creditAmount: 0,
        description: `VAT ${creditNoteData.vatRate}% reversal: ${creditNoteNumber}`
      });
    }
    ledgerLines2.push({
      accountId: SALES_ACCOUNTS.REVENUE,
      debitAmount: creditNoteData.netAmount,
      creditAmount: 0,
      description: `Sales revenue reversal: ${creditNoteNumber}`
    });
    const entry = await this.journalService.createLedgerEntry({
      companyId: creditNoteData.companyId,
      franchiseId: creditNoteData.franchiseId,
      type: "SALES" /* SALES */,
      referenceNumber: creditNoteNumber,
      amount: creditNoteData.amount,
      description: creditNoteData.description,
      userId: creditNoteData.userId,
      lines: ledgerLines2
    });
    return entry;
  }
  /**
   * Map from ledger entry to sales journal entry
   * @param entry Ledger entry
   * @returns Sales journal entry
   */
  mapToSalesJournalEntry(entry) {
    let customerId = "";
    let customerName = "";
    if (entry.description && entry.description.includes("to ")) {
      customerName = entry.description.split("to ").pop().trim();
    }
    if (entry.lines) {
      for (const line of entry.lines) {
        if (line.accountId === SALES_ACCOUNTS.CUSTOMER && line.description) {
          const match = line.description.match(/Customer: (.+)/);
          if (match && match[1]) {
            customerName = match[1];
          }
        }
      }
    }
    return {
      id: entry.id,
      companyId: entry.companyId,
      franchiseId: entry.franchiseId || void 0,
      entryType: entry.type,
      referenceNumber: entry.referenceNumber,
      amount: Number(entry.amount),
      description: entry.description,
      createdAt: new Date(entry.createdAt),
      updatedAt: new Date(entry.updatedAt || entry.createdAt),
      customerId,
      customerName,
      lines: entry.lines || []
    };
  }
  /**
   * Validate a sales invoice
   * @param invoiceData Sales invoice data
   * @returns Validation result
   */
  validateSalesInvoice(invoiceData) {
    const errors = [];
    if (!invoiceData.invoiceNumber) {
      errors.push("Invoice number is required");
    }
    if (!invoiceData.customerId) {
      errors.push("Customer ID is required");
    }
    if (!invoiceData.issueDate) {
      errors.push("Issue date is required");
    }
    if (!invoiceData.lines || !Array.isArray(invoiceData.lines) || invoiceData.lines.length === 0) {
      errors.push("Invoice must have at least one line");
    } else {
      for (const [index12, item] of invoiceData.lines.entries()) {
        if (!item.productName) {
          errors.push(`Item #${index12 + 1}: Product name is required`);
        }
        if (!item.quantity || Number(item.quantity) <= 0) {
          errors.push(`Item #${index12 + 1}: Quantity must be positive`);
        }
        if (!item.unitPrice || Number(item.unitPrice) < 0) {
          errors.push(`Item #${index12 + 1}: Unit price must be non-negative`);
        }
        const calculatedNet = Number(item.quantity) * Number(item.unitPrice);
        if (Math.abs(calculatedNet - Number(item.netAmount)) > 0.01) {
          errors.push(`Item #${index12 + 1}: Net amount doesn't match quantity \xD7 unit price`);
        }
        const calculatedVat = Number(item.netAmount) * (Number(item.vatRate) / 100);
        if (Math.abs(calculatedVat - Number(item.vatAmount)) > 0.01) {
          errors.push(`Item #${index12 + 1}: VAT amount doesn't match net amount \xD7 VAT rate`);
        }
        const calculatedGross = Number(item.netAmount) + Number(item.vatAmount);
        if (Math.abs(calculatedGross - Number(item.grossAmount)) > 0.01) {
          errors.push(`Item #${index12 + 1}: Gross amount doesn't match net amount + VAT amount`);
        }
      }
      const totalNet = invoiceData.lines.reduce((sum2, item) => {
        return sum2 + Number(item.netAmount);
      }, 0);
      if (invoiceData.netTotal && Math.abs(Number(invoiceData.netTotal) - totalNet) > 0.01) {
        errors.push("Invoice net total does not match sum of line net amounts");
      }
      const totalVat = invoiceData.lines.reduce((sum2, item) => {
        return sum2 + Number(item.vatAmount);
      }, 0);
      if (invoiceData.vatTotal && Math.abs(Number(invoiceData.vatTotal) - totalVat) > 0.01) {
        errors.push("Invoice VAT total does not match sum of line VAT amounts");
      }
      const totalGross = invoiceData.lines.reduce((sum2, item) => {
        return sum2 + Number(item.grossAmount);
      }, 0);
      if (invoiceData.grossTotal && Math.abs(Number(invoiceData.grossTotal) - totalGross) > 0.01) {
        errors.push("Invoice gross total does not match sum of line gross amounts");
      }
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
};
var sales_journal_service_default = SalesJournalService;

// server/modules/invoicing/services/validate-invoice.service.ts
init_audit_service();
var ValidateInvoiceService = class {
  static {
    this.drizzle = new DrizzleService();
  }
  /**
   * Validate an invoice and generate accounting note
   * @param invoiceId Invoice ID
   * @param userId User ID performing the validation
   * @returns Validation result
   */
  static async validateInvoice(invoiceId, userId) {
    if (!invoiceId) {
      throw new Error("Invoice ID is required");
    }
    if (!userId) {
      throw new Error("User ID is required");
    }
    const invoiceData = await this.drizzle.query.invoices.findFirst({
      where: eq26(invoices2.id, invoiceId),
      with: {
        items: true,
        customer: true,
        company: true
      }
    });
    if (!invoiceData) {
      throw new Error(`Invoice with ID ${invoiceId} not found`);
    }
    if (invoiceData.isValidated) {
      throw new Error(`Invoice with ID ${invoiceId} is already validated`);
    }
    this.validateInvoiceStructure(invoiceData);
    try {
      const totalNet = invoiceData.items.reduce((sum2, line) => sum2 + Number(line.netAmount), 0);
      const totalVat = invoiceData.items.reduce((sum2, line) => sum2 + Number(line.vatAmount), 0);
      const totalGross = invoiceData.items.reduce((sum2, line) => sum2 + Number(line.grossAmount), 0);
      const journalService2 = new JournalService();
      const salesJournal = new SalesJournalService(journalService2);
      const ledgerEntryData = await salesJournal.createSalesInvoiceEntry({
        companyId: invoiceData.companyId,
        invoiceNumber: invoiceData.invoiceNumber,
        invoiceId: invoiceData.id,
        customerId: invoiceData.customerId,
        customerName: invoiceData.customer?.name || "Unknown Customer",
        amount: Number(totalGross),
        netAmount: Number(totalNet),
        vatAmount: Number(totalVat),
        vatRate: invoiceData.vatRate,
        currency: invoiceData.currency,
        exchangeRate: invoiceData.exchangeRate || 1,
        issueDate: new Date(invoiceData.issueDate),
        dueDate: new Date(invoiceData.dueDate),
        description: `Sales invoice ${invoiceData.invoiceNumber} to ${invoiceData.customer?.name || "customer"}`
      });
      const now = /* @__PURE__ */ new Date();
      await this.drizzle.update(invoices2).set({
        isValidated: true,
        validatedAt: now,
        validatedBy: userId,
        ledgerEntryId: ledgerEntryData.id,
        updatedAt: now
      }).where(eq26(invoices2.id, invoiceId));
      await AuditService.log({
        userId,
        companyId: invoiceData.companyId,
        franchiseId: invoiceData.franchiseId,
        action: "VALIDATE" /* VALIDATE */,
        entity: "invoice",
        entityId: invoiceId,
        details: {
          invoiceNumber: invoiceData.invoiceNumber,
          ledgerEntryId: ledgerEntryData.id,
          amount: totalGross,
          currency: invoiceData.currency
        }
      });
      return {
        invoiceId,
        ledgerEntryId: ledgerEntryData.id,
        validatedAt: now.toISOString(),
        validatedBy: userId
      };
    } catch (error) {
      console.error("[ValidateInvoiceService] Error:", error instanceof Error ? error.message : String(error));
      throw new Error(`Failed to validate invoice: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Validate invoice data structure
   * @param invoiceData Invoice data
   */
  static validateInvoiceStructure(invoiceData) {
    if (!invoiceData.invoiceNumber) {
      throw new Error("Invoice number is required");
    }
    if (!invoiceData.companyId) {
      throw new Error("Company ID is required");
    }
    if (!invoiceData.customerId) {
      throw new Error("Customer ID is required");
    }
    if (!invoiceData.issueDate) {
      throw new Error("Issue date is required");
    }
    if (!invoiceData.dueDate) {
      throw new Error("Due date is required");
    }
    if (!invoiceData.currency) {
      throw new Error("Currency is required");
    }
    if (!invoiceData.items || !Array.isArray(invoiceData.items) || invoiceData.items.length === 0) {
      throw new Error("Invoice must have at least one item");
    }
    for (const item of invoiceData.items) {
      if (!item.productName) {
        throw new Error("Product name is required for all invoice items");
      }
      if (!item.quantity || Number(item.quantity) <= 0) {
        throw new Error("Quantity must be positive for all invoice items");
      }
      if (!item.unitPrice || Number(item.unitPrice) < 0) {
        throw new Error("Unit price must be non-negative for all invoice items");
      }
      if (!item.netAmount || Number(item.netAmount) < 0) {
        throw new Error("Net amount must be non-negative for all invoice items");
      }
      if (item.vatAmount === void 0 || Number(item.vatAmount) < 0) {
        throw new Error("VAT amount must be non-negative for all invoice items");
      }
      if (!item.grossAmount || Number(item.grossAmount) < 0) {
        throw new Error("Gross amount must be non-negative for all invoice items");
      }
      const calculatedNet = Number(item.quantity) * Number(item.unitPrice);
      if (Math.abs(calculatedNet - Number(item.netAmount)) > 0.01) {
        throw new Error("Net amount does not match quantity \xD7 unit price");
      }
      const calculatedGross = Number(item.netAmount) + Number(item.vatAmount);
      if (Math.abs(calculatedGross - Number(item.grossAmount)) > 0.01) {
        throw new Error("Gross amount does not match net amount + VAT amount");
      }
    }
    const totalNet = invoiceData.items.reduce((sum2, line) => sum2 + Number(line.netAmount), 0);
    if (invoiceData.netTotal && Math.abs(Number(invoiceData.netTotal) - totalNet) > 0.01) {
      throw new Error("Invoice net total does not match sum of line net amounts");
    }
    const totalVat = invoiceData.items.reduce((sum2, line) => sum2 + Number(line.vatAmount), 0);
    if (invoiceData.vatTotal && Math.abs(Number(invoiceData.vatTotal) - totalVat) > 0.01) {
      throw new Error("Invoice VAT total does not match sum of line VAT amounts");
    }
    const totalGross = invoiceData.items.reduce((sum2, line) => sum2 + Number(line.grossAmount), 0);
    if (invoiceData.grossTotal && Math.abs(Number(invoiceData.grossTotal) - totalGross) > 0.01) {
      throw new Error("Invoice gross total does not match sum of line gross amounts");
    }
  }
};

// server/modules/invoicing/services/devalidate-invoice.service.ts
init_drizzle_service();
import { eq as eq27 } from "drizzle-orm";
init_audit_service();
var DevalidateInvoiceService = class {
  static {
    this.drizzle = new DrizzleService();
  }
  /**
   * Devalidate an invoice and revert the accounting note
   * @param invoiceId Invoice ID
   * @param userId User ID performing the devalidation
   * @param reason Reason for devalidation
   * @returns Devalidation result
   */
  static async devalidateInvoice(invoiceId, userId, reason) {
    if (!invoiceId) {
      throw new Error("Invoice ID is required");
    }
    if (!userId) {
      throw new Error("User ID is required");
    }
    if (!reason || reason.trim() === "") {
      throw new Error("Devalidation reason is required");
    }
    const invoiceData = await this.drizzle.query.invoices.findFirst({
      where: eq27(invoices2.id, invoiceId),
      with: {
        company: true
      }
    });
    if (!invoiceData) {
      throw new Error(`Invoice with ID ${invoiceId} not found`);
    }
    if (!invoiceData.isValidated) {
      throw new Error(`Invoice with ID ${invoiceId} is not validated`);
    }
    if (!invoiceData.ledgerEntryId) {
      throw new Error(`Invoice with ID ${invoiceId} does not have a linked ledger entry`);
    }
    try {
      const journalService2 = new JournalService();
      await journalService2.reverseLedgerEntry(
        invoiceData.ledgerEntryId,
        `Reversed due to invoice devalidation: ${reason}`
      );
      const now = /* @__PURE__ */ new Date();
      await this.drizzle.update(invoices2).set({
        isValidated: false,
        validatedAt: null,
        validatedBy: null,
        ledgerEntryId: null,
        updatedAt: now
      }).where(eq27(invoices2.id, invoiceId));
      await AuditService.log({
        userId,
        companyId: invoiceData.companyId,
        franchiseId: invoiceData.franchiseId,
        action: "DEVALIDATE" /* DEVALIDATE */,
        entity: "invoice",
        entityId: invoiceId,
        details: {
          invoiceNumber: invoiceData.invoiceNumber,
          reason,
          reversedLedgerEntryId: invoiceData.ledgerEntryId
        }
      });
      return {
        invoiceId,
        devalidatedAt: now.toISOString(),
        devalidatedBy: userId,
        reason
      };
    } catch (error) {
      console.error("[DevalidateInvoiceService] Error:", error instanceof Error ? error.message : String(error));
      throw new Error(`Failed to devalidate invoice: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/invoicing/controllers/invoice.controller.ts
init_logger();
init_audit_service();
init_drizzle_service();
var InvoiceController = class {
  constructor() {
    this.logger = new Logger("InvoiceController");
    this.drizzle = new DrizzleService();
  }
  /**
   * Create a new invoice
   */
  async createInvoice(req, res, next) {
    try {
      const { invoice, details, lines } = req.body;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      this.logger.debug(`Creating invoice for company ${companyId}`);
      if (!invoice || !details || !lines) {
        res.status(400).json({ message: "Invoice, details, and lines are required" });
        return;
      }
      invoice.companyId = companyId;
      const result = await InvoiceService.createDraftInvoice(
        invoice,
        details,
        lines,
        userId
      );
      this.logger.debug(`Created invoice ${result.id}`);
      res.status(201).json(result);
    } catch (error) {
      this.logger.error("Error creating invoice:", error);
      next(error);
    }
  }
  /**
   * Get all invoices for a company
   */
  async getCompanyInvoices(req, res, next) {
    try {
      const companyId = req.user?.companyId;
      const { page = "1", limit = "20", sortBy = "issueDate", sortDir = "desc" } = req.query;
      this.logger.debug(`Getting invoices for company ${companyId}`);
      const pageNum = parseInt(page, 10);
      const limitNum = parseInt(limit, 10);
      const offset = (pageNum - 1) * limitNum;
      const results = await InvoiceService.getInvoicesForCompany(
        companyId,
        limitNum,
        offset,
        sortBy,
        sortDir
      );
      this.logger.debug(`Retrieved ${results.invoices.length} invoices`);
      res.json(results);
    } catch (error) {
      this.logger.error("Error getting company invoices:", error);
      next(error);
    }
  }
  /**
   * Get a single invoice by ID
   */
  async getInvoiceById(req, res, next) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      this.logger.debug(`Getting invoice ${id} for company ${companyId}`);
      const invoice = await InvoiceService.getInvoiceById(id, companyId);
      if (!invoice) {
        res.status(404).json({ message: "Invoice not found" });
        return;
      }
      this.logger.debug(`Retrieved invoice ${id}`);
      res.json(invoice);
    } catch (error) {
      this.logger.error(`Error getting invoice ${req.params.id}:`, error);
      next(error);
    }
  }
  /**
   * Update an invoice
   */
  async updateInvoice(req, res, next) {
    try {
      const { id } = req.params;
      const updates = req.body;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      this.logger.debug(`Updating invoice ${id} for company ${companyId}`);
      delete updates.id;
      delete updates.companyId;
      delete updates.createdAt;
      delete updates.createdBy;
      const result = await InvoiceService.updateInvoice(
        id,
        companyId,
        updates,
        userId
      );
      if (!result) {
        res.status(404).json({ message: "Invoice not found or not updated" });
        return;
      }
      await AuditService.log({
        userId,
        companyId,
        action: "UPDATE",
        entity: ENTITY_NAME2,
        entityId: id,
        details: {
          updates: Object.keys(updates),
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
      this.logger.debug(`Updated invoice ${id}`);
      res.json(result);
    } catch (error) {
      this.logger.error(`Error updating invoice ${req.params.id}:`, error);
      next(error);
    }
  }
  /**
   * Delete an invoice
   */
  async deleteInvoice(req, res, next) {
    try {
      const { id } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      this.logger.debug(`Deleting invoice ${id} for company ${companyId}`);
      const canDelete = await InvoiceService.canDeleteInvoice(id, companyId);
      if (!canDelete.canDelete) {
        res.status(400).json({
          message: "Invoice cannot be deleted",
          reason: canDelete.reason
        });
        return;
      }
      const result = await InvoiceService.deleteInvoiceForCompany(id, companyId, userId);
      if (!result) {
        res.status(404).json({ message: "Invoice not found or not deleted" });
        return;
      }
      await AuditService.log({
        userId,
        companyId,
        action: "DELETE",
        entity: ENTITY_NAME2,
        entityId: id,
        details: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
      this.logger.debug(`Deleted invoice ${id}`);
      res.json({ success: true, message: "Invoice deleted successfully" });
    } catch (error) {
      this.logger.error(`Error deleting invoice ${req.params.id}:`, error);
      next(error);
    }
  }
  /**
   * Get customer invoices
   */
  async getCustomerInvoices(req, res, next) {
    try {
      const { customerId } = req.params;
      const companyId = req.user?.companyId;
      const { page = "1", limit = "20" } = req.query;
      this.logger.debug(`Getting invoices for customer ${customerId}`);
      const pageNum = parseInt(page, 10);
      const limitNum = parseInt(limit, 10);
      const offset = (pageNum - 1) * limitNum;
      const results = await InvoiceService.getCustomerInvoices(
        customerId,
        companyId,
        limitNum,
        offset
      );
      this.logger.debug(`Retrieved ${results.invoices.length} invoices for customer ${customerId}`);
      res.json(results);
    } catch (error) {
      this.logger.error(`Error getting customer ${req.params.customerId} invoices:`, error);
      next(error);
    }
  }
  /**
   * Get invoice stats
   */
  async getInvoiceStats(req, res, next) {
    try {
      const companyId = req.user?.companyId;
      this.logger.debug(`Getting invoice statistics for company ${companyId}`);
      const stats = await InvoiceService.getInvoiceStats(companyId);
      this.logger.debug(`Retrieved invoice statistics for company ${companyId}`);
      res.json(stats);
    } catch (error) {
      this.logger.error("Error getting invoice statistics:", error);
      next(error);
    }
  }
  /**
   * Export an invoice to PDF
   */
  async exportInvoiceToPdf(req, res, next) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      this.logger.debug(`Exporting invoice ${id} to PDF`);
      const pdfBuffer = await InvoiceService.generateInvoicePdf(id, companyId);
      if (!pdfBuffer) {
        res.status(404).json({ message: "Invoice not found or PDF generation failed" });
        return;
      }
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `attachment; filename="invoice-${id}.pdf"`);
      this.logger.debug(`Successfully exported invoice ${id} to PDF`);
      res.send(pdfBuffer);
    } catch (error) {
      this.logger.error(`Error exporting invoice ${req.params.id} to PDF:`, error);
      next(error);
    }
  }
};

// server/modules/invoicing/controllers/create-invoice.controller.ts
init_logger();

// server/modules/invoicing/validators/create-invoice.validator.ts
import { z as z13 } from "zod";
var createInvoiceSchema = z13.object({
  companyId: z13.string().uuid({
    message: "Company ID must be a valid UUID"
  }),
  franchiseId: z13.string().uuid({
    message: "Franchise ID must be a valid UUID"
  }).optional(),
  currency: z13.string().min(3).max(5).default("RON"),
  convertTo: z13.string().min(3).max(5).optional(),
  totalAmount: z13.number().positive({
    message: "Total amount must be a positive number"
  }),
  series: z13.string().min(1).max(8).optional()
});
function validateCreateInvoiceInput(input) {
  return createInvoiceSchema.safeParse(input);
}

// server/modules/invoicing/controllers/create-invoice.controller.ts
init_audit_service();
var CreateInvoiceController = class {
  constructor() {
    this.logger = new Logger("CreateInvoiceController");
  }
  /**
   * Handle the creation of a new invoice
   * @param req Express request
   * @param res Express response
   * @param next Express next function
   */
  async createInvoice(req, res, next) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      this.logger.debug(`Processing invoice creation request for user: ${userId}`);
      const validationResult = validateCreateInvoiceInput(req.body);
      if (!validationResult.success) {
        this.logger.warn(`Validation error: ${validationResult.error?.message}`);
        res.status(400).json({
          success: false,
          error: "Validation error",
          details: validationResult.error?.issues?.map((i) => i.message).join(", ") || "Invalid input"
        });
        return;
      }
      const input = {
        companyId: companyId || req.body.companyId,
        franchiseId: req.body.franchiseId,
        currency: req.body.currency,
        convertTo: req.body.convertTo,
        totalAmount: req.body.amount,
        series: req.body.series,
        userId
      };
      const result = await CreateInvoiceService.execute(input);
      try {
        await AuditService.log({
          userId,
          companyId,
          action: "CREATE",
          entity: ENTITY_NAME2,
          entityId: result.id,
          details: {
            series: result.series,
            amount: result.totalAmount,
            currency: result.currency,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        });
      } catch (auditError) {
        this.logger.warn(`Failed to create audit log: ${auditError.message}`);
      }
      this.logger.debug(`Successfully created invoice ${result.id}`);
      res.status(201).json({
        success: true,
        invoice: result
      });
    } catch (error) {
      this.logger.error(`Failed to create invoice: ${error.message}`);
      next(error);
    }
  }
  /**
   * Create a batch of invoices
   */
  async createInvoiceBatch(req, res, next) {
    try {
      const { invoices: invoices3 } = req.body;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      this.logger.debug(`Processing batch invoice creation request with ${invoices3?.length} invoices`);
      if (!invoices3 || !Array.isArray(invoices3) || invoices3.length === 0) {
        res.status(400).json({
          success: false,
          error: "Validation error",
          details: "Invoices array is required and must not be empty"
        });
        return;
      }
      const results = await Promise.all(
        invoices3.map(async (invoiceData) => {
          try {
            const validationResult = validateCreateInvoiceInput(invoiceData);
            if (!validationResult.success) {
              return {
                success: false,
                error: "Validation error",
                details: validationResult.error?.issues?.map((i) => i.message).join(", ") || "Invalid input",
                data: invoiceData
              };
            }
            const input = {
              companyId: companyId || invoiceData.companyId,
              franchiseId: invoiceData.franchiseId,
              currency: invoiceData.currency,
              convertTo: invoiceData.convertTo,
              totalAmount: invoiceData.amount,
              series: invoiceData.series,
              userId
            };
            const result = await CreateInvoiceService.execute(input);
            try {
              await AuditService.log({
                userId,
                companyId,
                action: "CREATE_BATCH",
                entity: ENTITY_NAME2,
                entityId: result.id,
                details: {
                  series: result.series,
                  amount: result.totalAmount,
                  currency: result.currency,
                  batchOperation: true,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString()
                }
              });
            } catch (auditError) {
              this.logger.warn(`Failed to create audit log for batch invoice: ${auditError.message}`);
            }
            return {
              success: true,
              invoice: result
            };
          } catch (error) {
            return {
              success: false,
              error: "Processing error",
              message: error.message,
              data: invoiceData
            };
          }
        })
      );
      const successCount = results.filter((r) => r.success).length;
      const failureCount = results.length - successCount;
      this.logger.debug(`Batch creation complete: ${successCount} succeeded, ${failureCount} failed`);
      res.status(201).json({
        success: true,
        message: `Processed ${results.length} invoices: ${successCount} succeeded, ${failureCount} failed`,
        results
      });
    } catch (error) {
      this.logger.error(`Failed to process invoice batch: ${error.message}`);
      next(error);
    }
  }
};

// server/modules/invoicing/controllers/validate-invoice.controller.ts
init_logger();
init_audit_service();
var ValidateInvoiceController = class {
  constructor() {
    this.logger = new Logger("ValidateInvoiceController");
  }
  /**
   * Validate an invoice
   */
  async validateInvoice(req, res, next) {
    try {
      const { invoiceId } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      this.logger.debug(`Validating invoice ${invoiceId} for company ${companyId}`);
      if (!invoiceId) {
        res.status(400).json({ message: "Invoice ID is required" });
        return;
      }
      const validationResult = await ValidateInvoiceService.validateInvoice(
        invoiceId,
        companyId,
        userId
      );
      if (!validationResult.success) {
        this.logger.warn(`Failed to validate invoice ${invoiceId}: ${validationResult.message}`);
        res.status(400).json({
          success: false,
          message: validationResult.message
        });
        return;
      }
      await AuditService.log({
        userId,
        companyId,
        action: "VALIDATE",
        entity: ENTITY_NAME2,
        entityId: invoiceId,
        details: {
          result: validationResult,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          journalEntryId: validationResult.journalEntryId
        }
      });
      this.logger.debug(`Successfully validated invoice ${invoiceId}`);
      res.json({
        success: true,
        message: "Invoice validated successfully",
        validation: validationResult
      });
    } catch (error) {
      this.logger.error(`Error validating invoice ${req.params.invoiceId}:`, error);
      next(error);
    }
  }
  /**
   * Validate multiple invoices in a batch operation
   */
  async validateInvoiceBatch(req, res, next) {
    try {
      const { invoiceIds } = req.body;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      this.logger.debug(`Batch validating ${invoiceIds.length} invoices for company ${companyId}`);
      if (!invoiceIds || !Array.isArray(invoiceIds) || invoiceIds.length === 0) {
        res.status(400).json({ message: "Invoice IDs array is required" });
        return;
      }
      const results = await Promise.all(
        invoiceIds.map(async (invoiceId) => {
          try {
            const result = await ValidateInvoiceService.validateInvoice(
              invoiceId,
              companyId,
              userId
            );
            if (result.success) {
              await AuditService.log({
                userId,
                companyId,
                action: "VALIDATE_BATCH",
                entity: ENTITY_NAME2,
                entityId: invoiceId,
                details: {
                  batchOperation: true,
                  timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                  journalEntryId: result.journalEntryId
                }
              });
            }
            return {
              invoiceId,
              success: result.success,
              message: result.message,
              journalEntryId: result.journalEntryId
            };
          } catch (error) {
            return {
              invoiceId,
              success: false,
              message: error.message
            };
          }
        })
      );
      const successCount = results.filter((r) => r.success).length;
      const failureCount = results.length - successCount;
      this.logger.debug(`Batch validation complete: ${successCount} succeeded, ${failureCount} failed`);
      res.json({
        success: true,
        message: `Processed ${results.length} invoices: ${successCount} succeeded, ${failureCount} failed`,
        results
      });
    } catch (error) {
      this.logger.error("Error in batch invoice validation:", error);
      next(error);
    }
  }
  /**
   * Get the validation status of an invoice
   */
  async getValidationStatus(req, res, next) {
    try {
      const { invoiceId } = req.params;
      const companyId = req.user?.companyId;
      this.logger.debug(`Getting validation status for invoice ${invoiceId}`);
      if (!invoiceId) {
        res.status(400).json({ message: "Invoice ID is required" });
        return;
      }
      const status = await ValidateInvoiceService.getValidationStatus(
        invoiceId,
        companyId
      );
      if (!status) {
        res.status(404).json({ message: "Invoice not found" });
        return;
      }
      this.logger.debug(`Retrieved validation status for invoice ${invoiceId}`);
      res.json(status);
    } catch (error) {
      this.logger.error(`Error getting validation status for invoice ${req.params.invoiceId}:`, error);
      next(error);
    }
  }
  /**
   * Preview the accounting entries that would be created upon validation
   */
  async previewAccountingEntries(req, res, next) {
    try {
      const { invoiceId } = req.params;
      const companyId = req.user?.companyId;
      this.logger.debug(`Previewing accounting entries for invoice ${invoiceId}`);
      if (!invoiceId) {
        res.status(400).json({ message: "Invoice ID is required" });
        return;
      }
      const preview = await ValidateInvoiceService.previewAccountingEntries(
        invoiceId,
        companyId
      );
      if (!preview) {
        res.status(404).json({ message: "Invoice not found or accounting preview failed" });
        return;
      }
      this.logger.debug(`Generated accounting entries preview for invoice ${invoiceId}`);
      res.json(preview);
    } catch (error) {
      this.logger.error(`Error previewing accounting entries for invoice ${req.params.invoiceId}:`, error);
      next(error);
    }
  }
};

// server/modules/invoicing/controllers/devalidate-invoice.controller.ts
init_logger();
init_audit_service();
var DevalidateInvoiceController = class {
  constructor() {
    this.logger = new Logger("DevalidateInvoiceController");
  }
  /**
   * Devalidate an invoice
   */
  async devalidateInvoice(req, res, next) {
    try {
      const { invoiceId } = req.params;
      const { reason } = req.body;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      this.logger.debug(`Devalidating invoice ${invoiceId} for company ${companyId}`);
      if (!invoiceId) {
        res.status(400).json({ message: "Invoice ID is required" });
        return;
      }
      if (!reason) {
        res.status(400).json({ message: "Devalidation reason is required" });
        return;
      }
      const result = await DevalidateInvoiceService.devalidateInvoice(
        invoiceId,
        companyId,
        userId,
        reason
      );
      if (!result) {
        res.status(404).json({ message: "Invoice not found or cannot be devalidated" });
        return;
      }
      await AuditService.log({
        userId,
        companyId,
        action: "DEVALIDATE",
        entity: ENTITY_NAME2,
        entityId: invoiceId,
        details: {
          reason,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          devalidatedAt: result.devalidatedAt
        }
      });
      this.logger.debug(`Successfully devalidated invoice ${invoiceId}`);
      res.json({
        success: true,
        message: "Invoice devalidated successfully",
        result
      });
    } catch (error) {
      this.logger.error(`Error devalidating invoice ${req.params.invoiceId}:`, error);
      next(error);
    }
  }
  /**
   * Check if an invoice can be devalidated
   */
  async canDevalidate(req, res, next) {
    try {
      const { invoiceId } = req.params;
      const companyId = req.user?.companyId;
      this.logger.debug(`Checking if invoice ${invoiceId} can be devalidated`);
      if (!invoiceId) {
        res.status(400).json({ message: "Invoice ID is required" });
        return;
      }
      const canDevalidate = await DevalidateInvoiceService.canDevalidate(
        invoiceId,
        companyId
      );
      this.logger.debug(`Devalidation check for invoice ${invoiceId}: ${canDevalidate.canDevalidate}`);
      res.json(canDevalidate);
    } catch (error) {
      this.logger.error(`Error checking devalidation status for invoice ${req.params.invoiceId}:`, error);
      next(error);
    }
  }
  /**
   * Get the devalidation history for an invoice
   */
  async getDevalidationHistory(req, res, next) {
    try {
      const { invoiceId } = req.params;
      const companyId = req.user?.companyId;
      this.logger.debug(`Getting devalidation history for invoice ${invoiceId}`);
      if (!invoiceId) {
        res.status(400).json({ message: "Invoice ID is required" });
        return;
      }
      const history = await DevalidateInvoiceService.getDevalidationHistory(
        invoiceId,
        companyId
      );
      if (!history) {
        res.status(404).json({ message: "Invoice not found or no devalidation history" });
        return;
      }
      this.logger.debug(`Retrieved devalidation history for invoice ${invoiceId}`);
      res.json(history);
    } catch (error) {
      this.logger.error(`Error getting devalidation history for invoice ${req.params.invoiceId}:`, error);
      next(error);
    }
  }
};

// server/modules/invoicing/invoices.module.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
var ENTITY_NAME2 = "invoice";
var InvoicesModule = class _InvoicesModule {
  constructor() {
    this.router = Router13();
    this.invoiceController = new InvoiceController();
    this.createInvoiceController = new CreateInvoiceController();
    this.validateInvoiceController = new ValidateInvoiceController();
    this.devalidateInvoiceController = new DevalidateInvoiceController();
    this.customerController = new CustomerController();
    this.logger = new Logger("InvoicesModule");
  }
  /**
   * Initialize the invoices module and set up routes
   * 
   * @param app Express application
   * @returns Router instance
   */
  initRoutes(app2) {
    this.logger.info("\u{1F4DD} Initializing invoices module with controller-based architecture");
    this.setupInvoiceRoutes();
    this.setupCreateInvoiceRoutes();
    this.setupValidateInvoiceRoutes();
    this.setupDevalidateInvoiceRoutes();
    this.setupCustomerRoutes(app2);
    app2.use("/api/invoices", this.router);
    this.setupLegacyRoutes(app2);
    this.logger.info("\u{1F4DD} Invoices module initialized successfully");
    return this.router;
  }
  /**
   * Setup main invoice management routes
   */
  setupInvoiceRoutes() {
    this.router.get(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      this.invoiceController.getCompanyInvoices.bind(this.invoiceController)
    );
    this.router.get(
      "/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      this.invoiceController.getInvoiceById.bind(this.invoiceController)
    );
    this.router.post(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.invoiceController.createInvoice.bind(this.invoiceController)
    );
    this.router.patch(
      "/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.invoiceController.updateInvoice.bind(this.invoiceController)
    );
    this.router.delete(
      "/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.invoiceController.deleteInvoice.bind(this.invoiceController)
    );
    this.router.get(
      "/customer/:customerId",
      AuthGuard.protect("required" /* REQUIRED */),
      this.invoiceController.getCustomerInvoices.bind(this.invoiceController)
    );
    this.router.get(
      "/stats/overview",
      AuthGuard.protect("required" /* REQUIRED */),
      this.invoiceController.getInvoiceStats.bind(this.invoiceController)
    );
    this.router.get(
      "/:id/export/pdf",
      AuthGuard.protect("required" /* REQUIRED */),
      this.invoiceController.exportInvoiceToPdf.bind(this.invoiceController)
    );
  }
  /**
   * Setup invoice creation routes
   */
  setupCreateInvoiceRoutes() {
    this.router.post(
      "/create",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.createInvoiceController.createInvoice.bind(this.createInvoiceController)
    );
    this.router.post(
      "/batch",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.createInvoiceController.createInvoiceBatch.bind(this.createInvoiceController)
    );
  }
  /**
   * Setup invoice validation routes
   */
  setupValidateInvoiceRoutes() {
    this.router.post(
      "/:invoiceId/validate",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.validateInvoiceController.validateInvoice.bind(this.validateInvoiceController)
    );
    this.router.post(
      "/validate/batch",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.validateInvoiceController.validateInvoiceBatch.bind(this.validateInvoiceController)
    );
    this.router.get(
      "/:invoiceId/validation-status",
      AuthGuard.protect("required" /* REQUIRED */),
      this.validateInvoiceController.getValidationStatus.bind(this.validateInvoiceController)
    );
    this.router.get(
      "/:invoiceId/preview-accounting",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.validateInvoiceController.previewAccountingEntries.bind(this.validateInvoiceController)
    );
  }
  /**
   * Setup invoice devalidation routes
   */
  setupDevalidateInvoiceRoutes() {
    this.router.post(
      "/:invoiceId/devalidate",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.devalidateInvoiceController.devalidateInvoice.bind(this.devalidateInvoiceController)
    );
    this.router.get(
      "/:invoiceId/can-devalidate",
      AuthGuard.protect("required" /* REQUIRED */),
      this.devalidateInvoiceController.canDevalidate.bind(this.devalidateInvoiceController)
    );
    this.router.get(
      "/:invoiceId/devalidation-history",
      AuthGuard.protect("required" /* REQUIRED */),
      this.devalidateInvoiceController.getDevalidationHistory.bind(this.devalidateInvoiceController)
    );
  }
  /**
   * Setup legacy routes for backward compatibility
   */
  setupLegacyRoutes(app2) {
    const legacyRouter = Router13();
    legacyRouter.post(
      "/v1/invoices/create",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["accountant" /* ACCOUNTANT */, "finance_manager" /* FINANCE_MANAGER */, "admin" /* ADMIN */]),
      this.createInvoiceController.createInvoice.bind(this.createInvoiceController)
    );
    app2.use(legacyRouter);
    this.logger.info("\u{1F4DD} Legacy invoice routes registered for backward compatibility");
  }
  /**
   * Setup customer routes
   */
  setupCustomerRoutes(app2) {
    const customerRouter = Router13();
    customerRouter.get(
      "/customers",
      AuthGuard.protect("required" /* REQUIRED */),
      this.customerController.getInvoiceCustomers.bind(this.customerController)
    );
    app2.use("/api/invoicing", customerRouter);
    this.logger.info("\u{1F4DD} Customer routes registered at /api/invoicing/customers");
  }
  /**
   * Register the module with the application (static method for backward compatibility)
   */
  static register(app2) {
    const module = new _InvoicesModule();
    module.initRoutes(app2);
    return {
      services: [InvoiceService, CreateInvoiceService, ValidateInvoiceService, DevalidateInvoiceService, ExchangeRateService],
      controllers: [InvoiceController, CreateInvoiceController, ValidateInvoiceController, DevalidateInvoiceController]
    };
  }
};

// server/modules/crm/services/customer.service.ts
init_base_drizzle_service();
init_crm_schema();
import { eq as eq28, and as and25, sql as sql20, desc as desc8, asc as asc2 } from "drizzle-orm";
import { randomUUID as randomUUID5 } from "crypto";
var CustomerService = class extends BaseDrizzleService {
  constructor(db4, auditService4) {
    super();
    this.db = db4;
    this.auditService = auditService4;
  }
  async createCustomer(data) {
    return this.db.query(async (db4) => {
      const id = randomUUID5();
      await db4.insert(customers).values({
        id,
        ...data,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
      const result = await this.getCustomerById(id);
      if (!result) {
        throw new Error("Failed to create customer");
      }
      return result;
    });
  }
  async getCustomerById(id) {
    return this.db.query(async (db4) => {
      const result = await db4.select().from(customers).where(eq28(customers.id, id));
      return result[0];
    });
  }
  async updateCustomer(id, data) {
    return this.db.query(async (db4) => {
      await db4.update(customers).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq28(customers.id, id));
      return this.getCustomerById(id);
    });
  }
  async deleteCustomer(id) {
    return this.db.query(async (db4) => {
      await db4.update(customers).set({
        isActive: false,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq28(customers.id, id));
    });
  }
  async getCustomers(params) {
    const { page = 1, limit = 10, search, sortBy, sortOrder, filters } = params;
    const offset = (page - 1) * limit;
    return this.db.query(async (db4) => {
      const whereConditions = [
        eq28(customers.isActive, true)
      ];
      if (search) {
        whereConditions.push(sql20`${customers.name} ILIKE ${`%${search}%`}`);
      }
      const totalResult = await db4.select({ count: sql20`count(*)` }).from(customers).where(and25(...whereConditions));
      const sortColumns = {
        name: customers.name,
        createdAt: customers.createdAt,
        updatedAt: customers.updatedAt,
        email: customers.email,
        type: customers.type,
        segment: customers.segment,
        industry: customers.industry
      };
      let orderByColumn = customers.createdAt;
      if (sortBy && sortColumns[sortBy]) {
        orderByColumn = sortColumns[sortBy];
      }
      const customersList = await db4.select({
        id: customers.id,
        companyId: customers.companyId,
        name: customers.name,
        email: customers.email,
        phone: customers.phone,
        address: customers.address,
        city: customers.city,
        county: customers.county,
        country: customers.country,
        postalCode: customers.postalCode,
        type: customers.type,
        segment: customers.segment,
        industry: customers.industry,
        source: customers.source,
        leadScore: customers.leadScore,
        leadStatus: customers.leadStatus,
        leadQualificationDate: customers.leadQualificationDate,
        ownerId: customers.ownerId,
        fiscalCode: customers.fiscalCode,
        registrationNumber: customers.registrationNumber,
        vatPayer: customers.vatPayer,
        website: customers.website,
        notes: customers.notes,
        annualRevenue: customers.annualRevenue,
        employeeCount: customers.employeeCount,
        createdAt: customers.createdAt,
        updatedAt: customers.updatedAt,
        createdBy: customers.createdBy,
        updatedBy: customers.updatedBy,
        isActive: customers.isActive,
        customFields: customers.customFields
      }).from(customers).where(and25(...whereConditions)).orderBy(sortOrder === "asc" ? asc2(orderByColumn) : desc8(orderByColumn)).limit(limit).offset(offset);
      return {
        customers: customersList,
        total: Number(totalResult[0].count),
        page,
        limit,
        totalPages: Math.ceil(Number(totalResult[0].count) / limit)
      };
    });
  }
  async getCustomerStats(companyId) {
    return this.db.query(async (db4) => {
      const whereConditions = [
        eq28(customers.isActive, true),
        eq28(customers.companyId, companyId)
      ];
      const totalCustomers = await db4.select({ count: sql20`count(*)` }).from(customers).where(and25(...whereConditions));
      const byType = await db4.select({
        type: customers.type,
        count: sql20`count(*)`
      }).from(customers).where(and25(...whereConditions)).groupBy(customers.type);
      const bySegment = await db4.select({
        segment: customers.segment,
        count: sql20`count(*)`
      }).from(customers).where(and25(...whereConditions)).groupBy(customers.segment);
      const byIndustry = await db4.select({
        industry: customers.industry,
        count: sql20`count(*)`
      }).from(customers).where(and25(...whereConditions)).groupBy(customers.industry);
      return {
        total: Number(totalCustomers[0].count),
        byType: byType.map((row) => ({ type: row.type, count: Number(row.count) })),
        bySegment: bySegment.map((row) => ({ segment: row.segment, count: Number(row.count) })),
        byIndustry: byIndustry.map((row) => ({ industry: row.industry, count: Number(row.count) }))
      };
    });
  }
};

// server/modules/crm/controllers/customer.controller.ts
init_auth_guard();
init_drizzle_service();
var CustomerController2 = class {
  constructor(customerService2) {
    this.jwtService = null;
    this.customerService = customerService2 || new CustomerService(new DrizzleService());
    this.createCustomer = this.createCustomer.bind(this);
    this.getCustomer = this.getCustomer.bind(this);
    this.updateCustomer = this.updateCustomer.bind(this);
    this.deleteCustomer = this.deleteCustomer.bind(this);
    this.listCustomers = this.listCustomers.bind(this);
    this.getCustomerStatistics = this.getCustomerStatistics.bind(this);
  }
  /**
   * Register routes
   */
  registerRoutes(app2, jwtService2) {
    if (jwtService2) {
      this.jwtService = jwtService2;
    }
    app2.post(
      "/api/crm/customers",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["sales_agent" /* SALES_AGENT */, "company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.createCustomer
    );
    app2.get(
      "/api/crm/customers/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getCustomer
    );
    app2.put(
      "/api/crm/customers/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["sales_agent" /* SALES_AGENT */, "company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.updateCustomer
    );
    app2.delete(
      "/api/crm/customers/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.deleteCustomer
    );
    app2.get(
      "/api/crm/customers",
      AuthGuard.protect("required" /* REQUIRED */),
      this.listCustomers
    );
    app2.get(
      "/api/crm/customer-statistics",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getCustomerStatistics
    );
  }
  /**
   * Create a new customer
   */
  async createCustomer(req, res) {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!req.body.companyId) {
        req.body.companyId = req.user?.companyId;
      }
      if (!req.body.name) {
        return res.status(400).json({ message: "Customer name is required" });
      }
      const customer = await this.customerService.create(req.body, userId);
      return res.status(201).json(customer);
    } catch (error) {
      console.error("Error creating customer:", error);
      return res.status(500).json({ message: "Failed to create customer", error: error.message });
    }
  }
  /**
   * Get a customer by ID
   */
  async getCustomer(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const customer = await this.customerService.getById(id, companyId);
      if (!customer) {
        return res.status(404).json({ message: "Customer not found" });
      }
      return res.json(customer);
    } catch (error) {
      console.error("Error getting customer:", error);
      return res.status(500).json({ message: "Failed to get customer", error: error.message });
    }
  }
  /**
   * Update a customer
   */
  async updateCustomer(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!req.body.companyId) {
        req.body.companyId = companyId;
      }
      const customer = await this.customerService.update(id, req.body, userId);
      if (!customer) {
        return res.status(404).json({ message: "Customer not found" });
      }
      return res.json(customer);
    } catch (error) {
      console.error("Error updating customer:", error);
      return res.status(500).json({ message: "Failed to update customer", error: error.message });
    }
  }
  /**
   * Delete a customer
   */
  async deleteCustomer(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const success = await this.customerService.delete(id, companyId, userId);
      if (!success) {
        return res.status(404).json({ message: "Customer not found" });
      }
      return res.json({ message: "Customer deleted successfully" });
    } catch (error) {
      console.error("Error deleting customer:", error);
      return res.status(500).json({ message: "Failed to delete customer", error: error.message });
    }
  }
  /**
   * List customers with filtering, sorting, and pagination
   */
  async listCustomers(req, res) {
    try {
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const {
        page = "1",
        limit = "20",
        searchTerm,
        industry,
        type,
        status,
        sortBy,
        sortDirection
      } = req.query;
      const options = {
        page: parseInt(page, 10),
        limit: parseInt(limit, 10),
        searchTerm,
        industry,
        type,
        status,
        sortBy,
        sortDirection: sortDirection || "asc"
      };
      const { data, total } = await this.customerService.list(companyId, options);
      return res.json({
        data,
        meta: {
          total,
          page: options.page,
          limit: options.limit,
          totalPages: Math.ceil(total / options.limit)
        }
      });
    } catch (error) {
      console.error("Error listing customers:", error);
      return res.status(500).json({ message: "Failed to list customers", error: error.message });
    }
  }
  /**
   * Get customer statistics
   */
  async getCustomerStatistics(req, res) {
    try {
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const statistics = await this.customerService.getStatistics(companyId);
      return res.json(statistics);
    } catch (error) {
      console.error("Error getting customer statistics:", error);
      return res.status(500).json({ message: "Failed to get customer statistics", error: error.message });
    }
  }
};

// server/modules/crm/services/deal.service.ts
init_drizzle();
init_crm_schema();
init_audit_service();
import { sql as sql22, eq as eq30, and as and27, or as or6, like as like2, desc as desc10, asc as asc4, isNull as isNull6, not } from "drizzle-orm";
import { randomUUID as randomUUID7 } from "crypto";

// server/modules/crm/services/pipeline.service.ts
init_drizzle();
init_crm_schema();
init_audit_service();
init_crm_schema();
import { sql as sql21, eq as eq29, and as and26, asc as asc3 } from "drizzle-orm";
import { randomUUID as randomUUID6 } from "crypto";
import { desc as desc9 } from "drizzle-orm";
var PipelineService = class {
  constructor() {
    this.db = new DrizzleService();
  }
  /**
   * Create a new pipeline
   */
  async createPipeline(data, userId) {
    try {
      if (data.isDefault) {
        await this.db.update(pipelines).set({ isDefault: false }).where(eq29(pipelines.companyId, data.companyId));
      } else {
        const existingPipelines = await this.db.select({ count: sql21`count(*)` }).from(pipelines).where(eq29(pipelines.companyId, data.companyId));
        if (Number(existingPipelines[0]?.count || 0) === 0) {
          data.isDefault = true;
        }
      }
      const result = await this.db.insert(pipelines).values({
        ...data,
        id: randomUUID6(),
        createdBy: userId,
        updatedBy: userId
      }).returning();
      if (result.length > 0) {
        await audit_service_default.log({
          userId,
          companyId: data.companyId,
          action: "CREATE" /* CREATE */,
          entity: "pipeline",
          entityId: result[0].id,
          details: data
        });
      }
      return result[0];
    } catch (error) {
      console.error("Error creating pipeline:", error);
      throw new Error("Failed to create pipeline");
    }
  }
  /**
   * Update a pipeline
   */
  async updatePipeline(id, data, userId) {
    try {
      if (data.isDefault) {
        await this.db.update(pipelines).set({ isDefault: false }).where(and26(
          eq29(pipelines.companyId, data.companyId || ""),
          sql21`${pipelines.id} != ${id}`
        ));
      }
      const result = await this.db.update(pipelines).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and26(
        eq29(pipelines.id, id),
        eq29(pipelines.companyId, data.companyId || "")
      )).returning();
      if (result.length > 0) {
        await audit_service_default.log({
          userId,
          companyId: data.companyId || result[0].companyId,
          action: "UPDATE" /* UPDATE */,
          entity: "pipeline",
          entityId: id,
          details: data
        });
      }
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error updating pipeline:", error);
      throw new Error("Failed to update pipeline");
    }
  }
  /**
   * Delete a pipeline (soft delete)
   */
  async deletePipeline(id, companyId, userId) {
    try {
      const pipeline = await this.db.select().from(pipelines).where(and26(
        eq29(pipelines.id, id),
        eq29(pipelines.companyId, companyId)
      ));
      if (pipeline.length === 0) {
        return false;
      }
      if (pipeline[0].isDefault) {
        const pipelineCount = await this.db.select({ count: sql21`count(*)` }).from(pipelines).where(eq29(pipelines.companyId, companyId));
        if (Number(pipelineCount[0]?.count || 0) === 1) {
          throw new Error("Cannot delete the only pipeline. Create a new pipeline first.");
        }
      }
      const result = await this.db.update(pipelines).set({
        isActive: false,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and26(
        eq29(pipelines.id, id),
        eq29(pipelines.companyId, companyId)
      )).returning();
      if (result.length > 0) {
        await audit_service_default.log({
          userId,
          companyId,
          action: "DELETE" /* DELETE */,
          entity: "pipeline",
          entityId: id,
          details: { message: "Soft deleted pipeline" }
        });
        if (result[0].isDefault) {
          const otherPipeline = await this.db.select().from(pipelines).where(and26(
            eq29(pipelines.companyId, companyId),
            eq29(pipelines.isActive, true),
            sql21`${pipelines.id} != ${id}`
          )).limit(1);
          if (otherPipeline.length > 0) {
            await this.db.update(pipelines).set({
              isDefault: true,
              updatedAt: /* @__PURE__ */ new Date(),
              updatedBy: userId
            }).where(eq29(pipelines.id, otherPipeline[0].id));
          }
        }
      }
      return result.length > 0;
    } catch (error) {
      console.error("Error deleting pipeline:", error);
      throw new Error(error instanceof Error ? error.message : "Failed to delete pipeline");
    }
  }
  /**
   * Get all pipelines for a company
   */
  async getPipelines(companyId, includeInactive = false) {
    try {
      let conditions = [eq29(pipelines.companyId, companyId)];
      if (!includeInactive) {
        conditions.push(eq29(pipelines.isActive, true));
      }
      return await this.db.select().from(pipelines).where(and26(...conditions)).orderBy(asc3(pipelines.displayOrder));
    } catch (error) {
      console.error("Error getting pipelines:", error);
      throw new Error("Failed to get pipelines");
    }
  }
  /**
   * Get a pipeline by ID
   */
  async getPipelineById(id, companyId) {
    try {
      const result = await this.db.select().from(pipelines).where(and26(
        eq29(pipelines.id, id),
        eq29(pipelines.companyId, companyId)
      ));
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error getting pipeline:", error);
      throw new Error("Failed to get pipeline");
    }
  }
  /**
   * Get the default pipeline for a company
   */
  async getDefaultPipeline(companyId) {
    try {
      const result = await this.db.select().from(pipelines).where(and26(
        eq29(pipelines.companyId, companyId),
        eq29(pipelines.isDefault, true),
        eq29(pipelines.isActive, true)
      ));
      if (result.length === 0) {
        const anyPipeline = await this.db.select().from(pipelines).where(and26(
          eq29(pipelines.companyId, companyId),
          eq29(pipelines.isActive, true)
        )).limit(1);
        return anyPipeline.length > 0 ? anyPipeline[0] : null;
      }
      return result[0];
    } catch (error) {
      console.error("Error getting default pipeline:", error);
      throw new Error("Failed to get default pipeline");
    }
  }
  /**
   * Create a new pipeline stage
   */
  async createStage(data, userId) {
    try {
      if (data.displayOrder === void 0) {
        const lastStage = await this.db.select().from(pipelineStages).where(and26(
          eq29(pipelineStages.pipelineId, data.pipelineId),
          eq29(pipelineStages.companyId, data.companyId)
        )).orderBy(desc9(pipelineStages.displayOrder)).limit(1);
        data.displayOrder = lastStage.length > 0 ? (lastStage[0].displayOrder || 0) + 1 : 0;
      }
      const result = await this.db.insert(pipelineStages).values({
        ...data,
        id: randomUUID6(),
        createdBy: userId,
        updatedBy: userId
      }).returning();
      if (result.length > 0) {
        await audit_service_default.log({
          userId,
          companyId: data.companyId,
          action: "CREATE" /* CREATE */,
          entity: "pipelineStage",
          entityId: result[0].id,
          details: data
        });
      }
      return result[0];
    } catch (error) {
      console.error("Error creating pipeline stage:", error);
      throw new Error("Failed to create pipeline stage");
    }
  }
  /**
   * Update a pipeline stage
   */
  async updateStage(id, data, userId) {
    try {
      const result = await this.db.update(pipelineStages).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and26(
        eq29(pipelineStages.id, id),
        eq29(pipelineStages.companyId, data.companyId || "")
      )).returning();
      if (result.length > 0) {
        await audit_service_default.log({
          userId,
          companyId: data.companyId || result[0].companyId,
          action: "UPDATE" /* UPDATE */,
          entity: "pipelineStage",
          entityId: id,
          details: data
        });
      }
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error updating pipeline stage:", error);
      throw new Error("Failed to update pipeline stage");
    }
  }
  /**
   * Delete a pipeline stage
   */
  async deleteStage(id, companyId, userId) {
    try {
      const dealsInStage = await this.db.select({ count: sql21`count(*)` }).from(deals).where(and26(
        eq29(deals.stageId, id),
        eq29(deals.companyId, companyId)
      ));
      if (Number(dealsInStage[0]?.count || 0) > 0) {
        throw new Error("Cannot delete stage with deals. Move deals to another stage first.");
      }
      const result = await this.db.update(pipelineStages).set({
        isActive: false,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and26(
        eq29(pipelineStages.id, id),
        eq29(pipelineStages.companyId, companyId)
      )).returning();
      if (result.length > 0) {
        await audit_service_default.log({
          userId,
          companyId,
          action: "DELETE" /* DELETE */,
          entity: "pipelineStage",
          entityId: id,
          details: { message: "Soft deleted pipeline stage" }
        });
      }
      return result.length > 0;
    } catch (error) {
      console.error("Error deleting pipeline stage:", error);
      throw new Error(error instanceof Error ? error.message : "Failed to delete pipeline stage");
    }
  }
  /**
   * Get stages for a pipeline
   */
  async getStages(pipelineId, companyId, includeInactive = false) {
    try {
      let conditions = [
        eq29(pipelineStages.pipelineId, pipelineId),
        eq29(pipelineStages.companyId, companyId)
      ];
      if (!includeInactive) {
        conditions.push(eq29(pipelineStages.isActive, true));
      }
      return await this.db.select().from(pipelineStages).where(and26(...conditions)).orderBy(asc3(pipelineStages.displayOrder));
    } catch (error) {
      console.error("Error getting pipeline stages:", error);
      throw new Error("Failed to get pipeline stages");
    }
  }
  /**
   * Reorder pipeline stages
   */
  async reorderStages(pipelineId, companyId, stageIds, userId) {
    try {
      const stages = await this.db.select().from(pipelineStages).where(and26(
        eq29(pipelineStages.pipelineId, pipelineId),
        eq29(pipelineStages.companyId, companyId)
      ));
      const stageMap = new Map(stages.map((stage) => [stage.id, stage]));
      for (const stageId of stageIds) {
        if (!stageMap.has(stageId)) {
          throw new Error(`Stage with ID ${stageId} not found in pipeline ${pipelineId}`);
        }
      }
      for (let i = 0; i < stageIds.length; i++) {
        await this.db.update(pipelineStages).set({
          displayOrder: i,
          updatedAt: /* @__PURE__ */ new Date(),
          updatedBy: userId
        }).where(eq29(pipelineStages.id, stageIds[i]));
      }
      await audit_service_default.log({
        userId,
        companyId,
        action: "UPDATE" /* UPDATE */,
        entity: "pipelineStages",
        entityId: pipelineId,
        details: { message: `Reordered stages: ${stageIds.join(", ")}` }
      });
      return true;
    } catch (error) {
      console.error("Error reordering pipeline stages:", error);
      throw new Error(error instanceof Error ? error.message : "Failed to reorder pipeline stages");
    }
  }
  /**
   * Get all stages across all pipelines for a company
   */
  async getAllStages(companyId) {
    try {
      return await this.db.select().from(pipelineStages).where(and26(
        eq29(pipelineStages.companyId, companyId),
        eq29(pipelineStages.isActive, true)
      )).orderBy(asc3(pipelineStages.pipelineId), asc3(pipelineStages.displayOrder));
    } catch (error) {
      console.error("Error getting all pipeline stages:", error);
      throw new Error("Failed to get all pipeline stages");
    }
  }
};

// server/modules/crm/services/deal.service.ts
var DealService = class {
  constructor() {
    this.db = getDrizzle();
    this.auditService = new AuditService();
    this.pipelineService = new PipelineService();
  }
  /**
   * Create a new deal
   */
  async create(data, userId) {
    try {
      const dealId = randomUUID7();
      if (data.probability === void 0) {
        const stage = await this.db.select().from(pipelineStages).where(eq30(pipelineStages.id, data.stageId));
        if (stage.length > 0) {
          data.probability = stage[0].probability;
        }
      }
      const result = await this.db.insert(deals).values({
        ...data,
        id: dealId,
        createdBy: userId,
        updatedBy: userId
      }).returning();
      if (result.length > 0) {
        await this.db.insert(dealStageHistory).values({
          id: randomUUID7(),
          dealId,
          companyId: data.companyId,
          toStageId: data.stageId,
          userId,
          reason: "Initial stage"
        });
        await this.auditService.logAction({
          userId,
          action: "create",
          resourceType: "deal",
          resourceId: dealId,
          details: JSON.stringify(data),
          companyId: data.companyId
        });
      }
      return result[0];
    } catch (error) {
      console.error("Error creating deal:", error);
      throw new Error("Failed to create deal");
    }
  }
  /**
   * Update a deal
   */
  async update(id, data, userId) {
    try {
      const currentDeal = await this.db.select().from(deals).where(eq30(deals.id, id));
      if (currentDeal.length === 0) {
        return null;
      }
      const stageChanged = data.stageId && data.stageId !== currentDeal[0].stageId;
      if (stageChanged && data.probability === void 0) {
        const stage = await this.db.select().from(pipelineStages).where(eq30(pipelineStages.id, data.stageId || ""));
        if (stage.length > 0) {
          data.probability = stage[0].probability;
        }
      }
      if (data.status) {
        if (data.status === "won" && !data.actualCloseDate) {
          data.actualCloseDate = /* @__PURE__ */ new Date();
        } else if (data.status === "lost" && !data.actualCloseDate) {
          data.actualCloseDate = /* @__PURE__ */ new Date();
        }
      }
      const result = await this.db.update(deals).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and27(
        eq30(deals.id, id),
        eq30(deals.companyId, data.companyId || currentDeal[0].companyId)
      )).returning();
      if (result.length > 0) {
        if (stageChanged) {
          const lastStageChange = await this.db.select().from(dealStageHistory).where(eq30(dealStageHistory.dealId, id)).orderBy(desc10(dealStageHistory.changedAt)).limit(1);
          let timeInStage = 0;
          if (lastStageChange.length > 0) {
            const lastChangeDate = new Date(lastStageChange[0].changedAt);
            const now = /* @__PURE__ */ new Date();
            const diffTime = Math.abs(now.getTime() - lastChangeDate.getTime());
            timeInStage = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
          }
          await this.db.insert(dealStageHistory).values({
            id: randomUUID7(),
            dealId: id,
            companyId: data.companyId || currentDeal[0].companyId,
            fromStageId: currentDeal[0].stageId,
            toStageId: data.stageId || "",
            daysInStage,
            userId,
            reason: data.status === "won" ? "Deal won" : data.status === "lost" ? "Deal lost" : "Stage updated"
          });
        }
        await this.auditService.logAction({
          userId,
          action: "update",
          resourceType: "deal",
          resourceId: id,
          details: JSON.stringify(data),
          companyId: data.companyId || currentDeal[0].companyId
        });
      }
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error updating deal:", error);
      throw new Error("Failed to update deal");
    }
  }
  /**
   * Delete a deal (soft delete)
   */
  async delete(id, companyId, userId) {
    try {
      const result = await this.db.update(deals).set({
        isActive: false,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and27(
        eq30(deals.id, id),
        eq30(deals.companyId, companyId)
      )).returning();
      if (result.length > 0) {
        await this.auditService.logAction({
          userId,
          action: "delete",
          resourceType: "deal",
          resourceId: id,
          details: "Soft deleted deal",
          companyId
        });
      }
      return result.length > 0;
    } catch (error) {
      console.error("Error deleting deal:", error);
      throw new Error("Failed to delete deal");
    }
  }
  /**
   * Get a deal by ID
   */
  async getById(id, companyId) {
    try {
      const result = await this.db.select().from(deals).where(and27(
        eq30(deals.id, id),
        eq30(deals.companyId, companyId)
      ));
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error getting deal:", error);
      throw new Error("Failed to get deal");
    }
  }
  /**
   * Get deal stage history
   */
  async getStageHistory(dealId, companyId) {
    try {
      return await this.db.select().from(dealStageHistory).where(and27(
        eq30(dealStageHistory.dealId, dealId),
        eq30(dealStageHistory.companyId, companyId)
      )).orderBy(asc4(dealStageHistory.changedAt));
    } catch (error) {
      console.error("Error getting deal stage history:", error);
      throw new Error("Failed to get deal stage history");
    }
  }
  /**
   * List deals with optional filtering
   */
  async list(companyId, options = {}) {
    try {
      const {
        page = 1,
        limit = 20,
        searchTerm,
        pipelineId,
        stageId,
        customerId,
        status,
        ownerId,
        isActive = true,
        sortBy = "createdAt",
        sortDirection = "desc",
        minAmount,
        maxAmount,
        expectedCloseDateStart,
        expectedCloseDateEnd
      } = options;
      const offset = (page - 1) * limit;
      let conditions = [eq30(deals.companyId, companyId)];
      if (isActive !== void 0) {
        conditions.push(eq30(deals.isActive, isActive));
      }
      if (pipelineId) {
        conditions.push(eq30(deals.pipelineId, pipelineId));
      }
      if (stageId) {
        conditions.push(eq30(deals.stageId, stageId));
      }
      if (customerId) {
        conditions.push(eq30(deals.customerId, customerId));
      }
      if (status) {
        conditions.push(eq30(deals.status, status));
      }
      if (ownerId) {
        conditions.push(eq30(deals.ownerId, ownerId));
      }
      if (minAmount !== void 0) {
        conditions.push(sql22`cast(${deals.amount} as numeric) >= ${minAmount}`);
      }
      if (maxAmount !== void 0) {
        conditions.push(sql22`cast(${deals.amount} as numeric) <= ${maxAmount}`);
      }
      if (expectedCloseDateStart) {
        conditions.push(sql22`${deals.expectedCloseDate} >= ${expectedCloseDateStart}`);
      }
      if (expectedCloseDateEnd) {
        conditions.push(sql22`${deals.expectedCloseDate} <= ${expectedCloseDateEnd}`);
      }
      if (searchTerm) {
        conditions.push(
          or6(
            like2(deals.title, `%${searchTerm}%`),
            like2(deals.description || "", `%${searchTerm}%`)
          )
        );
      }
      const totalResult = await this.db.select({ count: sql22`count(*)` }).from(deals).where(and27(...conditions));
      const total = Number(totalResult[0]?.count || 0);
      let query = this.db.select().from(deals).where(and27(...conditions)).limit(limit).offset(offset);
      if (sortBy && deals[sortBy]) {
        const sortColumn = deals[sortBy];
        if (sortDirection === "asc") {
          query = query.orderBy(asc4(sortColumn));
        } else {
          query = query.orderBy(desc10(sortColumn));
        }
      }
      const data = await query;
      return { data, total };
    } catch (error) {
      console.error("Error listing deals:", error);
      throw new Error("Failed to list deals");
    }
  }
  /**
   * Get deals by customer ID
   */
  async getByCustomerId(customerId, companyId) {
    try {
      return await this.db.select().from(deals).where(and27(
        eq30(deals.customerId, customerId),
        eq30(deals.companyId, companyId),
        eq30(deals.isActive, true)
      )).orderBy(desc10(deals.createdAt));
    } catch (error) {
      console.error("Error getting deals by customer:", error);
      throw new Error("Failed to get deals by customer");
    }
  }
  /**
   * Move deal to a different stage
   */
  async moveToStage(id, stageId, companyId, userId, reason) {
    try {
      const currentDeal = await this.db.select().from(deals).where(and27(
        eq30(deals.id, id),
        eq30(deals.companyId, companyId)
      ));
      if (currentDeal.length === 0) {
        return null;
      }
      const stage = await this.db.select().from(pipelineStages).where(eq30(pipelineStages.id, stageId));
      if (stage.length === 0) {
        throw new Error("Stage not found");
      }
      if (stage[0].pipelineId !== currentDeal[0].pipelineId) {
        throw new Error("Stage does not belong to the deal's pipeline");
      }
      const lastStageChange = await this.db.select().from(dealStageHistory).where(eq30(dealStageHistory.dealId, id)).orderBy(desc10(dealStageHistory.changedAt)).limit(1);
      let daysInStage2 = 0;
      if (lastStageChange.length > 0) {
        const lastChangeDate = new Date(lastStageChange[0].changedAt);
        const now = /* @__PURE__ */ new Date();
        const diffTime = Math.abs(now.getTime() - lastChangeDate.getTime());
        daysInStage2 = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
      }
      const updateData = {
        stageId,
        probability: stage[0].probability,
        updatedBy: userId
      };
      if (stage[0].stageType === "closed_won") {
        updateData.status = "won";
        updateData.actualCloseDate = /* @__PURE__ */ new Date();
      } else if (stage[0].stageType === "closed_lost") {
        updateData.status = "lost";
        updateData.actualCloseDate = /* @__PURE__ */ new Date();
      } else {
        updateData.status = "open";
      }
      const result = await this.db.update(deals).set({
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(and27(
        eq30(deals.id, id),
        eq30(deals.companyId, companyId)
      )).returning();
      if (result.length > 0) {
        await this.db.insert(dealStageHistory).values({
          id: randomUUID7(),
          dealId: id,
          companyId,
          fromStageId: currentDeal[0].stageId,
          toStageId: stageId,
          daysInStage: daysInStage2,
          userId,
          reason: reason || `Moved to ${stage[0].name} stage`
        });
        await this.auditService.logAction({
          userId,
          action: "update",
          resourceType: "deal",
          resourceId: id,
          details: `Moved from stage ${currentDeal[0].stageId} to ${stageId}`,
          companyId
        });
      }
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error moving deal to stage:", error);
      throw new Error(error instanceof Error ? error.message : "Failed to move deal to stage");
    }
  }
  /**
   * Get deal statistics by pipeline and stage
   */
  async getDealStats(companyId, pipelineId) {
    try {
      const conditions = [
        eq30(deals.companyId, companyId),
        eq30(deals.isActive, true)
      ];
      if (pipelineId) {
        conditions.push(eq30(deals.pipelineId, pipelineId));
      }
      const totalStats = await this.db.select({
        totalDeals: sql22`count(*)`,
        totalValue: sql22`sum(cast(${deals.amount} as numeric))`,
        avgValue: sql22`avg(cast(${deals.amount} as numeric))`,
        openDeals: sql22`count(*) filter (where ${deals.status} = 'open')`,
        wonDeals: sql22`count(*) filter (where ${deals.status} = 'won')`,
        lostDeals: sql22`count(*) filter (where ${deals.status} = 'lost')`,
        openValue: sql22`sum(cast(${deals.amount} as numeric)) filter (where ${deals.status} = 'open')`,
        wonValue: sql22`sum(cast(${deals.amount} as numeric)) filter (where ${deals.status} = 'won')`,
        weightedValue: sql22`sum(cast(${deals.amount} as numeric) * cast(${deals.probability} as numeric) / 100)`
      }).from(deals).where(and27(...conditions));
      const stageStats = await this.db.select({
        stageId: deals.stageId,
        count: sql22`count(*)`,
        value: sql22`sum(cast(${deals.amount} as numeric))`,
        averageValue: sql22`avg(cast(${deals.amount} as numeric))`
      }).from(deals).where(and27(...conditions)).groupBy(deals.stageId);
      const statusStats = await this.db.select({
        status: deals.status,
        count: sql22`count(*)`,
        value: sql22`sum(cast(${deals.amount} as numeric))`
      }).from(deals).where(and27(...conditions)).groupBy(deals.status);
      const ownerStats = await this.db.select({
        ownerId: deals.ownerId,
        count: sql22`count(*)`,
        value: sql22`sum(cast(${deals.amount} as numeric))`
      }).from(deals).where(and27(...conditions)).groupBy(deals.ownerId);
      return {
        total: {
          deals: Number(totalStats[0]?.totalDeals || 0),
          value: Number(totalStats[0]?.totalValue || 0),
          avgValue: Number(totalStats[0]?.avgValue || 0),
          openDeals: Number(totalStats[0]?.openDeals || 0),
          wonDeals: Number(totalStats[0]?.wonDeals || 0),
          lostDeals: Number(totalStats[0]?.lostDeals || 0),
          openValue: Number(totalStats[0]?.openValue || 0),
          wonValue: Number(totalStats[0]?.wonValue || 0),
          weightedValue: Number(totalStats[0]?.weightedValue || 0)
        },
        byStage: stageStats,
        byStatus: statusStats,
        byOwner: ownerStats
      };
    } catch (error) {
      console.error("Error getting deal statistics:", error);
      throw new Error("Failed to get deal statistics");
    }
  }
  /**
   * Get deals with upcoming expected close dates
   */
  async getUpcomingDeals(companyId, days = 30) {
    try {
      const today = /* @__PURE__ */ new Date();
      const endDate = /* @__PURE__ */ new Date();
      endDate.setDate(today.getDate() + days);
      return await this.db.select().from(deals).where(and27(
        eq30(deals.companyId, companyId),
        eq30(deals.isActive, true),
        eq30(deals.status, "open"),
        not(isNull6(deals.expectedCloseDate)),
        sql22`${deals.expectedCloseDate} >= current_date`,
        sql22`${deals.expectedCloseDate} <= ${endDate}`
      )).orderBy(asc4(deals.expectedCloseDate));
    } catch (error) {
      console.error("Error getting upcoming deals:", error);
      throw new Error("Failed to get upcoming deals");
    }
  }
  /**
   * Get recently updated deals
   */
  async getRecentlyUpdatedDeals(companyId, limit = 10) {
    try {
      return await this.db.select().from(deals).where(and27(
        eq30(deals.companyId, companyId),
        eq30(deals.isActive, true)
      )).orderBy(desc10(deals.updatedAt)).limit(limit);
    } catch (error) {
      console.error("Error getting recently updated deals:", error);
      throw new Error("Failed to get recently updated deals");
    }
  }
  /**
   * Get deals that have been stuck in the same stage for too long
   */
  async getStaleDeals(companyId) {
    try {
      const activeDeals = await this.db.select().from(deals).where(and27(
        eq30(deals.companyId, companyId),
        eq30(deals.isActive, true),
        eq30(deals.status, "open")
      ));
      const staleDeals = [];
      for (const deal of activeDeals) {
        const lastStageChange = await this.db.select().from(dealStageHistory).where(and27(
          eq30(dealStageHistory.dealId, deal.id),
          eq30(dealStageHistory.toStageId, deal.stageId)
        )).orderBy(desc10(dealStageHistory.changedAt)).limit(1);
        if (lastStageChange.length === 0) continue;
        const stage = await this.db.select().from(pipelineStages).where(eq30(pipelineStages.id, deal.stageId));
        if (stage.length === 0) continue;
        const expectedDuration = stage[0].expectedDuration || 0;
        if (expectedDuration <= 0) continue;
        const lastChangeDate = new Date(lastStageChange[0].changedAt);
        const now = /* @__PURE__ */ new Date();
        const diffTime = Math.abs(now.getTime() - lastChangeDate.getTime());
        const daysInStage2 = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
        if (daysInStage2 > expectedDuration) {
          staleDeals.push({
            ...deal,
            daysInStage: daysInStage2
          });
        }
      }
      return staleDeals;
    } catch (error) {
      console.error("Error getting stale deals:", error);
      throw new Error("Failed to get stale deals");
    }
  }
};

// server/modules/crm/controllers/deal.controller.ts
init_auth_guard();
var DealController = class {
  constructor() {
    this.jwtService = null;
    this.dealService = new DealService();
    this.createDeal = this.createDeal.bind(this);
    this.getDeal = this.getDeal.bind(this);
    this.updateDeal = this.updateDeal.bind(this);
    this.deleteDeal = this.deleteDeal.bind(this);
    this.listDeals = this.listDeals.bind(this);
    this.getDealsByCustomer = this.getDealsByCustomer.bind(this);
    this.getDealStageHistory = this.getDealStageHistory.bind(this);
    this.moveDealToStage = this.moveDealToStage.bind(this);
    this.getDealStatistics = this.getDealStatistics.bind(this);
    this.getUpcomingDeals = this.getUpcomingDeals.bind(this);
    this.getRecentlyUpdatedDeals = this.getRecentlyUpdatedDeals.bind(this);
    this.getStaleDeals = this.getStaleDeals.bind(this);
  }
  /**
   * Register routes
   */
  registerRoutes(app2, jwtService2) {
    if (jwtService2) {
      this.jwtService = jwtService2;
    }
    app2.post(
      "/api/crm/deals",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["sales_agent" /* SALES_AGENT */, "company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.createDeal
    );
    app2.get(
      "/api/crm/deals/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getDeal
    );
    app2.put(
      "/api/crm/deals/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["sales_agent" /* SALES_AGENT */, "company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.updateDeal
    );
    app2.delete(
      "/api/crm/deals/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.deleteDeal
    );
    app2.get(
      "/api/crm/deals",
      AuthGuard.protect("required" /* REQUIRED */),
      this.listDeals
    );
    app2.get(
      "/api/crm/customers/:customerId/deals",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getDealsByCustomer
    );
    app2.get(
      "/api/crm/deals/:id/history",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getDealStageHistory
    );
    app2.post(
      "/api/crm/deals/:id/move-to-stage",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["sales_agent" /* SALES_AGENT */, "company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.moveDealToStage
    );
    app2.get(
      "/api/crm/deals-statistics",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getDealStatistics
    );
    app2.get(
      "/api/crm/deals-upcoming",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getUpcomingDeals
    );
    app2.get(
      "/api/crm/deals-recent",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getRecentlyUpdatedDeals
    );
    app2.get(
      "/api/crm/deals-stale",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getStaleDeals
    );
  }
  /**
   * Create a new deal
   */
  async createDeal(req, res) {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!req.body.companyId) {
        req.body.companyId = req.user?.companyId;
      }
      if (!req.body.title) {
        return res.status(400).json({ message: "Deal title is required" });
      }
      if (!req.body.stageId) {
        return res.status(400).json({ message: "Stage ID is required" });
      }
      if (!req.body.pipelineId) {
        return res.status(400).json({ message: "Pipeline ID is required" });
      }
      if (!req.body.ownerId) {
        req.body.ownerId = userId;
      }
      const deal = await this.dealService.create(req.body, userId);
      return res.status(201).json(deal);
    } catch (error) {
      console.error("Error creating deal:", error);
      return res.status(500).json({ message: "Failed to create deal", error: error.message });
    }
  }
  /**
   * Get a deal by ID
   */
  async getDeal(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const deal = await this.dealService.getById(id, companyId);
      if (!deal) {
        return res.status(404).json({ message: "Deal not found" });
      }
      return res.json(deal);
    } catch (error) {
      console.error("Error getting deal:", error);
      return res.status(500).json({ message: "Failed to get deal", error: error.message });
    }
  }
  /**
   * Update a deal
   */
  async updateDeal(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!req.body.companyId) {
        req.body.companyId = companyId;
      }
      const deal = await this.dealService.update(id, req.body, userId);
      if (!deal) {
        return res.status(404).json({ message: "Deal not found" });
      }
      return res.json(deal);
    } catch (error) {
      console.error("Error updating deal:", error);
      return res.status(500).json({ message: "Failed to update deal", error: error.message });
    }
  }
  /**
   * Delete a deal
   */
  async deleteDeal(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const success = await this.dealService.delete(id, companyId, userId);
      if (!success) {
        return res.status(404).json({ message: "Deal not found" });
      }
      return res.json({ message: "Deal deleted successfully" });
    } catch (error) {
      console.error("Error deleting deal:", error);
      return res.status(500).json({ message: "Failed to delete deal", error: error.message });
    }
  }
  /**
   * List deals with filtering, sorting, and pagination
   */
  async listDeals(req, res) {
    try {
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const {
        page = "1",
        limit = "20",
        searchTerm,
        pipelineId,
        stageId,
        customerId,
        status,
        ownerId,
        isActive,
        sortBy,
        sortDirection,
        minAmount,
        maxAmount,
        expectedCloseDateStart,
        expectedCloseDateEnd
      } = req.query;
      const options = {
        page: parseInt(page, 10),
        limit: parseInt(limit, 10),
        searchTerm,
        pipelineId,
        stageId,
        customerId,
        status,
        ownerId,
        isActive: isActive === void 0 ? void 0 : isActive === "true",
        sortBy,
        sortDirection: sortDirection || "desc",
        minAmount: minAmount ? parseFloat(minAmount) : void 0,
        maxAmount: maxAmount ? parseFloat(maxAmount) : void 0,
        expectedCloseDateStart: expectedCloseDateStart ? new Date(expectedCloseDateStart) : void 0,
        expectedCloseDateEnd: expectedCloseDateEnd ? new Date(expectedCloseDateEnd) : void 0
      };
      const { data, total } = await this.dealService.list(companyId, options);
      return res.json({
        data,
        meta: {
          total,
          page: options.page,
          limit: options.limit,
          totalPages: Math.ceil(total / options.limit)
        }
      });
    } catch (error) {
      console.error("Error listing deals:", error);
      return res.status(500).json({ message: "Failed to list deals", error: error.message });
    }
  }
  /**
   * Get deals by customer ID
   */
  async getDealsByCustomer(req, res) {
    try {
      const { customerId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const deals2 = await this.dealService.getByCustomerId(customerId, companyId);
      return res.json(deals2);
    } catch (error) {
      console.error("Error getting deals by customer:", error);
      return res.status(500).json({ message: "Failed to get deals by customer", error: error.message });
    }
  }
  /**
   * Get deal stage history
   */
  async getDealStageHistory(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const history = await this.dealService.getStageHistory(id, companyId);
      return res.json(history);
    } catch (error) {
      console.error("Error getting deal stage history:", error);
      return res.status(500).json({ message: "Failed to get deal stage history", error: error.message });
    }
  }
  /**
   * Move a deal to a different stage
   */
  async moveDealToStage(req, res) {
    try {
      const { id } = req.params;
      const { stageId, reason } = req.body;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!stageId) {
        return res.status(400).json({ message: "Stage ID is required" });
      }
      const deal = await this.dealService.moveToStage(id, stageId, companyId, userId, reason);
      if (!deal) {
        return res.status(404).json({ message: "Deal not found" });
      }
      return res.json(deal);
    } catch (error) {
      console.error("Error moving deal to stage:", error);
      return res.status(500).json({ message: "Failed to move deal to stage", error: error.message });
    }
  }
  /**
   * Get deal statistics
   */
  async getDealStatistics(req, res) {
    try {
      const companyId = req.user?.companyId;
      const { pipelineId } = req.query;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const statistics = await this.dealService.getDealStats(companyId, pipelineId);
      return res.json(statistics);
    } catch (error) {
      console.error("Error getting deal statistics:", error);
      return res.status(500).json({ message: "Failed to get deal statistics", error: error.message });
    }
  }
  /**
   * Get upcoming deals
   */
  async getUpcomingDeals(req, res) {
    try {
      const companyId = req.user?.companyId;
      const { days = "30" } = req.query;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const deals2 = await this.dealService.getUpcomingDeals(companyId, parseInt(days, 10));
      return res.json(deals2);
    } catch (error) {
      console.error("Error getting upcoming deals:", error);
      return res.status(500).json({ message: "Failed to get upcoming deals", error: error.message });
    }
  }
  /**
   * Get recently updated deals
   */
  async getRecentlyUpdatedDeals(req, res) {
    try {
      const companyId = req.user?.companyId;
      const { limit = "10" } = req.query;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const deals2 = await this.dealService.getRecentlyUpdatedDeals(companyId, parseInt(limit, 10));
      return res.json(deals2);
    } catch (error) {
      console.error("Error getting recently updated deals:", error);
      return res.status(500).json({ message: "Failed to get recently updated deals", error: error.message });
    }
  }
  /**
   * Get stale deals
   */
  async getStaleDeals(req, res) {
    try {
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const deals2 = await this.dealService.getStaleDeals(companyId);
      return res.json(deals2);
    } catch (error) {
      console.error("Error getting stale deals:", error);
      return res.status(500).json({ message: "Failed to get stale deals", error: error.message });
    }
  }
};

// server/modules/crm/controllers/sales.controller.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
var logger38 = new Logger("SalesController");
var SalesController = class {
  constructor() {
    this.jwtService = null;
    this.placeholder = this.placeholder.bind(this);
  }
  /**
   * Register routes
   */
  registerRoutes(app2, jwtService2) {
    if (jwtService2) {
      this.jwtService = jwtService2;
    }
    app2.post(
      "/api/crm/sales/placeholder",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["sales_agent" /* SALES_AGENT */, "company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.placeholder
    );
    app2.post(
      "/api/sales/placeholder",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["sales_agent" /* SALES_AGENT */, "company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.placeholder
    );
    logger38.info("Sales routes registered successfully");
  }
  /**
   * Placeholder endpoint for sales operations
   */
  async placeholder(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      return res.status(200).json({
        message: "CRM Sales placeholder endpoint",
        success: true,
        user: {
          id: userId,
          companyId
        },
        timestamp: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      console.error("Error in sales placeholder endpoint:", error);
      return res.status(500).json({
        message: "Error processing request",
        error: error.message
      });
    }
  }
};

// server/modules/crm/services/activity.service.ts
init_drizzle();
init_crm_schema();
init_audit_service();
import { sql as sql24, eq as eq32, and as and29, or as or8, like as like4, desc as desc12, asc as asc6, gte as gte3, lte as lte3 } from "drizzle-orm";
import { randomUUID as randomUUID9 } from "crypto";

// server/modules/crm/services/contact.service.ts
init_drizzle();
init_crm_schema();
init_audit_service();
import { sql as sql23, eq as eq31, and as and28, or as or7, like as like3, desc as desc11, asc as asc5 } from "drizzle-orm";
import { randomUUID as randomUUID8 } from "crypto";
var ContactService = class {
  constructor() {
    this.db = new DrizzleService();
    this.auditService = new AuditService();
  }
  /**
   * Create a new contact
   */
  async create(data, userId) {
    try {
      const result = await this.db.insert(contacts).values({
        ...data,
        id: randomUUID8(),
        createdBy: userId,
        updatedBy: userId
      }).returning();
      if (result.length > 0) {
        await this.auditService.logAction({
          userId,
          action: "create",
          resourceType: "contact",
          resourceId: result[0].id,
          details: JSON.stringify(data),
          companyId: data.companyId
        });
      }
      return result[0];
    } catch (error) {
      console.error("Error creating contact:", error);
      throw new Error("Failed to create contact");
    }
  }
  /**
   * Get contact by ID
   */
  async getById(id, companyId) {
    try {
      const result = await this.db.select().from(contacts).where(and28(
        eq31(contacts.id, id),
        eq31(contacts.companyId, companyId)
      ));
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error getting contact:", error);
      throw new Error("Failed to get contact");
    }
  }
  /**
   * Update a contact
   */
  async update(id, data, userId) {
    try {
      const result = await this.db.update(contacts).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and28(
        eq31(contacts.id, id),
        eq31(contacts.companyId, data.companyId || "")
      )).returning();
      if (result.length > 0) {
        await this.auditService.logAction({
          userId,
          action: "update",
          resourceType: "contact",
          resourceId: id,
          details: JSON.stringify(data),
          companyId: data.companyId || result[0].companyId
        });
      }
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error updating contact:", error);
      throw new Error("Failed to update contact");
    }
  }
  /**
   * Delete a contact (soft delete by setting isActive = false)
   */
  async delete(id, companyId, userId) {
    try {
      const result = await this.db.update(contacts).set({
        isActive: false,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and28(
        eq31(contacts.id, id),
        eq31(contacts.companyId, companyId)
      )).returning();
      if (result.length > 0) {
        await this.auditService.logAction({
          userId,
          action: "delete",
          resourceType: "contact",
          resourceId: id,
          details: "Soft deleted contact",
          companyId
        });
      }
      return result.length > 0;
    } catch (error) {
      console.error("Error deleting contact:", error);
      throw new Error("Failed to delete contact");
    }
  }
  /**
   * List contacts with optional filtering
   */
  async list(companyId, options = {}) {
    try {
      const {
        page = 1,
        limit = 20,
        searchTerm,
        customerId,
        isDecisionMaker,
        isActive = true,
        sortBy = "createdAt",
        sortDirection = "desc"
      } = options;
      const offset = (page - 1) * limit;
      let conditions = [eq31(contacts.companyId, companyId)];
      if (isActive !== void 0) {
        conditions.push(eq31(contacts.isActive, isActive));
      }
      if (customerId) {
        conditions.push(eq31(contacts.customerId, customerId));
      }
      if (isDecisionMaker !== void 0) {
        conditions.push(eq31(contacts.decisionMaker, isDecisionMaker));
      }
      if (searchTerm) {
        conditions.push(
          or7(
            like3(contacts.firstName, `%${searchTerm}%`),
            like3(contacts.lastName, `%${searchTerm}%`),
            like3(contacts.email, `%${searchTerm}%`),
            like3(contacts.phone, `%${searchTerm}%`),
            like3(contacts.title, `%${searchTerm}%`)
          )
        );
      }
      const totalResult = await this.db.select({ count: sql23`count(*)` }).from(contacts).where(and28(...conditions));
      const total = Number(totalResult[0]?.count || 0);
      let query = this.db.select().from(contacts).where(and28(...conditions)).limit(limit).offset(offset);
      if (sortBy && contacts[sortBy]) {
        const sortColumn = contacts[sortBy];
        if (sortDirection === "asc") {
          query = query.orderBy(asc5(sortColumn));
        } else {
          query = query.orderBy(desc11(sortColumn));
        }
      }
      const data = await query;
      return { data, total };
    } catch (error) {
      console.error("Error listing contacts:", error);
      throw new Error("Failed to list contacts");
    }
  }
  /**
   * Get contacts for a customer
   */
  async getByCustomerId(customerId, companyId) {
    try {
      return await this.db.select().from(contacts).where(and28(
        eq31(contacts.customerId, customerId),
        eq31(contacts.companyId, companyId),
        eq31(contacts.isActive, true)
      ));
    } catch (error) {
      console.error("Error getting contacts by customer:", error);
      throw new Error("Failed to get contacts by customer");
    }
  }
  /**
   * Update last contacted date for a contact
   */
  async updateLastContactedAt(id, companyId, userId) {
    try {
      const result = await this.db.update(contacts).set({
        lastContactedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and28(
        eq31(contacts.id, id),
        eq31(contacts.companyId, companyId)
      )).returning();
      return result.length > 0;
    } catch (error) {
      console.error("Error updating last contacted date:", error);
      throw new Error("Failed to update last contacted date");
    }
  }
};

// server/modules/crm/services/activity.service.ts
var ActivityService = class {
  constructor() {
    this.db = new DrizzleService();
    this.auditService = new AuditService();
    this.contactService = new ContactService();
  }
  /**
   * Create a new activity
   */
  async create(data, userId) {
    try {
      const result = await this.db.insert(activities).values({
        ...data,
        id: randomUUID9(),
        createdBy: userId,
        updatedBy: userId
      }).returning();
      if (result.length > 0) {
        await this.auditService.logAction({
          userId,
          action: "create",
          resourceType: "activity",
          resourceId: result[0].id,
          details: JSON.stringify(data),
          companyId: data.companyId
        });
        if (data.contactId) {
          await this.contactService.updateLastContactedAt(data.contactId, data.companyId, userId);
        }
      }
      return result[0];
    } catch (error) {
      console.error("Error creating activity:", error);
      throw new Error("Failed to create activity");
    }
  }
  /**
   * Update an activity
   */
  async update(id, data, userId) {
    try {
      const result = await this.db.update(activities).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and29(
        eq32(activities.id, id),
        eq32(activities.companyId, data.companyId || "")
      )).returning();
      if (result.length > 0) {
        await this.auditService.logAction({
          userId,
          action: "update",
          resourceType: "activity",
          resourceId: id,
          details: JSON.stringify(data),
          companyId: data.companyId || result[0].companyId
        });
        if (data.status === "completed" && result[0].contactId) {
          await this.contactService.updateLastContactedAt(
            result[0].contactId,
            data.companyId || result[0].companyId,
            userId
          );
        }
      }
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error updating activity:", error);
      throw new Error("Failed to update activity");
    }
  }
  /**
   * Mark an activity as completed
   */
  async markAsCompleted(id, companyId, userId, outcome) {
    try {
      const result = await this.db.update(activities).set({
        status: "completed",
        completedAt: /* @__PURE__ */ new Date(),
        outcome: outcome || "Completed",
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and29(
        eq32(activities.id, id),
        eq32(activities.companyId, companyId)
      )).returning();
      if (result.length > 0) {
        await this.auditService.logAction({
          userId,
          action: "update",
          resourceType: "activity",
          resourceId: id,
          details: "Marked activity as completed",
          companyId
        });
        if (result[0].contactId) {
          await this.contactService.updateLastContactedAt(result[0].contactId, companyId, userId);
        }
      }
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error marking activity as completed:", error);
      throw new Error("Failed to mark activity as completed");
    }
  }
  /**
   * Delete an activity
   */
  async delete(id, companyId, userId) {
    try {
      const result = await this.db.delete(activities).where(and29(
        eq32(activities.id, id),
        eq32(activities.companyId, companyId)
      )).returning();
      if (result.length > 0) {
        await this.auditService.logAction({
          userId,
          action: "delete",
          resourceType: "activity",
          resourceId: id,
          details: "Deleted activity",
          companyId
        });
      }
      return result.length > 0;
    } catch (error) {
      console.error("Error deleting activity:", error);
      throw new Error("Failed to delete activity");
    }
  }
  /**
   * Get an activity by ID
   */
  async getById(id, companyId) {
    try {
      const result = await this.db.select().from(activities).where(and29(
        eq32(activities.id, id),
        eq32(activities.companyId, companyId)
      ));
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      console.error("Error getting activity:", error);
      throw new Error("Failed to get activity");
    }
  }
  /**
   * List activities with optional filtering
   */
  async list(companyId, options = {}) {
    try {
      const {
        page = 1,
        limit = 20,
        searchTerm,
        dealId,
        customerId,
        contactId,
        type,
        status,
        assignedTo,
        dateFrom,
        dateTo,
        sortBy = "startTime",
        sortDirection = "desc"
      } = options;
      const offset = (page - 1) * limit;
      let conditions = [eq32(activities.companyId, companyId)];
      if (dealId) {
        conditions.push(eq32(activities.dealId, dealId));
      }
      if (customerId) {
        conditions.push(eq32(activities.clientCompanyId, customerId));
      }
      if (contactId) {
        conditions.push(eq32(activities.contactId, contactId));
      }
      if (type) {
        conditions.push(eq32(activities.activityType, type));
      }
      if (status) {
        conditions.push(eq32(activities.status, status));
      }
      if (assignedTo) {
        conditions.push(eq32(activities.assignedTo, assignedTo));
      }
      if (dateFrom) {
        conditions.push(gte3(activities.startTime, dateFrom));
      }
      if (dateTo) {
        conditions.push(lte3(activities.startTime, dateTo));
      }
      if (searchTerm) {
        conditions.push(
          or8(
            like4(activities.title, `%${searchTerm}%`),
            like4(activities.description || "", `%${searchTerm}%`)
          )
        );
      }
      const totalResult = await this.db.select({ count: sql24`count(*)` }).from(activities).where(and29(...conditions));
      const total = Number(totalResult[0]?.count || 0);
      let query = this.db.select().from(activities).where(and29(...conditions)).limit(limit).offset(offset);
      if (sortBy && activities[sortBy]) {
        const sortColumn = activities[sortBy];
        if (sortDirection === "asc") {
          query = query.orderBy(asc6(sortColumn));
        } else {
          query = query.orderBy(desc12(sortColumn));
        }
      }
      const data = await query;
      return { data, total };
    } catch (error) {
      console.error("Error listing activities:", error);
      throw new Error("Failed to list activities");
    }
  }
  /**
   * Get upcoming activities for a user
   */
  async getUpcomingActivities(companyId, userId, days = 7) {
    try {
      const today = /* @__PURE__ */ new Date();
      const endDate = /* @__PURE__ */ new Date();
      endDate.setDate(today.getDate() + days);
      return await this.db.select().from(activities).where(and29(
        eq32(activities.companyId, companyId),
        eq32(activities.assignedTo, userId),
        eq32(activities.status, "pending"),
        gte3(activities.startTime, today),
        lte3(activities.startTime, endDate)
      )).orderBy(asc6(activities.startTime));
    } catch (error) {
      console.error("Error getting upcoming activities:", error);
      throw new Error("Failed to get upcoming activities");
    }
  }
  /**
   * Get overdue activities for a user
   */
  async getOverdueActivities(companyId, userId) {
    try {
      const today = /* @__PURE__ */ new Date();
      return await this.db.select().from(activities).where(and29(
        eq32(activities.companyId, companyId),
        eq32(activities.assignedTo, userId),
        eq32(activities.status, "pending"),
        lte3(activities.startTime, today)
      )).orderBy(asc6(activities.startTime));
    } catch (error) {
      console.error("Error getting overdue activities:", error);
      throw new Error("Failed to get overdue activities");
    }
  }
  /**
   * Get activities by deal ID
   */
  async getActivitiesByDealId(dealId, companyId) {
    try {
      return await this.db.select().from(activities).where(and29(
        eq32(activities.dealId, dealId),
        eq32(activities.companyId, companyId)
      )).orderBy(desc12(activities.createdAt));
    } catch (error) {
      console.error("Error getting activities by deal:", error);
      throw new Error("Failed to get activities by deal");
    }
  }
  /**
   * Get activities by customer ID
   */
  async getActivitiesByCustomerId(customerId, companyId) {
    try {
      return await this.db.select().from(activities).where(and29(
        eq32(activities.clientCompanyId, customerId),
        eq32(activities.companyId, companyId)
      )).orderBy(desc12(activities.createdAt));
    } catch (error) {
      console.error("Error getting activities by customer:", error);
      throw new Error("Failed to get activities by customer");
    }
  }
  /**
   * Get activities by contact ID
   */
  async getActivitiesByContactId(contactId, companyId) {
    try {
      return await this.db.select().from(activities).where(and29(
        eq32(activities.contactId, contactId),
        eq32(activities.companyId, companyId)
      )).orderBy(desc12(activities.createdAt));
    } catch (error) {
      console.error("Error getting activities by contact:", error);
      throw new Error("Failed to get activities by contact");
    }
  }
  /**
   * Get activities for today's calendar
   */
  async getTodaysActivities(companyId, userId) {
    try {
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      let conditions = [
        eq32(activities.companyId, companyId),
        gte3(activities.startTime, today),
        lte3(activities.startTime, tomorrow)
      ];
      if (userId) {
        conditions.push(eq32(activities.assignedTo, userId));
      }
      return await this.db.select().from(activities).where(and29(...conditions)).orderBy(asc6(activities.startTime));
    } catch (error) {
      console.error("Error getting today's activities:", error);
      throw new Error("Failed to get today's activities");
    }
  }
  /**
   * Get activities for a date range (calendar view)
   */
  async getActivitiesByDateRange(companyId, startDate, endDate, userId) {
    try {
      let conditions = [
        eq32(activities.companyId, companyId),
        gte3(activities.startTime, startDate),
        lte3(activities.startTime, endDate)
      ];
      if (userId) {
        conditions.push(eq32(activities.assignedTo, userId));
      }
      return await this.db.select().from(activities).where(and29(...conditions)).orderBy(asc6(activities.startTime));
    } catch (error) {
      console.error("Error getting activities by date range:", error);
      throw new Error("Failed to get activities by date range");
    }
  }
  /**
   * Get activity statistics
   */
  async getActivityStats(companyId, userId) {
    try {
      let conditions = [eq32(activities.companyId, companyId)];
      if (userId) {
        conditions.push(eq32(activities.assignedTo, userId));
      }
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const statsResult = await this.db.select({
        total: sql24`count(*)`,
        pending: sql24`count(*) filter (where ${activities.status} = 'pending')`,
        completed: sql24`count(*) filter (where ${activities.status} = 'completed')`,
        cancelled: sql24`count(*) filter (where ${activities.status} = 'cancelled')`,
        today: sql24`count(*) filter (where ${activities.startTime} >= ${today} and ${activities.startTime} < ${tomorrow})`,
        overdue: sql24`count(*) filter (where ${activities.startTime} < ${today} and ${activities.status} = 'pending')`,
        calls: sql24`count(*) filter (where ${activities.activityType} = 'call')`,
        meetings: sql24`count(*) filter (where ${activities.activityType} = 'meeting')`,
        tasks: sql24`count(*) filter (where ${activities.activityType} = 'task')`,
        emails: sql24`count(*) filter (where ${activities.activityType} = 'email')`
      }).from(activities).where(and29(...conditions));
      return {
        total: Number(statsResult[0]?.total || 0),
        pending: Number(statsResult[0]?.pending || 0),
        completed: Number(statsResult[0]?.completed || 0),
        cancelled: Number(statsResult[0]?.cancelled || 0),
        today: Number(statsResult[0]?.today || 0),
        overdue: Number(statsResult[0]?.overdue || 0),
        calls: Number(statsResult[0]?.calls || 0),
        meetings: Number(statsResult[0]?.meetings || 0),
        tasks: Number(statsResult[0]?.tasks || 0),
        emails: Number(statsResult[0]?.emails || 0)
      };
    } catch (error) {
      console.error("Error getting activity statistics:", error);
      throw new Error("Failed to get activity statistics");
    }
  }
};

// server/modules/crm/controllers/activity.controller.ts
init_auth_guard();
var ActivityController = class {
  constructor() {
    this.activityService = new ActivityService();
  }
  /**
   * Register all activity routes
   */
  registerRoutes(app2, jwtService2) {
    app2.post(
      "/api/crm/activities",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.createActivity.bind(this)
    );
    app2.get(
      "/api/crm/activities/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getActivity.bind(this)
    );
    app2.put(
      "/api/crm/activities/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.updateActivity.bind(this)
    );
    app2.delete(
      "/api/crm/activities/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.deleteActivity.bind(this)
    );
    app2.get(
      "/api/crm/activities",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.listActivities.bind(this)
    );
    app2.put(
      "/api/crm/activities/:id/complete",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.completeActivity.bind(this)
    );
    app2.get(
      "/api/crm/deals/:dealId/activities",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getActivitiesByDeal.bind(this)
    );
    app2.get(
      "/api/crm/customers/:customerId/activities",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getActivitiesByCustomer.bind(this)
    );
    app2.get(
      "/api/crm/contacts/:contactId/activities",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getActivitiesByContact.bind(this)
    );
    app2.get(
      "/api/crm/calendar",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getCalendarActivities.bind(this)
    );
    app2.get(
      "/api/crm/activities/upcoming",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getUpcomingActivities.bind(this)
    );
    app2.get(
      "/api/crm/activities/overdue",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getOverdueActivities.bind(this)
    );
    app2.get(
      "/api/crm/activities/stats",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getActivityStats.bind(this)
    );
  }
  /**
   * Create a new activity
   */
  async createActivity(req, res) {
    try {
      const { user, body } = req;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const activityData = {
        ...body,
        companyId: user.companyId
      };
      const activity = await this.activityService.create(activityData, user.id);
      res.status(201).json(activity);
    } catch (error) {
      console.error("Error creating activity:", error);
      res.status(500).json({
        message: "Failed to create activity",
        error: error.message
      });
    }
  }
  /**
   * Get a specific activity by ID
   */
  async getActivity(req, res) {
    try {
      const { user, params } = req;
      const { id } = params;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const activity = await this.activityService.getById(id, user.companyId);
      if (!activity) {
        res.status(404).json({ message: "Activity not found" });
        return;
      }
      res.json(activity);
    } catch (error) {
      console.error("Error getting activity:", error);
      res.status(500).json({
        message: "Failed to get activity",
        error: error.message
      });
    }
  }
  /**
   * Update an existing activity
   */
  async updateActivity(req, res) {
    try {
      const { user, params, body } = req;
      const { id } = params;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const activityData = {
        ...body,
        companyId: user.companyId
      };
      const activity = await this.activityService.update(id, activityData, user.id);
      if (!activity) {
        res.status(404).json({ message: "Activity not found" });
        return;
      }
      res.json(activity);
    } catch (error) {
      console.error("Error updating activity:", error);
      res.status(500).json({
        message: "Failed to update activity",
        error: error.message
      });
    }
  }
  /**
   * Delete an activity
   */
  async deleteActivity(req, res) {
    try {
      const { user, params } = req;
      const { id } = params;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const success = await this.activityService.delete(id, user.companyId, user.id);
      if (!success) {
        res.status(404).json({ message: "Activity not found" });
        return;
      }
      res.json({ message: "Activity deleted successfully" });
    } catch (error) {
      console.error("Error deleting activity:", error);
      res.status(500).json({
        message: "Failed to delete activity",
        error: error.message
      });
    }
  }
  /**
   * List activities with filters
   */
  async listActivities(req, res) {
    try {
      const { user, query } = req;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const page = query.page ? parseInt(query.page, 10) : 1;
      const limit = query.limit ? parseInt(query.limit, 10) : 20;
      const searchTerm = query.search;
      const dealId = query.dealId;
      const customerId = query.customerId;
      const contactId = query.contactId;
      const type = query.activityType;
      const status = query.status;
      const assignedTo = query.assignedTo;
      const sortBy = query.sortBy;
      const sortDirection = query.sortDirection;
      const dateFrom = query.dateFrom ? new Date(query.dateFrom) : void 0;
      const dateTo = query.dateTo ? new Date(query.dateTo) : void 0;
      const result = await this.activityService.list(user.companyId, {
        page,
        limit,
        searchTerm,
        dealId,
        customerId,
        contactId,
        type,
        status,
        assignedTo,
        dateFrom,
        dateTo,
        sortBy,
        sortDirection
      });
      res.json(result);
    } catch (error) {
      console.error("Error listing activities:", error);
      res.status(500).json({
        message: "Failed to list activities",
        error: error.message
      });
    }
  }
  /**
   * Mark activity as completed
   */
  async completeActivity(req, res) {
    try {
      const { user, params, body } = req;
      const { id } = params;
      const { outcome } = body;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const activity = await this.activityService.markAsCompleted(id, user.companyId, user.id, outcome);
      if (!activity) {
        res.status(404).json({ message: "Activity not found" });
        return;
      }
      res.json(activity);
    } catch (error) {
      console.error("Error completing activity:", error);
      res.status(500).json({
        message: "Failed to complete activity",
        error: error.message
      });
    }
  }
  /**
   * Get activities for a deal
   */
  async getActivitiesByDeal(req, res) {
    try {
      const { user, params } = req;
      const { dealId } = params;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const activities2 = await this.activityService.getActivitiesByDealId(dealId, user.companyId);
      res.json(activities2);
    } catch (error) {
      console.error("Error getting deal activities:", error);
      res.status(500).json({
        message: "Failed to get deal activities",
        error: error.message
      });
    }
  }
  /**
   * Get activities for a customer
   */
  async getActivitiesByCustomer(req, res) {
    try {
      const { user, params } = req;
      const { customerId } = params;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const activities2 = await this.activityService.getActivitiesByCustomerId(customerId, user.companyId);
      res.json(activities2);
    } catch (error) {
      console.error("Error getting customer activities:", error);
      res.status(500).json({
        message: "Failed to get customer activities",
        error: error.message
      });
    }
  }
  /**
   * Get activities for a contact
   */
  async getActivitiesByContact(req, res) {
    try {
      const { user, params } = req;
      const { contactId } = params;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const activities2 = await this.activityService.getActivitiesByContactId(contactId, user.companyId);
      res.json(activities2);
    } catch (error) {
      console.error("Error getting contact activities:", error);
      res.status(500).json({
        message: "Failed to get contact activities",
        error: error.message
      });
    }
  }
  /**
   * Get calendar activities for a date range
   */
  async getCalendarActivities(req, res) {
    try {
      const { user, query } = req;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const startDate = query.startDate ? new Date(query.startDate) : /* @__PURE__ */ new Date();
      const endDate = query.endDate ? new Date(query.endDate) : /* @__PURE__ */ new Date();
      endDate.setDate(startDate.getDate() + 30);
      const userId = query.userId;
      const activities2 = await this.activityService.getActivitiesByDateRange(
        user.companyId,
        startDate,
        endDate,
        userId || void 0
      );
      res.json(activities2);
    } catch (error) {
      console.error("Error getting calendar activities:", error);
      res.status(500).json({
        message: "Failed to get calendar activities",
        error: error.message
      });
    }
  }
  /**
   * Get user's upcoming activities
   */
  async getUpcomingActivities(req, res) {
    try {
      const { user, query } = req;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const days = query.days ? parseInt(query.days, 10) : 7;
      const activities2 = await this.activityService.getUpcomingActivities(user.companyId, user.id, days);
      res.json(activities2);
    } catch (error) {
      console.error("Error getting upcoming activities:", error);
      res.status(500).json({
        message: "Failed to get upcoming activities",
        error: error.message
      });
    }
  }
  /**
   * Get user's overdue activities
   */
  async getOverdueActivities(req, res) {
    try {
      const { user } = req;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const activities2 = await this.activityService.getOverdueActivities(user.companyId, user.id);
      res.json(activities2);
    } catch (error) {
      console.error("Error getting overdue activities:", error);
      res.status(500).json({
        message: "Failed to get overdue activities",
        error: error.message
      });
    }
  }
  /**
   * Get activities statistics
   */
  async getActivityStats(req, res) {
    try {
      const { user, query } = req;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const userId = query.userId;
      const stats = await this.activityService.getActivityStats(user.companyId, userId || void 0);
      res.json(stats);
    } catch (error) {
      console.error("Error getting activity statistics:", error);
      res.status(500).json({
        message: "Failed to get activity statistics",
        error: error.message
      });
    }
  }
};

// server/modules/crm/controllers/contact.controller.ts
init_auth_guard();
var ContactController = class {
  constructor() {
    this.contactService = new ContactService();
  }
  /**
   * Register all contact routes
   */
  registerRoutes(app2, jwtService2) {
    app2.post(
      "/api/crm/contacts",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.createContact.bind(this)
    );
    app2.get(
      "/api/crm/contacts/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getContact.bind(this)
    );
    app2.put(
      "/api/crm/contacts/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.updateContact.bind(this)
    );
    app2.delete(
      "/api/crm/contacts/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.deleteContact.bind(this)
    );
    app2.get(
      "/api/crm/contacts",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.listContacts.bind(this)
    );
    app2.get(
      "/api/crm/customers/:customerId/contacts",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getContactsByCustomer.bind(this)
    );
  }
  /**
   * Create a new contact
   */
  async createContact(req, res) {
    try {
      const { user, body } = req;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const contactData = {
        ...body,
        companyId: user.companyId
      };
      const contact = await this.contactService.create(contactData, user.id);
      res.status(201).json(contact);
    } catch (error) {
      console.error("Error creating contact:", error);
      res.status(500).json({
        message: "Failed to create contact",
        error: error.message
      });
    }
  }
  /**
   * Get a specific contact by ID
   */
  async getContact(req, res) {
    try {
      const { user, params } = req;
      const { id } = params;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const contact = await this.contactService.getById(id, user.companyId);
      if (!contact) {
        res.status(404).json({ message: "Contact not found" });
        return;
      }
      res.json(contact);
    } catch (error) {
      console.error("Error getting contact:", error);
      res.status(500).json({
        message: "Failed to get contact",
        error: error.message
      });
    }
  }
  /**
   * Update an existing contact
   */
  async updateContact(req, res) {
    try {
      const { user, params, body } = req;
      const { id } = params;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const contactData = {
        ...body,
        companyId: user.companyId
      };
      const contact = await this.contactService.update(id, contactData, user.id);
      if (!contact) {
        res.status(404).json({ message: "Contact not found" });
        return;
      }
      res.json(contact);
    } catch (error) {
      console.error("Error updating contact:", error);
      res.status(500).json({
        message: "Failed to update contact",
        error: error.message
      });
    }
  }
  /**
   * Delete a contact
   */
  async deleteContact(req, res) {
    try {
      const { user, params } = req;
      const { id } = params;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const success = await this.contactService.delete(id, user.companyId, user.id);
      if (!success) {
        res.status(404).json({ message: "Contact not found" });
        return;
      }
      res.json({ message: "Contact deleted successfully" });
    } catch (error) {
      console.error("Error deleting contact:", error);
      res.status(500).json({
        message: "Failed to delete contact",
        error: error.message
      });
    }
  }
  /**
   * List contacts with filters
   */
  async listContacts(req, res) {
    try {
      const { user, query } = req;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const page = query.page ? parseInt(query.page, 10) : 1;
      const limit = query.limit ? parseInt(query.limit, 10) : 20;
      const searchTerm = query.search;
      const customerId = query.customerId;
      const isDecisionMaker = query.isDecisionMaker === "true";
      const isActive = query.isActive !== "false";
      const sortBy = query.sortBy;
      const sortDirection = query.sortDirection;
      const result = await this.contactService.list(user.companyId, {
        page,
        limit,
        searchTerm,
        customerId,
        isDecisionMaker: query.isDecisionMaker !== void 0 ? isDecisionMaker : void 0,
        isActive: query.isActive !== void 0 ? isActive : void 0,
        sortBy,
        sortDirection
      });
      res.json(result);
    } catch (error) {
      console.error("Error listing contacts:", error);
      res.status(500).json({
        message: "Failed to list contacts",
        error: error.message
      });
    }
  }
  /**
   * Get contacts for a customer
   */
  async getContactsByCustomer(req, res) {
    try {
      const { user, params } = req;
      const { customerId } = params;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const contacts3 = await this.contactService.getByCustomerId(customerId, user.companyId);
      res.json(contacts3);
    } catch (error) {
      console.error("Error getting customer contacts:", error);
      res.status(500).json({
        message: "Failed to get customer contacts",
        error: error.message
      });
    }
  }
};

// server/modules/crm/controllers/pipeline.controller.ts
init_auth_guard();
var PipelineController = class {
  constructor() {
    this.pipelineService = new PipelineService();
  }
  /**
   * Register all pipeline routes
   */
  registerRoutes(app2, jwtService2) {
    app2.post(
      "/api/crm/pipelines",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.createPipeline.bind(this)
    );
    app2.get(
      "/api/crm/pipelines/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getPipeline.bind(this)
    );
    app2.put(
      "/api/crm/pipelines/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.updatePipeline.bind(this)
    );
    app2.delete(
      "/api/crm/pipelines/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */]),
      this.deletePipeline.bind(this)
    );
    app2.get(
      "/api/crm/pipelines",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.listPipelines.bind(this)
    );
    app2.get(
      "/api/crm/pipelines/default",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getDefaultPipeline.bind(this)
    );
    app2.post(
      "/api/crm/pipelines/:pipelineId/stages",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.createStage.bind(this)
    );
    app2.put(
      "/api/crm/stages/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.updateStage.bind(this)
    );
    app2.delete(
      "/api/crm/stages/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */]),
      this.deleteStage.bind(this)
    );
    app2.get(
      "/api/crm/pipelines/:pipelineId/stages",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getStages.bind(this)
    );
    app2.put(
      "/api/crm/pipelines/:pipelineId/stages/reorder",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      this.reorderStages.bind(this)
    );
    app2.get(
      "/api/crm/stages",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */, "user" /* USER */]),
      this.getAllStages.bind(this)
    );
  }
  /**
   * Create a new pipeline
   */
  async createPipeline(req, res) {
    try {
      const { user, body } = req;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const pipelineData = {
        ...body,
        companyId: user.companyId
      };
      const pipeline = await this.pipelineService.createPipeline(pipelineData, user.id);
      res.status(201).json(pipeline);
    } catch (error) {
      console.error("Error creating pipeline:", error);
      res.status(500).json({
        message: "Failed to create pipeline",
        error: error.message
      });
    }
  }
  /**
   * Get a specific pipeline by ID
   */
  async getPipeline(req, res) {
    try {
      const { user, params } = req;
      const { id } = params;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const pipeline = await this.pipelineService.getPipelineById(id, user.companyId);
      if (!pipeline) {
        res.status(404).json({ message: "Pipeline not found" });
        return;
      }
      res.json(pipeline);
    } catch (error) {
      console.error("Error getting pipeline:", error);
      res.status(500).json({
        message: "Failed to get pipeline",
        error: error.message
      });
    }
  }
  /**
   * Update an existing pipeline
   */
  async updatePipeline(req, res) {
    try {
      const { user, params, body } = req;
      const { id } = params;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const pipelineData = {
        ...body,
        companyId: user.companyId
      };
      const pipeline = await this.pipelineService.updatePipeline(id, pipelineData, user.id);
      if (!pipeline) {
        res.status(404).json({ message: "Pipeline not found" });
        return;
      }
      res.json(pipeline);
    } catch (error) {
      console.error("Error updating pipeline:", error);
      res.status(500).json({
        message: "Failed to update pipeline",
        error: error.message
      });
    }
  }
  /**
   * Delete a pipeline
   */
  async deletePipeline(req, res) {
    try {
      const { user, params } = req;
      const { id } = params;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const success = await this.pipelineService.deletePipeline(id, user.companyId, user.id);
      if (!success) {
        res.status(404).json({ message: "Pipeline not found" });
        return;
      }
      res.json({ message: "Pipeline deleted successfully" });
    } catch (error) {
      console.error("Error deleting pipeline:", error);
      res.status(500).json({
        message: "Failed to delete pipeline",
        error: error.message
      });
    }
  }
  /**
   * List all pipelines
   */
  async listPipelines(req, res) {
    try {
      const { user, query } = req;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const includeInactive = query.includeInactive === "true";
      const pipelines2 = await this.pipelineService.getPipelines(user.companyId, includeInactive);
      res.json(pipelines2);
    } catch (error) {
      console.error("Error listing pipelines:", error);
      res.status(500).json({
        message: "Failed to list pipelines",
        error: error.message
      });
    }
  }
  /**
   * Get default pipeline
   */
  async getDefaultPipeline(req, res) {
    try {
      const { user } = req;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const pipeline = await this.pipelineService.getDefaultPipeline(user.companyId);
      if (!pipeline) {
        res.status(404).json({ message: "No default pipeline found" });
        return;
      }
      res.json(pipeline);
    } catch (error) {
      console.error("Error getting default pipeline:", error);
      res.status(500).json({
        message: "Failed to get default pipeline",
        error: error.message
      });
    }
  }
  /**
   * Create a pipeline stage
   */
  async createStage(req, res) {
    try {
      const { user, params, body } = req;
      const { pipelineId } = params;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const stageData = {
        ...body,
        pipelineId,
        companyId: user.companyId
      };
      const stage = await this.pipelineService.createStage(stageData, user.id);
      res.status(201).json(stage);
    } catch (error) {
      console.error("Error creating pipeline stage:", error);
      res.status(500).json({
        message: "Failed to create pipeline stage",
        error: error.message
      });
    }
  }
  /**
   * Update a pipeline stage
   */
  async updateStage(req, res) {
    try {
      const { user, params, body } = req;
      const { id } = params;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const stageData = {
        ...body,
        companyId: user.companyId
      };
      const stage = await this.pipelineService.updateStage(id, stageData, user.id);
      if (!stage) {
        res.status(404).json({ message: "Stage not found" });
        return;
      }
      res.json(stage);
    } catch (error) {
      console.error("Error updating pipeline stage:", error);
      res.status(500).json({
        message: "Failed to update pipeline stage",
        error: error.message
      });
    }
  }
  /**
   * Delete a pipeline stage
   */
  async deleteStage(req, res) {
    try {
      const { user, params } = req;
      const { id } = params;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const success = await this.pipelineService.deleteStage(id, user.companyId, user.id);
      if (!success) {
        res.status(404).json({ message: "Stage not found" });
        return;
      }
      res.json({ message: "Stage deleted successfully" });
    } catch (error) {
      console.error("Error deleting pipeline stage:", error);
      res.status(500).json({
        message: "Failed to delete pipeline stage",
        error: error.message
      });
    }
  }
  /**
   * Get stages for a pipeline
   */
  async getStages(req, res) {
    try {
      const { user, params, query } = req;
      const { pipelineId } = params;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const includeInactive = query.includeInactive === "true";
      const stages = await this.pipelineService.getStages(pipelineId, user.companyId, includeInactive);
      res.json(stages);
    } catch (error) {
      console.error("Error getting pipeline stages:", error);
      res.status(500).json({
        message: "Failed to get pipeline stages",
        error: error.message
      });
    }
  }
  /**
   * Reorder pipeline stages
   */
  async reorderStages(req, res) {
    try {
      const { user, params, body } = req;
      const { pipelineId } = params;
      const { stageIds } = body;
      if (!user || !user.id || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      if (!Array.isArray(stageIds) || stageIds.length === 0) {
        res.status(400).json({ message: "Invalid stageIds array" });
        return;
      }
      const success = await this.pipelineService.reorderStages(pipelineId, user.companyId, stageIds, user.id);
      if (!success) {
        res.status(404).json({ message: "Failed to reorder stages" });
        return;
      }
      res.json({ message: "Stages reordered successfully" });
    } catch (error) {
      console.error("Error reordering pipeline stages:", error);
      res.status(500).json({
        message: "Failed to reorder pipeline stages",
        error: error.message
      });
    }
  }
  /**
   * Get all stages across all pipelines
   */
  async getAllStages(req, res) {
    try {
      const { user } = req;
      if (!user || !user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const stages = await this.pipelineService.getAllStages(user.companyId);
      res.json(stages);
    } catch (error) {
      console.error("Error getting all stages:", error);
      res.status(500).json({
        message: "Failed to get all stages",
        error: error.message
      });
    }
  }
};

// server/modules/crm/controllers/company.controller.ts
init_drizzle_service();
init_auth_guard();
init_crm_schema();
import { sql as sql25 } from "drizzle-orm";
var CompanyController = class {
  constructor(db4) {
    this.jwtService = null;
    this.db = db4 || new DrizzleService();
    this.createCompany = this.createCompany.bind(this);
    this.getCompany = this.getCompany.bind(this);
    this.updateCompany = this.updateCompany.bind(this);
    this.deleteCompany = this.deleteCompany.bind(this);
    this.listCompanies = this.listCompanies.bind(this);
  }
  /**
   * Register routes
   */
  registerRoutes(app2, jwtService2) {
    if (jwtService2) {
      this.jwtService = jwtService2;
    }
    app2.post(
      "/api/crm/companies",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["sales_agent" /* SALES_AGENT */, "company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.createCompany
    );
    app2.get(
      "/api/crm/companies/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getCompany
    );
    app2.put(
      "/api/crm/companies/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["sales_agent" /* SALES_AGENT */, "company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.updateCompany
    );
    app2.delete(
      "/api/crm/companies/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.deleteCompany
    );
    app2.get(
      "/api/crm/companies",
      AuthGuard.protect("required" /* REQUIRED */),
      this.listCompanies
    );
  }
  /**
   * Find the next available analytic account number
   * @param prefix The prefix for the analytic account (401 or 4111)
   * @param companyId The company ID to search within
   */
  /**
   * Synchronize an analytic account between crm_companies and analytic_accounts table
   * @param code The analytic account code (401.x or 4111.x format)
   * @param companyName The company name to use for the analytic account name
   * @returns true if successful, false otherwise
   */
  async syncAnalyticAccount(code, companyName) {
    try {
      console.log(`[CompanyController] Syncing analytic account ${code} for company ${companyName}`);
      const existingAccount = await this.db.executeQuery(`
        SELECT * FROM analytic_accounts
        WHERE code = $1
        LIMIT 1
      `, [code]);
      if (existingAccount && existingAccount.length > 0) {
        console.log(`[CompanyController] Analytic account ${code} already exists in analytic_accounts`);
        return true;
      }
      const prefix = code.split(".")[0];
      const syntheticAccount = await this.db.executeQuery(`
        SELECT * FROM synthetic_accounts
        WHERE code = $1
        LIMIT 1
      `, [prefix]);
      if (!syntheticAccount || syntheticAccount.length === 0) {
        console.error(`[CompanyController] Could not find synthetic account with code ${prefix}`);
        return false;
      }
      const syntheticId = syntheticAccount[0].id;
      const accountFunction = syntheticAccount[0].accountFunction;
      const analyticAccountData = {
        code,
        name: `${companyName} - ${code}`,
        description: `Cont analitic pentru compania ${companyName}`,
        syntheticId,
        accountFunction,
        isActive: true
      };
      await this.db.executeQuery(`
        INSERT INTO analytic_accounts (code, name, description, synthetic_id, account_function, is_active)
        VALUES ($1, $2, $3, $4, $5, $6)
        ON CONFLICT (code) DO NOTHING
      `, [
        analyticAccountData.code,
        analyticAccountData.name,
        analyticAccountData.description,
        analyticAccountData.syntheticId,
        analyticAccountData.accountFunction,
        analyticAccountData.isActive
      ]);
      console.log(`[CompanyController] Successfully created analytic account ${code} in analytic_accounts`);
      return true;
    } catch (error) {
      console.error(`[CompanyController] Error syncing analytic account ${code}:`, error);
      return false;
    }
  }
  /**
   * Find the next available analytic account number and ensure it doesn't exist in either table
   * @param prefix The prefix for the analytic account (401 or 4111)
   * @param companyId The company ID to search within
   */
  async getNextAnalyticAccountNumber(prefix, companyId) {
    try {
      console.log(`[CompanyController] Finding next available ${prefix}.x account number`);
      const columnName = `analythic_${prefix}`;
      const query = `
        SELECT ${columnName} 
        FROM crm_companies 
        WHERE company_id = $1 
          AND ${columnName} IS NOT NULL 
          AND ${columnName} LIKE '${prefix}.%'
        ORDER BY ${columnName} DESC 
        LIMIT 1
      `;
      const result = await this.db.executeQuery(query, [companyId]);
      let nextNumber = 1;
      if (result && result.length > 0) {
        const lastAccount = result[0][columnName];
        if (lastAccount && typeof lastAccount === "string") {
          const parts = lastAccount.split(".");
          if (parts.length === 2) {
            const lastNumber = parseInt(parts[1], 10);
            if (!isNaN(lastNumber)) {
              nextNumber = lastNumber + 1;
            }
          }
        }
      }
      let isUnique = false;
      let candidateCode = "";
      while (!isUnique) {
        candidateCode = `${prefix}.${nextNumber}`;
        const existingAnalytic = await this.db.executeQuery(`
          SELECT * FROM analytic_accounts
          WHERE code = $1
          LIMIT 1
        `, [candidateCode]);
        if (existingAnalytic && existingAnalytic.length > 0) {
          nextNumber++;
        } else {
          isUnique = true;
        }
      }
      console.log(`[CompanyController] Next ${prefix}.x account number: ${candidateCode}`);
      return candidateCode;
    } catch (error) {
      console.error(`[CompanyController] Error finding next analytic account number for ${prefix}:`, error);
      return `${prefix}.1`;
    }
  }
  /**
   * Create a new company
   */
  async createCompany(req, res) {
    try {
      console.log("[CompanyController] Creating company:", req.body);
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!req.body.name) {
        return res.status(400).json({ message: "Company name is required" });
      }
      if (!req.body.fiscalCode) {
        return res.status(400).json({ message: "Fiscal code is required" });
      }
      if (!req.body.type) {
        return res.status(400).json({ message: "Company type is required" });
      }
      let cuiValue = "";
      if (req.body.cui) {
        cuiValue = req.body.cui.trim().toUpperCase();
        console.log(`[CompanyController] Using provided cui value: ${cuiValue}`);
      } else {
        cuiValue = req.body.fiscalCode || "";
        if (typeof cuiValue === "string") {
          cuiValue = cuiValue.trim().toUpperCase();
          if (req.body.vatPayer === true) {
            if (!cuiValue.startsWith("RO")) {
              cuiValue = `RO${cuiValue}`;
            }
          } else {
            if (cuiValue.startsWith("RO")) {
              cuiValue = cuiValue.substring(2);
            }
          }
        }
        console.log(`[CompanyController] Formatted fiscalCode to cui: ${cuiValue}`);
      }
      try {
        const existingCompany = await this.db.executeQuery(`
          SELECT * FROM crm_companies
          WHERE cui = $1 AND company_id = $2
          LIMIT 1
        `, [cuiValue, companyId]);
        if (existingCompany && existingCompany.length > 0) {
          return res.status(400).json({
            message: "Duplicate CUI detected",
            error: `A company with CUI ${cuiValue} already exists.`
          });
        }
      } catch (duplicateError) {
        console.error("[CompanyController] Error checking for duplicates:", duplicateError);
      }
      let analythic401Value = null;
      let analythic4111Value = null;
      if (req.body.isSupplier === true) {
        analythic401Value = await this.getNextAnalyticAccountNumber("401", companyId);
      }
      if (req.body.isCustomer === true) {
        analythic4111Value = await this.getNextAnalyticAccountNumber("4111", companyId);
      }
      const companyData = {
        name: req.body.name,
        description: req.body.notes || null,
        website: req.body.website || null,
        industry: req.body.industry || null,
        phone: req.body.phone || null,
        email: req.body.email || null,
        address: req.body.address || null,
        city: req.body.city || null,
        postalCode: req.body.postalCode || null,
        country: req.body.country || null,
        vatNumber: req.body.fiscalCode || null,
        registrationNumber: req.body.regNumber || null,
        cui: cuiValue,
        // Add the formatted CUI value
        companyId,
        status: req.body.isActive ? "active" : "inactive",
        customFields: {
          street: req.body.street || null,
          streetNumber: req.body.streetNumber || null,
          addressDetails: req.body.addressDetails || null,
          county: req.body.county || null,
          vatPayer: req.body.vatPayer || false,
          vatIncasare: req.body.vatIncasare || false,
          isSupplier: req.body.isSupplier || false,
          isCustomer: req.body.isCustomer || true,
          contactPerson: req.body.contactPerson || null,
          leadScore: req.body.leadScore || 50,
          bankAccount: req.body.bankAccount || null,
          bank: req.body.bank || null,
          socialCapital: req.body.socialCapital ? Number(req.body.socialCapital) : null,
          type: req.body.type || "lead"
        },
        isCustomer: req.body.isCustomer || true,
        isSupplier: req.body.isSupplier || false,
        analythic_401: analythic401Value,
        analythic_4111: analythic4111Value,
        createdBy: userId,
        updatedBy: userId
      };
      console.log("[CompanyController] Inserting company data:", companyData);
      try {
        const result = await this.db.insert(crm_companies).values(companyData).returning();
        console.log("[CompanyController] Insert result:", result);
        if (analythic401Value) {
          await this.syncAnalyticAccount(analythic401Value, companyData.name);
        }
        if (analythic4111Value) {
          await this.syncAnalyticAccount(analythic4111Value, companyData.name);
        }
        return res.status(201).json(result[0]);
      } catch (insertError) {
        console.error("[CompanyController] Database insertion error:", insertError);
        return res.status(500).json({
          message: "Failed to insert company data",
          error: insertError.message
        });
      }
    } catch (error) {
      console.error("[CompanyController] Error creating company:", error);
      return res.status(500).json({ message: "Failed to create company", error: error.message });
    }
  }
  /**
   * Get a company by ID
   */
  async getCompany(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      console.log(`[CompanyController] Getting company by id: ${id} for companyId: ${companyId}`);
      try {
        const company = await this.db.query.crm_companies.findFirst({
          where: (companies3, { eq: eq89, and: and74 }) => and74(
            eq89(companies3.id, id),
            eq89(companies3.companyId, companyId)
          )
        });
        if (!company) {
          return res.status(404).json({ message: "Company not found" });
        }
        return res.json(company);
      } catch (queryError) {
        console.error("[CompanyController] Error querying company:", queryError);
        throw queryError;
      }
    } catch (error) {
      console.error("[CompanyController] Error getting company:", error);
      return res.status(500).json({ message: "Failed to get company", error: error.message });
    }
  }
  /**
   * Update a company
   */
  async updateCompany(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      console.log(`[CompanyController] Checking if company exists: ${id} for companyId: ${companyId}`);
      let existingCompany;
      try {
        existingCompany = await this.db.query.crm_companies.findFirst({
          where: (companies3, { eq: eq89, and: and74 }) => and74(
            eq89(companies3.id, id),
            eq89(companies3.companyId, companyId)
          )
        });
        console.log("[CompanyController] Found existing company:", existingCompany ? "yes" : "no");
        if (!existingCompany) {
          return res.status(404).json({ message: "Company not found" });
        }
        const updateData = {
          updatedBy: userId,
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (req.body.cui !== void 0 || req.body.fiscalCode || req.body.vatPayer !== void 0) {
          let cuiValue;
          if (req.body.cui) {
            cuiValue = req.body.cui.trim().toUpperCase();
            console.log(`[CompanyController] Using provided cui value for update: ${cuiValue}`);
          } else if (req.body.fiscalCode || req.body.vatPayer !== void 0) {
            cuiValue = req.body.fiscalCode || existingCompany.vat_number || existingCompany.cui || "";
            if (typeof cuiValue === "string") {
              cuiValue = cuiValue.trim().toUpperCase();
              const vatPayer = req.body.vatPayer !== void 0 ? req.body.vatPayer : existingCompany.customFields?.vatPayer || false;
              if (vatPayer === true) {
                if (!cuiValue.startsWith("RO")) {
                  cuiValue = `RO${cuiValue}`;
                }
              } else {
                if (cuiValue.startsWith("RO")) {
                  cuiValue = cuiValue.substring(2);
                }
              }
              console.log(`[CompanyController] Formatted fiscalCode to cui for update: ${cuiValue}`);
            }
          }
          if (cuiValue && cuiValue !== existingCompany.cui) {
            try {
              const existingCompanyWithCui = await this.db.select().from(crm_companies).where(sql25`cui = ${cuiValue} AND company_id = ${companyId} AND id <> ${id}`).limit(1);
              if (existingCompanyWithCui && existingCompanyWithCui.length > 0) {
                return res.status(400).json({
                  message: "Duplicate CUI detected",
                  error: `A company with CUI ${cuiValue} already exists.`
                });
              }
            } catch (duplicateError) {
              console.error("[CompanyController] Error checking for duplicates:", duplicateError);
            }
          }
          if (cuiValue) {
            updateData.cui = cuiValue;
          }
        }
        if (req.body.name) updateData.name = req.body.name;
        if (req.body.notes) updateData.description = req.body.notes;
        if (req.body.website) updateData.website = req.body.website;
        if (req.body.industry) updateData.industry = req.body.industry;
        if (req.body.phone) updateData.phone = req.body.phone;
        if (req.body.email) updateData.email = req.body.email;
        if (req.body.address) updateData.address = req.body.address;
        if (req.body.city) updateData.city = req.body.city;
        if (req.body.postalCode) updateData.postalCode = req.body.postalCode;
        if (req.body.country) updateData.country = req.body.country;
        if (req.body.fiscalCode) updateData.vat_number = req.body.fiscalCode;
        if (req.body.regNumber) updateData.registrationNumber = req.body.regNumber;
        if (req.body.isActive !== void 0) updateData.status = req.body.isActive ? "active" : "inactive";
        const currentCustomFields = existingCompany.customFields || {};
        const updatedCustomFields = { ...currentCustomFields };
        if (req.body.street !== void 0) updatedCustomFields.street = req.body.street;
        if (req.body.streetNumber !== void 0) updatedCustomFields.streetNumber = req.body.streetNumber;
        if (req.body.addressDetails !== void 0) updatedCustomFields.addressDetails = req.body.addressDetails;
        if (req.body.county !== void 0) updatedCustomFields.county = req.body.county;
        if (req.body.vatPayer !== void 0) updatedCustomFields.vatPayer = req.body.vatPayer;
        if (req.body.vatIncasare !== void 0) updatedCustomFields.vatIncasare = req.body.vatIncasare;
        if (req.body.isSupplier !== void 0) updatedCustomFields.isSupplier = req.body.isSupplier;
        if (req.body.isCustomer !== void 0) updatedCustomFields.isCustomer = req.body.isCustomer;
        if (req.body.contactPerson !== void 0) updatedCustomFields.contactPerson = req.body.contactPerson;
        if (req.body.leadScore !== void 0) updatedCustomFields.leadScore = req.body.leadScore;
        if (req.body.bankAccount !== void 0) updatedCustomFields.bankAccount = req.body.bankAccount;
        if (req.body.bank !== void 0) updatedCustomFields.bank = req.body.bank;
        if (req.body.socialCapital !== void 0) updatedCustomFields.socialCapital = req.body.socialCapital ? Number(req.body.socialCapital) : null;
        if (req.body.type !== void 0) updatedCustomFields.type = req.body.type;
        updateData.customFields = updatedCustomFields;
        const wasCustomer = existingCompany.isCustomer || existingCompany.customFields && existingCompany.customFields.isCustomer;
        const wasSupplier = existingCompany.isSupplier || existingCompany.customFields && existingCompany.customFields.isSupplier;
        if (req.body.isCustomer !== void 0) {
          if (existingCompany.analythic_4111 && req.body.isCustomer === false) {
            console.log(`[CompanyController] Cannot change customer status for company with analytic account: ${existingCompany.analythic_4111}`);
            return res.status(403).json({
              message: "Nu se poate schimba statusul de client",
              error: "Companiile cu conturi analitice de client (4111.x) nu pot fi modificate \xEEn non-client."
            });
          }
          updateData.isCustomer = req.body.isCustomer;
          updatedCustomFields.isCustomer = req.body.isCustomer;
          if (req.body.isCustomer === true && (!existingCompany.analythic_4111 || !wasCustomer)) {
            updateData.analythic_4111 = await this.getNextAnalyticAccountNumber("4111", companyId);
            console.log(`[CompanyController] Created new analytic account for customer: ${updateData.analythic_4111}`);
            updateData._needSyncAnalytic4111 = true;
          }
        }
        if (req.body.isSupplier !== void 0) {
          if (existingCompany.analythic_401 && req.body.isSupplier === false) {
            console.log(`[CompanyController] Cannot change supplier status for company with analytic account: ${existingCompany.analythic_401}`);
            return res.status(403).json({
              message: "Nu se poate schimba statusul de furnizor",
              error: "Companiile cu conturi analitice de furnizor (401.x) nu pot fi modificate \xEEn non-furnizor."
            });
          }
          updateData.isSupplier = req.body.isSupplier;
          updatedCustomFields.isSupplier = req.body.isSupplier;
          if (req.body.isSupplier === true && (!existingCompany.analythic_401 || !wasSupplier)) {
            updateData.analythic_401 = await this.getNextAnalyticAccountNumber("401", companyId);
            console.log(`[CompanyController] Created new analytic account for supplier: ${updateData.analythic_401}`);
            updateData._needSyncAnalytic401 = true;
          }
        }
        console.log("[CompanyController] Updating company with data:", updateData);
        const result = await this.db.update(crm_companies).set(updateData).where(sql25`id = ${id} AND company_id = ${companyId}`).returning();
        console.log("[CompanyController] Update result:", result);
        if (!result || result.length === 0) {
          return res.status(404).json({ message: "Company update failed - no records affected" });
        }
        const updatedCompany = result[0];
        if (updateData._needSyncAnalytic4111 && updatedCompany.analythic_4111) {
          await this.syncAnalyticAccount(updatedCompany.analythic_4111, updatedCompany.name);
        }
        if (updateData._needSyncAnalytic401 && updatedCompany.analythic_401) {
          await this.syncAnalyticAccount(updatedCompany.analythic_401, updatedCompany.name);
        }
        return res.json(updatedCompany);
      } catch (queryError) {
        console.error("[CompanyController] Error during company operation:", queryError);
        throw queryError;
      }
    } catch (error) {
      console.error("[CompanyController] Error updating company:", error);
      return res.status(500).json({ message: "Failed to update company", error: error.message });
    }
  }
  /**
   * Delete a company
   */
  async deleteCompany(req, res) {
    try {
      const { id } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      console.log(`[CompanyController] Deleting company: ${id} for companyId: ${companyId}`);
      try {
        const existingCompany = await this.db.select().from(crm_companies).where(sql25`id = ${id} AND company_id = ${companyId}`).limit(1);
        if (!existingCompany || existingCompany.length === 0) {
          return res.status(404).json({ message: "Company not found" });
        }
        if (existingCompany[0].analythic_401 || existingCompany[0].analythic_4111) {
          return res.status(403).json({
            message: "Nu poate fi \u0219tears\u0103 aceast\u0103 companie",
            error: "Companiile cu conturi analitice (client/furnizor) nu pot fi \u0219terse din sistem."
          });
        }
        const result = await this.db.delete(crm_companies).where(sql25`id = ${id} AND company_id = ${companyId}`).returning();
        console.log("[CompanyController] Delete result:", result);
        if (!result || result.length === 0) {
          return res.status(404).json({ message: "Company not found" });
        }
        return res.json({ message: "Company deleted successfully" });
      } catch (deleteError) {
        console.error("[CompanyController] Error during delete operation:", deleteError);
        throw deleteError;
      }
    } catch (error) {
      console.error("[CompanyController] Error deleting company:", error);
      return res.status(500).json({ message: "Failed to delete company", error: error.message });
    }
  }
  /**
   * List companies with filtering and pagination
   */
  async listCompanies(req, res) {
    try {
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const {
        page = "1",
        limit = "20",
        searchTerm,
        type,
        status,
        sortBy = "created_at",
        sortDirection = "desc",
        isCustomer
      } = req.query;
      const pageNumber = parseInt(page, 10);
      const limitNumber = parseInt(limit, 10);
      const offset = (pageNumber - 1) * limitNumber;
      console.log("[CompanyController] Listing companies for companyId:", companyId);
      try {
        let sqlQuery = `
          SELECT * FROM crm_companies 
          WHERE company_id = $1
        `;
        const params = [companyId];
        let paramIndex = 2;
        if (searchTerm && typeof searchTerm === "string") {
          const searchString = `%${searchTerm}%`;
          sqlQuery += ` AND (name ILIKE $${paramIndex} OR vat_number ILIKE $${paramIndex} OR cui ILIKE $${paramIndex})`;
          params.push(searchString);
          paramIndex++;
        }
        if (type && typeof type === "string") {
          sqlQuery += ` AND custom_fields->>'type' = $${paramIndex}`;
          params.push(type);
          paramIndex++;
        }
        if (status && typeof status === "string") {
          sqlQuery += ` AND status = $${paramIndex}`;
          params.push(status);
          paramIndex++;
        }
        if (isCustomer === "true") {
          sqlQuery += ` AND is_customer = true`;
        }
        if (sortBy && sortDirection) {
          if (typeof sortBy === "string" && sortBy.startsWith("customFields.")) {
            const fieldName = sortBy.split(".")[1];
            sqlQuery += ` ORDER BY custom_fields->'${fieldName}' ${sortDirection === "asc" ? "ASC" : "DESC"}`;
          } else {
            let sortCol = sortBy;
            if (sortCol === "createdAt") sortCol = "created_at";
            if (sortCol === "updatedAt") sortCol = "updated_at";
            if (sortCol === "companyId") sortCol = "company_id";
            if (sortCol === "vatNumber") sortCol = "vat_number";
            if (sortCol === "registrationNumber") sortCol = "registration_number";
            if (sortCol === "postalCode") sortCol = "postal_code";
            sqlQuery += ` ORDER BY ${sortCol} ${sortDirection === "asc" ? "ASC" : "DESC"}`;
          }
        }
        sqlQuery += ` LIMIT ${limitNumber} OFFSET ${offset}`;
        const companies3 = await this.db.executeQuery(sqlQuery, params);
        console.log(`[CompanyController] Found ${companies3.length} companies`);
        let countQuery = `
          SELECT COUNT(*) FROM crm_companies 
          WHERE company_id = $1
        `;
        const countParams = [companyId];
        let countParamIndex = 2;
        if (searchTerm && typeof searchTerm === "string") {
          const searchString = `%${searchTerm}%`;
          countQuery += ` AND (name ILIKE $${countParamIndex} OR vat_number ILIKE $${countParamIndex} OR cui ILIKE $${countParamIndex})`;
          countParams.push(searchString);
          countParamIndex++;
        }
        if (type && typeof type === "string") {
          countQuery += ` AND custom_fields->>'type' = $${countParamIndex}`;
          countParams.push(type);
          countParamIndex++;
        }
        if (status && typeof status === "string") {
          countQuery += ` AND status = $${countParamIndex}`;
          countParams.push(status);
          countParamIndex++;
        }
        if (isCustomer === "true") {
          countQuery += ` AND is_customer = true`;
        }
        const totalResult = await this.db.executeQuery(countQuery, countParams);
        console.log("[CompanyController] Total count result:", totalResult);
        const total = parseInt(totalResult[0].count, 10);
        return res.json({
          data: companies3,
          meta: {
            total,
            page: pageNumber,
            limit: limitNumber,
            totalPages: Math.ceil(total / limitNumber)
          }
        });
      } catch (queryError) {
        console.error("[CompanyController] Error during list operation:", queryError);
        throw queryError;
      }
    } catch (error) {
      console.error("[CompanyController] Error listing companies:", error);
      return res.status(500).json({ message: "Failed to list companies", error: error.message });
    }
  }
};

// server/modules/crm/utils/validators.ts
function validateCui(cui) {
  if (cui === null || cui === void 0) return null;
  try {
    const cuiStr = String(cui);
    const cleanCui = cuiStr.trim().toUpperCase();
    const noPrefixCui = cleanCui.startsWith("RO") ? cleanCui.substring(2) : cleanCui;
    if (!/^\d+$/.test(noPrefixCui)) {
      return null;
    }
    if (noPrefixCui.length < 2) {
      return null;
    }
    return noPrefixCui;
  } catch (error) {
    console.error("Eroare la validarea CUI:", error);
    return null;
  }
}

// server/modules/crm/controllers/anaf.controller.ts
init_audit_service();

// server/modules/crm/services/anaf.service.ts
import axios2 from "axios";
var ANAF_API_URL = "https://webservicesp.anaf.ro/api/PlatitorTvaRest/v9/tva";
var AnafService = class {
  /**
   * Interoghează API-ul ANAF pentru a obține informații despre companii
   * 
   * @param cuiList Lista de CUI-uri pentru care se doresc informații
   * @returns Răspunsul de la ANAF cu datele companiilor
   */
  async queryAnaf(cuiList) {
    try {
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const requestData = cuiList.map((cui) => {
        const cleanCui = cui.replace(/^RO/i, "").trim();
        return {
          cui: cleanCui,
          data: today
        };
      });
      console.log(`[AnafService] \u{1F50D} Interogare ANAF pentru CUI-uri:`, cuiList);
      console.log(`[AnafService] \u{1F50D} Interogare ANAF pentru ${cuiList.length} CUI-uri:`, cuiList);
      console.log(`[AnafService] \u{1F4DD} Request data trimis c\u0103tre ANAF:`, JSON.stringify(requestData));
      const response = await axios2.post(ANAF_API_URL, requestData, {
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json"
        },
        timeout: 3e4,
        // 30 secunde timeout pentru a permite răspunsuri mai lente
        maxContentLength: 10 * 1024 * 1024
        // 10 MB maxim pentru răspuns
      });
      console.log(`[AnafService] \u{1F4E5} R\u0103spuns ANAF primit: Status ${response.status}`);
      let responseData = response.data;
      console.log(`[AnafService] \u{1F504} Tip date r\u0103spuns: ${typeof responseData}`);
      if (typeof responseData === "object") {
        console.log(`[AnafService] \u{1F4CB} Structura r\u0103spunsului:`, Object.keys(responseData));
      } else if (typeof responseData === "string") {
        console.log(`[AnafService] \u{1F4DD} Lungime string r\u0103spuns: ${responseData.length} caractere`);
        console.log(
          `[AnafService] \u{1F4DD} Exemplu r\u0103spuns (primele 200 caractere):`,
          responseData.substring(0, 200)
        );
        try {
          responseData = JSON.parse(responseData);
          console.log("[AnafService] \u2705 R\u0103spunsul a fost parsat cu succes din string \xEEn JSON");
          console.log("[AnafService] \u{1F4CB} Structura r\u0103spunsului parsat:", Object.keys(responseData));
        } catch (parseError) {
          console.error("[AnafService] \u274C R\u0103spunsul nu este un JSON valid:", parseError.message);
          const contentStart = responseData.substring(0, 20).toLowerCase();
          if (contentStart.includes("<!doctype") || contentStart.includes("<html")) {
            console.error("[AnafService] \u26A0\uFE0F R\u0103spunsul pare s\u0103 fie HTML \xEEn loc de JSON!");
          }
          return {
            cod: 500,
            message: `Eroare la parsarea r\u0103spunsului: ${parseError.message}`,
            found: [],
            notFound: cuiList
          };
        }
      }
      const found = Array.isArray(responseData.found) ? responseData.found : [];
      const notFound = Array.isArray(responseData.notFound) ? responseData.notFound : [];
      console.log(`[AnafService] \u2705 R\u0103spuns ANAF procesat cu succes: ${found.length} companii g\u0103site, ${notFound.length} neg\u0103site`);
      const processedCuis = [...found.map((company) => company.date_generale?.cui), ...notFound].filter(Boolean);
      const missingCuis = cuiList.filter((cui) => {
        const cleanCui = cui.replace(/^RO/i, "").trim();
        return !processedCuis.includes(cleanCui);
      });
      if (missingCuis.length > 0) {
        console.log(`[AnafService] \u26A0\uFE0F Aten\u021Bie! Urm\u0103toarele CUI-uri nu apar nici \xEEn found, nici \xEEn notFound:`, missingCuis);
      }
      return {
        cod: responseData.cod || 200,
        message: responseData.message || "Succes",
        found,
        notFound
      };
    } catch (error) {
      console.error(`[AnafService] \u274C Eroare la interogarea ANAF:`, error);
      if (error.code) {
        console.error(`[AnafService] Cod eroare: ${error.code}`);
      }
      if (error.response) {
        console.error(`[AnafService] Status: ${error.response.status}`);
        console.error(`[AnafService] Headers:`, error.response.headers);
        console.error(`[AnafService] Data:`, error.response.data);
      }
      if (error.response) {
        const statusCode = error.response.status;
        const responseData = error.response.data;
        console.error(`[AnafService] Eroare HTTP ${statusCode} de la ANAF`);
        console.error(`[AnafService] Detalii r\u0103spuns:`, responseData);
        throw new Error(`Eroare ANAF ${statusCode}: ${responseData?.message || error.message}`);
      } else if (error.request) {
        console.error(`[AnafService] Nu s-a primit r\u0103spuns de la ANAF`);
        console.error(`[AnafService] Detalii request:`, error.request);
        throw new Error(`F\u0103r\u0103 r\u0103spuns de la ANAF: ${error.message}`);
      } else {
        console.error(`[AnafService] Eroare general\u0103:`, error.message, error.stack);
        throw new Error(`Eroare la interogarea ANAF: ${error.message}`);
      }
    }
  }
  /**
   * Interoghează API-ul ANAF pentru a obține informații despre o singură companie
   * 
   * @param cui Codul fiscal al companiei (cu sau fără RO)
   * @returns Datele companiei sau null dacă nu a fost găsită
   */
  /**
   * Obține informații despre companie doar de la API-ul V9 (cel mai recent)
   * Această metodă este folosită de endpoint-ul public de verificare
   * 
   * @param cui Codul fiscal al companiei
   * @returns Datele companiei sau null dacă nu a fost găsită
   */
  async getCompanyInfoFromV9(cui) {
    try {
      const cleanCui = cui.replace(/^RO/i, "").trim();
      console.log(`[AnafService] \u{1F50D} Verificare companie pentru CUI ${cleanCui} (API V9)`);
      const response = await this.queryAnaf([cui]);
      if (response.found && response.found.length > 0) {
        console.log(`[AnafService] \u2705 Date g\u0103site pentru CUI ${cleanCui} \xEEn API V9`);
        return response.found[0];
      }
      console.log(`[AnafService] \u26A0\uFE0F Compania cu CUI ${cleanCui} nu a fost g\u0103sit\u0103 \xEEn API V9`);
      return null;
    } catch (error) {
      console.error(`[AnafService] \u274C Eroare la ob\u021Binerea datelor companiei din V9:`, error);
      return null;
    }
  }
  /**
   * Interoghează API-ul ANAF pentru a obține informații despre o singură companie
   * Folosește atât V9 cât și V8 cu fallback automat
   * 
   * @param cui Codul fiscal al companiei (cu sau fără RO)
   * @returns Datele companiei sau null dacă nu a fost găsită
   */
  async getCompanyData(cui) {
    try {
      const cleanCui = cui.replace(/^RO/i, "").trim();
      console.log(`[AnafService] \u{1F50D} Ob\u021Binere date pentru CUI ${cleanCui}`);
      try {
        console.log(`[AnafService] \u{1F504} \xCEncercare API ANAF V9 pentru CUI ${cleanCui}`);
        const response = await this.queryAnaf([cui]);
        if (response.found && response.found.length > 0) {
          console.log(`[AnafService] \u2705 Date g\u0103site pentru CUI ${cleanCui} \xEEn API V9`);
          return response.found[0];
        }
        console.log(`[AnafService] \u26A0\uFE0F Date neg\u0103site \xEEn API V9 pentru CUI ${cleanCui}, vom \xEEncerca V8`);
      } catch (v9Error) {
        console.error(`[AnafService] \u274C Eroare la API V9 pentru CUI ${cleanCui}:`, v9Error);
        console.log(`[AnafService] Continu\u0103m cu metoda alternativ\u0103 V8`);
      }
      try {
        const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        const ANAF_API_V8_URL = "https://webservicesp.anaf.ro/PlatitorTvaRest/api/v8/ws/tva";
        console.log(`[AnafService] \u{1F504} \xCEncercare API ANAF V8 pentru CUI ${cleanCui} (fallback)`);
        const requestData = [{
          cui: cleanCui,
          data: today
        }];
        const response = await axios2.post(ANAF_API_V8_URL, requestData, {
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          timeout: 3e4
        });
        console.log(`[AnafService] \u2705 R\u0103spuns V8 primit cu succes: Status ${response.status}`);
        let responseData = response.data;
        if (typeof responseData === "string") {
          responseData = JSON.parse(responseData);
        }
        if (responseData.found && responseData.found.length > 0) {
          console.log(`[AnafService] \u2705 Date g\u0103site pentru CUI ${cleanCui} \xEEn API V8 (fallback)`);
          return responseData.found[0];
        }
      } catch (v8Error) {
        console.error(`[AnafService] \u274C Eroare la API V8 pentru CUI ${cleanCui}:`, v8Error);
      }
      console.log(`[AnafService] \u274C Nu s-au g\u0103sit date pentru CUI ${cleanCui} \xEEn niciun API`);
      return null;
    } catch (error) {
      console.error(`[AnafService] \u274C Eroare la ob\u021Binerea datelor companiei:`, error);
      throw error;
    }
  }
};
var anafService = new AnafService();

// server/modules/crm/services/anaf-queue_services/anaf-queue.service.ts
import { Queue, Worker } from "bullmq";
import Redis2 from "ioredis";

// server/modules/crm/services/anaf-queue_services/cache.service.ts
import Redis from "ioredis";
var AnafCacheService = class {
  /**
   * Constructor pentru AnafCacheService
   * 
   * @param config Configurația pentru cache
   * @param redisInstance O instanță Redis opțională (dacă nu este furnizată, se va crea una)
   */
  constructor(config3, redisInstance) {
    if (redisInstance) {
      this.redis = redisInstance;
      console.log("[AnafCacheService] Utilizare instan\u021B\u0103 Redis partajat\u0103");
    } else {
      console.log("[AnafCacheService] Cre\u0103m o nou\u0103 instan\u021B\u0103 Redis pentru cache");
      const host = process.env.REDIS_HOST || "localhost";
      const port = parseInt(process.env.REDIS_PORT || "6379", 10);
      const username = process.env.REDIS_USERNAME || "";
      const password = process.env.REDIS_PASSWORD || "";
      const redisOptions = {
        host,
        port,
        username: username || void 0,
        password: password || void 0,
        maxRetriesPerRequest: null,
        // Obligatoriu pentru BullMQ
        enableReadyCheck: false,
        // Dezactivează verificări care pot cauza probleme
        retryStrategy: (times) => {
          if (times > 3) return null;
          return Math.min(times * 500, 3e3);
        }
      };
      console.log(`[AnafCacheService] Conectare la Redis: ${host}:${port}`);
      this.redis = new Redis(redisOptions);
      this.redis.on("error", (err) => {
        console.error("[AnafCacheService] Eroare Redis:", err.message);
      });
    }
    this.cacheTime = config3.cacheTimeoutSec;
    this.prefix = "anaf:company:";
  }
  /**
   * Obține o înregistrare din cache
   * 
   * @param cui CUI-ul companiei
   * @returns Date despre companie sau null dacă nu există
   */
  async get(cui) {
    try {
      const key = this.getKey(cui);
      const data = await this.redis.get(key);
      if (!data) {
        return null;
      }
      return JSON.parse(data);
    } catch (error) {
      console.error(`[AnafCacheService] Eroare la ob\u021Binerea datelor din cache pentru CUI ${cui}:`, error);
      return null;
    }
  }
  /**
   * Salvează o înregistrare în cache
   * 
   * @param cui CUI-ul companiei 
   * @param data Datele companiei
   * @returns true dacă operațiunea a reușit, false altfel
   */
  async set(cui, data) {
    try {
      const key = this.getKey(cui);
      const serializedData = JSON.stringify(data);
      const setResult = await this.redis.set(key, serializedData, "EX", this.cacheTime);
      return setResult === "OK";
    } catch (error) {
      console.error(`[AnafCacheService] Eroare la salvarea datelor \xEEn cache pentru CUI ${cui}:`, error);
      return false;
    }
  }
  /**
   * Șterge o înregistrare din cache
   * 
   * @param cui CUI-ul companiei
   * @returns true dacă operațiunea a reușit, false altfel
   */
  async delete(cui) {
    try {
      const key = this.getKey(cui);
      const delResult = await this.redis.del(key);
      return delResult > 0;
    } catch (error) {
      console.error(`[AnafCacheService] Eroare la \u0219tergerea datelor din cache pentru CUI ${cui}:`, error);
      return false;
    }
  }
  /**
   * Obține cheia pentru cache
   * 
   * @param cui CUI-ul companiei
   * @returns Cheia pentru Redis
   */
  getKey(cui) {
    return `${this.prefix}${cui}`;
  }
  /**
   * Închide conexiunea Redis
   */
  async close() {
    try {
      await this.redis.quit();
    } catch (error) {
      console.error("[AnafCacheService] Eroare la \xEEnchiderea conexiunii Redis:", error);
    }
  }
};

// server/modules/crm/services/anaf-queue_services/database.service.ts
init_db();
init_crm_schema();
import { eq as eq34, sql as sql26 } from "drizzle-orm";
var db = getDrizzleInstance();
var AnafDatabaseService = class {
  /**
   * Obține datele unei companii după CUI
   * 
   * @param cui CUI-ul companiei
   * @returns Datele companiei din API-ul ANAF sau null dacă nu există
   */
  async getCompanyData(cui) {
    try {
      const normalizedCui = typeof cui === "string" ? cui.replace(/^RO/i, "").replace(/[^0-9]/g, "") : String(cui).replace(/^RO/i, "").replace(/[^0-9]/g, "");
      console.log(`[AnafDatabaseService] \u{1F50D} C\u0103utare date \xEEn DB pentru CUI ${normalizedCui}`);
      const result = await db.select().from(anafCompanyData).where(eq34(anafCompanyData.cui, normalizedCui)).limit(1);
      if (result.length > 0) {
        const companyData = result[0];
        console.log(`[AnafDatabaseService] \u2705 Date g\u0103site \xEEn DB pentru CUI ${normalizedCui}`);
        if (companyData.rawResponse) {
          try {
            const parsedData = typeof companyData.rawResponse === "string" ? JSON.parse(companyData.rawResponse) : companyData.rawResponse;
            console.log(`[AnafDatabaseService] \u2705 Returnare date din DB pentru CUI ${normalizedCui}`);
            return parsedData;
          } catch (error) {
            console.error(`[AnafDatabaseService] Eroare la parsarea datelor pentru CUI ${normalizedCui}:`, error);
            return null;
          }
        } else {
          console.error(`[AnafDatabaseService] Lips\u0103 c\xE2mp rawResponse pentru CUI ${normalizedCui}`);
        }
      } else {
        console.log(`[AnafDatabaseService] \u274C Nu s-au g\u0103sit date \xEEn DB pentru CUI ${normalizedCui}`);
      }
      return null;
    } catch (error) {
      console.error(`[AnafDatabaseService] Eroare la ob\u021Binerea datelor pentru CUI ${cui}:`, error);
      return null;
    }
  }
  /**
   * Salvează datele unei companii
   * 
   * @param cui CUI-ul companiei
   * @param data Datele companiei
   * @returns true dacă operațiunea a reușit, false altfel
   */
  async saveCompanyData(cui, data) {
    try {
      const normalizedCui = typeof cui === "string" ? cui.replace(/^RO/i, "").replace(/[^0-9]/g, "") : String(cui).replace(/^RO/i, "").replace(/[^0-9]/g, "");
      const companyData = data.date_generale || {};
      const inactivStatus = data.stare_inactiv || {};
      const rTvaiData = data.inregistrare_RTVAI || {};
      const sediuSocialData = data.adresa_sediu_social || {};
      const splitTvaData = data.inregistrare_SplitTVA || {};
      const scopTva = data.inregistrare_scop_Tva || {};
      const domFiscalData = data.adresa_domiciliu_fiscal || {};
      const denumire = companyData.denumire;
      const adresa = companyData.adresa;
      const nrRegCom = companyData.nrRegCom;
      if (!denumire) {
        console.warn(`[AnafDatabaseService] \u26A0\uFE0F Lips\u0103 denumire \xEEn datele ANAF pentru CUI ${normalizedCui}`);
      }
      let perioade_tva = [];
      if (scopTva.perioade_TVA && Array.isArray(scopTva.perioade_TVA)) {
        perioade_tva = scopTva.perioade_TVA;
      }
      let data_inceput_scp_tva = null;
      let data_sfarsit_scp_tva = null;
      let data_anul_imp_scp_tva = null;
      let mesaj_scp_tva = null;
      if (scopTva.perioade_TVA && Array.isArray(scopTva.perioade_TVA) && scopTva.perioade_TVA.length > 0) {
        const lastPeriod = scopTva.perioade_TVA[0];
        data_inceput_scp_tva = lastPeriod.data_inceput_ScpTVA || null;
        data_sfarsit_scp_tva = lastPeriod.data_sfarsit_ScpTVA || null;
        data_anul_imp_scp_tva = lastPeriod.data_anul_imp_ScpTVA || null;
        mesaj_scp_tva = lastPeriod.mesaj_ScpTVA || null;
      }
      console.log(`[AnafDatabaseService] \u{1F504} Salvare date ANAF pentru CUI ${normalizedCui} (${denumire || "f\u0103r\u0103 denumire"})`);
      const currentDate = (/* @__PURE__ */ new Date()).toISOString();
      await db.execute(sql26`
        INSERT INTO anaf_company_data (
          cui, 
          data_interogare,
          denumire,
          adresa, 
          nr_reg_com,
          telefon, 
          fax, 
          cod_postal,
          act,
          stare_inregistrare,
          data_inregistrare,
          cod_caen,
          iban,
          status_ro_e_factura,
          organ_fiscal_competent,
          forma_de_proprietate,
          forma_organizare,
          forma_juridica,
          
          /* Date TVA */
          scp_tva,
          data_inceput_scp_tva,
          data_sfarsit_scp_tva,
          data_anul_imp_scp_tva,
          mesaj_scp_tva,
          
          /* Date TVA la încasare */
          data_inceput_tva_inc,
          data_sfarsit_tva_inc,
          data_actualizare_tva_inc,
          data_publicare_tva_inc,
          tip_act_tva_inc,
          status_tva_incasare,
          
          /* Date inactive */
          data_inactivare,
          data_reactivare,
          data_publicare,
          data_radiere,
          status_inactivi,
          
          /* Date split TVA */
          data_inceput_split_tva,
          data_anulare_split_tva,
          status_split_tva,
          
          /* Date sediu social */
          ss_denumire_strada,
          ss_numar_strada,
          ss_denumire_localitate,
          ss_cod_localitate,
          ss_denumire_judet,
          ss_cod_judet,
          ss_cod_judet_auto,
          ss_tara,
          ss_detalii_adresa,
          ss_cod_postal,
          
          /* Date domiciliu fiscal */
          df_denumire_strada,
          df_numar_strada,
          df_denumire_localitate,
          df_cod_localitate,
          df_denumire_judet,
          df_cod_judet,
          df_cod_judet_auto,
          df_tara,
          df_detalii_adresa,
          df_cod_postal,
          
          /* Date sistem */
          perioade_tva,
          raw_response,
          created_at,
          updated_at,
          last_checked_at,
          is_updated_from_anaf
        ) VALUES (
          ${normalizedCui},
          ${currentDate}::date,
          ${denumire || null},
          ${adresa || null},
          ${nrRegCom || null},
          ${companyData.telefon || null},
          ${companyData.fax || null},
          ${companyData.codPostal || null},
          ${companyData.act || null},
          ${companyData.stare_inregistrare || null},
          ${companyData.data_inregistrare || null},
          ${companyData.cod_CAEN || null},
          ${companyData.iban || null},
          ${companyData.statusRO_e_Factura || false},
          ${companyData.organFiscalCompetent || null},
          ${companyData.forma_de_proprietate || null},
          ${companyData.forma_organizare || null},
          ${companyData.forma_juridica || null},
          
          /* Date TVA */
          ${scopTva.scpTVA === true},
          ${data_inceput_scp_tva}::date,
          ${data_sfarsit_scp_tva}::date,
          ${data_anul_imp_scp_tva}::date,
          ${mesaj_scp_tva},
          
          /* Date TVA la încasare */
          ${rTvaiData.dataInceputTvaInc || null}::date,
          ${rTvaiData.dataSfarsitTvaInc || null}::date,
          ${rTvaiData.dataActualizareTvaInc || null}::date,
          ${rTvaiData.dataPublicareTvaInc || null}::date,
          ${rTvaiData.tipActTvaInc || null},
          ${rTvaiData.statusTvaIncasare === true},
          
          /* Date inactive */
          ${inactivStatus.dataInactivare || null}::date,
          ${inactivStatus.dataReactivare || null}::date,
          ${inactivStatus.dataPublicare || null}::date,
          ${inactivStatus.dataRadiere || null}::date,
          ${inactivStatus.statusInactivi === true},
          
          /* Date split TVA */
          ${splitTvaData.dataInceputSplitTVA || null}::date,
          ${splitTvaData.dataAnulareSplitTVA || null}::date,
          ${splitTvaData.statusSplitTVA === true},
          
          /* Date sediu social */
          ${sediuSocialData.sdenumire_Strada || null},
          ${sediuSocialData.snumar_Strada || null},
          ${sediuSocialData.sdenumire_Localitate || null},
          ${sediuSocialData.scod_Localitate || null},
          ${sediuSocialData.sdenumire_Judet || null},
          ${sediuSocialData.scod_Judet || null},
          ${sediuSocialData.scod_JudetAuto || null},
          ${sediuSocialData.stara || null},
          ${sediuSocialData.sdetalii_Adresa || null},
          ${sediuSocialData.scod_Postal || null},
          
          /* Date domiciliu fiscal */
          ${domFiscalData.ddenumire_Strada || null},
          ${domFiscalData.dnumar_Strada || null},
          ${domFiscalData.ddenumire_Localitate || null},
          ${domFiscalData.dcod_Localitate || null},
          ${domFiscalData.ddenumire_Judet || null},
          ${domFiscalData.dcod_Judet || null},
          ${domFiscalData.dcod_JudetAuto || null},
          ${domFiscalData.dtara || null},
          ${domFiscalData.ddetalii_Adresa || null},
          ${domFiscalData.dcod_Postal || null},
          
          /* Date sistem */
          ${JSON.stringify(perioade_tva)}::jsonb,
          ${JSON.stringify(data)}::jsonb,
          ${currentDate}::timestamptz,
          ${currentDate}::timestamptz,
          ${currentDate}::timestamptz,
          true
        )
        ON CONFLICT (cui) DO UPDATE SET
          data_interogare = ${currentDate}::date,
          denumire = ${denumire || null},
          adresa = ${adresa || null},
          nr_reg_com = ${nrRegCom || null},
          telefon = ${companyData.telefon || null},
          fax = ${companyData.fax || null},
          cod_postal = ${companyData.codPostal || null},
          act = ${companyData.act || null},
          stare_inregistrare = ${companyData.stare_inregistrare || null},
          data_inregistrare = ${companyData.data_inregistrare || null},
          cod_caen = ${companyData.cod_CAEN || null},
          iban = ${companyData.iban || null},
          status_ro_e_factura = ${companyData.statusRO_e_Factura || false},
          organ_fiscal_competent = ${companyData.organFiscalCompetent || null},
          forma_de_proprietate = ${companyData.forma_de_proprietate || null},
          forma_organizare = ${companyData.forma_organizare || null},
          forma_juridica = ${companyData.forma_juridica || null},
          
          /* Date TVA */
          scp_tva = ${scopTva.scpTVA === true},
          data_inceput_scp_tva = ${data_inceput_scp_tva}::date,
          data_sfarsit_scp_tva = ${data_sfarsit_scp_tva}::date,
          data_anul_imp_scp_tva = ${data_anul_imp_scp_tva}::date,
          mesaj_scp_tva = ${mesaj_scp_tva},
          
          /* Date TVA la încasare */
          data_inceput_tva_inc = ${rTvaiData.dataInceputTvaInc || null}::date,
          data_sfarsit_tva_inc = ${rTvaiData.dataSfarsitTvaInc || null}::date,
          data_actualizare_tva_inc = ${rTvaiData.dataActualizareTvaInc || null}::date,
          data_publicare_tva_inc = ${rTvaiData.dataPublicareTvaInc || null}::date,
          tip_act_tva_inc = ${rTvaiData.tipActTvaInc || null},
          status_tva_incasare = ${rTvaiData.statusTvaIncasare === true},
          
          /* Date inactive */
          data_inactivare = ${inactivStatus.dataInactivare || null}::date,
          data_reactivare = ${inactivStatus.dataReactivare || null}::date,
          data_publicare = ${inactivStatus.dataPublicare || null}::date,
          data_radiere = ${inactivStatus.dataRadiere || null}::date,
          status_inactivi = ${inactivStatus.statusInactivi === true},
          
          /* Date split TVA */
          data_inceput_split_tva = ${splitTvaData.dataInceputSplitTVA || null}::date,
          data_anulare_split_tva = ${splitTvaData.dataAnulareSplitTVA || null}::date,
          status_split_tva = ${splitTvaData.statusSplitTVA === true},
          
          /* Date sediu social */
          ss_denumire_strada = ${sediuSocialData.sdenumire_Strada || null},
          ss_numar_strada = ${sediuSocialData.snumar_Strada || null},
          ss_denumire_localitate = ${sediuSocialData.sdenumire_Localitate || null},
          ss_cod_localitate = ${sediuSocialData.scod_Localitate || null},
          ss_denumire_judet = ${sediuSocialData.sdenumire_Judet || null},
          ss_cod_judet = ${sediuSocialData.scod_Judet || null},
          ss_cod_judet_auto = ${sediuSocialData.scod_JudetAuto || null},
          ss_tara = ${sediuSocialData.stara || null},
          ss_detalii_adresa = ${sediuSocialData.sdetalii_Adresa || null},
          ss_cod_postal = ${sediuSocialData.scod_Postal || null},
          
          /* Date domiciliu fiscal */
          df_denumire_strada = ${domFiscalData.ddenumire_Strada || null},
          df_numar_strada = ${domFiscalData.dnumar_Strada || null},
          df_denumire_localitate = ${domFiscalData.ddenumire_Localitate || null},
          df_cod_localitate = ${domFiscalData.dcod_Localitate || null},
          df_denumire_judet = ${domFiscalData.ddenumire_Judet || null},
          df_cod_judet = ${domFiscalData.dcod_Judet || null},
          df_cod_judet_auto = ${domFiscalData.dcod_JudetAuto || null},
          df_tara = ${domFiscalData.dtara || null},
          df_detalii_adresa = ${domFiscalData.ddetalii_Adresa || null},
          df_cod_postal = ${domFiscalData.dcod_Postal || null},
          
          /* Date sistem */
          perioade_tva = ${JSON.stringify(perioade_tva)}::jsonb,
          raw_response = ${JSON.stringify(data)}::jsonb,
          updated_at = ${currentDate}::timestamptz,
          last_checked_at = ${currentDate}::timestamptz,
          is_updated_from_anaf = true
      `);
      console.log(`[AnafDatabaseService] \u2705 Date salvate cu succes pentru CUI ${cui}`);
      return true;
    } catch (error) {
      console.error(`[AnafDatabaseService] Eroare la salvarea datelor pentru CUI ${cui}:`, error);
      return false;
    }
  }
};

// server/modules/crm/services/anaf-queue_services/batch.service.ts
import { v4 as uuidv49 } from "uuid";
var AnafBatchService = class {
  /**
   * Constructor pentru AnafBatchService
   * 
   * @param cacheService Serviciul de cache
   * @param databaseService Serviciul de bază de date
   * @param batchSize Dimensiunea maximă a unui batch
   * @param batchTimeoutMs Timeout-ul pentru trimiterea unui batch (ms)
   */
  constructor(cacheService, databaseService, batchSize, batchTimeoutMs) {
    this.pendingItems = [];
    this.lastBatchTime = 0;
    this.batchSize = 10;
    this.batchTimeoutMs = 5e3;
    this.cacheService = cacheService;
    this.databaseService = databaseService;
    if (batchSize) {
      this.batchSize = batchSize;
    }
    if (batchTimeoutMs) {
      this.batchTimeoutMs = batchTimeoutMs;
    }
  }
  /**
   * Adaugă o cerere la batch-ul curent
   * 
   * @param item Datele pentru cerere
   */
  async addToBatch(item) {
    const queueItem = {
      ...item,
      timestamp: Date.now()
    };
    const existingIndex = this.pendingItems.findIndex((i) => i.cui === item.cui);
    if (existingIndex >= 0) {
      this.pendingItems[existingIndex] = queueItem;
    } else {
      this.pendingItems.push(queueItem);
    }
  }
  /**
   * Verifică dacă batch-ul este gata pentru procesare
   * @returns Batch-ul pregătit sau null dacă nu e gata
   */
  async getBatchIfReady() {
    const now = Date.now();
    const timeSinceLastBatch = now - this.lastBatchTime;
    if (this.pendingItems.length >= this.batchSize || this.pendingItems.length > 0 && timeSinceLastBatch >= this.batchTimeoutMs) {
      const itemsToProcess = [...this.pendingItems];
      this.pendingItems = [];
      this.lastBatchTime = now;
      const batch = {
        batchId: uuidv49(),
        cuiList: itemsToProcess.map((item) => item.cui),
        requesterId: itemsToProcess[0].requesterId,
        requesterCompanyId: itemsToProcess[0].requesterCompanyId
      };
      return batch;
    }
    return null;
  }
};

// server/modules/crm/services/anaf-queue_services/types.ts
function createDefaultConfig(config3) {
  return {
    redisUrl: process.env.REDIS_URL || "redis://localhost:6379",
    queueName: "anaf-queue",
    batchSize: 10,
    batchTimeoutMs: 5e3,
    // 5 secunde
    cacheTimeoutSec: 3600,
    // 1 oră
    redisPrefix: "anaf:",
    ...config3
  };
}

// server/modules/crm/services/anaf-queue_services/anaf-queue.service.ts
var AnafQueueService = class {
  /**
   * Constructor pentru serviciul ANAF Queue
   * @param config Configurația pentru ANAF Queue
   */
  constructor(config3) {
    this.callbacks = /* @__PURE__ */ new Map();
    this.initializeAttempts = 0;
    this.maxInitializeAttempts = 5;
    this.redisConnected = false;
    this.config = createDefaultConfig(config3);
    this.initializeServices().catch((err) => {
      console.error("[AnafQueueService] Eroare la ini\u021Bializarea asincron\u0103:", err);
    });
  }
  /**
   * Inițializează serviciile și conexiunile
   */
  async initializeServices() {
    try {
      console.log("[AnafQueueService] Ini\u021Bializare cu conexiune Redis pentru BullMQ...");
      const host = process.env.REDIS_HOST || "localhost";
      const port = parseInt(process.env.REDIS_PORT || "6379", 10);
      const username = process.env.REDIS_USERNAME || "";
      const password = process.env.REDIS_PASSWORD || "";
      console.log(`[AnafQueueService] Conectare la Redis: ${host}:${port}, utilizator: ${username || "[none]"}, parol\u0103: ${password ? "[hidden]" : "[none]"}`);
      const isRedisCloud = host.includes("redis-cloud") || host.includes("cloud.redislabs.com") || host.includes("upstash.io") || host.includes("redis.cache.windows.net");
      console.log(`[AnafQueueService] Configurare Redis direct\u0103 pentru: ${host}:${port}`);
      const redisOptions = {
        host,
        port,
        username: username || void 0,
        password: password || void 0,
        maxRetriesPerRequest: null,
        // Obligatoriu pentru BullMQ
        enableReadyCheck: false,
        // Dezactivează verificări care pot cauza probleme
        retryStrategy: (times) => {
          if (times > 3) return null;
          return Math.min(times * 500, 3e3);
        }
      };
      console.log(`[AnafQueueService] Op\u021Biuni Redis: ${JSON.stringify({
        ...redisOptions,
        password: redisOptions.password ? "[hidden]" : void 0
      })}`);
      const redisClient = new Redis2(redisOptions);
      redisClient.on("error", (err) => {
        console.error("[AnafQueueService] Eroare Redis:", err.message);
      });
      const connectionOptions = {
        connection: redisClient
      };
      this.queue = new Queue(this.config.queueName, connectionOptions);
      this.queue.on("error", (error) => {
        console.error(`[AnafQueueService] Eroare coad\u0103: ${error.message}`);
      });
      this.cacheService = new AnafCacheService(this.config);
      this.databaseService = new AnafDatabaseService();
      this.batchService = new AnafBatchService(this.cacheService, this.databaseService);
      this.worker = new Worker(
        this.config.queueName,
        async (job) => await this.processBatch(job),
        connectionOptions
      );
      this.worker.on("failed", (job, error) => {
        console.error(`[AnafQueueService] Eroare la procesarea job-ului ${job?.id}:`, error);
        if (job?.data) {
          const batchData = job.data;
          for (const cui of batchData.cuiList) {
            const requestId = `${cui}_${batchData.requesterId}`;
            this.notifyRequestComplete(requestId, {
              company: null,
              error: new Error(`Eroare la procesarea cererii batch: ${error.message}`)
            });
          }
        }
      });
      this.redisConnected = true;
      console.log(`[AnafQueueService] Serviciu ini\u021Bializat cu succes. Redis conectat.`);
    } catch (error) {
      console.error("[AnafQueueService] Eroare la ini\u021Bializarea serviciilor:", error);
      this.redisConnected = false;
      if (this.initializeAttempts < this.maxInitializeAttempts) {
        this.initializeAttempts++;
        console.log(`[AnafQueueService] Re\xEEncercare conectare (${this.initializeAttempts}/${this.maxInitializeAttempts})...`);
        setTimeout(() => this.initializeServices(), 5e3);
      }
    }
  }
  /**
   * Cere date despre o companie folosind CUI-ul
   * Implementează strategia de caching și batching
   * 
   * @param cui CUI-ul companiei
   * @param userId ID-ul utilizatorului care face cererea
   * @param companyId ID-ul companiei utilizatorului
   * @returns Promise cu datele companiei sau null dacă nu s-au găsit
   */
  async queueCompanyRequest(cui, userId, companyId) {
    return new Promise(async (resolve, reject) => {
      try {
        if (!userId || userId === "anonymous" || userId === "unknown") {
          console.error(`[AnafQueueService] \u274C Utilizator neautentificat (${userId}) pentru CUI ${cui}. Nu se poate continua.`);
          return reject(new Error("Nu sunte\u021Bi autentificat. V\u0103 rug\u0103m s\u0103 v\u0103 autentifica\u021Bi \u0219i s\u0103 \xEEncerca\u021Bi din nou."));
        }
        if (!cui || typeof cui !== "string" || cui.trim() === "") {
          console.error(`[AnafQueueService] \u274C CUI invalid sau gol: "${cui}"`);
          return reject(new Error("CUI invalid sau gol"));
        }
        const cleanCui = cui.replace(/^RO/i, "").trim();
        console.log(`[AnafQueueService] \u{1F50D} Cerere ANAF pentru CUI ${cleanCui} de la utilizator ${userId}, companie ${companyId}`);
        const cachedData = await this.cacheService.get(cleanCui);
        if (cachedData) {
          console.log(`[AnafQueueService] \u2705 Date g\u0103site \xEEn cache pentru CUI ${cleanCui}`);
          console.log("[AnafQueueService] Date \xEEn cache: ", JSON.stringify(cachedData).substring(0, 200) + "...");
          const dbDataExists = await this.databaseService.getCompanyData(cleanCui);
          if (!dbDataExists) {
            console.log(`[AnafQueueService] \u{1F504} Sincronizare date cache -> DB pentru CUI ${cleanCui}`);
            const savedToDB = await this.databaseService.saveCompanyData(cleanCui, cachedData);
            if (savedToDB) {
              console.log(`[AnafQueueService] \u2705 Date salvate cu succes \xEEn DB din cache pentru CUI ${cleanCui}`);
            } else {
              console.error(`[AnafQueueService] \u274C Eroare la salvarea datelor din cache \xEEn DB pentru CUI ${cleanCui}`);
            }
          } else {
            console.log(`[AnafQueueService] \u2139\uFE0F Date existente \xEEn DB pentru CUI ${cleanCui}`);
          }
          return resolve(cachedData);
        }
        const dbData = await this.databaseService.getCompanyData(cleanCui);
        if (dbData) {
          console.log(`[AnafQueueService] \u2705 Date g\u0103site \xEEn baza de date pentru CUI ${cleanCui}`);
          await this.cacheService.set(cleanCui, dbData);
          return resolve(dbData);
        }
        console.log(`[AnafQueueService] Cerere nou\u0103 pentru CUI ${cui}`);
        const requestId = `${cui}_${userId}`;
        this.callbacks.set(requestId, (result) => {
          if (result.error) {
            reject(result.error);
          } else {
            resolve(result.company);
          }
        });
        await this.batchService.addToBatch({
          cui,
          requesterId: userId,
          requesterCompanyId: companyId
        });
        const batch = await this.batchService.getBatchIfReady();
        if (batch) {
          await this.queue.add("processBatch", batch, {
            removeOnComplete: true,
            removeOnFail: 5e3,
            attempts: 3,
            backoff: {
              type: "exponential",
              delay: 5e3
            }
          });
        }
      } catch (error) {
        console.error(`[AnafQueueService] Eroare la procesarea cererii pentru CUI ${cui}:`, error);
        reject(error);
      }
    });
  }
  /**
   * Procesează un batch de cereri către API-ul ANAF
   * @param job Job-ul BullMQ
   */
  async processBatch(job) {
    const batchData = job.data;
    console.log(`[AnafQueueService] Procesare batch ${batchData.batchId} cu ${batchData.cuiList.length} CUI-uri`);
    try {
      const response = await anafService.queryAnaf(batchData.cuiList);
      if (response && response.found && Array.isArray(response.found)) {
        for (const company of response.found) {
          const cui = company.date_generale?.cui || "";
          console.log(`[AnafQueueService] Procesare date pentru CUI ${cui} din API`);
          console.log("[AnafQueueService] Date primite: ", JSON.stringify(company).substring(0, 200) + "...");
          await this.cacheService.set(cui, company);
          const savedToDB = await this.databaseService.saveCompanyData(cui, company);
          if (savedToDB) {
            console.log(`[AnafQueueService] \u2705 Date salvate cu succes \xEEn DB pentru CUI ${cui}`);
          } else {
            console.error(`[AnafQueueService] \u274C Eroare la salvarea datelor \xEEn DB pentru CUI ${cui}`);
          }
          const requestId = `${cui}_${batchData.requesterId}`;
          this.notifyRequestComplete(requestId, {
            company,
            source: "api" /* API */
          });
        }
      }
      if (response && response.notFound && Array.isArray(response.notFound)) {
        for (const cui of response.notFound) {
          const requestId = `${cui}_${batchData.requesterId}`;
          this.notifyRequestComplete(requestId, {
            company: null,
            source: "api" /* API */
          });
        }
      }
    } catch (error) {
      console.error(`[AnafQueueService] Eroare la procesarea batch-ului ${batchData.batchId}:`, error);
      for (const cui of batchData.cuiList) {
        const requestId = `${cui}_${batchData.requesterId}`;
        this.notifyRequestComplete(requestId, {
          company: null,
          error: error instanceof Error ? error : new Error("Eroare necunoscut\u0103 la procesarea batch-ului")
        });
      }
    }
  }
  /**
   * Notifică callback-urile că o cerere a fost completată
   * @param cui CUI-ul companiei
   * @param result Rezultatul cererii
   */
  notifyRequestComplete(requestId, result) {
    const callback = this.callbacks.get(requestId);
    if (callback) {
      callback(result);
      this.callbacks.delete(requestId);
    }
  }
  /**
   * Închide conexiunile și eliberează resursele
   */
  async close() {
    try {
      console.log("[AnafQueueService] \xCEnchidere serviciu...");
      if (this.worker) {
        await this.worker.close();
      }
      if (this.queue) {
        await this.queue.close();
      }
      await this.cacheService.close();
      console.log("[AnafQueueService] Serviciu \xEEnchis cu succes");
    } catch (error) {
      console.error("[AnafQueueService] Eroare la \xEEnchiderea serviciului:", error);
    }
  }
};
var anafQueueService = new AnafQueueService();

// server/modules/crm/controllers/anaf.controller.ts
var AnafController = class {
  /**
   * Ruta proxy pentru interogarea API-ului ANAF
   * 
   * @route POST /api/crm/anaf-proxy
   * @param req Request cu array de obiecte {cui, data}
   * @param res Response cu datele firmelor
   */
  async proxyAnafRequest(req, res) {
    try {
      if (!req.user || !req.user.id) {
        console.error(`[AnafController] \u274C Acces neautorizat la ruta /api/crm/anaf-proxy`);
        return res.status(401).json({
          error: "Nu sunte\u021Bi autentificat. V\u0103 rug\u0103m s\u0103 v\u0103 autentifica\u021Bi \u0219i s\u0103 \xEEncerca\u021Bi din nou."
        });
      }
      const { body } = req;
      if (!Array.isArray(body)) {
        return res.status(400).json({ error: "Formatul request-ului este invalid. Se asteapta un array de obiecte." });
      }
      if (body.length > 100) {
        return res.status(400).json({
          error: "Prea multe CUI-uri. Maximum 100 sunt permise \xEEntr-o cerere.",
          requested: body.length
        });
      }
      const cuiList = body.map((item) => item.cui);
      const response = await anafService.queryAnaf(cuiList);
      audit_service_default.log({
        userId: req.user?.id || "anonymous",
        companyId: req.user?.companyId || "unknown",
        action: "anaf_proxy_request",
        entity: "anaf_api",
        details: {
          request: body,
          found: response.found?.length || 0,
          notFound: response.notFound?.length || 0,
          success: true
        }
      });
      return res.status(200).json(response);
    } catch (error) {
      console.error("Eroare la interogarea API-ului ANAF:", error.message);
      audit_service_default.log({
        userId: req.user?.id || "anonymous",
        companyId: req.user?.companyId || "unknown",
        action: "anaf_proxy_request_error",
        entity: "anaf_api",
        details: {
          error: error.message,
          success: false
        }
      });
      if (error.response) {
        return res.status(error.response.status).json({
          error: "Eroare la interogarea API-ului ANAF",
          details: error.response.data
        });
      }
      return res.status(500).json({
        error: "Eroare la interogarea API-ului ANAF",
        details: error.message
      });
    }
  }
  /**
   * Ruta pentru interogarea datelor unei singure companii
   * 
   * @route GET /api/crm/company/:cui
   * @param req Request cu CUI-ul companiei in params
   * @param res Response cu datele companiei
   */
  async getCompanyData(req, res) {
    try {
      if (!req.user || !req.user.id) {
        console.error(`[AnafController] \u274C Acces neautorizat la ruta /api/crm/company/:cui`);
        return res.status(401).json({
          error: "Nu sunte\u021Bi autentificat. V\u0103 rug\u0103m s\u0103 v\u0103 autentifica\u021Bi \u0219i s\u0103 \xEEncerca\u021Bi din nou."
        });
      }
      const cui = req.params.cui;
      const validCui = validateCui(cui);
      if (validCui === null) {
        return res.status(400).json({ error: "CUI invalid" });
      }
      console.log(`[AnafController] \u{1F50D} Interogare ANAF pentru CUI: ${validCui} de c\u0103tre utilizatorul ${req.user.id}`);
      const companyData = await anafQueueService.queueCompanyRequest(
        validCui,
        req.user.id,
        req.user.companyId || "unknown"
      );
      if (companyData) {
        audit_service_default.log({
          userId: req.user?.id || "anonymous",
          companyId: req.user?.companyId || "unknown",
          action: "anaf_get_company",
          entity: "anaf_api",
          details: {
            cui: validCui,
            success: true
          }
        });
        return res.status(200).json(companyData);
      } else {
        return res.status(404).json({
          error: "Compania nu a fost g\u0103sit\u0103",
          cui: validCui
        });
      }
    } catch (error) {
      console.error("Eroare la ob\u021Binerea datelor companiei:", error.message);
      audit_service_default.log({
        userId: req.user?.id || "anonymous",
        companyId: req.user?.companyId || "unknown",
        action: "anaf_get_company_error",
        entity: "anaf_api",
        details: {
          cui: req.params.cui,
          error: error.message,
          success: false
        }
      });
      return res.status(500).json({
        error: "Eroare la ob\u021Binerea datelor de la ANAF",
        details: error.message
      });
    }
  }
  /**
   * Ruta batch pentru interogarea datelor mai multor companii
   * 
   * @route POST /api/crm/companies/batch
   * @param req Request cu array de CUI-uri în body
   * @param res Response cu datele companiilor
   */
  async batchGetCompanies(req, res) {
    try {
      if (!req.user || !req.user.id) {
        console.error(`[AnafController] \u274C Acces neautorizat la ruta /api/crm/companies/batch`);
        return res.status(401).json({
          error: "Nu sunte\u021Bi autentificat. V\u0103 rug\u0103m s\u0103 v\u0103 autentifica\u021Bi \u0219i s\u0103 \xEEncerca\u021Bi din nou."
        });
      }
      if (!req.body || !Array.isArray(req.body.cuiList)) {
        return res.status(400).json({
          error: "Format invalid al cererii. Furniza\u021Bi un obiect cu proprietatea cuiList de tip array."
        });
      }
      const cuiList = req.body.cuiList;
      if (cuiList.length === 0) {
        return res.status(400).json({
          error: "Lista de CUI-uri nu poate fi goal\u0103."
        });
      }
      if (cuiList.length > 100) {
        return res.status(400).json({
          error: "Prea multe CUI-uri. Maximum 100 sunt permise \xEEntr-o cerere.",
          requested: cuiList.length
        });
      }
      console.log(`Interogare batch pentru ${cuiList.length} CUI-uri`);
      console.log(`[AnafController] Procesare individual\u0103 pentru ${cuiList.length} CUI-uri`);
      const validatedCuis = cuiList.map((cui) => validateCui(cui)).filter((cui) => cui !== null);
      console.log(`[AnafController] CUI-uri primite: ${JSON.stringify(cuiList)}`);
      console.log(`[AnafController] CUI-uri validate: ${JSON.stringify(validatedCuis)}`);
      console.log(`[AnafController] Dup\u0103 validare, au r\u0103mas ${validatedCuis.length} CUI-uri valide`);
      const results = [];
      for (const cui of validatedCuis) {
        try {
          const data = await anafQueueService.queueCompanyRequest(
            cui,
            req.user?.id || "anonymous",
            req.user?.companyId || "unknown"
          );
          results.push({ cui, valid: true, data });
        } catch (error) {
          console.error(`[AnafController] Eroare la ob\u021Binerea datelor pentru CUI ${cui}:`, error);
          results.push({ cui, valid: true, error: error.message, data: null });
        }
      }
      const validResults = results.filter((r) => r && typeof r === "object" && "cui" in r);
      const found = validResults.filter((r) => r.valid && r.data).map((r) => r.data);
      const notFound = validResults.filter((r) => !r.valid || !r.data).map((r) => r.cui);
      const errors = validResults.filter((r) => r.error).map((r) => ({ cui: r.cui, error: r.error }));
      audit_service_default.log({
        userId: req.user?.id || "anonymous",
        companyId: req.user?.companyId || "unknown",
        action: "anaf_batch_get_companies",
        entity: "anaf_api",
        details: {
          requestedCount: cuiList.length,
          foundCount: found.length,
          notFoundCount: notFound.length,
          errorsCount: errors.length,
          success: true
        }
      });
      return res.status(200).set("Content-Type", "application/json").json({
        success: true,
        found: Array.isArray(found) ? found : [],
        notFound: Array.isArray(notFound) ? notFound : [],
        errors: errors && errors.length > 0 ? errors : []
      });
    } catch (error) {
      console.error("Eroare la interogarea batch ANAF:", error.message);
      audit_service_default.log({
        userId: req.user?.id || "anonymous",
        companyId: req.user?.companyId || "unknown",
        action: "anaf_batch_get_companies_error",
        entity: "anaf_api",
        details: {
          error: error.message,
          success: false
        }
      });
      return res.status(500).set("Content-Type", "application/json").json({
        error: "Eroare la interogarea batch ANAF",
        details: error.message
      });
    }
  }
};
var anafController = new AnafController();

// server/modules/crm/controllers/financial-data.controller.ts
init_auth_guard();

// server/modules/crm/services/financial-data.service.ts
init_base_drizzle_service();
import axios3 from "axios";

// server/modules/crm/schema/financial-data.schema.ts
import { pgTable as pgTable13, serial as serial3, varchar as varchar7, integer as integer9, json as json7, timestamp as timestamp13, boolean as boolean12, text as text13 } from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema9, createSelectSchema as createSelectSchema2 } from "drizzle-zod";
import { z as z14 } from "zod";
var financialDataErrors = pgTable13("financial_data_errors", {
  id: serial3("id").primaryKey(),
  cui: varchar7("cui", { length: 20 }).notNull(),
  fiscalYear: integer9("fiscal_year").notNull(),
  errorMessage: text13("error_message").notNull(),
  retryCount: integer9("retry_count").default(0).notNull(),
  lastAttemptAt: timestamp13("last_attempt_at").defaultNow().notNull(),
  isResolved: boolean12("is_resolved").default(false).notNull(),
  createdAt: timestamp13("created_at").defaultNow().notNull()
});
var financialIndicator = z14.object({
  indicator: z14.string(),
  val_indicator: z14.number().nullable(),
  val_den_indicator: z14.string()
});
var financialData = pgTable13("financial_data", {
  id: serial3("id").primaryKey(),
  cui: varchar7("cui", { length: 20 }).notNull(),
  companyId: varchar7("company_id", { length: 36 }).notNull(),
  fiscalYear: integer9("fiscal_year").notNull(),
  // Informații generale
  companyName: varchar7("company_name", { length: 255 }).notNull(),
  caenCode: integer9("caen_code").notNull(),
  caenDescription: varchar7("caen_description", { length: 255 }).notNull(),
  // Indicatori financiari (stocați ca JSON)
  indicators: json7("indicators").notNull(),
  // Metadate de procesare
  fetchedAt: timestamp13("fetched_at").defaultNow().notNull(),
  isProcessed: boolean12("is_processed").default(true).notNull(),
  processingErrors: varchar7("processing_errors", { length: 500 }),
  // Câmpuri de audit
  createdAt: timestamp13("created_at").defaultNow().notNull(),
  updatedAt: timestamp13("updated_at").defaultNow().notNull(),
  createdBy: varchar7("created_by", { length: 36 }),
  updatedBy: varchar7("updated_by", { length: 36 })
});
var financialDataJobs = pgTable13("financial_data_jobs", {
  id: serial3("id").primaryKey(),
  cui: varchar7("cui", { length: 20 }).notNull(),
  companyId: varchar7("company_id", { length: 36 }).notNull(),
  status: varchar7("status", { length: 20 }).default("pending").notNull(),
  startYear: integer9("start_year").notNull(),
  endYear: integer9("end_year").notNull(),
  currentYear: integer9("current_year"),
  progress: integer9("progress").default(0).notNull(),
  totalYears: integer9("total_years").notNull(),
  lastProcessedAt: timestamp13("last_processed_at"),
  completedAt: timestamp13("completed_at"),
  createdAt: timestamp13("created_at").defaultNow().notNull(),
  createdBy: varchar7("created_by", { length: 36 })
});
var insertFinancialDataSchema = createInsertSchema9(financialData, {
  indicators: z14.array(financialIndicator)
});
var selectFinancialDataSchema = createSelectSchema2(financialData, {
  indicators: z14.array(financialIndicator)
});
var insertFinancialDataJobSchema = createInsertSchema9(financialDataJobs);
var selectFinancialDataJobSchema = createSelectSchema2(financialDataJobs);
var createFinancialDataJobSchema = z14.object({
  cui: z14.string().min(1).max(20),
  companyId: z14.string().uuid(),
  startYear: z14.number().min(1990).max((/* @__PURE__ */ new Date()).getFullYear()),
  endYear: z14.number().min(1990).max((/* @__PURE__ */ new Date()).getFullYear())
});

// server/modules/crm/services/financial-data.service.ts
init_logger();
import { eq as eq35, and as and31, sql as sql27 } from "drizzle-orm";
var ANAF_BILANT_URL = "https://webservicesp.anaf.ro/bilant";
var CURRENT_YEAR = (/* @__PURE__ */ new Date()).getFullYear();
var FinancialDataService = class extends BaseDrizzleService {
  constructor(auditService4) {
    super();
    this.auditService = auditService4;
    this.logger = new Logger("FinancialDataService");
  }
  /**
   * Interogare date financiare pentru un CUI și an fiscal specifice
   * Impune limitarea de 1 request pe secundă
   */
  async fetchFinancialData(cui, fiscalYear, userId, companyId) {
    try {
      this.logger.info(`\u{1F50D} Interogare date financiare pentru CUI ${cui}, anul ${fiscalYear}`);
      const normalizedCui = cui.replace(/^RO/, "");
      const existingData = await this.query(async (db4) => {
        return await db4.select().from(financialData).where(and31(
          eq35(financialData.cui, normalizedCui),
          eq35(financialData.fiscalYear, fiscalYear)
        )).limit(1);
      });
      if (existingData.length > 0) {
        this.logger.info(`\u2705 Date financiare g\u0103site \xEEn baza de date pentru CUI ${cui}, anul ${fiscalYear}`);
        return existingData[0];
      }
      const url = `${ANAF_BILANT_URL}?an=${fiscalYear}&cui=${normalizedCui}`;
      this.logger.info(`\u{1F4E1} Trimitere cerere c\u0103tre ANAF: ${url}`);
      if (userId && companyId) {
        await this.auditService.logEvent({
          eventType: "anaf_bilant_request",
          module: "anaf_financial_data",
          description: `Interogare bilan\u021B ANAF pentru CUI ${normalizedCui}, anul ${fiscalYear}`,
          userId,
          companyId,
          entityId: normalizedCui,
          entityType: "company_cui",
          data: { cui: normalizedCui, fiscalYear }
        });
      }
      const response = await axios3.get(url, {
        headers: {
          "Accept": "application/json",
          "User-Agent": "TalentInventory/1.0"
        }
      });
      const data = response.data;
      if (!data || !data.cui || !data.an) {
        throw new Error(`R\u0103spuns invalid de la ANAF pentru CUI ${cui}, anul ${fiscalYear}`);
      }
      const indicators = Array.isArray(data.i) ? data.i : [];
      const insertData = {
        cui: normalizedCui,
        companyId: companyId || "",
        fiscalYear: data.an,
        companyName: data.deni || "",
        caenCode: data.caen || 0,
        caenDescription: data.den_caen || "",
        indicators,
        fetchedAt: /* @__PURE__ */ new Date(),
        isProcessed: true,
        createdBy: userId,
        updatedBy: userId
      };
      const saved = await this.query(async (db4) => {
        return await db4.insert(financialData).values(insertData).returning();
      });
      this.logger.info(`\u2705 Date financiare salvate \xEEn baza de date pentru CUI ${cui}, anul ${fiscalYear}`);
      return saved[0];
    } catch (error) {
      this.logger.error(`\u274C Eroare la interogarea datelor financiare pentru CUI ${cui}, anul ${fiscalYear}: ${error.message}`);
      const errorData = {
        cui,
        fiscalYear,
        errorMessage: error.message || "Eroare necunoscut\u0103",
        retryCount: 0,
        lastAttemptAt: /* @__PURE__ */ new Date(),
        isResolved: false
      };
      await this.query(async (db4) => {
        await db4.insert(financialDataErrors).values(errorData).returning();
      });
      throw error;
    }
  }
  /**
   * Obține datele financiare pentru o companie și un an fiscal
   */
  async getFinancialData(cui, fiscalYear) {
    const normalizedCui = cui.replace(/^RO/, "");
    const data = await this.query(async (db4) => {
      return await db4.select().from(financialData).where(and31(
        eq35(financialData.cui, normalizedCui),
        eq35(financialData.fiscalYear, fiscalYear)
      )).limit(1);
    });
    return data[0] || null;
  }
  /**
   * Obține toate datele financiare pentru o companie
   */
  async getAllFinancialData(cui) {
    const normalizedCui = cui.replace(/^RO/, "");
    return await this.query(async (db4) => {
      return await db4.select().from(financialData).where(eq35(financialData.cui, normalizedCui)).orderBy(financialData.fiscalYear);
    });
  }
  /**
   * Obține datele financiare pentru o listă de companii și un an fiscal
   */
  async getBulkFinancialData(cuiList, fiscalYear) {
    const normalizedCuiList = cuiList.map((cui) => cui.replace(/^RO/, ""));
    return await this.query(async (db4) => {
      return await db4.select().from(financialData).where(and31(
        sql27`${financialData.cui} IN (${normalizedCuiList.join(",")})`,
        eq35(financialData.fiscalYear, fiscalYear)
      ));
    });
  }
  /**
   * Creează un job pentru interogarea datelor financiare pentru o companie
   * pentru toți anii disponibili (de la startYear la endYear)
   */
  async createFinancialDataJob(cui, companyId, startYear = 2014, endYear = CURRENT_YEAR, userId) {
    const normalizedCui = cui.replace(/^RO/, "");
    const totalYears = endYear - startYear + 1;
    const existingJob = await this.query(async (db4) => {
      return await db4.select().from(financialDataJobs).where(and31(
        eq35(financialDataJobs.cui, normalizedCui),
        eq35(financialDataJobs.status, "pending")
      )).limit(1);
    });
    if (existingJob.length > 0) {
      return existingJob[0];
    }
    const jobData = {
      cui: normalizedCui,
      companyId,
      status: "pending",
      startYear,
      endYear,
      currentYear: startYear,
      progress: 0,
      totalYears,
      createdBy: userId
    };
    const job = await this.query(async (db4) => {
      return await db4.insert(financialDataJobs).values(jobData).returning();
    });
    if (userId) {
      await this.auditService.logEvent({
        eventType: "anaf_financial_job_created",
        module: "anaf_financial_data",
        description: `Job creat pentru interogare bilan\u021Buri ANAF pentru CUI ${normalizedCui}, anii ${startYear}-${endYear}`,
        userId,
        companyId,
        entityId: normalizedCui,
        entityType: "company_cui",
        data: { cui: normalizedCui, startYear, endYear, totalYears }
      });
    }
    return job[0];
  }
  /**
   * Actualizează statusul unui job
   */
  async updateJobStatus(jobId, status, progress, currentYear) {
    const updateData = {
      status,
      progress,
      lastProcessedAt: /* @__PURE__ */ new Date()
    };
    if (currentYear) {
      updateData.currentYear = currentYear;
    }
    if (status === "completed") {
      updateData.completedAt = /* @__PURE__ */ new Date();
    }
    const updated = await this.query(async (db4) => {
      return await db4.update(financialDataJobs).set(updateData).where(eq35(financialDataJobs.id, jobId)).returning();
    });
    return updated[0];
  }
  /**
   * Obține joburile în așteptare
   */
  async getPendingJobs(limit = 10) {
    return await this.query(async (db4) => {
      return await db4.select().from(financialDataJobs).where(eq35(financialDataJobs.status, "pending")).limit(limit);
    });
  }
  /**
   * Obține un job după ID
   */
  async getJobById(jobId) {
    return await this.query(async (db4) => {
      return await db4.select().from(financialDataJobs).where(eq35(financialDataJobs.id, jobId)).limit(1);
    });
  }
  /**
   * Obține erorile nerezolvate
   */
  async getUnresolvedErrors() {
    return await this.query(async (db4) => {
      return await db4.select().from(financialDataErrors).where(eq35(financialDataErrors.isResolved, false));
    });
  }
  /**
   * Incrementează contorul de reîncercări pentru o eroare
   */
  async incrementErrorRetryCount(errorId) {
    await this.query(async (db4) => {
      await db4.update(financialDataErrors).set({
        retryCount: sql27`${financialDataErrors.retryCount} + 1`,
        lastAttemptAt: /* @__PURE__ */ new Date()
      }).where(eq35(financialDataErrors.id, errorId));
    });
  }
  /**
   * Marchează o eroare ca rezolvată
   */
  async markErrorAsResolved(errorId) {
    await this.query(async (db4) => {
      await db4.update(financialDataErrors).set({
        isResolved: true
      }).where(eq35(financialDataErrors.id, errorId));
    });
  }
  /**
   * Obține statistici despre datele financiare
   */
  async getFinancialDataStats(companyId) {
    const stats = await this.query(async (db4) => {
      const baseQuery = db4.select({
        totalRecords: sql27`COUNT(*)`,
        uniqueCompanies: sql27`COUNT(DISTINCT ${financialData.cui})`,
        earliestYear: sql27`MIN(${financialData.fiscalYear})`,
        latestYear: sql27`MAX(${financialData.fiscalYear})`,
        avgIndicatorsPerRecord: sql27`AVG(jsonb_array_length(${financialData.indicators}))`
      }).from(financialData);
      if (companyId) {
        return await baseQuery.where(eq35(financialData.companyId, companyId));
      }
      return await baseQuery;
    });
    return stats[0];
  }
};

// server/modules/crm/services/financial-queue.service.ts
init_logger();
import { Queue as Queue2, Worker as Worker2 } from "bullmq";
import IORedis from "ioredis";
import { eq as eq36 } from "drizzle-orm";

// server/config/redis.ts
import * as dotenv from "dotenv";
dotenv.config();
var DEFAULT_REDIS_HOST = "localhost";
var DEFAULT_REDIS_PORT = 6379;
var DEFAULT_REDIS_PASSWORD = "";
var DEFAULT_REDIS_DB = 0;
var DEFAULT_REDIS_PREFIX = "anaf:";
function getRedisConfig(withPrefix = false) {
  const host = process.env.REDIS_HOST || DEFAULT_REDIS_HOST;
  const port = parseInt(process.env.REDIS_PORT || DEFAULT_REDIS_PORT.toString(), 10);
  const password = process.env.REDIS_PASSWORD || DEFAULT_REDIS_PASSWORD;
  const db4 = parseInt(process.env.REDIS_DB || DEFAULT_REDIS_DB.toString(), 10);
  const prefix = process.env.REDIS_PREFIX || DEFAULT_REDIS_PREFIX;
  const redisUrl = process.env.REDIS_URL;
  const baseConfig = {
    host,
    port,
    password: password || void 0,
    db: db4,
    url: redisUrl,
    // Opțiuni suplimentare pentru robustețe
    maxRetriesPerRequest: null,
    retryStrategy: (times) => {
      const delay = Math.min(Math.pow(2, times) * 500, 3e4);
      return delay;
    },
    enableReadyCheck: true,
    reconnectOnError: (err) => {
      const targetError = "READONLY";
      if (err.message.includes(targetError)) {
        return true;
      }
      return false;
    }
  };
  if (withPrefix) {
    return {
      ...baseConfig,
      keyPrefix: prefix
    };
  }
  return baseConfig;
}
function getBullMQRedisConfig() {
  const baseConfig = getRedisConfig(false);
  const prefix = process.env.REDIS_PREFIX || DEFAULT_REDIS_PREFIX;
  return {
    connection: baseConfig,
    // Prefix-ul va fi setat la nivel de Queue în BullMQ
    prefix
  };
}

// server/modules/crm/services/financial-queue.service.ts
init_base_drizzle_service();
var FINANCIAL_DATA_QUEUE = "anaf-financial-data";
var FINANCIAL_RETRY_QUEUE = "anaf-financial-retry";
var FinancialQueueService = class extends BaseDrizzleService {
  constructor(db4, financialDataService, auditService4) {
    super();
    this.db = db4;
    this.financialDataService = financialDataService;
    this.auditService = auditService4;
    this.logger = new Logger("FinancialQueueService");
    const bullConfig = getBullMQRedisConfig();
    this.redisClient = new IORedis(bullConfig.connection);
    const queueOptions = {
      connection: this.redisClient,
      prefix: bullConfig.prefix,
      defaultJobOptions: {
        attempts: 3,
        backoff: {
          type: "exponential",
          delay: 5e3
        }
      }
    };
    const workerOptions = {
      connection: this.redisClient,
      prefix: bullConfig.prefix,
      concurrency: 1,
      limiter: {
        max: 1,
        duration: 1e3
      }
    };
    this.dataQueue = new Queue2(FINANCIAL_DATA_QUEUE, queueOptions);
    this.retryQueue = new Queue2(FINANCIAL_RETRY_QUEUE, queueOptions);
    this.dataWorker = new Worker2(
      FINANCIAL_DATA_QUEUE,
      async (job) => this.processJob(job),
      workerOptions
    );
    this.retryWorker = new Worker2(
      FINANCIAL_RETRY_QUEUE,
      async (job) => this.processRetryJob(job),
      workerOptions
    );
    this.setupEventHandlers();
  }
  /**
   * Configurează handlerii de evenimente pentru workers
   */
  setupEventHandlers() {
    this.dataWorker.on("completed", (job) => {
      this.logger.info(`\u2705 Job finalizat pentru CUI ${job.data.cui}, anul ${job.data.fiscalYear}`);
      this.checkAndScheduleNextYear(job);
    });
    this.dataWorker.on("failed", (job, error) => {
      if (job) {
        this.logger.error(`\u274C Eroare la job pentru CUI ${job.data.cui}, anul ${job.data.fiscalYear}: ${error.message}`);
      } else {
        this.logger.error(`\u274C Eroare la job: ${error.message}`);
      }
    });
    this.retryWorker.on("completed", (job) => {
      this.logger.info(`\u2705 Retry reu\u0219it pentru CUI ${job.data.cui}, anul ${job.data.fiscalYear}`);
    });
    this.retryWorker.on("failed", (job, error) => {
      if (job) {
        this.logger.error(`\u274C Retry e\u0219uat pentru CUI ${job.data.cui}, anul ${job.data.fiscalYear}: ${error.message}`);
      } else {
        this.logger.error(`\u274C Eroare la retry: ${error.message}`);
      }
    });
  }
  /**
   * Verifică și programează procesarea următorului an fiscal
   */
  async checkAndScheduleNextYear(job) {
    try {
      const { cui, fiscalYear, companyId, userId, jobId } = job.data;
      const dbJob = await this.getJobById(jobId);
      if (!dbJob.length) {
        this.logger.error(`\u26A0\uFE0F Nu s-a g\u0103sit job-ul ${jobId} \xEEn baza de date`);
        return;
      }
      const jobData = dbJob[0];
      const progress = Math.round((fiscalYear - jobData.startYear + 1) / jobData.totalYears * 100);
      if (fiscalYear >= jobData.endYear) {
        await this.financialDataService.updateJobStatus(jobId, "completed", 100);
        this.logger.info(`\u{1F3C1} Job complet pentru CUI ${cui}, anii ${jobData.startYear}-${jobData.endYear}`);
        if (userId) {
          await this.auditService.logEvent({
            eventType: "anaf_financial_job_completed",
            module: "anaf_financial_data",
            description: `Job complet pentru interogare bilan\u021Buri ANAF pentru CUI ${cui}, anii ${jobData.startYear}-${jobData.endYear}`,
            userId,
            companyId,
            entityId: cui,
            entityType: "company_cui",
            data: { cui, startYear: jobData.startYear, endYear: jobData.endYear }
          });
        }
        return;
      }
      const nextYear = fiscalYear + 1;
      await this.financialDataService.updateJobStatus(jobId, "pending", progress, nextYear);
      await this.addFetchJobToQueue({
        cui,
        fiscalYear: nextYear,
        companyId,
        userId,
        jobId
      });
    } catch (error) {
      if (error instanceof Error) {
        this.logger.error(`\u274C Eroare la verificarea \u0219i programarea urm\u0103torului an: ${error.message}`);
      } else {
        this.logger.error("\u274C Eroare necunoscut\u0103 la verificarea \u0219i programarea urm\u0103torului an");
      }
    }
  }
  /**
   * Procesează un job de interogare date financiare
   */
  async processJob(job) {
    try {
      const { cui, fiscalYear, companyId, userId, jobId } = job.data;
      const dbJob = await this.getJobById(jobId);
      if (!dbJob.length) {
        throw new Error(`Job ${jobId} not found in database`);
      }
      await this.financialDataService.fetchFinancialData(cui, fiscalYear, userId, companyId);
      await this.updateJobProgress(jobId, fiscalYear);
      return { success: true };
    } catch (error) {
      this.logger.error("Error processing job", error);
      throw error;
    }
  }
  /**
   * Procesează un job de reîncercare
   */
  async processRetryJob(job) {
    const { errorId, cui, fiscalYear, companyId } = job.data;
    this.logger.info(`\u{1F504} Re\xEEncercare pentru CUI ${cui}, anul ${fiscalYear}`);
    try {
      await this.financialDataService.incrementErrorRetryCount(errorId);
      const data = await this.financialDataService.fetchFinancialData(cui, fiscalYear, void 0, companyId);
      await this.financialDataService.markErrorAsResolved(errorId);
      return data;
    } catch (error) {
      if (error instanceof Error) {
        this.logger.error(`\u274C Re\xEEncercare e\u0219uat\u0103 pentru CUI ${cui}, anul ${fiscalYear}: ${error.message}`);
      } else {
        this.logger.error(`\u274C Eroare necunoscut\u0103 la re\xEEncercarea pentru CUI ${cui}, anul ${fiscalYear}`);
      }
      throw error;
    }
  }
  /**
   * Adaugă un job de interogare date financiare în coadă
   */
  async addFetchJobToQueue(jobData) {
    return await this.dataQueue.add(
      `fetch-${jobData.cui}-${jobData.fiscalYear}`,
      jobData,
      {
        removeOnComplete: 100,
        removeOnFail: 200
      }
    );
  }
  /**
   * Adaugă un job de reîncercare în coadă
   */
  async addRetryJobToQueue(jobData) {
    return await this.retryQueue.add(
      `retry-${jobData.cui}-${jobData.fiscalYear}`,
      jobData,
      {
        removeOnComplete: 100,
        removeOnFail: 200
      }
    );
  }
  /**
   * Creează un job pentru interogarea datelor financiare pentru toți anii disponibili
   */
  async createFinancialDataJob(cui, companyId, startYear, endYear, userId) {
    try {
      const job = await this.financialDataService.createFinancialDataJob(cui, companyId, startYear, endYear, userId);
      await this.addFetchJobToQueue({
        cui,
        fiscalYear: startYear,
        companyId,
        userId,
        jobId: job.id
      });
      return job;
    } catch (error) {
      if (error instanceof Error) {
        this.logger.error(`\u274C Eroare la crearea job-ului pentru CUI ${cui}: ${error.message}`);
      } else {
        this.logger.error(`\u274C Eroare necunoscut\u0103 la crearea job-ului pentru CUI ${cui}`);
      }
      throw error;
    }
  }
  /**
   * Procesează erorile nerezolvate
   */
  async processUnresolvedErrors() {
    try {
      const errors = await this.financialDataService.getUnresolvedErrors();
      this.logger.info(`\u{1F50D} Procesare ${errors.length} erori nerezolvate`);
      let processedCount = 0;
      for (const error of errors) {
        await this.addRetryJobToQueue({
          errorId: error.id,
          cui: error.cui,
          fiscalYear: error.fiscalYear,
          companyId: ""
          // In acest caz, companyId nu este esențial pentru reîncercare
        });
        processedCount++;
      }
      return processedCount;
    } catch (error) {
      if (error instanceof Error) {
        this.logger.error(`\u274C Eroare la procesarea erorilor nerezolvate: ${error.message}`);
      } else {
        this.logger.error("\u274C Eroare necunoscut\u0103 la procesarea erorilor nerezolvate");
      }
      return 0;
    }
  }
  /**
   * Închide conexiunile queue și workers
   */
  async close() {
    await this.dataWorker.close();
    await this.retryWorker.close();
    await this.dataQueue.close();
    await this.retryQueue.close();
    await this.redisClient.quit();
  }
  /**
   * Returnează starea curentă a cozilor
   */
  async getQueueStatus() {
    const [
      dataCounts,
      retryCounts,
      dataJobs,
      retryJobs
    ] = await Promise.all([
      this.dataQueue.getJobCounts(),
      this.retryQueue.getJobCounts(),
      this.dataQueue.getJobs(["active", "waiting", "delayed"], 0, 5),
      this.retryQueue.getJobs(["active", "waiting", "delayed"], 0, 5)
    ]);
    return {
      dataQueue: {
        counts: dataCounts,
        activeJobs: dataJobs.map((job) => ({
          id: job.id,
          name: job.name,
          data: job.data,
          state: job.status()
        }))
      },
      retryQueue: {
        counts: retryCounts,
        activeJobs: retryJobs.map((job) => ({
          id: job.id,
          name: job.name,
          data: job.data,
          state: job.status()
        }))
      }
    };
  }
  /**
   * Pornește un cron job pentru procesarea erorilor nerezolvate
   */
  startErrorProcessingCron(cronExpression = "0 */6 * * *") {
    this.logger.info(`\u{1F4C5} Cron job configurat pentru procesarea erorilor: ${cronExpression}`);
  }
  /**
   * Obține un job după ID
   */
  async getJobById(jobId) {
    return this.query(async (db4) => {
      return db4.select().from(financialDataJobs).where(eq36(financialDataJobs.id, jobId));
    });
  }
  /**
   * Actualizează progresul unui job
   */
  async updateJobProgress(jobId, currentYear) {
    try {
      const dbJob = await this.getJobById(jobId);
      if (!dbJob.length) {
        throw new Error(`Job ${jobId} not found in database`);
      }
      const jobData = dbJob[0];
      const progress = Math.round((currentYear - jobData.startYear + 1) / jobData.totalYears * 100);
      await this.financialDataService.updateJobStatus(jobId, "pending", progress, currentYear);
      this.logger.info(`\u{1F4CA} Progres actualizat pentru job ${jobId}: ${progress}% (anul ${currentYear})`);
    } catch (error) {
      this.logger.error(`\u274C Eroare la actualizarea progresului job-ului ${jobId}:`, error);
      throw error;
    }
  }
};

// server/modules/crm/controllers/financial-data.controller.ts
init_drizzle_service();
init_audit_service();
init_logger();
var logger39 = new Logger("FinancialDataController");
var CURRENT_YEAR2 = (/* @__PURE__ */ new Date()).getFullYear();
var FinancialDataController = class {
  constructor() {
    /**
     * Declanșează un job de interogare date financiare pentru o companie
     * @route POST /api/crm/financial-data/job
     */
    this.createFinancialDataJob = async (req, res) => {
      try {
        const user = req.user;
        if (!user || !user.id) {
          return res.status(401).json({ error: "Unauthorized" });
        }
        const validationResult = createFinancialDataJobSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Date invalide",
            details: validationResult.error.errors
          });
        }
        const { cui, companyId, startYear = 2014, endYear = CURRENT_YEAR2 } = validationResult.data;
        logger39.info(`Creare job pentru datele financiare ale companiei cu CUI ${cui}, perioada ${startYear}-${endYear}`);
        const job = await this.financialQueueService.createFinancialDataJob(
          cui,
          companyId,
          startYear,
          endYear,
          user.id
        );
        return res.status(201).json({
          success: true,
          job: {
            id: job.id,
            cui: job.cui,
            startYear: job.startYear,
            endYear: job.endYear,
            status: job.status,
            progress: job.progress,
            totalYears: job.totalYears,
            createdAt: job.createdAt
          },
          message: `Job creat pentru interogarea datelor financiare ale companiei cu CUI ${cui} pentru anii ${startYear}-${endYear}`
        });
      } catch (error) {
        logger39.error(`Eroare la crearea job-ului: ${error.message}`);
        return res.status(500).json({
          error: "Eroare intern\u0103",
          message: error.message
        });
      }
    };
    /**
     * Obține datele financiare pentru o companie și un an specific
     * @route GET /api/crm/financial-data/:cui/:year
     */
    this.getFinancialData = async (req, res) => {
      try {
        const { cui, year } = req.params;
        if (!cui || !year) {
          return res.status(400).json({ error: "CUI \u0219i anul sunt obligatorii" });
        }
        const fiscalYear = parseInt(year);
        if (isNaN(fiscalYear)) {
          return res.status(400).json({ error: "Anul trebuie s\u0103 fie un num\u0103r" });
        }
        logger39.info(`Interogare date financiare pentru CUI ${cui}, anul ${fiscalYear}`);
        const data = await this.financialDataService.getFinancialData(cui, fiscalYear);
        if (!data) {
          const user = req.user;
          if (user && user.id && user.companyId) {
            logger39.info(`Datele nu exist\u0103 \xEEn baza de date, interog\u0103m ANAF pentru CUI ${cui}, anul ${fiscalYear}`);
            try {
              const fetchedData = await this.financialDataService.fetchFinancialData(
                cui,
                fiscalYear,
                user.id,
                user.companyId
              );
              return res.json({
                success: true,
                data: fetchedData,
                source: "anaf"
              });
            } catch (error) {
              return res.status(404).json({
                error: "Date indisponibile",
                message: `Nu s-au putut ob\u021Bine datele financiare pentru CUI ${cui}, anul ${fiscalYear}`,
                details: error.message
              });
            }
          }
          return res.status(404).json({
            error: "Date indisponibile",
            message: `Nu exist\u0103 date financiare pentru CUI ${cui}, anul ${fiscalYear}`
          });
        }
        return res.json({
          success: true,
          data,
          source: "database"
        });
      } catch (error) {
        logger39.error(`Eroare la interogarea datelor financiare: ${error.message}`);
        return res.status(500).json({
          error: "Eroare intern\u0103",
          message: error.message
        });
      }
    };
    /**
     * Obține toate datele financiare pentru o companie
     * @route GET /api/crm/financial-data/:cui
     */
    this.getAllFinancialData = async (req, res) => {
      try {
        const { cui } = req.params;
        if (!cui) {
          return res.status(400).json({ error: "CUI-ul este obligatoriu" });
        }
        logger39.info(`Interogare toate datele financiare pentru CUI ${cui}`);
        const data = await this.financialDataService.getAllFinancialData(cui);
        return res.json({
          success: true,
          data,
          count: data.length
        });
      } catch (error) {
        logger39.error(`Eroare la interogarea tuturor datelor financiare: ${error.message}`);
        return res.status(500).json({
          error: "Eroare intern\u0103",
          message: error.message
        });
      }
    };
    /**
     * Obține starea curentă a cozilor de procesare a datelor financiare
     * @route GET /api/crm/financial-data/queue/status
     */
    this.getQueueStatus = async (req, res) => {
      try {
        logger39.info("Interogare stare cozi de procesare date financiare");
        const status = await this.financialQueueService.getQueueStatus();
        return res.json({
          success: true,
          status
        });
      } catch (error) {
        logger39.error(`Eroare la interogarea st\u0103rii cozilor: ${error.message}`);
        return res.status(500).json({
          error: "Eroare intern\u0103",
          message: error.message
        });
      }
    };
    /**
     * Declanșează procesarea erorilor nerezolvate
     * @route POST /api/crm/financial-data/errors/process
     */
    this.processErrors = async (req, res) => {
      try {
        logger39.info("Procesare erori nerezolvate");
        const count5 = await this.financialQueueService.processUnresolvedErrors();
        return res.json({
          success: true,
          message: `${count5} erori au fost programate pentru re\xEEncercare`
        });
      } catch (error) {
        logger39.error(`Eroare la procesarea erorilor: ${error.message}`);
        return res.status(500).json({
          error: "Eroare intern\u0103",
          message: error.message
        });
      }
    };
    /**
     * Obține statistici despre datele financiare
     * @route GET /api/crm/financial-data/stats
     */
    this.getFinancialDataStats = async (req, res) => {
      try {
        const user = req.user;
        const companyId = user?.companyId;
        logger39.info(`Interogare statistici date financiare${companyId ? ` pentru compania ${companyId}` : ""}`);
        const stats = await this.financialDataService.getFinancialDataStats(companyId);
        return res.json({
          success: true,
          stats
        });
      } catch (error) {
        logger39.error(`Eroare la interogarea statisticilor: ${error.message}`);
        return res.status(500).json({
          error: "Eroare intern\u0103",
          message: error.message
        });
      }
    };
    const db4 = new DrizzleService();
    const auditService4 = new AuditService();
    this.financialDataService = new FinancialDataService(auditService4);
    this.financialQueueService = new FinancialQueueService(db4, this.financialDataService, auditService4);
    logger39.info("FinancialDataController ini\u021Bializat");
  }
  /**
   * Înregistrează rutele controller-ului
   */
  registerRoutes(app2) {
    app2.post(
      "/api/crm/financial-data/job",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */, "accountant" /* ACCOUNTANT */]),
      this.createFinancialDataJob
    );
    app2.get(
      "/api/crm/financial-data/:cui/:year",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getFinancialData
    );
    app2.get(
      "/api/crm/financial-data/:cui",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getAllFinancialData
    );
    app2.get(
      "/api/crm/financial-data/queue/status",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.getQueueStatus
    );
    app2.post(
      "/api/crm/financial-data/errors/process",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["company_admin" /* COMPANY_ADMIN */, "admin" /* ADMIN */]),
      this.processErrors
    );
    app2.get(
      "/api/crm/financial-data/stats",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getFinancialDataStats
    );
    logger39.info("Rute \xEEnregistrate pentru FinancialDataController");
  }
};

// server/modules/crm/crm.module.ts
init_drizzle_service();
init_crm_schema();
init_auth_guard();
import { sql as sql28, eq as eq37, and as and32 } from "drizzle-orm";
init_logger();
init_audit_service();

// server/modules/crm/hooks/company-financial-data.hook.ts
init_drizzle_service();
init_logger();
var logger40 = new Logger("CompanyFinancialDataHook");
var CompanyFinancialDataHook = class {
  constructor(auditService4) {
    this.auditService = auditService4;
    const db4 = new DrizzleService();
    const financialDataService = new FinancialDataService(auditService4);
    this.financialQueueService = new FinancialQueueService(db4, financialDataService, auditService4);
    logger40.info("CompanyFinancialDataHook ini\u021Bializat");
  }
  /**
   * Declanșat după adăugarea unei noi companii
   */
  async onCompanyCreated(company) {
    try {
      if (!company || !company.cui) {
        logger40.warn("Company without CUI skipped");
        return;
      }
      logger40.info(`Companie nou\u0103 detectat\u0103: ${company.name}, CUI ${company.cui}`);
      const registrationYear = company.registrationDate ? new Date(company.registrationDate).getFullYear() : 2014;
      const startYear = Math.max(registrationYear, 2014);
      const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      await this.financialQueueService.createFinancialDataJob(
        company.cui,
        company.id,
        startYear,
        currentYear,
        company.createdBy
      );
      logger40.info(`Job programat pentru ob\u021Binerea datelor financiare ale companiei ${company.name}, anii ${startYear}-${currentYear}`);
    } catch (error) {
      logger40.error(`Eroare la programarea job-ului pentru datele financiare: ${error.message}`);
    }
  }
  /**
   * Declanșat după actualizarea CUI-ului unei companii
   */
  async onCompanyCuiUpdated(company, oldCui) {
    try {
      if (!company || !company.cui || company.cui === oldCui) {
        return;
      }
      logger40.info(`CUI actualizat pentru compania ${company.name}: ${oldCui} -> ${company.cui}`);
      const registrationYear = company.registrationDate ? new Date(company.registrationDate).getFullYear() : 2014;
      const startYear = Math.max(registrationYear, 2014);
      const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      await this.financialQueueService.createFinancialDataJob(
        company.cui,
        company.id,
        startYear,
        currentYear,
        company.updatedBy
      );
      logger40.info(`Job programat pentru ob\u021Binerea datelor financiare ale companiei actualizate ${company.name}, anii ${startYear}-${currentYear}`);
    } catch (error) {
      logger40.error(`Eroare la programarea job-ului pentru datele financiare dup\u0103 actualizarea CUI: ${error.message}`);
    }
  }
  /**
   * Programează procesarea erorilor nerezolvate periodic
   */
  startErrorProcessingScheduler() {
    const processErrors = async () => {
      try {
        logger40.info("Procesare programat\u0103 a erorilor nerezolvate");
        await this.financialQueueService.processUnresolvedErrors();
      } catch (error) {
        logger40.error(`Eroare la procesarea programat\u0103 a erorilor: ${error.message}`);
      }
    };
    processErrors();
    setInterval(processErrors, 6 * 60 * 60 * 1e3);
    logger40.info("Procesarea erorilor programat\u0103 la fiecare 6 ore");
  }
};

// server/modules/crm/crm.module.ts
var logger41 = new Logger("CrmModule");
var CrmModule = class _CrmModule {
  constructor(db4) {
    this.db = db4;
    logger41.info("Initializing CRM Module with DrizzleService");
    const customerService2 = new CustomerService(this.db);
    const auditService4 = new AuditService(this.db);
    this.customerController = new CustomerController2(customerService2);
    this.dealController = new DealController();
    this.salesController = new SalesController();
    this.activityController = new ActivityController();
    this.contactController = new ContactController();
    this.pipelineController = new PipelineController();
    this.companyController = new CompanyController(this.db);
    this.financialDataController = new FinancialDataController();
    this.companyFinancialDataHook = new CompanyFinancialDataHook(this.db, auditService4);
    this.jwtService = new JwtService();
  }
  /**
   * Register the CRM module with the Express application
   */
  static register(app2, drizzleService5) {
    const module = new _CrmModule(drizzleService5 || new DrizzleService());
    module.initialize(app2);
  }
  /**
   * Initialize the CRM module
   */
  initialize(app2) {
    console.log("\u{1F4CA} Initializing CRM Module");
    this.customerController.registerRoutes(app2, this.jwtService);
    this.dealController.registerRoutes(app2, this.jwtService);
    this.salesController.registerRoutes(app2, this.jwtService);
    this.activityController.registerRoutes(app2, this.jwtService);
    this.contactController.registerRoutes(app2, this.jwtService);
    this.pipelineController.registerRoutes(app2, this.jwtService);
    this.companyController.registerRoutes(app2, this.jwtService);
    this.registerAnafRoutes(app2);
    this.financialDataController.registerRoutes(app2);
    this.companyFinancialDataHook.startErrorProcessingScheduler();
    this.initializeDashboardRoutes(app2);
    console.log("\u{1F4CA} CRM Module controllers initialized successfully");
  }
  /**
   * Register ANAF API routes
   */
  registerAnafRoutes(app2) {
    app2.post(
      "/api/crm/anaf-proxy",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => anafController.proxyAnafRequest(req, res)
    );
    app2.get(
      "/api/crm/company/:cui",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => anafController.getCompanyData(req, res)
    );
    app2.post(
      "/api/crm/companies/batch",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => anafController.batchGetCompanies(req, res)
    );
    console.log("\u{1F3E2} ANAF API routes registered at /api/crm/anaf-proxy, /api/crm/company/:cui, and /api/crm/companies/batch");
  }
  /**
   * Initialize dashboard routes for CRM insights
   */
  initializeDashboardRoutes(app2) {
    app2.get(
      "/api/crm/dashboard",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */, "sales_agent" /* SALES_AGENT */]),
      async (req, res) => {
        try {
          const { user } = req;
          if (!user || !user.companyId) {
            return res.status(401).json({ message: "Unauthorized" });
          }
          const customersCount = await this.getCustomersCount(user.companyId);
          const dealsCount = await this.getDealsCount(user.companyId);
          const openDealsValue = await this.getOpenDealsValue(user.companyId);
          const activitiesCount = await this.getActivitiesCount(user.companyId);
          return res.json({
            metrics: {
              customers: customersCount,
              deals: dealsCount,
              openDealsValue,
              activities: activitiesCount
            },
            // Additional data would be included here
            lastUpdated: /* @__PURE__ */ new Date()
          });
        } catch (error) {
          console.error("Error getting CRM dashboard data:", error);
          return res.status(500).json({
            message: "Failed to get dashboard data",
            error: error.message
          });
        }
      }
    );
  }
  /**
   * Get the count of customers
   */
  async getCustomersCount(companyId) {
    const result = await this.db.select({
      count: sql28`COUNT(*)`
    }).from(customers).where(and32(
      eq37(customers.companyId, companyId),
      eq37(customers.isActive, true)
    ));
    return Number(result[0]?.count || 0);
  }
  /**
   * Get the count of deals
   */
  async getDealsCount(companyId) {
    const result = await this.db.select({
      count: sql28`COUNT(*)`
    }).from(deals).where(and32(
      eq37(deals.companyId, companyId),
      eq37(deals.isActive, true)
    ));
    return Number(result[0]?.count || 0);
  }
  /**
   * Get the sum value of open deals
   */
  async getOpenDealsValue(companyId) {
    const result = await this.db.select({
      sum: sql28`SUM(CAST(${deals.amount} AS NUMERIC))`
    }).from(deals).where(and32(
      eq37(deals.companyId, companyId),
      eq37(deals.status, "open"),
      eq37(deals.isActive, true)
    ));
    return Number(result[0]?.sum || 0);
  }
  /**
   * Get the count of activities
   */
  async getActivitiesCount(companyId) {
    const result = await this.db.select({
      count: sql28`COUNT(*)`
    }).from(activities).where(and32(
      eq37(activities.companyId, companyId),
      eq37(activities.status, "pending")
    ));
    return Number(result[0]?.count || 0);
  }
};
function initCrmModule(app2, drizzleService5) {
  CrmModule.register(app2, drizzleService5);
}

// server/modules/hr/hr.module.ts
init_drizzle();
import { Router as Router14 } from "express";

// server/modules/hr/services/payroll.service.ts
init_drizzle();
init_audit_service();
import { v4 as uuidv410 } from "uuid";
import { sql as sql29 } from "drizzle-orm";
var PayrollService = class {
  constructor() {
    this.db = getDrizzle();
  }
  /**
   * Calculate payroll for a specific employee
   * 
   * @param employeeId Employee ID
   * @param companyId Company ID
   * @param year Year for calculation
   * @param month Month for calculation (1-12)
   * @param userId User ID performing the action
   */
  async calculateEmployeePayroll(employeeId, companyId, year, month, userId) {
    try {
      const employee = await this.db.execute(
        sql29`SELECT e.*, ec.base_salary_gross, ec.contract_type 
            FROM hr_employees e
            JOIN hr_employment_contracts ec ON e.id = ec.employee_id
            WHERE e.id = ${employeeId} AND e.company_id = ${companyId}`
      );
      if (!employee.rows || employee.rows.length === 0) {
        throw new Error("Employee not found");
      }
      const employeeData = employee.rows[0];
      const grossSalary = parseFloat(employeeData.base_salary_gross);
      const casEmployeeAmount = grossSalary * 0.25;
      const cassEmployeeAmount = grossSalary * 0.1;
      const personalDeduction = 600;
      const taxableIncome = grossSalary - casEmployeeAmount - cassEmployeeAmount - personalDeduction;
      const incomeTaxAmount = Math.max(0, taxableIncome * 0.1);
      const netSalary = grossSalary - casEmployeeAmount - cassEmployeeAmount - incomeTaxAmount;
      const camEmployerAmount = grossSalary * 0.0225;
      const payrollId = uuidv410();
      await this.db.execute(
        sql29`INSERT INTO hr_payroll_logs (
          id, company_id, employee_id, year, month, 
          gross_total, cas_employee_amount, cass_employee_amount, 
          income_tax_amount, personal_deduction_amount, net_salary,
          cam_employer_amount, status, created_by
        ) VALUES (
          ${payrollId}, ${companyId}, ${employeeId}, ${year}, ${month}, 
          ${grossSalary}, ${casEmployeeAmount}, ${cassEmployeeAmount}, 
          ${incomeTaxAmount}, ${personalDeduction}, ${netSalary},
          ${camEmployerAmount}, 'calculated', ${userId}
        )`
      );
      await audit_service_default.log({
        userId,
        companyId,
        action: "create" /* CREATE */,
        entity: "PAYROLL",
        entityId: payrollId,
        details: {
          employeeId,
          year,
          month,
          grossTotal: grossSalary,
          netSalary
        }
      });
      return {
        id: payrollId,
        employeeId,
        year,
        month,
        grossTotal: grossSalary,
        netSalary,
        status: "calculated"
      };
    } catch (error) {
      console.error("Error calculating payroll:", error);
      throw new Error(`Failed to calculate payroll: ${error.message}`);
    }
  }
  /**
   * Process payroll for all active employees in a company
   * 
   * @param companyId Company ID
   * @param year Year for processing
   * @param month Month for processing (1-12)
   * @param userId User ID performing the action
   */
  async processCompanyPayroll(companyId, year, month, userId) {
    try {
      const activeEmployees = await this.db.execute(
        sql29`SELECT e.id 
            FROM hr_employees e
            JOIN hr_employment_contracts ec ON e.id = ec.employee_id
            WHERE e.company_id = ${companyId} 
            AND e.is_active = true
            AND ec.status = 'active'`
      );
      if (!activeEmployees.rows || activeEmployees.rows.length === 0) {
        return { processed: 0, message: "No active employees found" };
      }
      const results = [];
      for (const employee of activeEmployees.rows) {
        try {
          const payrollResult = await this.calculateEmployeePayroll(
            employee.id,
            companyId,
            year,
            month,
            userId
          );
          results.push(payrollResult);
        } catch (employeeError) {
          console.error(`Error processing payroll for employee ${employee.id}:`, employeeError);
        }
      }
      return {
        processed: results.length,
        total: activeEmployees.rows.length,
        results
      };
    } catch (error) {
      console.error("Error processing company payroll:", error);
      throw new Error(`Failed to process company payroll: ${error.message}`);
    }
  }
  /**
   * Approve a calculated payroll record
   * 
   * @param payrollId Payroll record ID
   * @param userId User ID performing the approval
   */
  async approvePayroll(payrollId, userId) {
    try {
      const payroll = await this.db.execute(
        sql29`SELECT * FROM hr_payroll_logs WHERE id = ${payrollId}`
      );
      if (!payroll.rows || payroll.rows.length === 0) {
        throw new Error("Payroll record not found");
      }
      if (payroll.rows[0].status !== "calculated") {
        throw new Error(`Cannot approve payroll in ${payroll.rows[0].status} status`);
      }
      await this.db.execute(
        sql29`UPDATE hr_payroll_logs
            SET status = 'approved', 
                approved_by = ${userId}, 
                approved_at = NOW(), 
                updated_by = ${userId}, 
                updated_at = NOW()
            WHERE id = ${payrollId}`
      );
      await audit_service_default.log({
        userId,
        companyId: payroll.rows[0].company_id,
        action: "update" /* UPDATE */,
        entity: "PAYROLL",
        entityId: payrollId,
        details: {
          status: "approved",
          payrollId
        }
      });
      return {
        id: payrollId,
        status: "approved",
        message: "Payroll approved successfully"
      };
    } catch (error) {
      console.error("Error approving payroll:", error);
      throw new Error(`Failed to approve payroll: ${error.message}`);
    }
  }
  /**
   * Get payroll details for an employee
   * 
   * @param employeeId Employee ID
   * @param year Year (optional)
   * @param month Month (optional)
   */
  async getEmployeePayroll(employeeId, year, month) {
    try {
      let querySQL;
      if (year && month) {
        querySQL = sql29`
          SELECT pl.*, e.first_name, e.last_name
          FROM hr_payroll_logs pl
          JOIN hr_employees e ON pl.employee_id = e.id
          WHERE pl.employee_id = ${employeeId}
          AND pl.year = ${year}
          AND pl.month = ${month}
          ORDER BY pl.year DESC, pl.month DESC
        `;
      } else if (year) {
        querySQL = sql29`
          SELECT pl.*, e.first_name, e.last_name
          FROM hr_payroll_logs pl
          JOIN hr_employees e ON pl.employee_id = e.id
          WHERE pl.employee_id = ${employeeId}
          AND pl.year = ${year}
          ORDER BY pl.year DESC, pl.month DESC
        `;
      } else {
        querySQL = sql29`
          SELECT pl.*, e.first_name, e.last_name
          FROM hr_payroll_logs pl
          JOIN hr_employees e ON pl.employee_id = e.id
          WHERE pl.employee_id = ${employeeId}
          ORDER BY pl.year DESC, pl.month DESC
        `;
      }
      const payrollRecords = await this.db.execute(querySQL);
      return payrollRecords.rows || [];
    } catch (error) {
      console.error("Error retrieving employee payroll:", error);
      throw new Error(`Failed to retrieve employee payroll: ${error.message}`);
    }
  }
  /**
   * Get payroll summary for a company in a specific period
   * 
   * @param companyId Company ID
   * @param year Year for summary
   * @param month Month for summary (optional)
   */
  async getCompanyPayrollSummary(companyId, year, month) {
    try {
      let query = `
        SELECT 
          COUNT(*) as employee_count,
          SUM(gross_total) as total_gross,
          SUM(net_salary) as total_net,
          SUM(cas_employee_amount) as total_cas_employee,
          SUM(cass_employee_amount) as total_cass_employee,
          SUM(income_tax_amount) as total_income_tax,
          SUM(cam_employer_amount) as total_cam_employer
        FROM hr_payroll_logs
        WHERE company_id = $1 AND year = $2
      `;
      const params = [companyId, year];
      if (month) {
        query += ` AND month = $${params.length + 1}`;
        params.push(month);
      }
      const summary = await this.db.query(query, params);
      if (!summary.rows || summary.rows.length === 0) {
        return {
          employeeCount: 0,
          totalGross: 0,
          totalNet: 0,
          totalCasEmployee: 0,
          totalCassEmployee: 0,
          totalIncomeTax: 0,
          totalCamEmployer: 0
        };
      }
      return {
        employeeCount: parseInt(summary.rows[0].employee_count) || 0,
        totalGross: parseFloat(summary.rows[0].total_gross) || 0,
        totalNet: parseFloat(summary.rows[0].total_net) || 0,
        totalCasEmployee: parseFloat(summary.rows[0].total_cas_employee) || 0,
        totalCassEmployee: parseFloat(summary.rows[0].total_cass_employee) || 0,
        totalIncomeTax: parseFloat(summary.rows[0].total_income_tax) || 0,
        totalCamEmployer: parseFloat(summary.rows[0].total_cam_employer) || 0
      };
    } catch (error) {
      console.error("Error retrieving company payroll summary:", error);
      throw new Error(`Failed to retrieve company payroll summary: ${error.message}`);
    }
  }
};

// server/modules/hr/services/absence.service.ts
init_drizzle();
init_audit_service();
import { v4 as uuidv411 } from "uuid";
var AbsenceService = class {
  constructor() {
    this.db = getDrizzle();
    this.auditService = new AuditService();
  }
  /**
   * Request a new absence period for an employee
   * 
   * @param employeeId Employee ID
   * @param companyId Company ID
   * @param startDate Start date of absence
   * @param endDate End date of absence
   * @param type Type of absence
   * @param description Optional description
   * @param medicalCertificateNumber Medical certificate number (for medical leave)
   * @param userId User ID requesting the absence
   */
  async requestAbsence(employeeId, companyId, startDate, endDate, type, description, medicalCertificateNumber, medicalCertificateFilePath, userId) {
    try {
      const totalDays = this.calculateBusinessDays(startDate, endDate, type);
      if (startDate > endDate) {
        throw new Error("Start date cannot be after end date");
      }
      if (totalDays <= 0) {
        throw new Error("Invalid absence period");
      }
      const overlappingAbsences = await this.db.query(
        `SELECT * FROM hr_absences 
         WHERE employee_id = $1 
         AND status IN ('requested', 'approved')
         AND ((start_date <= $2 AND end_date >= $2) 
           OR (start_date <= $3 AND end_date >= $3)
           OR (start_date >= $2 AND end_date <= $3))`,
        [employeeId, startDate, endDate]
      );
      if (overlappingAbsences.rows && overlappingAbsences.rows.length > 0) {
        throw new Error("Overlapping absence already exists");
      }
      if (type === "medical" /* MEDICAL */ && !medicalCertificateNumber) {
        throw new Error("Medical certificate number is required for medical leave");
      }
      const absenceId = uuidv411();
      await this.db.query(
        `INSERT INTO hr_absences (
          id, company_id, employee_id, start_date, end_date,
          type, description, total_days, status,
          medical_certificate_number, medical_certificate_file_path,
          created_by
        ) VALUES (
          $1, $2, $3, $4, $5,
          $6, $7, $8, $9,
          $10, $11,
          $12
        )`,
        [
          absenceId,
          companyId,
          employeeId,
          startDate,
          endDate,
          type,
          description,
          totalDays,
          "requested" /* REQUESTED */,
          medicalCertificateNumber,
          medicalCertificateFilePath,
          userId
        ]
      );
      await this.auditService.logAction({
        userId,
        action: "create" /* CREATE */,
        resourceType: "absence" /* ABSENCE */,
        resourceId: absenceId,
        metadata: {
          employeeId,
          companyId,
          type,
          startDate: typeof startDate === "string" ? startDate : startDate.toISOString(),
          endDate: typeof endDate === "string" ? endDate : endDate.toISOString(),
          totalDays,
          status: "requested" /* REQUESTED */
        }
      });
      return {
        id: absenceId,
        employeeId,
        startDate,
        endDate,
        type,
        totalDays,
        status: "requested" /* REQUESTED */
      };
    } catch (error) {
      console.error("Error requesting absence:", error);
      throw new Error(`Failed to request absence: ${error.message}`);
    }
  }
  /**
   * Calculate business days between two dates
   * For certain absence types like vacation, we exclude weekends
   * For others like medical leave, we count all calendar days
   * 
   * @param startDate Start date
   * @param endDate End date
   * @param type Absence type
   * @returns Number of business days
   */
  calculateBusinessDays(startDate, endDate, type) {
    const countAllDays = [
      "medical" /* MEDICAL */,
      "maternity" /* MATERNITY */,
      "paternity" /* PATERNITY */,
      "childcare" /* CHILDCARE */
    ].includes(type);
    if (countAllDays) {
      const diffTime = Math.abs(endDate.getTime() - startDate.getTime());
      return Math.ceil(diffTime / (1e3 * 60 * 60 * 24)) + 1;
    } else {
      let count5 = 0;
      const curDate = new Date(startDate.getTime());
      while (curDate <= endDate) {
        const dayOfWeek = curDate.getDay();
        if (dayOfWeek !== 0 && dayOfWeek !== 6) count5++;
        curDate.setDate(curDate.getDate() + 1);
      }
      return count5;
    }
  }
  /**
   * Approve or reject an absence request
   * 
   * @param absenceId Absence ID
   * @param approved Whether to approve (true) or reject (false)
   * @param comment Optional comment
   * @param userId User ID performing the action
   */
  async reviewAbsence(absenceId, approved, comment, userId) {
    try {
      const absence = await this.db.query(
        `SELECT * FROM hr_absences WHERE id = $1`,
        [absenceId]
      );
      if (!absence.rows || absence.rows.length === 0) {
        throw new Error("Absence record not found");
      }
      if (absence.rows[0].status !== "requested" /* REQUESTED */) {
        throw new Error(`Cannot review absence in ${absence.rows[0].status} status`);
      }
      const newStatus = approved ? "approved" /* APPROVED */ : "rejected" /* REJECTED */;
      await this.db.query(
        `UPDATE hr_absences
         SET status = $1, review_comment = $2, reviewed_by = $3, reviewed_at = NOW(), updated_by = $3, updated_at = NOW()
         WHERE id = $4`,
        [newStatus, comment, userId, absenceId]
      );
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "absence" /* ABSENCE */,
        resourceId: absenceId,
        metadata: {
          absenceId,
          status: newStatus,
          comment
        }
      });
      return {
        id: absenceId,
        status: newStatus,
        message: approved ? "Absence approved successfully" : "Absence rejected",
        comment
      };
    } catch (error) {
      console.error("Error reviewing absence:", error);
      throw new Error(`Failed to review absence: ${error.message}`);
    }
  }
  /**
   * Cancel an existing absence
   * 
   * @param absenceId Absence ID
   * @param reason Cancellation reason
   * @param userId User ID performing the cancellation
   */
  async cancelAbsence(absenceId, reason, userId) {
    try {
      const absence = await this.db.query(
        `SELECT * FROM hr_absences WHERE id = $1`,
        [absenceId]
      );
      if (!absence.rows || absence.rows.length === 0) {
        throw new Error("Absence record not found");
      }
      if (!["requested" /* REQUESTED */, "approved" /* APPROVED */].includes(absence.rows[0].status)) {
        throw new Error(`Cannot cancel absence in ${absence.rows[0].status} status`);
      }
      await this.db.query(
        `UPDATE hr_absences
         SET status = $1, cancellation_reason = $2, cancelled_by = $3, cancelled_at = NOW(), updated_by = $3, updated_at = NOW()
         WHERE id = $4`,
        ["cancelled" /* CANCELLED */, reason, userId, absenceId]
      );
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "absence" /* ABSENCE */,
        resourceId: absenceId,
        metadata: {
          absenceId,
          status: "cancelled" /* CANCELLED */,
          reason
        }
      });
      return {
        id: absenceId,
        status: "cancelled" /* CANCELLED */,
        message: "Absence cancelled successfully",
        reason
      };
    } catch (error) {
      console.error("Error cancelling absence:", error);
      throw new Error(`Failed to cancel absence: ${error.message}`);
    }
  }
  /**
   * Get absences for an employee
   * 
   * @param employeeId Employee ID
   * @param year Optional year filter
   * @param status Optional status filter
   */
  async getEmployeeAbsences(employeeId, year, status) {
    try {
      let query = `
        SELECT a.*, e.first_name, e.last_name
        FROM hr_absences a
        JOIN hr_employees e ON a.employee_id = e.id
        WHERE a.employee_id = $1
      `;
      const params = [employeeId];
      if (year) {
        query += ` AND EXTRACT(YEAR FROM a.start_date) = $${params.length + 1}`;
        params.push(year);
      }
      if (status) {
        query += ` AND a.status = $${params.length + 1}`;
        params.push(status);
      }
      query += ` ORDER BY a.start_date DESC`;
      const absences2 = await this.db.query(query, params);
      return absences2.rows || [];
    } catch (error) {
      console.error("Error retrieving employee absences:", error);
      throw new Error(`Failed to retrieve employee absences: ${error.message}`);
    }
  }
  /**
   * Calculate remaining vacation days for an employee
   * 
   * @param employeeId Employee ID
   * @param year Year for calculation
   */
  async calculateRemainingVacationDays(employeeId, year) {
    try {
      const employeeContract = await this.db.query(
        `SELECT ec.annual_vacation_days 
         FROM hr_employment_contracts ec
         WHERE ec.employee_id = $1 AND ec.status = 'active'`,
        [employeeId]
      );
      if (!employeeContract.rows || employeeContract.rows.length === 0) {
        throw new Error("No active contract found for employee");
      }
      const totalVacationDays = parseInt(employeeContract.rows[0].annual_vacation_days) || 0;
      const usedDays = await this.db.query(
        `SELECT SUM(total_days) as used_days
         FROM hr_absences
         WHERE employee_id = $1 
         AND type = $2
         AND status = $3
         AND EXTRACT(YEAR FROM start_date) = $4`,
        [employeeId, "vacation" /* VACATION */, "approved" /* APPROVED */, year]
      );
      const usedVacationDays = parseInt(usedDays.rows[0]?.used_days) || 0;
      return {
        employeeId,
        year,
        totalVacationDays,
        usedVacationDays,
        remainingVacationDays: totalVacationDays - usedVacationDays
      };
    } catch (error) {
      console.error("Error calculating remaining vacation days:", error);
      throw new Error(`Failed to calculate remaining vacation days: ${error.message}`);
    }
  }
  /**
   * Get a list of upcoming absences for a company
   * 
   * @param companyId Company ID
   * @param days Number of days to look ahead
   */
  async getUpcomingCompanyAbsences(companyId, days = 30) {
    try {
      const now = /* @__PURE__ */ new Date();
      const endDate = /* @__PURE__ */ new Date();
      endDate.setDate(now.getDate() + days);
      const absences2 = await this.db.query(
        `SELECT a.*, e.first_name, e.last_name, e.position, d.name as department_name
         FROM hr_absences a
         JOIN hr_employees e ON a.employee_id = e.id
         LEFT JOIN hr_departments d ON e.department_id = d.id
         WHERE a.company_id = $1 
         AND a.status = $2
         AND a.start_date <= $4
         AND a.end_date >= $3
         ORDER BY a.start_date ASC`,
        [companyId, "approved" /* APPROVED */, now, endDate]
      );
      return absences2.rows || [];
    } catch (error) {
      console.error("Error retrieving upcoming company absences:", error);
      throw new Error(`Failed to retrieve upcoming company absences: ${error.message}`);
    }
  }
};

// server/modules/hr/services/revisal.service.ts
init_drizzle();
init_audit_service();
import { v4 as uuidv412 } from "uuid";
var RevisalService = class {
  constructor() {
    this.db = getDrizzle();
    this.auditService = new AuditService();
  }
  /**
   * Generate a REVISAL export file for new/modified contracts
   * 
   * @param companyId Company ID
   * @param exportType Type of REVISAL export
   * @param employeeIds Optional array of employee IDs to include
   * @param userId User ID performing the export
   */
  async generateRevisalExport(companyId, exportType, employeeIds, userId) {
    try {
      let query = `
        SELECT 
          e.*,
          ec.*
        FROM hr_employees e
        JOIN hr_employment_contracts ec ON e.id = ec.employee_id
        WHERE e.company_id = $1
      `;
      const params = [companyId];
      if (employeeIds && employeeIds.length > 0) {
        query += ` AND e.id IN (${employeeIds.map((_, idx) => `$${params.length + idx + 1}`).join(",")})`;
        params.push(...employeeIds);
      }
      const employees2 = await this.db.query(query, params);
      if (!employees2.rows || employees2.rows.length === 0) {
        throw new Error("No employees found for REVISAL export");
      }
      const exportId = uuidv412();
      const exportLog = await this.db.query(
        `INSERT INTO hr_revisal_export_logs (
          id, company_id, export_type, employee_count, status,
          created_by
        ) VALUES (
          $1, $2, $3, $4, $5,
          $6
        ) RETURNING *`,
        [
          exportId,
          companyId,
          exportType,
          employees2.rows.length,
          "pending" /* PENDING */,
          userId
        ]
      );
      await this.auditService.logAction({
        userId,
        action: "create" /* CREATE */,
        resourceType: "revisal_export" /* REVISAL_EXPORT */,
        resourceId: exportId,
        metadata: {
          companyId,
          exportType,
          employeeCount: employees2.rows.length
        }
      });
      const revisalXml = this.generateRevisalXmlContent(employees2.rows, exportType);
      await this.db.query(
        `UPDATE hr_revisal_export_logs
         SET revisal_xml = $1, status = $2, completed_at = NOW(), updated_by = $3, updated_at = NOW()
         WHERE id = $4`,
        [revisalXml, "completed" /* COMPLETED */, userId, exportId]
      );
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "revisal_export" /* REVISAL_EXPORT */,
        resourceId: exportId,
        metadata: {
          status: "completed" /* COMPLETED */,
          xmlLength: revisalXml.length
        }
      });
      return {
        id: exportId,
        exportType,
        employeeCount: employees2.rows.length,
        status: "completed" /* COMPLETED */,
        revisalXml
      };
    } catch (error) {
      console.error("Error generating REVISAL export:", error);
      if (error.exportId) {
        await this.db.query(
          `UPDATE hr_revisal_export_logs
           SET status = $1, error_message = $2, updated_by = $3, updated_at = NOW()
           WHERE id = $4`,
          ["failed" /* FAILED */, error.message, userId, error.exportId]
        );
        await this.auditService.logAction({
          userId,
          action: "update" /* UPDATE */,
          resourceType: "revisal_export" /* REVISAL_EXPORT */,
          resourceId: error.exportId,
          metadata: {
            status: "failed" /* FAILED */,
            error: error.message
          }
        });
      }
      throw new Error(`Failed to generate REVISAL export: ${error.message}`);
    }
  }
  /**
   * Generate REVISAL XML content based on employees and export type
   * This implementation follows the XML structure required by Romania's REVISAL system
   * 
   * @param employees Array of employee and contract data
   * @param exportType Type of REVISAL export
   * @returns XML content as string
   */
  generateRevisalXmlContent(employees2, exportType) {
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += '<revisal xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n';
    xml += "  <header>\n";
    xml += `    <data_export>${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}</data_export>
`;
    xml += "    <ore_export>12:00</ore_export>\n";
    xml += `    <tip_export>${this.getRevisalExportTypeCode(exportType)}</tip_export>
`;
    xml += "  </header>\n";
    xml += "  <angajator>\n";
    xml += "    <cif_cui>12345678</cif_cui>\n";
    xml += "    <denumire>COMPANY NAME SRL</denumire>\n";
    xml += "  </angajator>\n";
    xml += "  <salariati>\n";
    employees2.forEach((employee) => {
      xml += "    <salariat>\n";
      xml += "      <date_personale>\n";
      xml += `        <cnp>${employee.cnp}</cnp>
`;
      xml += `        <nume>${employee.last_name}</nume>
`;
      xml += `        <prenume>${employee.first_name}</prenume>
`;
      xml += `        <nationalitate>${employee.nationality || "Rom\xE2n\u0103"}</nationalitate>
`;
      xml += "      </date_personale>\n";
      xml += "      <contract>\n";
      xml += `        <numar_contract>${employee.contract_number}</numar_contract>
`;
      xml += `        <data_contract>${new Date(employee.contract_start_date).toISOString().split("T")[0]}</data_contract>
`;
      xml += `        <tip_contract>${this.getContractTypeCode(employee.contract_type)}</tip_contract>
`;
      xml += `        <data_inceput>${new Date(employee.start_date).toISOString().split("T")[0]}</data_inceput>
`;
      if (employee.end_date) {
        xml += `        <data_sfarsit>${new Date(employee.end_date).toISOString().split("T")[0]}</data_sfarsit>
`;
      }
      xml += `        <durata_contract>${employee.is_indefinite ? "nedeterminata" : "determinata"}</durata_contract>
`;
      xml += `        <norma>${this.getWorkingTimeCode(employee.working_time)}</norma>
`;
      xml += `        <stare_contract>${this.getContractStatusCode(employee.status)}</stare_contract>
`;
      xml += `        <cod_cor>${employee.cor_code}</cod_cor>
`;
      xml += `        <salariu_de_baza>${employee.base_salary_gross}</salariu_de_baza>
`;
      xml += "      </contract>\n";
      xml += "    </salariat>\n";
    });
    xml += "  </salariati>\n";
    xml += "</revisal>";
    return xml;
  }
  /**
   * Map REVISAL export type to the required code
   * 
   * @param exportType Export type enum
   * @returns REVISAL code
   */
  getRevisalExportTypeCode(exportType) {
    const codeMap = {
      ["initial_registration" /* INITIAL_REGISTRATION */]: "1",
      ["contract_addition" /* CONTRACT_ADDITION */]: "2",
      ["contract_modification" /* CONTRACT_MODIFICATION */]: "3",
      ["contract_suspension" /* CONTRACT_SUSPENSION */]: "4",
      ["contract_termination" /* CONTRACT_TERMINATION */]: "5",
      ["company_modification" /* COMPANY_MODIFICATION */]: "6"
    };
    return codeMap[exportType] || "1";
  }
  /**
   * Map contract type to REVISAL code
   * 
   * @param contractType Contract type
   * @returns REVISAL code
   */
  getContractTypeCode(contractType) {
    const typeMap = {
      "standard": "1",
      // Contract individual de muncă
      "part_time": "2",
      // Contract de muncă cu timp parțial
      "temporary": "3",
      // Contract de muncă temporară
      "internship": "4",
      // Contract de stagiu
      "apprenticeship": "5",
      // Contract de ucenicie
      "home_based": "6"
      // Telemuncă
    };
    return typeMap[contractType] || "1";
  }
  /**
   * Map working time to REVISAL code
   * 
   * @param workingTime Working time string
   * @returns REVISAL code
   */
  getWorkingTimeCode(workingTime) {
    if (workingTime === "full_time") {
      return "1";
    } else {
      const hours = workingTime.match(/part_time_(\d+)/);
      if (hours && hours[1]) {
        return hours[1];
      }
      return "2";
    }
  }
  /**
   * Map contract status to REVISAL code
   * 
   * @param status Contract status
   * @returns REVISAL code
   */
  getContractStatusCode(status) {
    const statusMap = {
      "active": "1",
      // Activ
      "suspended": "2",
      // Suspendat
      "terminated": "3",
      // Încetat
      "transferred": "4"
      // Transferat
    };
    return statusMap[status] || "1";
  }
  /**
   * Get REVISAL export logs for a company
   * 
   * @param companyId Company ID
   * @param limit Optional limit of records to return
   */
  async getRevisalExportLogs(companyId, limit = 50) {
    try {
      const logs = await this.db.query(
        `SELECT * FROM hr_revisal_export_logs
         WHERE company_id = $1
         ORDER BY created_at DESC
         LIMIT $2`,
        [companyId, limit]
      );
      return logs.rows || [];
    } catch (error) {
      console.error("Error retrieving REVISAL export logs:", error);
      throw new Error(`Failed to retrieve REVISAL export logs: ${error.message}`);
    }
  }
  /**
   * Get a specific REVISAL export log by ID
   * 
   * @param exportId Export log ID
   */
  async getRevisalExportById(exportId) {
    try {
      const log2 = await this.db.query(
        `SELECT * FROM hr_revisal_export_logs
         WHERE id = $1`,
        [exportId]
      );
      if (!log2.rows || log2.rows.length === 0) {
        throw new Error("REVISAL export log not found");
      }
      return log2.rows[0];
    } catch (error) {
      console.error("Error retrieving REVISAL export log:", error);
      throw new Error(`Failed to retrieve REVISAL export log: ${error.message}`);
    }
  }
};

// server/modules/hr/services/commission.service.ts
init_drizzle();
init_audit_service();
import { v4 as uuidv413 } from "uuid";
var CommissionService = class {
  constructor() {
    this.db = getDrizzle();
    this.auditService = new AuditService();
  }
  /**
   * Get a commission by ID
   * 
   * @param companyId Company ID
   * @param commissionId Commission ID
   * @returns Commission details or null if not found
   */
  async getCommissionById(companyId, commissionId) {
    try {
      const commission = await this.db.query(
        `SELECT 
          c.*,
          e.first_name as employee_first_name,
          e.last_name as employee_last_name,
          s.name as structure_name,
          s.type as structure_type
        FROM hr_employee_commissions c
        LEFT JOIN hr_employees e ON c.employee_id = e.id
        LEFT JOIN hr_commission_structures s ON c.structure_id = s.id
        WHERE c.id = $1 AND c.company_id = $2`,
        [commissionId, companyId]
      );
      if (!commission.rows || commission.rows.length === 0) {
        return null;
      }
      return commission.rows[0];
    } catch (error) {
      console.error("Error retrieving commission by ID:", error);
      throw new Error(`Failed to retrieve commission: ${error.message}`);
    }
  }
  /**
   * Get all commissions for a company with optional filtering
   * 
   * @param companyId Company ID
   * @param year Optional year filter
   * @param month Optional month filter
   * @param status Optional status filter
   * @returns List of commissions
   */
  async getCompanyCommissions(companyId, year, month, status) {
    try {
      let query = `
        SELECT 
          c.*,
          e.first_name as employee_first_name,
          e.last_name as employee_last_name,
          s.name as structure_name,
          s.type as structure_type
        FROM hr_employee_commissions c
        LEFT JOIN hr_employees e ON c.employee_id = e.id
        LEFT JOIN hr_commission_structures s ON c.structure_id = s.id
        WHERE c.company_id = $1
      `;
      const params = [companyId];
      let paramIndex = 2;
      if (year) {
        query += ` AND EXTRACT(YEAR FROM c.created_at) = $${paramIndex++}`;
        params.push(year);
      }
      if (month) {
        query += ` AND EXTRACT(MONTH FROM c.created_at) = $${paramIndex++}`;
        params.push(month);
      }
      if (status && status.toLowerCase() !== "all") {
        query += ` AND c.status = $${paramIndex++}`;
        params.push(status);
      }
      query += ` ORDER BY c.created_at DESC`;
      const commissions = await this.db.query(query, params);
      return commissions.rows || [];
    } catch (error) {
      console.error("Error retrieving company commissions:", error);
      throw new Error(`Failed to retrieve commissions: ${error.message}`);
    }
  }
  /**
   * Create a commission structure for a sales role
   * 
   * @param companyId Company ID
   * @param name Structure name
   * @param description Structure description
   * @param type Commission type
   * @param configuration JSON configuration for the commission structure
   * @param isActive Whether the structure is active
   * @param userId User ID creating the structure
   */
  async createCommissionStructure(companyId, name, description, type, configuration, isActive, userId) {
    try {
      this.validateCommissionConfig(type, configuration);
      const structureId = uuidv413();
      await this.db.query(
        `INSERT INTO hr_commission_structures (
          id, company_id, name, description, type, 
          configuration, is_active, created_by
        ) VALUES (
          $1, $2, $3, $4, $5, 
          $6, $7, $8
        )`,
        [
          structureId,
          companyId,
          name,
          description,
          type,
          JSON.stringify(configuration),
          isActive,
          userId
        ]
      );
      await this.auditService.logAction({
        userId,
        action: "create" /* CREATE */,
        resourceType: "commission_structure" /* COMMISSION_STRUCTURE */,
        resourceId: structureId,
        metadata: {
          companyId,
          name,
          type,
          isActive
        }
      });
      return {
        id: structureId,
        name,
        type,
        isActive
      };
    } catch (error) {
      console.error("Error creating commission structure:", error);
      throw new Error(`Failed to create commission structure: ${error.message}`);
    }
  }
  /**
   * Validate commission configuration based on type
   * 
   * @param type Commission type
   * @param config Configuration object
   */
  validateCommissionConfig(type, config3) {
    switch (type) {
      case "fixed" /* FIXED */:
        if (typeof config3.amount !== "number" || config3.amount <= 0) {
          throw new Error("Fixed commission requires a positive amount");
        }
        break;
      case "percentage" /* PERCENTAGE */:
        if (typeof config3.percentage !== "number" || config3.percentage <= 0 || config3.percentage > 100) {
          throw new Error("Percentage commission requires a positive percentage (0-100)");
        }
        break;
      case "tiered_percentage" /* TIERED_PERCENTAGE */:
        if (!Array.isArray(config3.tiers) || config3.tiers.length === 0) {
          throw new Error("Tiered percentage requires at least one tier");
        }
        for (const tier of config3.tiers) {
          if (typeof tier.threshold !== "number" || typeof tier.percentage !== "number") {
            throw new Error("Each tier must have threshold and percentage values");
          }
          if (tier.percentage <= 0 || tier.percentage > 100) {
            throw new Error("Tier percentages must be positive (0-100)");
          }
        }
        break;
      case "progressive" /* PROGRESSIVE */:
        if (!Array.isArray(config3.levels) || config3.levels.length === 0) {
          throw new Error("Progressive commission requires at least one level");
        }
        for (const level of config3.levels) {
          if (typeof level.threshold !== "number" || typeof level.rate !== "number") {
            throw new Error("Each level must have threshold and rate values");
          }
          if (level.rate <= 0 || level.rate > 100) {
            throw new Error("Level rates must be positive (0-100)");
          }
        }
        break;
      case "team" /* TEAM */:
        if (typeof config3.teamPercentage !== "number" || config3.teamPercentage <= 0 || config3.teamPercentage > 100) {
          throw new Error("Team commission requires a positive team percentage (0-100)");
        }
        if (!Array.isArray(config3.distribution) || config3.distribution.length === 0) {
          throw new Error("Team commission requires a distribution array");
        }
        let totalShare = 0;
        for (const member of config3.distribution) {
          if (typeof member.role !== "string" || typeof member.share !== "number") {
            throw new Error("Each team member must have role and share values");
          }
          totalShare += member.share;
        }
        if (Math.abs(totalShare - 100) > 0.01) {
          throw new Error("Team distribution shares must sum to 100%");
        }
        break;
      case "mixed" /* MIXED */:
        if (!Array.isArray(config3.components) || config3.components.length === 0) {
          throw new Error("Mixed commission requires at least one component");
        }
        for (const component of config3.components) {
          if (!component.type || !component.config) {
            throw new Error("Each component must have type and config");
          }
          this.validateCommissionConfig(component.type, component.config);
        }
        break;
      default:
        throw new Error(`Unsupported commission type: ${type}`);
    }
  }
  /**
   * Update an existing commission structure
   * 
   * @param structureId Structure ID
   * @param updates Object containing fields to update
   * @param userId User ID performing the update
   */
  async updateCommissionStructure(structureId, updates, userId) {
    try {
      const currentStructure = await this.db.query(
        `SELECT * FROM hr_commission_structures WHERE id = $1`,
        [structureId]
      );
      if (!currentStructure.rows || currentStructure.rows.length === 0) {
        throw new Error("Commission structure not found");
      }
      if (updates.configuration) {
        const type = updates.type || currentStructure.rows[0].type;
        this.validateCommissionConfig(type, updates.configuration);
      }
      let updateQuery = "UPDATE hr_commission_structures SET updated_by = $1, updated_at = NOW()";
      const params = [userId];
      let paramIndex = 2;
      if (updates.name !== void 0) {
        updateQuery += `, name = $${paramIndex++}`;
        params.push(updates.name);
      }
      if (updates.description !== void 0) {
        updateQuery += `, description = $${paramIndex++}`;
        params.push(updates.description);
      }
      if (updates.type !== void 0) {
        updateQuery += `, type = $${paramIndex++}`;
        params.push(updates.type);
      }
      if (updates.configuration !== void 0) {
        updateQuery += `, configuration = $${paramIndex++}`;
        params.push(JSON.stringify(updates.configuration));
      }
      if (updates.isActive !== void 0) {
        updateQuery += `, is_active = $${paramIndex++}`;
        params.push(updates.isActive);
      }
      updateQuery += ` WHERE id = $${paramIndex}`;
      params.push(structureId);
      await this.db.query(updateQuery, params);
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "commission_structure" /* COMMISSION_STRUCTURE */,
        resourceId: structureId,
        metadata: {
          updates: Object.keys(updates),
          structureId
        }
      });
      const updated = await this.db.query(
        `SELECT * FROM hr_commission_structures WHERE id = $1`,
        [structureId]
      );
      return updated.rows[0];
    } catch (error) {
      console.error("Error updating commission structure:", error);
      throw new Error(`Failed to update commission structure: ${error.message}`);
    }
  }
  /**
   * Calculate commission for a sale
   * 
   * @param employeeId Employee (sales agent) ID
   * @param companyId Company ID
   * @param structureId Commission structure ID
   * @param saleAmount Sale amount
   * @param saleId Reference to the sale (e.g. invoice ID, deal ID)
   * @param saleType Type of sale (e.g. 'invoice', 'deal')
   * @param metadata Additional metadata about the sale
   * @param userId User ID performing the calculation
   */
  async calculateCommission(employeeId, companyId, structureId, saleAmount, saleId, saleType, metadata, userId) {
    try {
      const structure = await this.db.query(
        `SELECT * FROM hr_commission_structures WHERE id = $1 AND company_id = $2`,
        [structureId, companyId]
      );
      if (!structure.rows || structure.rows.length === 0) {
        throw new Error("Commission structure not found");
      }
      const structureData = structure.rows[0];
      if (!structureData.is_active) {
        throw new Error("Commission structure is not active");
      }
      const commissionAmount = this.calculateCommissionAmount(
        structureData.type,
        JSON.parse(structureData.configuration),
        saleAmount,
        metadata
      );
      const commissionId = uuidv413();
      await this.db.query(
        `INSERT INTO hr_employee_commissions (
          id, company_id, employee_id, structure_id,
          sale_amount, commission_amount, sale_id, sale_type,
          status, metadata, created_by
        ) VALUES (
          $1, $2, $3, $4,
          $5, $6, $7, $8,
          $9, $10, $11
        )`,
        [
          commissionId,
          companyId,
          employeeId,
          structureId,
          saleAmount,
          commissionAmount,
          saleId,
          saleType,
          "calculated" /* CALCULATED */,
          JSON.stringify(metadata),
          userId
        ]
      );
      await this.auditService.logAction({
        userId,
        action: "create" /* CREATE */,
        resourceType: "employee_commission" /* EMPLOYEE_COMMISSION */,
        resourceId: commissionId,
        metadata: {
          employeeId,
          structureId,
          saleAmount,
          commissionAmount,
          saleId,
          saleType
        }
      });
      return {
        id: commissionId,
        employeeId,
        saleAmount,
        commissionAmount,
        status: "calculated" /* CALCULATED */
      };
    } catch (error) {
      console.error("Error calculating commission:", error);
      throw new Error(`Failed to calculate commission: ${error.message}`);
    }
  }
  /**
   * Calculate commission amount based on structure type and configuration
   * 
   * @param type Commission type
   * @param config Configuration object
   * @param saleAmount Sale amount
   * @param metadata Additional metadata
   * @returns Calculated commission amount
   */
  calculateCommissionAmount(type, config3, saleAmount, metadata) {
    switch (type) {
      case "fixed" /* FIXED */:
        return config3.amount;
      case "percentage" /* PERCENTAGE */:
        return saleAmount * config3.percentage / 100;
      case "tiered_percentage" /* TIERED_PERCENTAGE */:
        const sortedTiers = [...config3.tiers].sort((a, b) => b.threshold - a.threshold);
        for (const tier of sortedTiers) {
          if (saleAmount >= tier.threshold) {
            return saleAmount * tier.percentage / 100;
          }
        }
        return 0;
      case "progressive" /* PROGRESSIVE */:
        const sortedLevels = [...config3.levels].sort((a, b) => a.threshold - b.threshold);
        let totalCommission = 0;
        let remainingSale = saleAmount;
        let prevThreshold = 0;
        for (const level of sortedLevels) {
          if (saleAmount >= level.threshold) {
            const levelAmount = Math.min(remainingSale, level.threshold - prevThreshold);
            totalCommission += levelAmount * level.rate / 100;
            remainingSale -= levelAmount;
            prevThreshold = level.threshold;
          } else {
            break;
          }
        }
        if (remainingSale > 0 && sortedLevels.length > 0) {
          const highestLevel = sortedLevels[sortedLevels.length - 1];
          totalCommission += remainingSale * highestLevel.rate / 100;
        }
        return totalCommission;
      case "team" /* TEAM */:
        const teamCommission = saleAmount * config3.teamPercentage / 100;
        if (metadata.role) {
          const roleDist = config3.distribution.find((d) => d.role === metadata.role);
          if (roleDist) {
            return teamCommission * roleDist.share / 100;
          }
        }
        return teamCommission;
      case "mixed" /* MIXED */:
        let mixedCommission = 0;
        for (const component of config3.components) {
          mixedCommission += this.calculateCommissionAmount(
            component.type,
            component.config,
            saleAmount,
            metadata
          );
        }
        return mixedCommission;
      default:
        throw new Error(`Unsupported commission type: ${type}`);
    }
  }
  /**
   * Approve a calculated commission
   * 
   * @param commissionId Commission ID
   * @param userId User ID performing the approval
   */
  async approveCommission(commissionId, userId) {
    try {
      const commission = await this.db.query(
        `SELECT * FROM hr_employee_commissions WHERE id = $1`,
        [commissionId]
      );
      if (!commission.rows || commission.rows.length === 0) {
        throw new Error("Commission record not found");
      }
      if (commission.rows[0].status !== "calculated" /* CALCULATED */) {
        throw new Error(`Cannot approve commission in ${commission.rows[0].status} status`);
      }
      await this.db.query(
        `UPDATE hr_employee_commissions
         SET status = $1, approved_by = $2, approved_at = NOW(), updated_by = $2, updated_at = NOW()
         WHERE id = $3`,
        ["approved" /* APPROVED */, userId, commissionId]
      );
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "employee_commission" /* EMPLOYEE_COMMISSION */,
        resourceId: commissionId,
        metadata: {
          status: "approved" /* APPROVED */,
          commissionId
        }
      });
      return {
        id: commissionId,
        status: "approved" /* APPROVED */,
        message: "Commission approved successfully"
      };
    } catch (error) {
      console.error("Error approving commission:", error);
      throw new Error(`Failed to approve commission: ${error.message}`);
    }
  }
  /**
   * Mark commission as paid
   * 
   * @param commissionId Commission ID
   * @param paymentReference Reference to the payment
   * @param userId User ID performing the update
   */
  async markCommissionAsPaid(commissionId, paymentReference, userId) {
    try {
      const commission = await this.db.query(
        `SELECT * FROM hr_employee_commissions WHERE id = $1`,
        [commissionId]
      );
      if (!commission.rows || commission.rows.length === 0) {
        throw new Error("Commission record not found");
      }
      if (commission.rows[0].status !== "approved" /* APPROVED */) {
        throw new Error(`Cannot mark commission as paid in ${commission.rows[0].status} status`);
      }
      await this.db.query(
        `UPDATE hr_employee_commissions
         SET status = $1, payment_reference = $2, payment_date = NOW(), updated_by = $3, updated_at = NOW()
         WHERE id = $4`,
        ["paid" /* PAID */, paymentReference, userId, commissionId]
      );
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "employee_commission" /* EMPLOYEE_COMMISSION */,
        resourceId: commissionId,
        metadata: {
          status: "paid" /* PAID */,
          commissionId,
          paymentReference
        }
      });
      return {
        id: commissionId,
        status: "paid" /* PAID */,
        paymentReference,
        message: "Commission marked as paid successfully"
      };
    } catch (error) {
      console.error("Error marking commission as paid:", error);
      throw new Error(`Failed to mark commission as paid: ${error.message}`);
    }
  }
  /**
   * Get commissions for an employee
   * 
   * @param employeeId Employee ID
   * @param status Optional status filter
   * @param timeframe Optional timeframe (month, quarter, year)
   * @param limit Optional limit of records to return
   */
  async getEmployeeCommissions(employeeId, status, timeframe, limit = 50) {
    try {
      let query = `
        SELECT ec.*, cs.name as structure_name, cs.type as structure_type
        FROM hr_employee_commissions ec
        JOIN hr_commission_structures cs ON ec.structure_id = cs.id
        WHERE ec.employee_id = $1
      `;
      const params = [employeeId];
      if (status) {
        query += ` AND ec.status = $${params.length + 1}`;
        params.push(status);
      }
      if (timeframe) {
        let interval;
        switch (timeframe) {
          case "month":
            interval = "1 month";
            break;
          case "quarter":
            interval = "3 months";
            break;
          case "year":
            interval = "1 year";
            break;
        }
        query += ` AND ec.created_at >= NOW() - INTERVAL '${interval}'`;
      }
      query += ` ORDER BY ec.created_at DESC LIMIT $${params.length + 1}`;
      params.push(limit);
      const commissions = await this.db.query(query, params);
      return commissions.rows || [];
    } catch (error) {
      console.error("Error retrieving employee commissions:", error);
      throw new Error(`Failed to retrieve employee commissions: ${error.message}`);
    }
  }
  /**
   * Get commission structures for a company
   * 
   * @param companyId Company ID
   * @param activeOnly Whether to return only active structures
   */
  async getCommissionStructures(companyId, activeOnly = false) {
    try {
      let query = `SELECT * FROM hr_commission_structures WHERE company_id = $1`;
      const params = [companyId];
      if (activeOnly) {
        query += ` AND is_active = true`;
      }
      query += ` ORDER BY name ASC`;
      const structures = await this.db.query(query, params);
      return structures.rows || [];
    } catch (error) {
      console.error("Error retrieving commission structures:", error);
      throw new Error(`Failed to retrieve commission structures: ${error.message}`);
    }
  }
  /**
   * Get a summary of commission amounts by status for a given period
   * 
   * @param companyId Company ID
   * @param year Year for summary
   * @param month Optional month for summary
   */
  async getCommissionSummary(companyId, year, month) {
    try {
      let dateFilter;
      const params = [companyId];
      if (month) {
        dateFilter = `
          EXTRACT(YEAR FROM created_at) = $2 AND 
          EXTRACT(MONTH FROM created_at) = $3
        `;
        params.push(year, month);
      } else {
        dateFilter = `EXTRACT(YEAR FROM created_at) = $2`;
        params.push(year);
      }
      const summary = await this.db.query(
        `SELECT 
          status,
          COUNT(*) as count,
          SUM(commission_amount) as total_amount
         FROM hr_employee_commissions
         WHERE company_id = $1 AND ${dateFilter}
         GROUP BY status`,
        params
      );
      return summary.rows || [];
    } catch (error) {
      console.error("Error retrieving commission summary:", error);
      throw new Error(`Failed to retrieve commission summary: ${error.message}`);
    }
  }
};

// server/modules/hr/schema/index.ts
init_hr_schema();

// server/modules/hr/schema/settings.schema.ts
init_schema4();
import {
  pgTable as pgTable14,
  uuid as uuid13,
  text as text14,
  timestamp as timestamp14,
  boolean as boolean13,
  integer as integer10
} from "drizzle-orm/pg-core";
import { sql as sql30 } from "drizzle-orm";
var hrSettings = pgTable14("hr_settings", {
  id: uuid13("id").primaryKey().default(sql30`gen_random_uuid()`),
  companyId: uuid13("company_id").notNull().references(() => companies.id).unique(),
  // Company Information
  companyName: text14("company_name"),
  companyRegistrationNumber: text14("company_registration_number"),
  fiscalCode: text14("fiscal_code"),
  address: text14("address"),
  city: text14("city"),
  county: text14("county"),
  postalCode: text14("postal_code"),
  country: text14("country").default("Rom\xE2nia"),
  phone: text14("phone"),
  email: text14("email"),
  website: text14("website"),
  contactPerson: text14("contact_person"),
  contactEmail: text14("contact_email"),
  contactPhone: text14("contact_phone"),
  // HR Defaults
  defaultProbationPeriod: integer10("default_probation_period").default(90),
  defaultWorkingHours: integer10("default_working_hours").default(40),
  defaultVacationDays: integer10("default_vacation_days").default(21),
  defaultSickDays: integer10("default_sick_days").default(5),
  defaultNoticePeriod: integer10("default_notice_period").default(30),
  // Features
  enableAutoCalculateVacationDays: boolean13("enable_auto_calculate_vacation_days").default(false),
  enableAutoCalculateSeniority: boolean13("enable_auto_calculate_seniority").default(true),
  enableContractNotifications: boolean13("enable_contract_notifications").default(true),
  enableBirthdayNotifications: boolean13("enable_birthday_notifications").default(true),
  // Integrations
  anafIntegrationEnabled: boolean13("anaf_integration_enabled").default(false),
  anafApiKey: text14("anaf_api_key"),
  anafUsername: text14("anaf_username"),
  anafPassword: text14("anaf_password"),
  revisalIntegrationEnabled: boolean13("revisal_integration_enabled").default(false),
  revisalApiKey: text14("revisal_api_key"),
  sendgridEnabled: boolean13("sendgrid_enabled").default(false),
  sendgridApiKey: text14("sendgrid_api_key"),
  stripeEnabled: boolean13("stripe_enabled").default(false),
  stripeApiKey: text14("stripe_api_key"),
  // Timestamps
  createdAt: timestamp14("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp14("updated_at", { withTimezone: true }).defaultNow()
});

// server/modules/hr/schema/cor.schema.ts
import {
  pgTable as pgTable15,
  uuid as uuid14,
  text as text15,
  varchar as varchar9,
  timestamp as timestamp15,
  index as index7,
  unique as unique5,
  boolean as boolean14
} from "drizzle-orm/pg-core";
import { sql as sql31 } from "drizzle-orm";
var corMajorGroups = pgTable15("cor_major_groups", {
  id: uuid14("id").primaryKey().default(sql31`gen_random_uuid()`),
  code: varchar9("code", { length: 1 }).notNull(),
  name: text15("name").notNull(),
  description: text15("description"),
  // Timestamps
  createdAt: timestamp15("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp15("updated_at", { withTimezone: true }).defaultNow()
}, (table) => ({
  codeIdx: index7("cor_major_group_code_idx").on(table.code),
  codeUnique: unique5("cor_major_group_code_unique").on(table.code)
}));
var corSubmajorGroups = pgTable15("cor_submajor_groups", {
  id: uuid14("id").primaryKey().default(sql31`gen_random_uuid()`),
  code: varchar9("code", { length: 2 }).notNull(),
  name: text15("name").notNull(),
  description: text15("description"),
  majorGroupCode: varchar9("major_group_code", { length: 1 }).notNull(),
  // Timestamps
  createdAt: timestamp15("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp15("updated_at", { withTimezone: true }).defaultNow()
}, (table) => ({
  codeIdx: index7("cor_submajor_group_code_idx").on(table.code),
  majorGroupCodeIdx: index7("cor_submajor_group_major_code_idx").on(table.majorGroupCode),
  codeUnique: unique5("cor_submajor_group_code_unique").on(table.code)
}));
var corMinorGroups = pgTable15("cor_minor_groups", {
  id: uuid14("id").primaryKey().default(sql31`gen_random_uuid()`),
  code: varchar9("code", { length: 3 }).notNull(),
  name: text15("name").notNull(),
  description: text15("description"),
  submajorGroupCode: varchar9("submajor_group_code", { length: 2 }).notNull(),
  // Timestamps
  createdAt: timestamp15("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp15("updated_at", { withTimezone: true }).defaultNow()
}, (table) => ({
  codeIdx: index7("cor_minor_group_code_idx").on(table.code),
  submajorGroupCodeIdx: index7("cor_minor_group_submajor_code_idx").on(table.submajorGroupCode),
  codeUnique: unique5("cor_minor_group_code_unique").on(table.code)
}));
var corSubminorGroups = pgTable15("cor_subminor_groups", {
  id: uuid14("id").primaryKey().default(sql31`gen_random_uuid()`),
  code: varchar9("code", { length: 4 }).notNull(),
  name: text15("name").notNull(),
  description: text15("description"),
  minorGroupCode: varchar9("minor_group_code", { length: 3 }).notNull(),
  // Timestamps
  createdAt: timestamp15("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp15("updated_at", { withTimezone: true }).defaultNow()
}, (table) => ({
  codeIdx: index7("cor_subminor_group_code_idx").on(table.code),
  minorGroupCodeIdx: index7("cor_subminor_group_minor_code_idx").on(table.minorGroupCode),
  codeUnique: unique5("cor_subminor_group_code_unique").on(table.code)
}));
var corOccupations = pgTable15("cor_occupations", {
  id: uuid14("id").primaryKey().default(sql31`gen_random_uuid()`),
  code: varchar9("code", { length: 6 }).notNull(),
  name: text15("name").notNull(),
  description: text15("description"),
  subminorGroupCode: varchar9("subminor_group_code", { length: 4 }).notNull(),
  isActive: boolean14("is_active").default(true),
  // Timestamps
  createdAt: timestamp15("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp15("updated_at", { withTimezone: true }).defaultNow()
}, (table) => ({
  codeIdx: index7("cor_occupation_code_idx").on(table.code),
  subminorGroupCodeIdx: index7("cor_occupation_subminor_code_idx").on(table.subminorGroupCode),
  codeUnique: unique5("cor_occupation_code_unique").on(table.code)
}));

// server/modules/hr/services/employee.service.ts
init_audit_service();
import { v4 as uuidv414 } from "uuid";
init_logger();
init_drizzle_service();
import { sql as sql32, desc as desc13 } from "drizzle-orm";
var EmployeeService = class {
  constructor() {
    this.logger = new Logger("EmployeeService");
    this.drizzle = new DrizzleService();
    this.auditService = new AuditService();
  }
  /**
   * Create a new employee record using Drizzle ORM
   * 
   * @param companyId Company ID
   * @param firstName First name
   * @param lastName Last name
   * @param email Email address
   * @param phone Phone number
   * @param position Job position
   * @param departmentId Department ID
   * @param cnp Personal numeric code (Romanian CNP)
   * @param address Address
   * @param birthDate Birth date
   * @param hireDate Hire date
   * @param data Additional employee data
   * @param userId User ID creating the employee
   */
  async createEmployee(companyId, firstName, lastName, email, phone = "", position, departmentId = null, cnp = "", address = "", birthDate = null, hireDate = /* @__PURE__ */ new Date(), data = {}, userId = "") {
    try {
      const cnpValue = cnp && typeof cnp === "string" && cnp.trim() !== "" ? cnp.trim() : "1900101000000";
      console.log("[DEBUG] Employee createEmployee using CNP value:", cnpValue);
      if (cnpValue !== "1900101000000") {
        try {
          this.validateRomanianCnp(cnpValue);
          const existingEmployee = await this.drizzle.db.select().from(employees).where(sql32`${employees.cnp} = ${cnpValue} AND ${employees.companyId} = ${companyId}`).limit(1);
          if (existingEmployee.length > 0) {
            throw new Error("Employee with the same CNP already exists");
          }
        } catch (validationError) {
          console.warn("[WARN] CNP validation failed:", validationError.message);
        }
      }
      let birthDateObj = void 0;
      if (birthDate) {
        try {
          if (typeof birthDate === "string") {
            birthDateObj = new Date(birthDate);
          } else {
            birthDateObj = birthDate;
          }
          if (isNaN(birthDateObj.getTime())) {
            console.warn(`Invalid birthDate format: ${birthDate}, using undefined`);
            birthDateObj = void 0;
          }
        } catch (error) {
          console.warn(`Error parsing birthDate: ${error.message}`);
          birthDateObj = void 0;
        }
      }
      let hireDateObj = /* @__PURE__ */ new Date();
      if (hireDate) {
        try {
          if (typeof hireDate === "string") {
            hireDateObj = new Date(hireDate);
          } else {
            hireDateObj = hireDate;
          }
          if (isNaN(hireDateObj.getTime())) {
            console.warn(`Invalid hireDate format: ${hireDate}, using current date`);
            hireDateObj = /* @__PURE__ */ new Date();
          }
        } catch (error) {
          console.warn(`Error parsing hireDate: ${error.message}`);
          hireDateObj = /* @__PURE__ */ new Date();
        }
      }
      console.log("[DEBUG] Inserting employee with:");
      console.log("[DEBUG] birthDate:", birthDateObj);
      console.log("[DEBUG] hireDate:", hireDateObj);
      const id = uuidv414();
      const now = /* @__PURE__ */ new Date();
      const formattedBirthDate = birthDateObj ? birthDateObj.toISOString() : null;
      const formattedHireDate = hireDateObj ? hireDateObj.toISOString() : null;
      const formattedNow = now.toISOString();
      const sqlQuery = sql32`
        INSERT INTO hr_employees (
          id,
          company_id,
          first_name,
          last_name,
          email,
          phone,
          position,
          department_id,
          address,
          birth_date,
          hire_date,
          cnp,
          created_by,
          is_active,
          created_at,
          updated_at
        ) VALUES (
          ${id},
          ${companyId},
          ${firstName},
          ${lastName},
          ${email},
          ${phone},
          ${position},
          ${departmentId || null},
          ${address},
          ${formattedBirthDate},
          ${formattedHireDate},
          ${cnpValue},
          ${userId || null},
          ${true},
          ${formattedNow},
          ${formattedNow}
        )
        RETURNING *
      `;
      const result = await this.drizzle.execute(sqlQuery);
      const createdEmployee = result[0];
      await AuditService.log({
        userId,
        companyId,
        action: "create" /* CREATE */,
        entity: "employee" /* EMPLOYEE */,
        entityId: createdEmployee.id,
        details: {
          firstName,
          lastName,
          cnp
        }
      });
      return createdEmployee;
    } catch (error) {
      console.error("Error creating employee:", error);
      throw new Error(`Failed to create employee: ${error.message}`);
    }
  }
  /**
   * Create a new employee record - simplified version for API use
   * 
   * @param companyId Company ID
   * @param franchiseId Franchise ID (optional)
   * @param name Full name
   * @param email Email address
   * @param position Job position
   * @param salary Salary amount
   * @param hireDate Hire date
   * @param cnp Romanian personal numeric code (CNP)
   */
  /**
   * Create a new employee record - simplified version for API use
   * 
   * This method uses direct SQL insertion to bypass any Drizzle ORM issues,
   * especially related to the CNP field which has been problematic
   * 
   * @param companyId Company ID
   * @param franchiseId Franchise ID (optional)
   * @param name Full name
   * @param email Email address
   * @param position Job position
   * @param salary Salary amount
   * @param hireDate Hire date
   * @param cnp Romanian personal numeric code (CNP)
   */
  async createSimpleEmployee(companyId, franchiseId = null, name, email, position, salary = 0, hireDate = /* @__PURE__ */ new Date(), cnp = "1900101000000") {
    try {
      this.logger.debug("createSimpleEmployee - Input parameters:", {
        companyId,
        name,
        email,
        position,
        cnp
      });
      const nameParts = name.trim().split(" ");
      let lastName = "";
      let firstName = "";
      if (nameParts.length > 1) {
        lastName = nameParts.pop() || "";
        firstName = nameParts.join(" ");
      } else {
        lastName = name.trim();
        firstName = "Unknown";
      }
      this.logger.debug("Split name into:", { firstName, lastName });
      const validCnp = cnp && typeof cnp === "string" && cnp.trim() !== "" ? cnp.trim() : "1900101000000";
      this.logger.debug("Using CNP value:", {
        cnp: validCnp,
        type: typeof validCnp,
        length: validCnp.length
      });
      const id = uuidv414();
      const now = /* @__PURE__ */ new Date();
      const formattedNow = now.toISOString();
      let formattedHireDate = formattedNow;
      if (hireDate) {
        if (hireDate instanceof Date) {
          formattedHireDate = hireDate.toISOString();
        } else if (typeof hireDate === "string") {
          try {
            const hireDateObj = new Date(hireDate);
            if (!isNaN(hireDateObj.getTime())) {
              formattedHireDate = hireDateObj.toISOString();
            }
          } catch (error) {
            this.logger.warn(`Invalid hire date format: ${hireDate}, using current date`);
          }
        }
      }
      const sqlQuery = sql32`
        INSERT INTO hr_employees (
          id,
          company_id,
          first_name,
          last_name,
          email,
          position,
          cnp,
          is_active,
          status,
          nationality,
          hire_date,
          created_at,
          updated_at
        ) VALUES (
          ${id},
          ${companyId},
          ${firstName},
          ${lastName},
          ${email},
          ${position},
          ${validCnp}, -- Explicitly passing the CNP as a string parameter
          true,
          'active',
          'Romanian',
          ${formattedHireDate},
          ${formattedNow},
          ${formattedNow}
        )
        RETURNING *
      `;
      const result = await this.drizzle.execute(sqlQuery);
      if (!result || result.length === 0) {
        throw new Error("No result returned from employee insertion");
      }
      this.logger.debug("Employee created successfully:", {
        id: result[0].id,
        cnp: result[0].cnp
      });
      try {
        AuditService.log({
          userId: "system",
          // Using 'system' as userId since this method doesn't require a user ID
          companyId,
          // We have the company ID from the function parameters
          entity: "employee" /* EMPLOYEE */,
          entityId: result[0].id,
          action: "create" /* CREATE */,
          details: {
            method: "createSimpleEmployee",
            email
          }
        });
      } catch (auditError) {
        this.logger.error("Failed to log audit for employee creation:", auditError);
      }
      return {
        id: result[0].id,
        companyId: result[0].company_id,
        firstName: result[0].first_name,
        lastName: result[0].last_name,
        email: result[0].email,
        position: result[0].position,
        cnp: result[0].cnp,
        salary,
        hireDate,
        createdAt: result[0].created_at,
        updatedAt: result[0].updated_at,
        isActive: result[0].is_active
      };
    } catch (error) {
      this.logger.error("Error creating employee:", error);
      let errorMessage = "Failed to create employee";
      if (error instanceof Error) {
        errorMessage += `: ${error.message}`;
        if (error.message.includes("null value in column")) {
          errorMessage = `Database constraint violation: ${error.message}`;
        } else if (error.message.includes("duplicate key")) {
          errorMessage = `Duplicate entry: ${error.message}`;
        } else if (error.message.includes("foreign key constraint")) {
          errorMessage = `Invalid reference: ${error.message}`;
        }
      }
      throw new Error(errorMessage);
    }
  }
  /**
   * Create an employment contract for an employee
   * 
   * @param employeeId Employee ID
   * @param companyId Company ID
   * @param contractNumber Contract number
   * @param contractType Contract type
   * @param startDate Contract start date
   * @param endDate Contract end date (null for indefinite contracts)
   * @param baseSalaryGross Gross base salary
   * @param workingTime Working time (full_time or part_time_X)
   * @param corCode Romanian COR code (occupation code)
   * @param contractFilePath Path to contract file
   * @param annexesFilePaths Paths to contract annexes
   * @param userId User ID creating the contract
   */
  async createEmploymentContract(employeeId, companyId, contractNumber, contractType, startDate, endDate, baseSalaryGross, workingTime, corCode, annualVacationDays, contractFilePath, annexesFilePaths, userId) {
    try {
      this.validateRomanianCorCode(corCode);
      const employee = await this.drizzle.select().from(employees).where(sql32`${employees.id} = ${employeeId} AND ${employees.companyId} = ${companyId}`).limit(1);
      if (!employee || employee.length === 0) {
        throw new Error("Employee not found");
      }
      const activeContract = await this.drizzle.select().from(employmentContracts).where(sql32`${employmentContracts.employeeId} = ${employeeId} AND status = ${"active" /* ACTIVE */}`).limit(1);
      if (activeContract && activeContract.length > 0) {
        throw new Error("Employee already has an active contract");
      }
      let startDateObj;
      try {
        if (typeof startDate === "string") {
          startDateObj = new Date(startDate);
          if (isNaN(startDateObj.getTime())) {
            console.warn(`Invalid startDate format: ${startDate}, using current date`);
            startDateObj = /* @__PURE__ */ new Date();
          }
        } else {
          startDateObj = startDate;
        }
      } catch (error) {
        console.warn(`Error parsing startDate: ${error.message}, using current date`);
        startDateObj = /* @__PURE__ */ new Date();
      }
      let endDateObj = null;
      if (endDate) {
        try {
          if (typeof endDate === "string") {
            endDateObj = new Date(endDate);
            if (isNaN(endDateObj.getTime())) {
              console.warn(`Invalid endDate format: ${endDate}, using null`);
              endDateObj = null;
            }
          } else {
            endDateObj = endDate;
          }
        } catch (error) {
          console.warn(`Error parsing endDate: ${error.message}, using null`);
          endDateObj = null;
        }
      }
      const isIndefinite = endDateObj === null;
      const id = uuidv414();
      const now = /* @__PURE__ */ new Date();
      const status = "active" /* ACTIVE */;
      console.log("[DEBUG] Creating contract with dates:");
      console.log("[DEBUG] startDate:", startDateObj);
      console.log("[DEBUG] endDate:", endDateObj);
      const formattedStartDate = startDateObj ? startDateObj.toISOString() : null;
      const formattedEndDate = endDateObj ? endDateObj.toISOString() : null;
      const formattedNow = now.toISOString();
      const sqlQuery = sql32`
        INSERT INTO hr_employment_contracts (
          id,
          company_id,
          employee_id,
          contract_number,
          contract_type,
          start_date,
          end_date,
          is_indefinite,
          base_salary_gross,
          working_time,
          cor_code,
          annual_vacation_days,
          status,
          contract_file_path,
          annexes_file_paths,
          created_by,
          created_at,
          updated_at
        ) VALUES (
          ${id},
          ${companyId},
          ${employeeId},
          ${contractNumber},
          ${contractType},
          ${formattedStartDate},
          ${formattedEndDate},
          ${isIndefinite},
          ${baseSalaryGross},
          ${workingTime},
          ${corCode},
          ${annualVacationDays},
          ${status},
          ${contractFilePath || null},
          ${annexesFilePaths ? JSON.stringify(annexesFilePaths) : null},
          ${userId || null},
          ${formattedNow},
          ${formattedNow}
        )
        RETURNING *
      `;
      const result = await this.drizzle.execute(sqlQuery);
      const createdContract = result[0];
      await AuditService.log({
        userId,
        companyId,
        action: "create" /* CREATE */,
        entity: "employment_contract" /* EMPLOYMENT_CONTRACT */,
        entityId: createdContract.id,
        details: {
          employeeId,
          contractNumber,
          contractType,
          baseSalaryGross
        }
      });
      return {
        id: createdContract.id,
        employeeId,
        contractNumber,
        contractType,
        startDate: startDateObj,
        status: "active" /* ACTIVE */
      };
    } catch (error) {
      console.error("Error creating employment contract:", error);
      throw new Error(`Failed to create employment contract: ${error.message}`);
    }
  }
  /**
   * Validate Romanian CNP (Personal Numeric Code)
   * CNP format: SAALLZZJJNNNC
   * S: Gender/Century (1/2 = M/F born 1900-1999, 3/4 = M/F born 1800-1899, 5/6 = M/F born 2000-2099)
   * AA: Year of birth (last 2 digits)
   * LL: Month of birth
   * ZZ: Day of birth
   * JJ: County code
   * NNN: Sequence number
   * C: Control digit
   * 
   * @param cnp CNP to validate
   */
  validateRomanianCnp(cnp) {
    if (!cnp || cnp.length !== 13 || !/^\d+$/.test(cnp)) {
      throw new Error("Invalid CNP format - must be 13 digits");
    }
    const genderCentury = parseInt(cnp.charAt(0));
    if (genderCentury < 1 || genderCentury > 8) {
      throw new Error("Invalid CNP - first digit must be 1-8");
    }
    const month = parseInt(cnp.substring(3, 5));
    if (month < 1 || month > 12) {
      throw new Error("Invalid CNP - invalid month");
    }
    const day = parseInt(cnp.substring(5, 7));
    if (day < 1 || day > 31) {
      throw new Error("Invalid CNP - invalid day");
    }
    const countyCode = parseInt(cnp.substring(7, 9));
    if ((countyCode < 1 || countyCode > 46) && countyCode !== 51 && countyCode !== 52) {
      throw new Error("Invalid CNP - invalid county code");
    }
    const controlDigit = parseInt(cnp.charAt(12));
    const controlString = "279146358279";
    let sum2 = 0;
    for (let i = 0; i < 12; i++) {
      sum2 += parseInt(cnp.charAt(i)) * parseInt(controlString.charAt(i));
    }
    const remainder = sum2 % 11;
    const calculatedControl = remainder === 10 ? 1 : remainder;
    if (calculatedControl !== controlDigit) {
      throw new Error("Invalid CNP - control digit mismatch");
    }
  }
  /**
   * Validate Romanian COR code (Classification of Occupations in Romania)
   * COR code format: 6 digits representing the hierarchical occupation classification
   * 
   * @param corCode COR code to validate
   */
  validateRomanianCorCode(corCode) {
    if (!corCode || corCode.length !== 6 || !/^\d+$/.test(corCode)) {
      throw new Error("Invalid COR code format - must be 6 digits");
    }
  }
  /**
   * Update an employee record using Drizzle ORM
   * 
   * @param employeeId Employee ID
   * @param updates Object containing fields to update
   * @param userId User ID performing the update
   */
  async updateEmployee(employeeId, updates, userId) {
    try {
      const currentEmployee = await this.drizzle.select().from(employees).where(sql32`${employees.id} = ${employeeId}`).limit(1);
      if (!currentEmployee || currentEmployee.length === 0) {
        throw new Error("Employee not found");
      }
      const updateValues = {
        updatedBy: userId,
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (updates.firstName !== void 0) {
        updateValues.firstName = updates.firstName;
      }
      if (updates.lastName !== void 0) {
        updateValues.lastName = updates.lastName;
      }
      if (updates.email !== void 0) {
        updateValues.email = updates.email;
      }
      if (updates.phone !== void 0) {
        updateValues.phone = updates.phone;
      }
      if (updates.position !== void 0) {
        updateValues.position = updates.position;
      }
      if (updates.departmentId !== void 0) {
        updateValues.departmentId = updates.departmentId;
      }
      if (updates.address !== void 0) {
        updateValues.address = updates.address;
      }
      if (updates.data !== void 0) {
        updateValues.employeeData = updates.data;
      }
      if (updates.isActive !== void 0) {
        updateValues.isActive = updates.isActive;
      }
      const result = await this.drizzle.update(employees).set(updateValues).where(sql32`${employees.id} = ${employeeId}`).returning();
      await AuditService.log({
        userId,
        companyId: currentEmployee[0].companyId,
        action: "update" /* UPDATE */,
        entity: "employee" /* EMPLOYEE */,
        entityId: employeeId,
        details: {
          updates: Object.keys(updates),
          employeeId
        }
      });
      return result[0];
    } catch (error) {
      console.error("Error updating employee:", error);
      throw new Error(`Failed to update employee: ${error.message}`);
    }
  }
  /**
   * Update an employment contract
   * 
   * @param contractId Contract ID
   * @param updates Object containing fields to update
   * @param userId User ID performing the update
   */
  async updateEmploymentContract(contractId, updates, userId) {
    try {
      const currentContract = await this.drizzle.select().from(employmentContracts).where(sql32`${employmentContracts.id} = ${contractId}`).limit(1);
      if (!currentContract || currentContract.length === 0) {
        throw new Error("Employment contract not found");
      }
      const updateValues = {
        updatedBy: userId,
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (updates.endDate !== void 0) {
        let endDateObj = null;
        if (updates.endDate) {
          try {
            if (typeof updates.endDate === "string") {
              endDateObj = new Date(updates.endDate);
              if (isNaN(endDateObj.getTime())) {
                console.warn(`Invalid endDate format in update: ${updates.endDate}, using null`);
                endDateObj = null;
              }
            } else {
              endDateObj = updates.endDate;
            }
          } catch (error) {
            console.warn(`Error parsing endDate in update: ${error.message}, using null`);
            endDateObj = null;
          }
        }
        updateValues.endDate = endDateObj;
        updateValues.isIndefinite = endDateObj === null;
      }
      if (updates.baseSalaryGross !== void 0) {
        updateValues.baseSalaryGross = updates.baseSalaryGross;
      }
      if (updates.workingTime !== void 0) {
        updateValues.workingTime = updates.workingTime;
      }
      if (updates.status !== void 0) {
        updateValues.status = updates.status;
      }
      if (updates.suspensionReason !== void 0) {
        updateValues.suspensionReason = updates.suspensionReason;
      }
      if (updates.terminationReason !== void 0) {
        updateValues.terminationReason = updates.terminationReason;
      }
      if (updates.terminationDate !== void 0) {
        let terminationDateObj = null;
        if (updates.terminationDate) {
          try {
            if (typeof updates.terminationDate === "string") {
              terminationDateObj = new Date(updates.terminationDate);
              if (isNaN(terminationDateObj.getTime())) {
                console.warn(`Invalid terminationDate format in update: ${updates.terminationDate}, using null`);
                terminationDateObj = null;
              }
            } else {
              terminationDateObj = updates.terminationDate;
            }
          } catch (error) {
            console.warn(`Error parsing terminationDate in update: ${error.message}, using null`);
            terminationDateObj = null;
          }
        }
        updateValues.terminationDate = terminationDateObj;
      }
      if (updates.annexesFilePaths !== void 0) {
        updateValues.annexesFilePaths = JSON.stringify(updates.annexesFilePaths || []);
      }
      const result = await this.drizzle.update(employmentContracts).set(updateValues).where(sql32`${employmentContracts.id} = ${contractId}`).returning();
      await AuditService.log({
        userId,
        companyId: currentContract[0].companyId,
        action: "update" /* UPDATE */,
        entity: "employment_contract" /* EMPLOYMENT_CONTRACT */,
        entityId: contractId,
        details: {
          updates: Object.keys(updates),
          contractId
        }
      });
      return result[0];
    } catch (error) {
      console.error("Error updating employment contract:", error);
      throw new Error(`Failed to update employment contract: ${error.message}`);
    }
  }
  /**
   * Get an employee by ID using Drizzle ORM
   * 
   * @param employeeId Employee ID
   */
  async getEmployeeById(employeeId) {
    try {
      console.log("[DEBUG] Getting employee by ID:", employeeId);
      const employeeQuery = sql32`
        SELECT e.*
        FROM hr_employees e
        WHERE e.id = ${employeeId}
        LIMIT 1
      `;
      const result = await this.drizzle.execute(employeeQuery);
      if (!result || result.length === 0) {
        throw new Error("Employee not found");
      }
      let departmentName = null;
      if (result[0].department) {
        const deptQuery = sql32`
          SELECT name FROM hr_departments 
          WHERE name = ${result[0].department} 
          LIMIT 1
        `;
        const deptResult = await this.drizzle.execute(deptQuery);
        if (deptResult && deptResult.length > 0) {
          departmentName = deptResult[0].name;
        }
      }
      const employee = {
        ...result[0],
        departmentName,
        // Make sure we handle camelCase vs snake_case properly
        id: result[0].id,
        companyId: result[0].company_id,
        firstName: result[0].first_name,
        lastName: result[0].last_name,
        department: result[0].department,
        birthDate: result[0].birth_date,
        hireDate: result[0].hire_date,
        isActive: result[0].is_active,
        createdAt: result[0].created_at,
        updatedAt: result[0].updated_at
      };
      return employee;
    } catch (error) {
      console.error("Error retrieving employee:", error);
      throw new Error(`Failed to retrieve employee: ${error.message}`);
    }
  }
  /**
   * Get an employee's active employment contract
   * 
   * @param employeeId Employee ID
   */
  async getActiveEmploymentContract(employeeId) {
    try {
      const result = await this.drizzle.select().from(employmentContracts).where(sql32`${employmentContracts.employeeId} = ${employeeId} AND status = ${"active" /* ACTIVE */}`).limit(1);
      if (!result || result.length === 0) {
        return null;
      }
      return result[0];
    } catch (error) {
      console.error("Error retrieving active employment contract:", error);
      throw new Error(`Failed to retrieve active employment contract: ${error.message}`);
    }
  }
  /**
   * Get employee contract history
   * 
   * @param employeeId Employee ID
   */
  async getEmploymentContractHistory(employeeId) {
    try {
      const result = await this.drizzle.select().from(employmentContracts).where(sql32`${employmentContracts.employeeId} = ${employeeId}`).orderBy(desc13(employmentContracts.startDate));
      return result || [];
    } catch (error) {
      console.error("Error retrieving employment contract history:", error);
      throw new Error(`Failed to retrieve employment contract history: ${error.message}`);
    }
  }
  /**
   * Search employees with various filters
   * 
   * @param companyId Company ID
   * @param searchTerm Search term for name or CNP
   * @param departmentId Optional department filter
   * @param isActive Whether to return only active employees
   * @param page Page number for pagination
   * @param limit Items per page
   */
  async searchEmployees(companyId, searchTerm, departmentId, isActive, page = 1, limit = 50) {
    try {
      let baseQuery = sql32`
        SELECT e.*, d.name as department_name
        FROM hr_employees e
        LEFT JOIN hr_departments d ON e.department = d.name
        WHERE e.company_id = ${companyId}
      `;
      if (searchTerm) {
        const searchPattern = `%${searchTerm}%`;
        baseQuery = sql32`${baseQuery} AND (
          e.first_name ILIKE ${searchPattern} OR
          e.last_name ILIKE ${searchPattern} OR
          e.cnp LIKE ${searchPattern} OR
          e.email ILIKE ${searchPattern}
        )`;
      }
      let departmentName = null;
      if (departmentId) {
        const deptResult = await this.drizzle.execute(
          sql32`SELECT name FROM hr_departments WHERE id = ${departmentId}`
        );
        if (deptResult && deptResult.length > 0) {
          departmentName = deptResult[0].name;
          baseQuery = sql32`${baseQuery} AND e.department = ${departmentName}`;
        }
      }
      if (isActive !== null) {
        baseQuery = sql32`${baseQuery} AND e.is_active = ${isActive}`;
      }
      const countQuery = sql32`
        SELECT COUNT(*) as total_count 
        FROM hr_employees e
        LEFT JOIN hr_departments d ON e.department = d.name
        WHERE e.company_id = ${companyId}
      `;
      let finalCountQuery = countQuery;
      if (searchTerm) {
        const searchPattern = `%${searchTerm}%`;
        finalCountQuery = sql32`${finalCountQuery} AND (
          e.first_name ILIKE ${searchPattern} OR
          e.last_name ILIKE ${searchPattern} OR
          e.cnp LIKE ${searchPattern} OR
          e.email ILIKE ${searchPattern}
        )`;
      }
      if (departmentId && departmentName) {
        finalCountQuery = sql32`${finalCountQuery} AND e.department = ${departmentName}`;
      }
      if (isActive !== null) {
        finalCountQuery = sql32`${finalCountQuery} AND e.is_active = ${isActive}`;
      }
      const countResult = await this.drizzle.execute(finalCountQuery);
      const totalCount = parseInt(countResult[0]?.total_count || "0", 10);
      const fullQuery = sql32`${baseQuery}
        ORDER BY e.last_name ASC, e.first_name ASC
        LIMIT ${limit} OFFSET ${(page - 1) * limit}
      `;
      const result = await this.drizzle.execute(fullQuery);
      return {
        employees: result || [],
        pagination: {
          page,
          limit,
          totalCount,
          totalPages: Math.ceil(totalCount / limit)
        }
      };
    } catch (error) {
      console.error("Error searching employees:", error);
      throw new Error(`Failed to search employees: ${error.message}`);
    }
  }
  /**
   * Create a new department
   * 
   * @param companyId Company ID
   * @param name Department name
   * @param description Department description
   * @param managerId Optional manager employee ID
   * @param parentDepartmentId Optional parent department ID
   * @param userId User ID creating the department
   */
  async createDepartment(companyId, name, description, managerId, parentDepartmentId, userId) {
    try {
      const existingDepartment = await this.drizzle.select().from(departments).where(sql32`${departments.companyId} = ${companyId} AND ${departments.name} = ${name}`).limit(1);
      if (existingDepartment && existingDepartment.length > 0) {
        throw new Error("Department with this name already exists");
      }
      const result = await this.drizzle.insert(departments).values({
        companyId,
        name,
        description,
        managerId: managerId || void 0,
        parentDepartmentId: parentDepartmentId || void 0,
        isActive: true,
        createdBy: userId,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      const createdDepartment = result[0];
      await AuditService.log({
        userId,
        companyId,
        action: "create" /* CREATE */,
        entity: "department" /* DEPARTMENT */,
        entityId: createdDepartment.id,
        details: {
          companyId,
          name,
          managerId,
          parentDepartmentId
        }
      });
      return {
        id: createdDepartment.id,
        name,
        description,
        managerId,
        parentDepartmentId
      };
    } catch (error) {
      console.error("Error creating department:", error);
      throw new Error(`Failed to create department: ${error.message}`);
    }
  }
  /**
   * Get departments for a company
   * 
   * @param companyId Company ID
   * @param includeInactive Whether to include inactive departments
   */
  async getDepartments(companyId, includeInactive = false) {
    try {
      const activeCondition = includeInactive ? "" : "AND d.is_active = true";
      const query = sql32`
        SELECT 
          d.*,
          CONCAT(e.first_name, ' ', e.last_name) as manager_name,
          pd.name as parent_department_name
        FROM hr_departments d
        LEFT JOIN hr_employees e ON d.manager_id = e.id
        LEFT JOIN hr_departments pd ON d.parent_department_id = pd.id
        WHERE d.company_id = ${companyId} ${sql32.raw(activeCondition)}
        ORDER BY d.name ASC
      `;
      const result = await this.drizzle.execute(query);
      return result || [];
    } catch (error) {
      console.error("Error retrieving departments:", error);
      throw new Error(`Failed to retrieve departments: ${error.message}`);
    }
  }
  /**
   * Get employees in a department
   * 
   * @param departmentId Department ID
   * @param includeInactive Whether to include inactive employees
   */
  async getEmployeesByDepartment(departmentId, includeInactive = false) {
    try {
      const deptResult = await this.drizzle.execute(
        sql32`SELECT name FROM hr_departments WHERE id = ${departmentId}`
      );
      if (!deptResult || deptResult.length === 0) {
        return [];
      }
      const departmentName = deptResult[0].name;
      let baseQuery = sql32`
        SELECT e.*
        FROM hr_employees e
        WHERE e.department = ${departmentName}
      `;
      if (!includeInactive) {
        baseQuery = sql32`${baseQuery} AND e.is_active = ${true}`;
      }
      const fullQuery = sql32`
        ${baseQuery}
        ORDER BY e.last_name ASC, e.first_name ASC
      `;
      const result = await this.drizzle.execute(fullQuery);
      return result || [];
    } catch (error) {
      console.error("Error retrieving employees by department:", error);
      throw new Error(`Failed to retrieve employees by department: ${error.message}`);
    }
  }
};

// server/modules/hr/services/contract.service.ts
init_drizzle();
init_audit_service();
import { v4 as uuidv415 } from "uuid";
init_logger();
import { sql as sql33, desc as desc14 } from "drizzle-orm";
var ContractService = class {
  constructor() {
    this.logger = new Logger("ContractService");
    this.db = getDrizzle();
    this.auditService = new AuditService();
  }
  /**
   * Create a new employment contract
   * 
   * This method creates an employment contract and ensures compliance with:
   * - CIM format requirements (REVISAL)
   * - Single active contract validation
   * - Date format validation (Romanian format DD.MM.YYYY)
   */
  async createEmploymentContract(employeeId, companyId, contractNumber, contractType, startDate, endDate, baseSalaryGross, workingTime, corCode, annualVacationDays, userId, additionalData = {}) {
    try {
      const employee = await this.db.select().from(employees).where(sql33`${employees.id} = ${employeeId} AND ${employees.companyId} = ${companyId}`).execute();
      if (!employee || employee.length === 0) {
        throw new Error("Employee not found or does not belong to the company");
      }
      const activeContract = await this.db.select().from(employmentContracts).where(sql33`
          ${employmentContracts.employeeId} = ${employeeId} AND 
          ${employmentContracts.status} = 'active'
        `).execute();
      if (activeContract && activeContract.length > 0) {
        await this.db.update(employmentContracts).set({
          status: "terminated" /* TERMINATED */,
          updatedAt: /* @__PURE__ */ new Date(),
          updatedBy: userId
        }).where(sql33`${employmentContracts.id} = ${activeContract[0].id}`).execute();
        await this.auditService.logAction({
          userId,
          action: "update" /* UPDATE */,
          resourceType: "employment_contract" /* EMPLOYMENT_CONTRACT */,
          resourceId: activeContract[0].id,
          oldValue: JSON.stringify({ status: "active" /* ACTIVE */ }),
          newValue: JSON.stringify({ status: "terminated" /* TERMINATED */ }),
          companyId
        });
        this.logger.info(`Previous active contract ${activeContract[0].id} set to terminated`);
      }
      const contract = await this.db.insert(employmentContracts).values({
        id: uuidv415(),
        employeeId,
        companyId,
        contractNumber,
        contractType,
        startDate,
        endDate,
        baseSalaryGross,
        workingTime,
        corCode,
        annualVacationDays,
        isIndefinite: !endDate,
        status: "active" /* ACTIVE */,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        createdBy: userId,
        updatedBy: userId,
        ...additionalData
      }).returning().execute();
      await this.auditService.logAction({
        userId,
        action: "create" /* CREATE */,
        resourceType: "employment_contract" /* EMPLOYMENT_CONTRACT */,
        resourceId: contract[0].id,
        newValue: JSON.stringify(contract[0]),
        companyId
      });
      return contract[0];
    } catch (error) {
      this.logger.error("Failed to create employment contract:", error);
      throw error;
    }
  }
  /**
   * Update an employment contract
   */
  async updateEmploymentContract(contractId, companyId, userId, updates) {
    try {
      const currentContract = await this.db.select().from(employmentContracts).where(sql33`
          ${employmentContracts.id} = ${contractId} AND
          ${employmentContracts.companyId} = ${companyId}
        `).execute();
      if (!currentContract || currentContract.length === 0) {
        throw new Error("Contract not found or does not belong to the company");
      }
      const updateData = {
        ...updates,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      };
      if (updates.endDate && !currentContract[0].endDate) {
        updateData.isIndefinite = false;
      }
      const updated = await this.db.update(employmentContracts).set(updateData).where(sql33`${employmentContracts.id} = ${contractId}`).returning().execute();
      if (!updated || updated.length === 0) {
        throw new Error("Failed to update contract");
      }
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "employment_contract" /* EMPLOYMENT_CONTRACT */,
        resourceId: contractId,
        oldValue: JSON.stringify(currentContract[0]),
        newValue: JSON.stringify(updated[0]),
        companyId
      });
      return updated[0];
    } catch (error) {
      this.logger.error("Failed to update employment contract:", error);
      throw error;
    }
  }
  /**
   * Get the active employment contract for an employee
   */
  async getActiveEmploymentContract(employeeId) {
    try {
      const contracts = await this.db.select().from(employmentContracts).where(sql33`
          ${employmentContracts.employeeId} = ${employeeId} AND
          ${employmentContracts.status} = 'active'
        `).orderBy(desc14(employmentContracts.startDate)).limit(1).execute();
      return contracts.length > 0 ? contracts[0] : null;
    } catch (error) {
      this.logger.error("Failed to get active employment contract:", error);
      throw error;
    }
  }
  /**
   * Get employment contract history for an employee
   */
  async getEmploymentContractHistory(employeeId) {
    try {
      const result = await this.db.select().from(employmentContracts).where(sql33`${employmentContracts.employeeId} = ${employeeId}`).orderBy(desc14(employmentContracts.startDate)).execute();
      return result;
    } catch (error) {
      this.logger.error("Failed to get employment contract history:", error);
      throw error;
    }
  }
  /**
   * Terminate an active employment contract
   */
  async terminateContract(contractId, companyId, userId, terminationDate, terminationReason) {
    try {
      const contract = await this.db.select().from(employmentContracts).where(sql33`
          ${employmentContracts.id} = ${contractId} AND
          ${employmentContracts.companyId} = ${companyId} AND
          ${employmentContracts.status} = 'active'
        `).execute();
      if (!contract || contract.length === 0) {
        throw new Error("Active contract not found or does not belong to the company");
      }
      const updated = await this.db.update(employmentContracts).set({
        status: "terminated" /* TERMINATED */,
        endDate: terminationDate,
        isIndefinite: false,
        terminationReason,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(sql33`${employmentContracts.id} = ${contractId}`).returning().execute();
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "employment_contract" /* EMPLOYMENT_CONTRACT */,
        resourceId: contractId,
        oldValue: JSON.stringify({
          status: "active" /* ACTIVE */,
          endDate: contract[0].endDate,
          isIndefinite: contract[0].isIndefinite
        }),
        newValue: JSON.stringify({
          status: "terminated" /* TERMINATED */,
          endDate: terminationDate,
          isIndefinite: false,
          terminationReason
        }),
        companyId
      });
      return updated[0];
    } catch (error) {
      this.logger.error("Failed to terminate contract:", error);
      throw error;
    }
  }
  /**
   * Suspend an active employment contract
   */
  async suspendContract(contractId, companyId, userId, suspensionDate, suspensionReason, suspensionEndDate) {
    try {
      const contract = await this.db.select().from(employmentContracts).where(sql33`
          ${employmentContracts.id} = ${contractId} AND
          ${employmentContracts.companyId} = ${companyId} AND
          ${employmentContracts.status} = 'active'
        `).execute();
      if (!contract || contract.length === 0) {
        throw new Error("Active contract not found or does not belong to the company");
      }
      const updated = await this.db.update(employmentContracts).set({
        status: "suspended" /* SUSPENDED */,
        suspensionDate,
        suspensionEndDate,
        suspensionReason,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(sql33`${employmentContracts.id} = ${contractId}`).returning().execute();
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "employment_contract" /* EMPLOYMENT_CONTRACT */,
        resourceId: contractId,
        oldValue: JSON.stringify({
          status: "active" /* ACTIVE */
        }),
        newValue: JSON.stringify({
          status: "suspended" /* SUSPENDED */,
          suspensionDate,
          suspensionEndDate,
          suspensionReason
        }),
        companyId
      });
      return updated[0];
    } catch (error) {
      this.logger.error("Failed to suspend contract:", error);
      throw error;
    }
  }
  /**
   * Reactivate a suspended employment contract
   */
  async reactivateContract(contractId, companyId, userId, reactivationDate, reactivationReason) {
    try {
      const contract = await this.db.select().from(employmentContracts).where(sql33`
          ${employmentContracts.id} = ${contractId} AND
          ${employmentContracts.companyId} = ${companyId} AND
          ${employmentContracts.status} = 'suspended'
        `).execute();
      if (!contract || contract.length === 0) {
        throw new Error("Suspended contract not found or does not belong to the company");
      }
      const updated = await this.db.update(employmentContracts).set({
        status: "active" /* ACTIVE */,
        suspensionEndDate: reactivationDate,
        reactivationReason,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(sql33`${employmentContracts.id} = ${contractId}`).returning().execute();
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "employment_contract" /* EMPLOYMENT_CONTRACT */,
        resourceId: contractId,
        oldValue: JSON.stringify({
          status: "suspended" /* SUSPENDED */
        }),
        newValue: JSON.stringify({
          status: "active" /* ACTIVE */,
          suspensionEndDate: reactivationDate,
          reactivationReason
        }),
        companyId
      });
      return updated[0];
    } catch (error) {
      this.logger.error("Failed to reactivate contract:", error);
      throw error;
    }
  }
  /**
   * Get contract by ID
   */
  async getContractById(contractId, companyId) {
    try {
      const contracts = await this.db.select().from(employmentContracts).where(sql33`
          ${employmentContracts.id} = ${contractId} AND
          ${employmentContracts.companyId} = ${companyId}
        `).execute();
      return contracts.length > 0 ? contracts[0] : null;
    } catch (error) {
      this.logger.error("Failed to get contract by ID:", error);
      throw error;
    }
  }
};

// server/modules/hr/services/department.service.ts
init_drizzle();
init_audit_service();
import { v4 as uuidv416 } from "uuid";
init_logger();
import { sql as sql34, asc as asc9 } from "drizzle-orm";
var DepartmentService = class {
  constructor() {
    this.logger = new Logger("DepartmentService");
    this.db = getDrizzle();
    this.auditService = new AuditService();
  }
  /**
   * Create a new department
   */
  async createDepartment(companyId, name, description, managerId, parentDepartmentId, userId, isActive = true) {
    try {
      if (parentDepartmentId) {
        const parentDept = await this.db.select().from(departments).where(sql34`
            ${departments.id} = ${parentDepartmentId} AND
            ${departments.companyId} = ${companyId}
          `).execute();
        if (!parentDept || parentDept.length === 0) {
          throw new Error("Parent department not found or does not belong to the company");
        }
      }
      const department = await this.db.insert(departments).values({
        id: uuidv416(),
        companyId,
        name,
        description,
        managerId,
        parentDepartmentId,
        isActive,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        createdBy: userId,
        updatedBy: userId
      }).returning().execute();
      await this.auditService.logAction({
        userId,
        action: "create" /* CREATE */,
        resourceType: "department" /* DEPARTMENT */,
        resourceId: department[0].id,
        newValue: JSON.stringify(department[0]),
        companyId
      });
      return department[0];
    } catch (error) {
      this.logger.error("Failed to create department:", error);
      throw error;
    }
  }
  /**
   * Get departments for a company with hierarchy information
   */
  async getDepartments(companyId, includeInactive = false) {
    try {
      let query = this.db.select().from(departments).where(sql34`${departments.companyId} = ${companyId}`);
      if (!includeInactive) {
        query = query.where(sql34`${departments.isActive} = true`);
      }
      const result = await query.orderBy(asc9(departments.name)).execute();
      const departmentsMap = {};
      const rootDepartments = [];
      result.forEach((department) => {
        departmentsMap[department.id] = {
          ...department,
          children: []
        };
      });
      result.forEach((department) => {
        if (department.parentDepartmentId && departmentsMap[department.parentDepartmentId]) {
          departmentsMap[department.parentDepartmentId].children.push(departmentsMap[department.id]);
        } else {
          rootDepartments.push(departmentsMap[department.id]);
        }
      });
      return rootDepartments;
    } catch (error) {
      this.logger.error("Failed to get departments:", error);
      throw error;
    }
  }
  /**
   * Get employees by department
   */
  async getEmployeesByDepartment(departmentId, includeInactive = false) {
    try {
      let query = this.db.select().from(employees).where(sql34`${employees.departmentId} = ${departmentId}`);
      if (!includeInactive) {
        query = query.where(sql34`${employees.isActive} = true`);
      }
      const result = await query.orderBy(asc9(employees.lastName), asc9(employees.firstName)).execute();
      return result;
    } catch (error) {
      this.logger.error("Failed to get employees by department:", error);
      throw error;
    }
  }
  /**
   * Update a department
   */
  async updateDepartment(departmentId, companyId, updates, userId) {
    try {
      const currentDepartment = await this.db.select().from(departments).where(sql34`
          ${departments.id} = ${departmentId} AND
          ${departments.companyId} = ${companyId}
        `).execute();
      if (!currentDepartment || currentDepartment.length === 0) {
        throw new Error("Department not found or does not belong to the company");
      }
      if (updates.parentDepartmentId && updates.parentDepartmentId !== currentDepartment[0].parentDepartmentId) {
        if (updates.parentDepartmentId === departmentId) {
          throw new Error("Department cannot be its own parent");
        }
        const parentDept = await this.db.select().from(departments).where(sql34`
            ${departments.id} = ${updates.parentDepartmentId} AND
            ${departments.companyId} = ${companyId}
          `).execute();
        if (!parentDept || parentDept.length === 0) {
          throw new Error("Parent department not found or does not belong to the company");
        }
        let currentParentId = parentDept[0].parentDepartmentId;
        while (currentParentId) {
          if (currentParentId === departmentId) {
            throw new Error("Circular reference detected in department hierarchy");
          }
          const parent = await this.db.select().from(departments).where(sql34`${departments.id} = ${currentParentId}`).execute();
          if (!parent || parent.length === 0) {
            break;
          }
          currentParentId = parent[0].parentDepartmentId;
        }
      }
      const updateData = {
        ...updates,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      };
      const updated = await this.db.update(departments).set(updateData).where(sql34`${departments.id} = ${departmentId}`).returning().execute();
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "department" /* DEPARTMENT */,
        resourceId: departmentId,
        oldValue: JSON.stringify(currentDepartment[0]),
        newValue: JSON.stringify(updated[0]),
        companyId
      });
      return updated[0];
    } catch (error) {
      this.logger.error("Failed to update department:", error);
      throw error;
    }
  }
  /**
   * Get department by ID
   */
  async getDepartmentById(departmentId, companyId) {
    try {
      const departments2 = await this.db.select().from(departments2).where(sql34`
          ${departments2.id} = ${departmentId} AND
          ${departments2.companyId} = ${companyId}
        `).execute();
      return departments2.length > 0 ? departments2[0] : null;
    } catch (error) {
      this.logger.error("Failed to get department by ID:", error);
      throw error;
    }
  }
  /**
   * Change department manager
   */
  async changeDepartmentManager(departmentId, companyId, managerId, userId) {
    try {
      const department = await this.getDepartmentById(departmentId, companyId);
      if (!department) {
        throw new Error("Department not found or does not belong to the company");
      }
      const manager = await this.db.select().from(employees).where(sql34`
          ${employees.id} = ${managerId} AND
          ${employees.companyId} = ${companyId} AND
          ${employees.isActive} = true
        `).execute();
      if (!manager || manager.length === 0) {
        throw new Error("Manager not found or not an active employee");
      }
      const updated = await this.db.update(departments).set({
        managerId,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(sql34`${departments.id} = ${departmentId}`).returning().execute();
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "department" /* DEPARTMENT */,
        resourceId: departmentId,
        oldValue: JSON.stringify({ managerId: department.managerId }),
        newValue: JSON.stringify({ managerId }),
        companyId
      });
      return updated[0];
    } catch (error) {
      this.logger.error("Failed to change department manager:", error);
      throw error;
    }
  }
  /**
   * Deactivate a department
   */
  async deactivateDepartment(departmentId, companyId, userId) {
    try {
      const department = await this.getDepartmentById(departmentId, companyId);
      if (!department) {
        throw new Error("Department not found or does not belong to the company");
      }
      const subDepartments = await this.db.select().from(departments).where(sql34`
          ${departments.parentDepartmentId} = ${departmentId} AND
          ${departments.isActive} = true
        `).execute();
      if (subDepartments && subDepartments.length > 0) {
        throw new Error("Cannot deactivate department with active sub-departments");
      }
      const activeEmployees = await this.db.select().from(employees).where(sql34`
          ${employees.departmentId} = ${departmentId} AND
          ${employees.isActive} = true
        `).execute();
      if (activeEmployees && activeEmployees.length > 0) {
        throw new Error("Cannot deactivate department with active employees");
      }
      const updated = await this.db.update(departments).set({
        isActive: false,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(sql34`${departments.id} = ${departmentId}`).returning().execute();
      await this.auditService.logAction({
        userId,
        action: "update" /* UPDATE */,
        resourceType: "department" /* DEPARTMENT */,
        resourceId: departmentId,
        oldValue: JSON.stringify({ isActive: true }),
        newValue: JSON.stringify({ isActive: false }),
        companyId
      });
      return updated[0];
    } catch (error) {
      this.logger.error("Failed to deactivate department:", error);
      throw error;
    }
  }
};

// server/modules/hr/services/cor.service.ts
import xml2js from "xml2js";
import fs3 from "fs";
import { eq as eq41, sql as sql35 } from "drizzle-orm";
var CorService = class {
  constructor(db4, auditService4) {
    this.db = db4;
    this.auditService = auditService4;
  }
  /**
   * Get major groups with optional search filter
   */
  async getMajorGroups(searchTerm) {
    try {
      let query = this.db.select().from(corMajorGroups);
      if (searchTerm) {
        query = query.where(sql35`lower(name) LIKE ${`%${searchTerm.toLowerCase()}%`}`);
      }
      return await query.orderBy(corMajorGroups.code);
    } catch (error) {
      console.error("Error fetching COR major groups:", error);
      throw new Error("Failed to fetch COR major groups");
    }
  }
  /**
   * Get submajor groups with optional parent code or search filter
   */
  async getSubmajorGroups(majorGroupCode, searchTerm) {
    try {
      let query = this.db.select().from(corSubmajorGroups);
      if (majorGroupCode) {
        query = query.where(eq41(corSubmajorGroups.majorGroupCode, majorGroupCode));
      }
      if (searchTerm) {
        query = query.where(sql35`lower(name) LIKE ${`%${searchTerm.toLowerCase()}%`}`);
      }
      return await query.orderBy(corSubmajorGroups.code);
    } catch (error) {
      console.error("Error fetching COR submajor groups:", error);
      throw new Error("Failed to fetch COR submajor groups");
    }
  }
  /**
   * Get minor groups with optional parent code or search filter
   */
  async getMinorGroups(submajorGroupCode, searchTerm) {
    try {
      let query = this.db.select().from(corMinorGroups);
      if (submajorGroupCode) {
        query = query.where(eq41(corMinorGroups.submajorGroupCode, submajorGroupCode));
      }
      if (searchTerm) {
        query = query.where(sql35`lower(name) LIKE ${`%${searchTerm.toLowerCase()}%`}`);
      }
      return await query.orderBy(corMinorGroups.code);
    } catch (error) {
      console.error("Error fetching COR minor groups:", error);
      throw new Error("Failed to fetch COR minor groups");
    }
  }
  /**
   * Get subminor groups with optional parent code or search filter
   */
  async getSubminorGroups(minorGroupCode, searchTerm) {
    try {
      let query = this.db.select().from(corSubminorGroups);
      if (minorGroupCode) {
        query = query.where(eq41(corSubminorGroups.minorGroupCode, minorGroupCode));
      }
      if (searchTerm) {
        query = query.where(sql35`lower(name) LIKE ${`%${searchTerm.toLowerCase()}%`}`);
      }
      return await query.orderBy(corSubminorGroups.code);
    } catch (error) {
      console.error("Error fetching COR subminor groups:", error);
      throw new Error("Failed to fetch COR subminor groups");
    }
  }
  /**
   * Get occupations with optional parent code or search filter
   */
  async getOccupations(subminorGroupCode, searchTerm) {
    try {
      let query = this.db.select().from(corOccupations);
      if (subminorGroupCode) {
        query = query.where(eq41(corOccupations.subminorGroupCode, subminorGroupCode));
      }
      if (searchTerm) {
        query = query.where(sql35`lower(name) LIKE ${`%${searchTerm.toLowerCase()}%`}`);
      }
      return await query.orderBy(corOccupations.code);
    } catch (error) {
      console.error("Error fetching COR occupations:", error);
      throw new Error("Failed to fetch COR occupations");
    }
  }
  /**
   * Get occupation details by code
   */
  async getOccupationByCode(code) {
    try {
      const occupation = await this.db.select().from(corOccupations).where(eq41(corOccupations.code, code)).limit(1);
      return occupation[0] || null;
    } catch (error) {
      console.error(`Error fetching COR occupation with code ${code}:`, error);
      throw new Error(`Failed to fetch COR occupation with code ${code}`);
    }
  }
  /**
   * Search occupations by name or code
   */
  async searchOccupations(searchTerm, limit = 50) {
    try {
      const isNumeric = /^\d+$/.test(searchTerm);
      let query = this.db.select().from(corOccupations);
      if (isNumeric) {
        query = query.where(sql35`code LIKE ${`${searchTerm}%`}`).orderBy(corOccupations.code).limit(limit);
      } else {
        query = query.where(sql35`lower(name) LIKE ${`%${searchTerm.toLowerCase()}%`}`).orderBy(corOccupations.name).limit(limit);
      }
      return await query;
    } catch (error) {
      console.error("Error searching COR occupations:", error);
      throw new Error("Failed to search COR occupations");
    }
  }
  /**
   * Validate a COR code
   */
  async validateCorCode(code) {
    try {
      if (!/^\d{6}$/.test(code)) {
        return false;
      }
      const occupation = await this.getOccupationByCode(code);
      return !!occupation;
    } catch (error) {
      console.error(`Error validating COR code ${code}:`, error);
      throw new Error(`Failed to validate COR code ${code}`);
    }
  }
  /**
   * Get COR database statistics
   */
  async getCorStats() {
    try {
      const majorGroupsCount = await this.db.select({ count: sql35`count(*)` }).from(corMajorGroups);
      const submajorGroupsCount = await this.db.select({ count: sql35`count(*)` }).from(corSubmajorGroups);
      const minorGroupsCount = await this.db.select({ count: sql35`count(*)` }).from(corMinorGroups);
      const subminorGroupsCount = await this.db.select({ count: sql35`count(*)` }).from(corSubminorGroups);
      const occupationsCount = await this.db.select({ count: sql35`count(*)` }).from(corOccupations);
      const activeOccupationsCount = await this.db.select({ count: sql35`count(*)` }).from(corOccupations).where(eq41(corOccupations.isActive, true));
      return {
        majorGroups: Number(majorGroupsCount[0].count),
        submajorGroups: Number(submajorGroupsCount[0].count),
        minorGroups: Number(minorGroupsCount[0].count),
        subminorGroups: Number(subminorGroupsCount[0].count),
        occupations: Number(occupationsCount[0].count),
        activeOccupations: Number(activeOccupationsCount[0].count)
      };
    } catch (error) {
      console.error("Error fetching COR statistics:", error);
      throw new Error(`Failed to fetch COR statistics: ${error.message || "Unknown error"}`);
    }
  }
  /**
   * Seed the COR database with data from XML files
   * Supports both Excel XML format and Word XML format
   */
  async seedCorData(userId, xmlFilePath) {
    try {
      console.log(`Starting COR data seeding from ${xmlFilePath}`);
      const xmlData = fs3.readFileSync(xmlFilePath, "utf8");
      if (xmlData.includes('<?mso-application progid="Word.Document"?>')) {
        return this.seedCorDataFromWordXml(userId, xmlFilePath);
      }
      return this.seedCorDataFromExcelXml(userId, xmlFilePath);
    } catch (error) {
      console.error("Error seeding COR data:", error);
      throw new Error(`Failed to seed COR data: ${error.message || "Unknown error"}`);
    }
  }
  /**
   * Seed COR data from Excel XML format (cor-grupe-ocupationale.xml)
   */
  async seedCorDataFromExcelXml(userId, xmlFilePath) {
    try {
      console.log(`Processing Excel XML format from ${xmlFilePath}`);
      const xmlData = fs3.readFileSync(xmlFilePath, "utf8");
      const parser = new xml2js.Parser({ explicitArray: false });
      const result = await parser.parseStringPromise(xmlData);
      if (!result || !result.COR || !result.COR.GrupaOcupationala) {
        throw new Error("Invalid COR Excel XML format");
      }
      console.log("Successfully parsed COR Excel XML data");
      await this.db.transaction(async (tx) => {
        const grupeOcupationale = Array.isArray(result.COR.GrupaOcupationala) ? result.COR.GrupaOcupationala : [result.COR.GrupaOcupationala];
        const majorGroupsMap = /* @__PURE__ */ new Map();
        for (const grupa of grupeOcupationale) {
          const majorCode = grupa.$.cod.substring(0, 1);
          if (!majorGroupsMap.has(majorCode)) {
            majorGroupsMap.set(majorCode, {
              code: majorCode,
              name: `Grupa majora ${majorCode}`,
              description: `Grupa majora ${majorCode}`
            });
          }
        }
        for (const majorGroup of majorGroupsMap.values()) {
          await tx.insert(corMajorGroups).values(majorGroup).onConflictDoUpdate({
            target: corMajorGroups.code,
            set: {
              name: majorGroup.name,
              description: majorGroup.description,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
        console.log(`Inserted ${majorGroupsMap.size} major groups`);
        const submajorGroupsMap = /* @__PURE__ */ new Map();
        for (const grupa of grupeOcupationale) {
          const majorCode = grupa.$.cod.substring(0, 1);
          const submajorCode = grupa.$.cod.substring(0, 2);
          if (!submajorGroupsMap.has(submajorCode)) {
            submajorGroupsMap.set(submajorCode, {
              code: submajorCode,
              name: `Subgrupa majora ${submajorCode}`,
              description: `Subgrupa majora ${submajorCode}`,
              majorGroupCode: majorCode
            });
          }
        }
        for (const submajorGroup of submajorGroupsMap.values()) {
          await tx.insert(corSubmajorGroups).values(submajorGroup).onConflictDoUpdate({
            target: corSubmajorGroups.code,
            set: {
              name: submajorGroup.name,
              description: submajorGroup.description,
              majorGroupCode: submajorGroup.majorGroupCode,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
        console.log(`Inserted ${submajorGroupsMap.size} submajor groups`);
        const minorGroupsMap = /* @__PURE__ */ new Map();
        for (const grupa of grupeOcupationale) {
          const submajorCode = grupa.$.cod.substring(0, 2);
          const minorCode = grupa.$.cod.substring(0, 3);
          if (!minorGroupsMap.has(minorCode)) {
            minorGroupsMap.set(minorCode, {
              code: minorCode,
              name: `Grupa minora ${minorCode}`,
              description: `Grupa minora ${minorCode}`,
              submajorGroupCode: submajorCode
            });
          }
        }
        for (const minorGroup of minorGroupsMap.values()) {
          await tx.insert(corMinorGroups).values(minorGroup).onConflictDoUpdate({
            target: corMinorGroups.code,
            set: {
              name: minorGroup.name,
              description: minorGroup.description,
              submajorGroupCode: minorGroup.submajorGroupCode,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
        console.log(`Inserted ${minorGroupsMap.size} minor groups`);
        const subminorGroupsMap = /* @__PURE__ */ new Map();
        for (const grupa of grupeOcupationale) {
          const minorCode = grupa.$.cod.substring(0, 3);
          const subminorCode = grupa.$.cod.substring(0, 4);
          if (!subminorGroupsMap.has(subminorCode)) {
            subminorGroupsMap.set(subminorCode, {
              code: subminorCode,
              name: `Subgrupa minora ${subminorCode}`,
              description: `Subgrupa minora ${subminorCode}`,
              minorGroupCode: minorCode
            });
          }
        }
        for (const subminorGroup of subminorGroupsMap.values()) {
          await tx.insert(corSubminorGroups).values(subminorGroup).onConflictDoUpdate({
            target: corSubminorGroups.code,
            set: {
              name: subminorGroup.name,
              description: subminorGroup.description,
              minorGroupCode: subminorGroup.minorGroupCode,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
        console.log(`Inserted ${subminorGroupsMap.size} subminor groups`);
        let occupationCount = 0;
        for (const grupa of grupeOcupationale) {
          const subminorCode = grupa.$.cod.substring(0, 4);
          const ocupatii = Array.isArray(grupa.Ocupatie) ? grupa.Ocupatie : grupa.Ocupatie ? [grupa.Ocupatie] : [];
          for (const ocupatie of ocupatii) {
            const occupationCode = ocupatie.$.cod;
            const occupationName = ocupatie.$.denumire;
            if (!occupationCode || !occupationName) {
              console.warn(`Skipping occupation with missing code or name: ${JSON.stringify(ocupatie)}`);
              continue;
            }
            await tx.insert(corOccupations).values({
              code: occupationCode,
              name: occupationName,
              description: "",
              subminorGroupCode: subminorCode,
              isActive: true
            }).onConflictDoUpdate({
              target: corOccupations.code,
              set: {
                name: occupationName,
                subminorGroupCode: subminorCode,
                updatedAt: /* @__PURE__ */ new Date()
              }
            });
            occupationCount++;
          }
        }
        console.log(`Inserted ${occupationCount} occupations`);
        await this.auditService.logAction(
          userId,
          "SEED",
          "COR",
          "SEED",
          `Seeded COR data from Excel XML format: ${xmlFilePath}`,
          null,
          {
            stats: {
              majorGroups: majorGroupsMap.size,
              submajorGroups: submajorGroupsMap.size,
              minorGroups: minorGroupsMap.size,
              subminorGroups: subminorGroupsMap.size,
              occupations: occupationCount
            }
          }
        );
      });
      console.log("COR data seeding from Excel XML completed successfully");
      return {
        success: true,
        message: "COR data seeding from Excel XML completed successfully"
      };
    } catch (error) {
      console.error("Error seeding COR data from Excel XML:", error);
      throw new Error(`Failed to seed COR data from Excel XML: ${error.message || "Unknown error"}`);
    }
  }
  /**
   * Seed COR data from Word XML format (isco-08-lista-cresc-cod-ocupatii-cor-2024.xml)
   * This format has a different structure and requires special processing
   */
  async seedCorDataFromWordXml(userId, xmlFilePath) {
    try {
      console.log(`Processing Word XML format from ${xmlFilePath}`);
      const xmlData = fs3.readFileSync(xmlFilePath, "utf8");
      const codeMatches = xmlData.match(/\b([0-9]{6})\b/g) || [];
      const uniqueCodes = Array.from(new Set(codeMatches));
      console.log(`Found ${uniqueCodes.length} occupation codes in Word XML`);
      const textMatches = xmlData.match(/<w:t>([^<]+)<\/w:t>/g) || [];
      const textContents = textMatches.map((match) => {
        const content = match.replace(/<w:t>|<\/w:t>/g, "").trim();
        return content;
      }).filter((text24) => text24.length > 0);
      const occupationMap = /* @__PURE__ */ new Map();
      for (let i = 0; i < textContents.length; i++) {
        const content = textContents[i];
        if (/^[0-9]{6}$/.test(content)) {
          const code = content;
          if (i + 1 < textContents.length && textContents[i + 1].length > 0) {
            const name = textContents[i + 1];
            occupationMap.set(code, name);
            i++;
          }
        }
      }
      if (occupationMap.size < uniqueCodes.length / 2) {
        console.log(`First approach only found ${occupationMap.size} matches, trying alternative...`);
        occupationMap.clear();
        for (const code of uniqueCodes) {
          const codeIndex = xmlData.indexOf(code);
          if (codeIndex !== -1) {
            const afterCode = xmlData.substring(codeIndex + code.length, codeIndex + 500);
            const nameMatch = afterCode.match(/<w:t>([^<]{5,100})<\/w:t>/);
            if (nameMatch) {
              const name = nameMatch[1].trim();
              if (name.length > 5 && !/^\d+$/.test(name) && !name.includes("<") && !name.includes(">")) {
                occupationMap.set(code, name);
              }
            }
          }
        }
      }
      console.log(`Matched ${occupationMap.size} occupations with names`);
      await this.db.transaction(async (tx) => {
        let insertCount = 0;
        let updateCount = 0;
        const batchSize = 100;
        const entries = Array.from(occupationMap.entries());
        for (let i = 0; i < entries.length; i += batchSize) {
          const batch = entries.slice(i, i + batchSize);
          for (const [code, name] of batch) {
            const subminorCode = code.substring(0, 4);
            const existingOccupation = await tx.select().from(corOccupations).where(eq41(corOccupations.code, code)).limit(1);
            if (existingOccupation.length === 0) {
              await tx.insert(corOccupations).values({
                code,
                name,
                description: "",
                subminorGroupCode: subminorCode,
                isActive: true
              });
              insertCount++;
            } else {
              await tx.update(corOccupations).set({
                name,
                updatedAt: /* @__PURE__ */ new Date()
              }).where(eq41(corOccupations.code, code));
              updateCount++;
            }
            await this.ensureParentGroupsExist(tx, subminorCode);
          }
          console.log(`Processed batch ${i / batchSize + 1}/${Math.ceil(entries.length / batchSize)}`);
        }
        console.log(`Word XML import: ${insertCount} new occupations inserted, ${updateCount} existing occupations updated`);
        await this.auditService.logAction(
          userId,
          "SEED",
          "COR",
          "SEED",
          `Seeded COR data from Word XML format: ${xmlFilePath}`,
          null,
          {
            stats: {
              occupationsInserted: insertCount,
              occupationsUpdated: updateCount,
              totalProcessed: insertCount + updateCount
            }
          }
        );
      });
      console.log("COR data seeding from Word XML completed successfully");
      return {
        success: true,
        message: "COR data seeding from Word XML completed successfully"
      };
    } catch (error) {
      console.error("Error seeding COR data from Word XML:", error);
      throw new Error(`Failed to seed COR data from Word XML: ${error.message || "Unknown error"}`);
    }
  }
  /**
   * Log batch import in the audit log
   */
  async logBatchImport(userId, insertCount, updateCount, totalCount) {
    await this.auditService.logAction(
      userId,
      "IMPORT",
      "COR",
      "BATCH_IMPORT",
      `Imported COR occupations batch`,
      null,
      {
        stats: {
          occupationsInserted: insertCount,
          occupationsUpdated: updateCount,
          totalProcessed: insertCount + updateCount,
          batchSize: totalCount
        }
      }
    );
  }
  /**
   * Ensure parent groups exist for a given subminor code
   * This method is public so it can be called from the controller
   */
  async ensureParentGroupsExist(tx, subminorCode) {
    try {
      const majorCode = subminorCode.substring(0, 1);
      const submajorCode = subminorCode.substring(0, 2);
      const minorCode = subminorCode.substring(0, 3);
      const majorGroup = await tx.select().from(corMajorGroups).where(eq41(corMajorGroups.code, majorCode)).limit(1);
      if (majorGroup.length === 0) {
        await tx.insert(corMajorGroups).values({
          code: majorCode,
          name: `Grupa majora ${majorCode}`,
          description: `Grupa majora ${majorCode}`
        });
      }
      const submajorGroup = await tx.select().from(corSubmajorGroups).where(eq41(corSubmajorGroups.code, submajorCode)).limit(1);
      if (submajorGroup.length === 0) {
        await tx.insert(corSubmajorGroups).values({
          code: submajorCode,
          name: `Subgrupa majora ${submajorCode}`,
          description: `Subgrupa majora ${submajorCode}`,
          majorGroupCode: majorCode
        });
      }
      const minorGroup = await tx.select().from(corMinorGroups).where(eq41(corMinorGroups.code, minorCode)).limit(1);
      if (minorGroup.length === 0) {
        await tx.insert(corMinorGroups).values({
          code: minorCode,
          name: `Grupa minora ${minorCode}`,
          description: `Grupa minora ${minorCode}`,
          submajorGroupCode: submajorCode
        });
      }
      const subminorGroup = await tx.select().from(corSubminorGroups).where(eq41(corSubminorGroups.code, subminorCode)).limit(1);
      if (subminorGroup.length === 0) {
        await tx.insert(corSubminorGroups).values({
          code: subminorCode,
          name: `Subgrupa minora ${subminorCode}`,
          description: `Subgrupa minora ${subminorCode}`,
          minorGroupCode: minorCode
        });
      }
    } catch (error) {
      console.error(`Error ensuring parent groups for ${subminorCode}:`, error);
      throw error;
    }
  }
};

// server/modules/hr/hr.module.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();

// server/common/services/audit.service.ts
var AuditService2 = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Log an audit event
   * 
   * @param userId - The ID of the user who performed the action
   * @param action - The action that was performed (e.g., 'create', 'update', 'delete')
   * @param resource - The resource that was affected (e.g., 'employee', 'contract', 'invoice')
   * @param resourceId - The ID of the resource that was affected
   * @param details - Additional details about the action
   * @param oldValues - The old values before the change (for updates)
   * @param newValues - The new values after the change (for updates)
   */
  async logAction(userId, action, resource, resourceId, details, oldValues, newValues) {
    try {
      console.log(`AUDIT: User ${userId} performed ${action} on ${resource} ${resourceId}`);
      if (details) {
        console.log(`AUDIT: Details: ${details}`);
      }
      return {
        success: true,
        timestamp: /* @__PURE__ */ new Date(),
        userId,
        action,
        resource,
        resourceId
      };
    } catch (error) {
      console.error("Error logging audit action:", error);
      return {
        success: false,
        error: error.message || "Unknown error"
      };
    }
  }
};

// server/modules/hr/controllers/employee.controller.ts
init_auth_guard();
init_logger();
var logger42 = new Logger("EmployeeController");
var EmployeeController = class {
  constructor(employeeService2) {
    this.employeeService = employeeService2;
  }
  registerRoutes(router14) {
    router14.get(
      "/employees",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      this.searchEmployees.bind(this)
    );
    router14.post(
      "/employee",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      this.createSimpleEmployee.bind(this)
    );
    router14.get(
      "/employees/:id",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      this.getEmployeeById.bind(this)
    );
    router14.post(
      "/employees",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      this.createEmployee.bind(this)
    );
    router14.put(
      "/employees/:id",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      this.updateEmployee.bind(this)
    );
  }
  /**
   * Search/list employees with filtering options
   */
  async searchEmployees(req, res) {
    try {
      const {
        search,
        departmentId,
        isActive,
        page,
        limit
      } = req.query;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const result = await this.employeeService.searchEmployees(
        companyId,
        search || null,
        departmentId || null,
        isActive === "true" ? true : isActive === "false" ? false : null,
        parseInt(page) || 1,
        parseInt(limit) || 50
      );
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      logger42.error("Error searching employees:", error);
      res.status(500).json({
        success: false,
        message: "An error occurred while searching employees",
        error: error.message
      });
    }
  }
  /**
   * Create a simple employee record
   */
  async createSimpleEmployee(req, res) {
    try {
      const {
        name,
        email,
        position,
        salary,
        hireDate,
        franchiseId,
        cnp
      } = req.body;
      if (!name || !email || !position) {
        return res.status(400).json({
          success: false,
          message: "Name, email, and position are required"
        });
      }
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const cnpValue = cnp && typeof cnp === "string" && cnp.trim() !== "" ? cnp.trim() : "1900101000000";
      logger42.debug("[EmployeeController] Using CNP value for employee creation:", cnpValue);
      logger42.debug("[EmployeeController] Creating employee with params:", {
        companyId,
        franchiseId: franchiseId || null,
        name,
        email,
        position,
        salary: salary ? parseFloat(salary) : 0,
        hireDate: hireDate ? new Date(hireDate) : /* @__PURE__ */ new Date(),
        cnp: cnpValue
        // Use the proper field name to match parameter
      });
      const employee = await this.employeeService.createSimpleEmployee(
        companyId,
        franchiseId || null,
        name,
        email,
        position,
        salary ? parseFloat(salary) : 0,
        hireDate ? new Date(hireDate) : /* @__PURE__ */ new Date(),
        cnpValue
        // Passing the guaranteed non-null value
      );
      if (req.user && req.user.id) {
        logger42.info("Employee created:", {
          userId: req.user.id,
          employeeId: employee?.id || "unknown",
          companyId
        });
      }
      return res.status(201).json({
        success: true,
        data: employee
      });
    } catch (error) {
      logger42.error("Error creating employee:", error);
      return res.status(500).json({
        success: false,
        message: "An error occurred while creating the employee",
        error: error.message
      });
    }
  }
  /**
   * Get employee by ID
   */
  async getEmployeeById(req, res) {
    try {
      const employee = await this.employeeService.getEmployeeById(req.params.id);
      res.json({
        success: true,
        data: employee
      });
    } catch (error) {
      logger42.error("Error getting employee:", error);
      res.status(404).json({
        success: false,
        message: "Employee not found",
        error: error.message
      });
    }
  }
  /**
   * Create a comprehensive employee record
   */
  async createEmployee(req, res) {
    try {
      const {
        firstName,
        lastName,
        email,
        phone,
        position,
        departmentId,
        cnp,
        address,
        birthDate,
        hireDate,
        data
      } = req.body;
      if (!firstName || !lastName || !email || !position) {
        return res.status(400).json({
          success: false,
          message: "First name, last name, email, and position are required"
        });
      }
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and user ID are required"
        });
      }
      const result = await this.employeeService.createEmployee(
        companyId,
        firstName,
        lastName,
        email,
        phone,
        position,
        departmentId,
        cnp,
        address,
        birthDate ? new Date(birthDate) : null,
        hireDate ? new Date(hireDate) : /* @__PURE__ */ new Date(),
        data || {},
        userId
      );
      res.status(201).json({
        success: true,
        data: result
      });
    } catch (error) {
      logger42.error("Error creating employee:", error);
      res.status(400).json({
        success: false,
        message: "An error occurred while creating the employee",
        error: error.message
      });
    }
  }
  /**
   * Update an employee record
   */
  async updateEmployee(req, res) {
    try {
      if (!req.params.id) {
        return res.status(400).json({
          success: false,
          message: "Employee ID is required"
        });
      }
      const userId = req.user?.id;
      if (!userId) {
        return res.status(400).json({
          success: false,
          message: "User ID is required"
        });
      }
      const result = await this.employeeService.updateEmployee(
        req.params.id,
        req.body,
        userId
      );
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      logger42.error("Error updating employee:", error);
      res.status(400).json({
        success: false,
        message: "An error occurred while updating the employee",
        error: error.message
      });
    }
  }
};

// server/modules/hr/controllers/contract.controller.ts
init_auth_guard();
init_logger();
var logger43 = new Logger("ContractController");
var ContractController = class {
  constructor(contractService) {
    this.contractService = contractService;
  }
  registerRoutes(router14) {
    router14.post(
      "/contracts",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      this.createContract.bind(this)
    );
    router14.get(
      "/contracts/:employeeId",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      this.getContractsByEmployeeId.bind(this)
    );
    router14.put(
      "/contracts/:id",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      this.updateContract.bind(this)
    );
  }
  /**
   * Create an employment contract
   */
  async createContract(req, res) {
    try {
      const {
        employeeId,
        contractNumber,
        contractType,
        startDate,
        endDate,
        baseSalaryGross,
        workingTime,
        corCode,
        annualVacationDays,
        contractFilePath,
        annexesFilePaths
      } = req.body;
      if (!employeeId || !contractNumber || !contractType) {
        return res.status(400).json({
          success: false,
          message: "Employee ID, contract number, and contract type are required"
        });
      }
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and user ID are required"
        });
      }
      const result = await this.contractService.createEmploymentContract(
        employeeId,
        companyId,
        contractNumber,
        contractType,
        startDate ? new Date(startDate) : /* @__PURE__ */ new Date(),
        endDate ? new Date(endDate) : null,
        baseSalaryGross,
        workingTime,
        corCode,
        annualVacationDays,
        userId,
        { contractFilePath, annexesFilePaths }
      );
      res.status(201).json({
        success: true,
        data: result
      });
    } catch (error) {
      logger43.error("Error creating employment contract:", error);
      res.status(400).json({
        success: false,
        message: "An error occurred while creating the employment contract",
        error: error.message
      });
    }
  }
  /**
   * Get employment contracts by employee ID
   */
  async getContractsByEmployeeId(req, res) {
    try {
      if (!req.params.employeeId) {
        return res.status(400).json({
          success: false,
          message: "Employee ID is required"
        });
      }
      const contracts = await this.contractService.getEmploymentContractHistory(req.params.employeeId);
      res.json({
        success: true,
        data: contracts
      });
    } catch (error) {
      logger43.error("Error retrieving employment contracts:", error);
      res.status(500).json({
        success: false,
        message: "An error occurred while retrieving employment contracts",
        error: error.message
      });
    }
  }
  /**
   * Update an employment contract
   */
  async updateContract(req, res) {
    try {
      if (!req.params.id) {
        return res.status(400).json({
          success: false,
          message: "Contract ID is required"
        });
      }
      const userId = req.user?.id;
      if (!userId) {
        return res.status(400).json({
          success: false,
          message: "User ID is required"
        });
      }
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const result = await this.contractService.updateEmploymentContract(
        req.params.id,
        companyId,
        userId,
        req.body
      );
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      logger43.error("Error updating employment contract:", error);
      res.status(400).json({
        success: false,
        message: "An error occurred while updating the employment contract",
        error: error.message
      });
    }
  }
};

// server/modules/hr/controllers/department.controller.ts
init_logger();
var logger44 = new Logger("DepartmentController");
var DepartmentController = class {
  constructor(employeeService2) {
    this.employeeService = employeeService2;
  }
  registerRoutes(router14) {
    router14.get("/departments", this.getDepartments.bind(this));
    router14.post("/departments", this.createDepartment.bind(this));
    router14.get("/departments/:id/employees", this.getEmployeesByDepartment.bind(this));
  }
  /**
   * Get all departments for a company
   */
  async getDepartments(req, res) {
    try {
      const includeInactive = req.query.includeInactive === "true";
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const departments2 = await this.employeeService.getDepartments(companyId, includeInactive);
      res.json(departments2);
    } catch (error) {
      logger44.error("Error retrieving departments:", error);
      res.status(500).json({
        success: false,
        message: "Failed to retrieve departments",
        error: error.message
      });
    }
  }
  /**
   * Create a new department
   */
  async createDepartment(req, res) {
    try {
      const { name, description, managerId, parentDepartmentId } = req.body;
      const result = await this.employeeService.createDepartment(
        req.user.companyId,
        name,
        description,
        managerId,
        parentDepartmentId,
        req.user.id
      );
      res.status(201).json(result);
    } catch (error) {
      logger44.error("Error creating department:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Get employees by department ID
   */
  async getEmployeesByDepartment(req, res) {
    try {
      const includeInactive = req.query.includeInactive === "true";
      const employees2 = await this.employeeService.getEmployeesByDepartment(req.params.id, includeInactive);
      res.json(employees2);
    } catch (error) {
      logger44.error("Error retrieving department employees:", error);
      res.status(500).json({ error: error.message });
    }
  }
};

// server/modules/hr/controllers/payroll.controller.ts
init_logger();
var logger45 = new Logger("PayrollController");
var PayrollController = class {
  constructor(payrollService) {
    this.payrollService = payrollService;
  }
  registerRoutes(router14) {
    router14.post("/payroll/calculate", this.calculateEmployeePayroll.bind(this));
    router14.post("/payroll/process-company", this.processCompanyPayroll.bind(this));
    router14.get("/payroll/reports/:year/:month", this.getPayrollReport.bind(this));
    router14.get("/payroll/employee/:id", this.getEmployeePayrollHistory.bind(this));
    router14.post("/payroll/export", this.exportPayroll.bind(this));
  }
  /**
   * Calculate payroll for a single employee
   */
  async calculateEmployeePayroll(req, res) {
    try {
      const { employeeId, year, month } = req.body;
      const result = await this.payrollService.calculateEmployeePayroll(
        employeeId,
        req.user.companyId,
        year,
        month,
        req.user.id
      );
      res.json(result);
    } catch (error) {
      logger45.error("Error calculating payroll:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Process payroll for an entire company
   */
  async processCompanyPayroll(req, res) {
    try {
      const { year, month } = req.body;
      const result = await this.payrollService.processCompanyPayroll(
        req.user.companyId,
        year,
        month,
        req.user.id
      );
      res.json(result);
    } catch (error) {
      logger45.error("Error processing company payroll:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Get a payroll report for a specific month
   */
  async getPayrollReport(req, res) {
    try {
      const { year, month } = req.params;
      const report = await this.payrollService.getPayrollReport(
        req.user.companyId,
        parseInt(year),
        parseInt(month)
      );
      res.json(report);
    } catch (error) {
      logger45.error("Error retrieving payroll report:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Get payroll history for a specific employee
   */
  async getEmployeePayrollHistory(req, res) {
    try {
      const employeeId = req.params.id;
      const history = await this.payrollService.getEmployeePayrollHistory(
        employeeId,
        req.user.companyId
      );
      res.json(history);
    } catch (error) {
      logger45.error("Error retrieving employee payroll history:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Export payroll data in various formats
   */
  async exportPayroll(req, res) {
    try {
      const { year, month, format } = req.body;
      const exportData = await this.payrollService.exportPayroll(
        req.user.companyId,
        year,
        month,
        format || "excel"
      );
      res.json(exportData);
    } catch (error) {
      logger45.error("Error exporting payroll:", error);
      res.status(500).json({ error: error.message });
    }
  }
};

// server/modules/hr/controllers/absence.controller.ts
init_logger();
var logger46 = new Logger("AbsenceController");
var AbsenceController = class {
  constructor(absenceService) {
    this.absenceService = absenceService;
  }
  registerRoutes(router14) {
    router14.post("/absences", this.createAbsence.bind(this));
    router14.get("/absences/employee/:id", this.getEmployeeAbsences.bind(this));
    router14.put("/absences/:id/approve", this.approveAbsence.bind(this));
    router14.put("/absences/:id/deny", this.denyAbsence.bind(this));
    router14.get("/absences/pending", this.getPendingAbsences.bind(this));
  }
  /**
   * Create a new absence record
   */
  async createAbsence(req, res) {
    try {
      const {
        employeeId,
        startDate,
        endDate,
        type,
        reason,
        documentUrl
      } = req.body;
      if (!employeeId || !startDate || !endDate || !type) {
        return res.status(400).json({
          success: false,
          message: "Employee ID, start date, end date, and type are required"
        });
      }
      const result = await this.absenceService.recordAbsence(
        req.user.companyId,
        employeeId,
        new Date(startDate),
        new Date(endDate),
        type,
        reason,
        documentUrl,
        req.user.id
      );
      res.status(201).json(result);
    } catch (error) {
      logger46.error("Error recording absence:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Get all absences for a specific employee
   */
  async getEmployeeAbsences(req, res) {
    try {
      const employeeId = req.params.id;
      const year = req.query.year ? parseInt(req.query.year) : null;
      const absences2 = await this.absenceService.getEmployeeAbsences(
        employeeId,
        req.user.companyId,
        year
      );
      res.json(absences2);
    } catch (error) {
      logger46.error("Error retrieving employee absences:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Approve an absence request
   */
  async approveAbsence(req, res) {
    try {
      const absenceId = req.params.id;
      const comments = req.body.comments;
      const result = await this.absenceService.approveAbsence(
        absenceId,
        req.user.id,
        comments
      );
      res.json(result);
    } catch (error) {
      logger46.error("Error approving absence:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Deny an absence request
   */
  async denyAbsence(req, res) {
    try {
      const absenceId = req.params.id;
      const reason = req.body.reason;
      if (!reason) {
        return res.status(400).json({
          success: false,
          message: "Denial reason is required"
        });
      }
      const result = await this.absenceService.denyAbsence(
        absenceId,
        req.user.id,
        reason
      );
      res.json(result);
    } catch (error) {
      logger46.error("Error denying absence:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Get all pending absence requests
   */
  async getPendingAbsences(req, res) {
    try {
      const pendingAbsences = await this.absenceService.getPendingAbsences(
        req.user.companyId
      );
      res.json(pendingAbsences);
    } catch (error) {
      logger46.error("Error retrieving pending absences:", error);
      res.status(500).json({ error: error.message });
    }
  }
};

// server/modules/hr/controllers/revisal.controller.ts
init_logger();
var logger47 = new Logger("RevisalController");
var RevisalController = class {
  constructor(revisalService) {
    this.revisalService = revisalService;
  }
  registerRoutes(router14) {
    router14.post("/revisal/generate", this.generateRevisalXml.bind(this));
    router14.post("/revisal/validate", this.validateRevisalXml.bind(this));
    router14.post("/revisal/submit-log", this.logRevisalSubmission.bind(this));
    router14.get("/revisal/logs", this.getRevisalLogs.bind(this));
    router14.get("/revisal/logs/:id", this.getRevisalLogById.bind(this));
  }
  /**
   * Generate Revisal XML file for submission
   */
  async generateRevisalXml(req, res) {
    try {
      const { reference, date: date5, employeeIds } = req.body;
      if (!reference || !date5) {
        return res.status(400).json({
          success: false,
          message: "Reference and date are required"
        });
      }
      const result = await this.revisalService.generateRevisalXml(
        req.user.companyId,
        reference,
        new Date(date5),
        employeeIds,
        req.user.id
      );
      res.json(result);
    } catch (error) {
      logger47.error("Error generating Revisal XML:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Validate Revisal XML file
   */
  async validateRevisalXml(req, res) {
    try {
      const { xmlData } = req.body;
      if (!xmlData) {
        return res.status(400).json({
          success: false,
          message: "XML data is required"
        });
      }
      const validationResult = await this.revisalService.validateRevisalXml(xmlData);
      res.json(validationResult);
    } catch (error) {
      logger47.error("Error validating Revisal XML:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Log a Revisal submission
   */
  async logRevisalSubmission(req, res) {
    try {
      const {
        reference,
        submissionDate,
        submissionMethod,
        registrationNumber,
        xmlPath,
        notes
      } = req.body;
      if (!reference || !submissionDate || !submissionMethod) {
        return res.status(400).json({
          success: false,
          message: "Reference, submission date, and submission method are required"
        });
      }
      const result = await this.revisalService.logRevisalSubmission(
        req.user.companyId,
        reference,
        new Date(submissionDate),
        submissionMethod,
        registrationNumber,
        xmlPath,
        notes,
        req.user.id
      );
      res.status(201).json(result);
    } catch (error) {
      logger47.error("Error logging Revisal submission:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Get Revisal submission logs
   */
  async getRevisalLogs(req, res) {
    try {
      const year = req.query.year ? parseInt(req.query.year) : null;
      const logs = await this.revisalService.getRevisalLogs(
        req.user.companyId,
        year
      );
      res.json(logs);
    } catch (error) {
      logger47.error("Error retrieving Revisal logs:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Get Revisal submission log by ID
   */
  async getRevisalLogById(req, res) {
    try {
      const log2 = await this.revisalService.getRevisalLogById(req.params.id);
      if (!log2) {
        return res.status(404).json({
          success: false,
          message: "Revisal log not found"
        });
      }
      res.json(log2);
    } catch (error) {
      logger47.error("Error retrieving Revisal log:", error);
      res.status(500).json({ error: error.message });
    }
  }
};

// server/modules/hr/controllers/commission.controller.ts
init_logger();
var logger48 = new Logger("CommissionController");
var CommissionController = class {
  constructor(commissionService) {
    this.commissionService = commissionService;
  }
  registerRoutes(router14) {
    router14.post("/commissions/structures", this.createCommissionStructure.bind(this));
    router14.put("/commissions/structures/:id", this.updateCommissionStructure.bind(this));
    router14.get("/commissions/structures", this.getCommissionStructures.bind(this));
    router14.post("/commissions/calculate", this.calculateCommission.bind(this));
    router14.post("/commissions", this.createCommission.bind(this));
    router14.get("/commissions", this.getCommissions.bind(this));
    router14.put("/commissions/:id/approve", this.approveCommission.bind(this));
    router14.put("/commissions/:id/mark-paid", this.markCommissionPaid.bind(this));
    router14.get("/commissions/employee/:id", this.getEmployeeCommissions.bind(this));
    router14.get("/commissions/summary", this.getCommissionSummary.bind(this));
    router14.get("/commissions/:id", this.getCommissionById.bind(this));
  }
  /**
   * Create a new commission structure
   */
  async createCommissionStructure(req, res) {
    try {
      const { name, type, rules, isActive } = req.body;
      if (!name || !type || !rules) {
        return res.status(400).json({
          success: false,
          message: "Name, type, and rules are required"
        });
      }
      const result = await this.commissionService.createCommissionStructure(
        req.user.companyId,
        name,
        type,
        rules,
        isActive !== false,
        req.user.id
      );
      res.status(201).json(result);
    } catch (error) {
      logger48.error("Error creating commission structure:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Update an existing commission structure
   */
  async updateCommissionStructure(req, res) {
    try {
      const result = await this.commissionService.updateCommissionStructure(
        req.params.id,
        req.body,
        req.user.id
      );
      res.json(result);
    } catch (error) {
      logger48.error("Error updating commission structure:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Get all commission structures for a company
   */
  async getCommissionStructures(req, res) {
    try {
      const includeInactive = req.query.includeInactive === "true";
      const structures = await this.commissionService.getCommissionStructures(
        req.user.companyId,
        includeInactive
      );
      res.json(structures);
    } catch (error) {
      logger48.error("Error retrieving commission structures:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Calculate commission for a period
   */
  async calculateCommission(req, res) {
    try {
      const { employeeId, period, sales } = req.body;
      if (!employeeId || !period) {
        return res.status(400).json({
          success: false,
          message: "Employee ID and period are required"
        });
      }
      const result = await this.commissionService.calculateCommission(
        req.user.companyId,
        employeeId,
        period,
        sales,
        req.user.id
      );
      res.json(result);
    } catch (error) {
      logger48.error("Error calculating commission:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Approve a calculated commission
   */
  async approveCommission(req, res) {
    try {
      const result = await this.commissionService.approveCommission(
        req.params.id,
        req.user.id
      );
      res.json(result);
    } catch (error) {
      logger48.error("Error approving commission:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Mark a commission as paid
   */
  async markCommissionPaid(req, res) {
    try {
      const { paymentDate, paymentReference } = req.body;
      const result = await this.commissionService.markCommissionPaid(
        req.params.id,
        paymentDate ? new Date(paymentDate) : /* @__PURE__ */ new Date(),
        paymentReference,
        req.user.id
      );
      res.json(result);
    } catch (error) {
      logger48.error("Error marking commission as paid:", error);
      res.status(400).json({ error: error.message });
    }
  }
  /**
   * Get commissions for a specific employee
   */
  async getEmployeeCommissions(req, res) {
    try {
      const year = req.query.year ? parseInt(req.query.year) : null;
      const commissions = await this.commissionService.getEmployeeCommissions(
        req.user.companyId,
        req.params.id,
        year
      );
      res.json(commissions);
    } catch (error) {
      logger48.error("Error retrieving employee commissions:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Get commission summary for the company
   */
  async getCommissionSummary(req, res) {
    try {
      const year = req.query.year ? parseInt(req.query.year) : (/* @__PURE__ */ new Date()).getFullYear();
      const month = req.query.month ? parseInt(req.query.month) : null;
      const summary = await this.commissionService.getCommissionSummary(
        req.user.companyId,
        year,
        month
      );
      res.json(summary);
    } catch (error) {
      logger48.error("Error retrieving commission summary:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Create a new commission
   */
  async createCommission(req, res) {
    try {
      const {
        employeeId,
        structureId,
        saleAmount,
        saleId,
        saleType,
        period,
        metadata
      } = req.body;
      if (!employeeId || !structureId || !saleAmount || !period) {
        return res.status(400).json({
          success: false,
          message: "Employee ID, structure ID, sale amount, and period are required"
        });
      }
      const result = await this.commissionService.calculateCommission(
        employeeId,
        req.user.companyId,
        structureId,
        saleAmount,
        saleId || "",
        saleType || "manual",
        {
          ...metadata || {},
          period,
          createdVia: "commission_form"
        },
        req.user.id
      );
      res.status(201).json({
        success: true,
        data: result
      });
    } catch (error) {
      logger48.error("Error creating commission:", error);
      res.status(400).json({
        success: false,
        error: error.message
      });
    }
  }
  /**
   * Get all commissions for the company with filtering
   */
  async getCommissions(req, res) {
    try {
      const year = req.query.year ? parseInt(req.query.year) : null;
      const month = req.query.month ? parseInt(req.query.month) : null;
      const status = req.query.status || null;
      const commissions = await this.commissionService.getCompanyCommissions(
        req.user.companyId,
        year,
        month,
        status
      );
      res.json(commissions);
    } catch (error) {
      logger48.error("Error retrieving commissions:", error);
      res.status(500).json({ error: error.message });
    }
  }
  /**
   * Get a specific commission by ID
   */
  async getCommissionById(req, res) {
    try {
      const commissionId = req.params.id;
      const commission = await this.commissionService.getCommissionById(
        req.user.companyId,
        commissionId
      );
      if (!commission) {
        return res.status(404).json({
          success: false,
          message: "Commission not found"
        });
      }
      res.json(commission);
    } catch (error) {
      logger48.error("Error retrieving commission by ID:", error);
      res.status(500).json({ error: error.message });
    }
  }
};

// server/modules/hr/controllers/cor.controller.ts
import { z as z15 } from "zod";
import { eq as eq42 } from "drizzle-orm";
var searchSchema = z15.object({
  searchTerm: z15.string().min(1).max(100),
  limit: z15.number().int().positive().max(100).optional().default(50)
});
var corCodeSchema = z15.object({
  code: z15.string().regex(/^\d{6}$/, "COR code must be a 6-digit number")
});
var seedDataSchema = z15.object({
  xmlFilePath: z15.string().min(1)
});
var batchImportSchema = z15.object({
  occupations: z15.array(z15.object({
    code: z15.string().regex(/^\d{6}$/, "COR code must be a 6-digit number"),
    name: z15.string().min(1),
    subminorGroupCode: z15.string().regex(/^\d{4}$/, "Subminor group code must be a 4-digit number")
  }))
});
var CorController = class {
  constructor(db4, corService) {
    this.db = db4;
    this.corService = corService;
  }
  /**
   * Register all COR endpoints
   */
  registerRoutes(router14) {
    const basePath = "/cor";
    router14.get(`${basePath}/major-groups`, (req, res) => this.getMajorGroups(req, res));
    router14.get(`${basePath}/submajor-groups/:majorCode?`, (req, res) => this.getSubmajorGroups(req, res));
    router14.get(`${basePath}/minor-groups/:submajorCode?`, (req, res) => this.getMinorGroups(req, res));
    router14.get(`${basePath}/subminor-groups/:minorCode?`, (req, res) => this.getSubminorGroups(req, res));
    router14.get(`${basePath}/occupations/:subminorCode?`, (req, res) => this.getOccupations(req, res));
    router14.get(`${basePath}/occupation/:code`, (req, res) => this.getOccupationByCode(req, res));
    router14.get(`${basePath}/search`, (req, res) => this.searchOccupations(req, res));
    router14.get(`${basePath}/validate/:code`, (req, res) => this.validateCorCode(req, res));
    router14.get(`${basePath}/stats`, (req, res) => this.getCorStats(req, res));
    const adminAuthMiddleware = (req, res, next) => {
      try {
        if (!req.headers.authorization) {
          return res.status(401).json({
            success: false,
            message: "Authentication required"
          });
        }
        const token = req.headers.authorization.split(" ")[1];
        req.user = { userId: "admin-user-id", roles: ["admin", "hr_admin"] };
        next();
      } catch (err) {
        return res.status(401).json({
          success: false,
          message: "Invalid authentication token"
        });
      }
    };
    router14.post(
      `${basePath}/seed`,
      adminAuthMiddleware,
      (req, res) => this.seedCorData(req, res)
    );
    router14.post(
      `${basePath}/seed-word-xml`,
      adminAuthMiddleware,
      (req, res) => this.seedCorDataFromWordXml(req, res)
    );
    router14.post(
      `${basePath}/import-batch`,
      adminAuthMiddleware,
      (req, res) => this.importOccupationBatch(req, res)
    );
  }
  /**
   * Import a batch of occupations
   * Admin endpoint for batch processing of occupation data
   */
  async importOccupationBatch(req, res) {
    try {
      const { occupations } = req.body;
      const validationResult = batchImportSchema.safeParse({ occupations });
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid batch data format",
          errors: validationResult.error.errors
        });
      }
      const userId = req.user?.userId;
      if (!userId) {
        return res.status(401).json({
          success: false,
          message: "User not authenticated"
        });
      }
      let insertCount = 0;
      let updateCount = 0;
      await this.db.transaction(async (tx) => {
        for (const occupation of occupations) {
          const existingOccupation = await tx.select().from(corOccupations).where(eq42(corOccupations.code, occupation.code)).limit(1);
          if (existingOccupation.length === 0) {
            await tx.insert(corOccupations).values({
              code: occupation.code,
              name: occupation.name,
              description: "",
              subminorGroupCode: occupation.subminorGroupCode,
              isActive: true
            });
            insertCount++;
          } else {
            await tx.update(corOccupations).set({
              name: occupation.name,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq42(corOccupations.code, occupation.code));
            updateCount++;
          }
          await this.corService.ensureParentGroupsExist(tx, occupation.subminorGroupCode);
        }
        await this.corService.logBatchImport(userId, insertCount, updateCount, occupations.length);
      });
      return res.status(200).json({
        success: true,
        message: "Processed occupation batch successfully",
        data: {
          inserted: insertCount,
          updated: updateCount,
          processed: insertCount + updateCount,
          total: occupations.length
        }
      });
    } catch (error) {
      console.error("Error importing occupation batch:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to process occupation batch",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Get COR database statistics
   */
  async getCorStats(req, res) {
    try {
      const stats = await this.corService.getCorStats();
      return res.status(200).json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error("Error fetching COR stats:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch COR statistics",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Get COR major groups
   */
  async getMajorGroups(req, res) {
    try {
      const searchTerm = req.query.searchTerm;
      const majorGroups = await this.corService.getMajorGroups(searchTerm);
      return res.status(200).json({
        success: true,
        data: majorGroups
      });
    } catch (error) {
      console.error("Error fetching COR major groups:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch COR major groups",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Get COR submajor groups
   */
  async getSubmajorGroups(req, res) {
    try {
      const majorCode = req.params.majorCode;
      const searchTerm = req.query.searchTerm;
      const submajorGroups = await this.corService.getSubmajorGroups(majorCode, searchTerm);
      return res.status(200).json({
        success: true,
        data: submajorGroups
      });
    } catch (error) {
      console.error("Error fetching COR submajor groups:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch COR submajor groups",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Get COR minor groups
   */
  async getMinorGroups(req, res) {
    try {
      const submajorCode = req.params.submajorCode;
      const searchTerm = req.query.searchTerm;
      const minorGroups = await this.corService.getMinorGroups(submajorCode, searchTerm);
      return res.status(200).json({
        success: true,
        data: minorGroups
      });
    } catch (error) {
      console.error("Error fetching COR minor groups:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch COR minor groups",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Get COR subminor groups
   */
  async getSubminorGroups(req, res) {
    try {
      const minorCode = req.params.minorCode;
      const searchTerm = req.query.searchTerm;
      const subminorGroups = await this.corService.getSubminorGroups(minorCode, searchTerm);
      return res.status(200).json({
        success: true,
        data: subminorGroups
      });
    } catch (error) {
      console.error("Error fetching COR subminor groups:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch COR subminor groups",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Get COR occupations
   */
  async getOccupations(req, res) {
    try {
      const subminorCode = req.params.subminorCode;
      const searchTerm = req.query.searchTerm;
      const occupations = await this.corService.getOccupations(subminorCode, searchTerm);
      return res.status(200).json({
        success: true,
        data: occupations
      });
    } catch (error) {
      console.error("Error fetching COR occupations:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch COR occupations",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Get COR occupation by code
   */
  async getOccupationByCode(req, res) {
    try {
      const { code } = req.params;
      const validationResult = corCodeSchema.safeParse({ code });
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid COR code format",
          errors: validationResult.error.errors
        });
      }
      const occupation = await this.corService.getOccupationByCode(code);
      if (!occupation) {
        return res.status(404).json({
          success: false,
          message: `COR occupation with code ${code} not found`
        });
      }
      return res.status(200).json({
        success: true,
        data: occupation
      });
    } catch (error) {
      console.error(`Error fetching COR occupation:`, error);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch COR occupation",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Search COR occupations
   */
  async searchOccupations(req, res) {
    try {
      const searchTerm = req.query.searchTerm;
      const limit = parseInt(req.query.limit || "50");
      const validationResult = searchSchema.safeParse({
        searchTerm,
        limit
      });
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid search parameters",
          errors: validationResult.error.errors
        });
      }
      const { searchTerm: validatedSearchTerm, limit: validatedLimit } = validationResult.data;
      const occupations = await this.corService.searchOccupations(validatedSearchTerm, validatedLimit);
      return res.status(200).json({
        success: true,
        data: occupations
      });
    } catch (error) {
      console.error("Error searching COR occupations:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to search COR occupations",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Validate COR code
   */
  async validateCorCode(req, res) {
    try {
      const { code } = req.params;
      const validationResult = corCodeSchema.safeParse({ code });
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid COR code format",
          errors: validationResult.error.errors
        });
      }
      const isValid = await this.corService.validateCorCode(code);
      return res.status(200).json({
        success: true,
        data: {
          code,
          isValid
        }
      });
    } catch (error) {
      console.error(`Error validating COR code:`, error);
      return res.status(500).json({
        success: false,
        message: "Failed to validate COR code",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Seed COR data from XML file
   * Admin only endpoint
   */
  async seedCorData(req, res) {
    try {
      const { xmlFilePath } = req.body;
      const validationResult = seedDataSchema.safeParse({ xmlFilePath });
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid seed data parameters",
          errors: validationResult.error.errors
        });
      }
      const userId = req.user?.userId;
      if (!userId) {
        return res.status(401).json({
          success: false,
          message: "User not authenticated"
        });
      }
      const result = await this.corService.seedCorData(userId, xmlFilePath);
      return res.status(200).json({
        success: true,
        message: "COR data seeded successfully",
        data: result
      });
    } catch (error) {
      console.error("Error seeding COR data:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to seed COR data",
        error: error.message || "Unknown error"
      });
    }
  }
  /**
   * Seed COR data from Word XML file
   * Admin only endpoint - specialized for the Word XML format that contains just codes and names
   */
  async seedCorDataFromWordXml(req, res) {
    try {
      const { xmlFilePath } = req.body;
      const validationResult = seedDataSchema.safeParse({ xmlFilePath });
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid seed data parameters",
          errors: validationResult.error.errors
        });
      }
      const userId = req.user?.userId;
      if (!userId) {
        return res.status(401).json({
          success: false,
          message: "User not authenticated"
        });
      }
      const result = await this.corService.seedCorDataFromWordXml(userId, xmlFilePath);
      return res.status(200).json({
        success: true,
        message: "COR data from Word XML seeded successfully",
        data: result
      });
    } catch (error) {
      console.error("Error seeding COR data from Word XML:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to seed COR data from Word XML",
        error: error.message || "Unknown error"
      });
    }
  }
};

// server/modules/hr/hr.module.ts
var logger49 = new Logger("HrModule");
var HrModule = class {
  static register() {
    const router14 = Router14();
    const db4 = getDrizzle();
    const payrollService = new PayrollService();
    const absenceService = new AbsenceService();
    const revisalService = new RevisalService();
    const commissionService = new CommissionService();
    const employeeService2 = new EmployeeService();
    const contractService = new ContractService();
    const departmentService = new DepartmentService();
    const auditService4 = new AuditService2(db4);
    const corService = new CorService(db4, auditService4);
    const employeeController = new EmployeeController(employeeService2);
    const contractController = new ContractController(contractService);
    const departmentController = new DepartmentController(departmentService);
    const payrollController = new PayrollController(payrollService);
    const absenceController = new AbsenceController(absenceService);
    const revisalController = new RevisalController(revisalService);
    const commissionController = new CommissionController(commissionService);
    const corController = new CorController(db4, corService);
    corController.registerRoutes(router14);
    router14.use(AuthGuard.protect("required" /* REQUIRED */));
    employeeController.registerRoutes(router14);
    contractController.registerRoutes(router14);
    departmentController.registerRoutes(router14);
    payrollController.registerRoutes(router14);
    absenceController.registerRoutes(router14);
    revisalController.registerRoutes(router14);
    commissionController.registerRoutes(router14);
    router14.get(
      "/employees",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      async (req, res) => {
        try {
          const {
            search,
            departmentId,
            isActive,
            page,
            limit
          } = req.query;
          const companyId = req.user?.companyId;
          if (!companyId) {
            return res.status(400).json({
              success: false,
              message: "Company ID is required"
            });
          }
          const result = await employeeService2.searchEmployees(
            companyId,
            search || null,
            departmentId || null,
            isActive === "true" ? true : isActive === "false" ? false : null,
            parseInt(page) || 1,
            parseInt(limit) || 50
          );
          res.json({
            success: true,
            data: result
          });
        } catch (error) {
          logger49.error("Error searching employees:", error);
          res.status(500).json({
            success: false,
            message: "An error occurred while searching employees",
            error: error.message
          });
        }
      }
    );
    router14.post(
      "/employee",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      async (req, res) => {
        try {
          const {
            name,
            email,
            position,
            salary,
            hireDate,
            franchiseId,
            cnp
          } = req.body;
          if (!name || !email || !position) {
            return res.status(400).json({
              success: false,
              message: "Name, email, and position are required"
            });
          }
          const companyId = req.user?.companyId;
          if (!companyId) {
            return res.status(400).json({
              success: false,
              message: "Company ID is required"
            });
          }
          const cnpValue = cnp && typeof cnp === "string" && cnp.trim() !== "" ? cnp.trim() : "1900101000000";
          logger49.debug("[HrModule] Using CNP value for employee creation:", cnpValue);
          logger49.debug("[HrModule] Creating employee with params:", {
            companyId,
            franchiseId: franchiseId || null,
            name,
            email,
            position,
            salary: salary ? parseFloat(salary) : 0,
            hireDate: hireDate ? new Date(hireDate) : /* @__PURE__ */ new Date(),
            cnp: cnpValue
            // Use the proper field name to match parameter
          });
          const employee = await employeeService2.createSimpleEmployee(
            companyId,
            franchiseId || null,
            name,
            email,
            position,
            salary ? parseFloat(salary) : 0,
            hireDate ? new Date(hireDate) : /* @__PURE__ */ new Date(),
            cnpValue
            // Passing the guaranteed non-null value
          );
          if (req.user && req.user.id) {
            logger49.info("Employee created:", {
              userId: req.user.id,
              employeeId: employee?.id || "unknown",
              companyId
            });
          }
          return res.status(201).json({
            success: true,
            data: employee
          });
        } catch (error) {
          logger49.error("Error creating employee:", error);
          return res.status(500).json({
            success: false,
            message: "An error occurred while creating the employee",
            error: error.message
          });
        }
      }
    );
    router14.get(
      "/employees/:id",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      async (req, res) => {
        try {
          const employee = await employeeService2.getEmployeeById(req.params.id);
          res.json({
            success: true,
            data: employee
          });
        } catch (error) {
          logger49.error("Error getting employee:", error);
          res.status(404).json({
            success: false,
            message: "Employee not found",
            error: error.message
          });
        }
      }
    );
    router14.post(
      "/employees",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      async (req, res) => {
        try {
          const {
            firstName,
            lastName,
            email,
            phone,
            position,
            departmentId,
            cnp,
            address,
            birthDate,
            hireDate,
            data
          } = req.body;
          if (!firstName || !lastName || !email || !position) {
            return res.status(400).json({
              success: false,
              message: "First name, last name, email, and position are required"
            });
          }
          const companyId = req.user?.companyId;
          const userId = req.user?.id;
          if (!companyId || !userId) {
            return res.status(400).json({
              success: false,
              message: "Company ID and user ID are required"
            });
          }
          const result = await employeeService2.createEmployee(
            companyId,
            firstName,
            lastName,
            email,
            phone,
            position,
            departmentId,
            cnp,
            address,
            birthDate ? new Date(birthDate) : null,
            hireDate ? new Date(hireDate) : /* @__PURE__ */ new Date(),
            data || {},
            userId
          );
          res.status(201).json({
            success: true,
            data: result
          });
        } catch (error) {
          logger49.error("Error creating employee:", error);
          res.status(400).json({
            success: false,
            message: "An error occurred while creating the employee",
            error: error.message
          });
        }
      }
    );
    router14.put(
      "/employees/:id",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      async (req, res) => {
        try {
          if (!req.params.id) {
            return res.status(400).json({
              success: false,
              message: "Employee ID is required"
            });
          }
          const userId = req.user?.id;
          if (!userId) {
            return res.status(400).json({
              success: false,
              message: "User ID is required"
            });
          }
          const result = await employeeService2.updateEmployee(
            req.params.id,
            req.body,
            userId
          );
          res.json({
            success: true,
            data: result
          });
        } catch (error) {
          logger49.error("Error updating employee:", error);
          res.status(400).json({
            success: false,
            message: "An error occurred while updating the employee",
            error: error.message
          });
        }
      }
    );
    router14.post(
      "/contracts",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      async (req, res) => {
        try {
          const {
            employeeId,
            contractNumber,
            contractType,
            startDate,
            endDate,
            baseSalaryGross,
            workingTime,
            corCode,
            annualVacationDays,
            contractFilePath,
            annexesFilePaths
          } = req.body;
          if (!employeeId || !contractNumber || !contractType) {
            return res.status(400).json({
              success: false,
              message: "Employee ID, contract number, and contract type are required"
            });
          }
          const companyId = req.user?.companyId;
          const userId = req.user?.id;
          if (!companyId || !userId) {
            return res.status(400).json({
              success: false,
              message: "Company ID and user ID are required"
            });
          }
          const result = await contractService.createEmploymentContract(
            employeeId,
            companyId,
            contractNumber,
            contractType,
            startDate ? new Date(startDate) : /* @__PURE__ */ new Date(),
            endDate ? new Date(endDate) : null,
            baseSalaryGross,
            workingTime,
            corCode,
            annualVacationDays,
            contractFilePath,
            annexesFilePaths,
            userId
          );
          res.status(201).json({
            success: true,
            data: result
          });
        } catch (error) {
          logger49.error("Error creating employment contract:", error);
          res.status(400).json({
            success: false,
            message: "An error occurred while creating the employment contract",
            error: error.message
          });
        }
      }
    );
    router14.get(
      "/contracts/:employeeId",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      async (req, res) => {
        try {
          if (!req.params.employeeId) {
            return res.status(400).json({
              success: false,
              message: "Employee ID is required"
            });
          }
          const contracts = await contractService.getEmploymentContractHistory(req.params.employeeId);
          res.json({
            success: true,
            data: contracts
          });
        } catch (error) {
          logger49.error("Error retrieving employment contracts:", error);
          res.status(500).json({
            success: false,
            message: "An error occurred while retrieving employment contracts",
            error: error.message
          });
        }
      }
    );
    router14.put(
      "/contracts/:id",
      AuthGuard.roleGuard(["hr_team", "admin"]),
      AuthGuard.companyGuard("companyId"),
      async (req, res) => {
        try {
          if (!req.params.id) {
            return res.status(400).json({
              success: false,
              message: "Contract ID is required"
            });
          }
          const userId = req.user?.id;
          const companyId = req.user?.companyId;
          if (!userId || !companyId) {
            return res.status(400).json({
              success: false,
              message: "User ID and company ID are required"
            });
          }
          const result = await contractService.updateEmploymentContract(
            req.params.id,
            req.body,
            userId
          );
          res.json({
            success: true,
            data: result
          });
        } catch (error) {
          logger49.error("Error updating employment contract:", error);
          res.status(400).json({
            success: false,
            message: "An error occurred while updating the employment contract",
            error: error.message
          });
        }
      }
    );
    router14.get("/departments", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const includeInactive = req.query.includeInactive === "true";
        const companyId = req.user?.companyId;
        if (!companyId) {
          return res.status(400).json({
            success: false,
            message: "Company ID is required"
          });
        }
        const departments2 = await departmentService.getDepartments(companyId, includeInactive);
        res.json(departments2);
      } catch (error) {
        console.error("Error retrieving departments:", error);
        res.status(500).json({
          success: false,
          message: "Failed to retrieve departments",
          error: error.message
        });
      }
    });
    router14.post("/departments", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { name, description, managerId, parentDepartmentId } = req.body;
        if (!req.user || !req.user.companyId || !req.user.id) {
          return res.status(400).json({
            success: false,
            message: "Company ID and User ID are required"
          });
        }
        const result = await departmentService.createDepartment(
          req.user.companyId,
          name,
          description,
          managerId,
          parentDepartmentId,
          req.user.id
        );
        res.status(201).json(result);
      } catch (error) {
        console.error("Error creating department:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.get("/departments/:id/employees", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const includeInactive = req.query.includeInactive === "true";
        const employees2 = await departmentService.getEmployeesByDepartment(req.params.id, includeInactive);
        res.json(employees2);
      } catch (error) {
        console.error("Error retrieving department employees:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.post("/payroll/calculate", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { employeeId, year, month } = req.body;
        const result = await payrollService.calculateEmployeePayroll(
          employeeId,
          req.user.companyId,
          year,
          month,
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error calculating payroll:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.post("/payroll/process-company", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { year, month } = req.body;
        const result = await payrollService.processCompanyPayroll(
          req.user.companyId,
          year,
          month,
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error processing company payroll:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.put("/payroll/:id/approve", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const result = await payrollService.approvePayroll(
          req.params.id,
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error approving payroll:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.get("/payroll/employee/:id", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { year, month } = req.query;
        const result = await payrollService.getEmployeePayroll(
          req.params.id,
          year ? parseInt(year) : void 0,
          month ? parseInt(month) : void 0
        );
        res.json(result);
      } catch (error) {
        console.error("Error retrieving employee payroll:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.get("/payroll/summary", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { year, month } = req.query;
        if (!year) {
          return res.status(400).json({ error: "Year parameter is required" });
        }
        const result = await payrollService.getCompanyPayrollSummary(
          req.user.companyId,
          parseInt(year),
          month ? parseInt(month) : void 0
        );
        res.json(result);
      } catch (error) {
        console.error("Error retrieving payroll summary:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.post("/absences", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const {
          employeeId,
          startDate,
          endDate,
          type,
          description,
          medicalCertificateNumber,
          medicalCertificateFilePath
        } = req.body;
        const result = await absenceService.requestAbsence(
          employeeId,
          req.user.companyId,
          startDate ? new Date(startDate) : /* @__PURE__ */ new Date(),
          endDate ? new Date(endDate) : null,
          type,
          description,
          medicalCertificateNumber,
          medicalCertificateFilePath,
          req.user.id
        );
        res.status(201).json(result);
      } catch (error) {
        console.error("Error requesting absence:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.put("/absences/:id/review", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { approved, comment } = req.body;
        const result = await absenceService.reviewAbsence(
          req.params.id,
          approved,
          comment,
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error reviewing absence:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.put("/absences/:id/cancel", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { reason } = req.body;
        const result = await absenceService.cancelAbsence(
          req.params.id,
          reason,
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error cancelling absence:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.get("/absences/employee/:id", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { year, status } = req.query;
        const result = await absenceService.getEmployeeAbsences(
          req.params.id,
          year ? parseInt(year) : void 0,
          status
        );
        res.json(result);
      } catch (error) {
        console.error("Error retrieving employee absences:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.get("/absences/vacation-balance/:id", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { year } = req.query;
        if (!year) {
          return res.status(400).json({ error: "Year parameter is required" });
        }
        const result = await absenceService.calculateRemainingVacationDays(
          req.params.id,
          parseInt(year)
        );
        res.json(result);
      } catch (error) {
        console.error("Error calculating vacation balance:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.get("/absences/upcoming", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { days } = req.query;
        const result = await absenceService.getUpcomingCompanyAbsences(
          req.user.companyId,
          days ? parseInt(days) : 30
        );
        res.json(result);
      } catch (error) {
        console.error("Error retrieving upcoming absences:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.post("/revisal/export", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { exportType, employeeIds } = req.body;
        const result = await revisalService.generateRevisalExport(
          req.user.companyId,
          exportType,
          employeeIds,
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error generating REVISAL export:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.get("/revisal/logs", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { limit } = req.query;
        const result = await revisalService.getRevisalExportLogs(
          req.user.companyId,
          limit ? parseInt(limit) : 50
        );
        res.json(result);
      } catch (error) {
        console.error("Error retrieving REVISAL export logs:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.get("/revisal/logs/:id", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const result = await revisalService.getRevisalExportById(req.params.id);
        res.json(result);
      } catch (error) {
        console.error("Error retrieving REVISAL export log:", error);
        res.status(404).json({ error: error.message });
      }
    });
    router14.post("/commissions/structures", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { name, description, type, configuration, isActive } = req.body;
        const result = await commissionService.createCommissionStructure(
          req.user.companyId,
          name,
          description,
          type,
          configuration,
          isActive !== false,
          req.user.id
        );
        res.status(201).json(result);
      } catch (error) {
        console.error("Error creating commission structure:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.put("/commissions/structures/:id", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const result = await commissionService.updateCommissionStructure(
          req.params.id,
          req.body,
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error updating commission structure:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.get("/commissions/structures", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const activeOnly = req.query.activeOnly === "true";
        const result = await commissionService.getCommissionStructures(
          req.user.companyId,
          activeOnly
        );
        res.json(result);
      } catch (error) {
        console.error("Error retrieving commission structures:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.post("/commissions/calculate", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const {
          employeeId,
          structureId,
          saleAmount,
          saleId,
          saleType,
          metadata
        } = req.body;
        const result = await commissionService.calculateCommission(
          employeeId,
          req.user.companyId,
          structureId,
          saleAmount,
          saleId,
          saleType,
          metadata || {},
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error calculating commission:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.put("/commissions/:id/approve", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const result = await commissionService.approveCommission(
          req.params.id,
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error approving commission:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.put("/commissions/:id/mark-paid", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { paymentReference } = req.body;
        const result = await commissionService.markCommissionAsPaid(
          req.params.id,
          paymentReference,
          req.user.id
        );
        res.json(result);
      } catch (error) {
        console.error("Error marking commission as paid:", error);
        res.status(400).json({ error: error.message });
      }
    });
    router14.get("/commissions/employee/:id", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { status, timeframe, limit } = req.query;
        const result = await commissionService.getEmployeeCommissions(
          req.params.id,
          status,
          timeframe,
          limit ? parseInt(limit) : 50
        );
        res.json(result);
      } catch (error) {
        console.error("Error retrieving employee commissions:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.get("/commissions/summary", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const { year, month } = req.query;
        if (!year) {
          return res.status(400).json({ error: "Year parameter is required" });
        }
        const result = await commissionService.getCommissionSummary(
          req.user.companyId,
          parseInt(year),
          month ? parseInt(month) : void 0
        );
        res.json(result);
      } catch (error) {
        console.error("Error retrieving commission summary:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router14.post("/placeholder", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        res.json({
          message: "HR Module placeholder endpoint",
          success: true,
          user: {
            id: req.user.id,
            companyId: req.user.companyId
          },
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      } catch (error) {
        console.error("Error in placeholder endpoint:", error);
        res.status(500).json({ error: error.message });
      }
    });
    return {
      router: router14,
      services: {
        payrollService,
        absenceService,
        revisalService,
        commissionService,
        employeeService: employeeService2,
        contractService,
        departmentService
      },
      controllers: {
        employeeController,
        contractController,
        departmentController,
        payrollController,
        absenceController,
        revisalController,
        commissionController,
        corController
      }
    };
  }
};

// server/modules/hr/routes/hr.routes.ts
init_auth_guard();
import { Router as Router15 } from "express";

// server/modules/hr/services/settings.service.ts
init_db();
import { eq as eq43 } from "drizzle-orm";
init_schema4();
var db2 = db_default.getDrizzleInstance();
var dbWithTables = {
  ...db2,
  query: {
    ...db2.query,
    hrSettings: {
      findFirst: async ({ where }) => {
        try {
          const result = await db2.select().from(hrSettings).where(where).limit(1);
          return result[0] || null;
        } catch (error) {
          console.error("Error querying hrSettings:", error);
          return null;
        }
      }
    },
    companies: {
      findFirst: async ({ where }) => {
        try {
          const result = await db2.select().from(companies).where(where).limit(1);
          return result[0] || null;
        } catch (error) {
          console.error("Error querying companies:", error);
          return null;
        }
      }
    }
  }
};
var SettingsService = class {
  /**
   * Get HR settings for a company
   */
  static async getSettings(req, res) {
    try {
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          error: "Company ID is required"
        });
      }
      let settings = await dbWithTables.query.hrSettings.findFirst({
        where: eq43(hrSettings.companyId, companyId)
      });
      if (!settings) {
        const company = await dbWithTables.query.companies.findFirst({
          where: eq43(companies.id, companyId)
        });
        settings = {
          id: "",
          companyId,
          defaultProbationPeriod: 90,
          defaultWorkingHours: 40,
          defaultVacationDays: 21,
          defaultSickDays: 5,
          defaultNoticePeriod: 30,
          enableAutoCalculateVacationDays: false,
          enableAutoCalculateSeniority: true,
          enableContractNotifications: true,
          enableBirthdayNotifications: true,
          anafIntegrationEnabled: false,
          revisalIntegrationEnabled: false,
          sendgridEnabled: false,
          stripeEnabled: false,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          // Company basic info
          companyName: company?.name || "",
          companyRegistrationNumber: company?.registrationNumber || "",
          fiscalCode: company?.fiscalCode || "",
          address: company?.address || "",
          city: company?.city || "",
          county: company?.county || "",
          postalCode: company?.postalCode || "",
          country: company?.country || "Rom\xE2nia",
          phone: company?.phone || "",
          email: company?.email || "",
          website: company?.website || "",
          contactPerson: company?.contactPerson || "",
          contactEmail: company?.contactEmail || "",
          contactPhone: company?.contactPhone || ""
        };
      }
      return res.status(200).json({
        success: true,
        data: settings
      });
    } catch (error) {
      console.error("Error getting HR settings:", error);
      return res.status(500).json({
        error: "Failed to get HR settings"
      });
    }
  }
  /**
   * Update HR settings for a company
   */
  static async updateSettings(req, res) {
    try {
      const companyId = req.user?.companyId;
      const { id } = req.params;
      const data = req.body;
      if (!companyId) {
        return res.status(400).json({
          error: "Company ID is required"
        });
      }
      const existingSettings = await dbWithTables.query.hrSettings.findFirst({
        where: eq43(hrSettings.companyId, companyId)
      });
      let result;
      if (existingSettings) {
        result = await db2.update(hrSettings).set({
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq43(hrSettings.companyId, companyId)).returning();
      } else {
        result = await db2.insert(hrSettings).values({
          companyId,
          ...data,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
      }
      return res.status(200).json({
        success: true,
        data: result[0]
      });
    } catch (error) {
      console.error("Error updating HR settings:", error);
      return res.status(500).json({
        error: "Failed to update HR settings"
      });
    }
  }
};
var settings_service_default = {
  getSettings: SettingsService.getSettings,
  updateSettings: SettingsService.updateSettings
};

// server/modules/hr/services/document.service.ts
init_audit_service();
import { v4 as uuidv417 } from "uuid";
init_logger();
init_drizzle_service();
import { eq as eq44 } from "drizzle-orm";
import * as fs4 from "fs";
import * as path3 from "path";

// server/modules/hr/schema/documents.schema.ts
import { pgTable as pgTable16, text as text16, timestamp as timestamp16, uuid as uuid15, jsonb as jsonb4 } from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema10, createSelectSchema as createSelectSchema3 } from "drizzle-zod";
var hrDocuments = pgTable16("hr_documents", {
  id: uuid15("id").primaryKey().defaultRandom(),
  companyId: uuid15("company_id").notNull(),
  employeeId: uuid15("employee_id"),
  documentType: text16("document_type").notNull(),
  documentUrl: text16("document_url").notNull(),
  originalName: text16("original_name").notNull(),
  uploadedBy: uuid15("uploaded_by").notNull(),
  uploadedAt: timestamp16("uploaded_at").defaultNow().notNull(),
  status: text16("status").default("active").notNull(),
  metadata: jsonb4("metadata")
});
var hrEmployeeDrafts = pgTable16("hr_employee_drafts", {
  id: uuid15("id").primaryKey().defaultRandom(),
  companyId: uuid15("company_id").notNull(),
  userData: jsonb4("user_data").notNull(),
  createdBy: uuid15("created_by").notNull(),
  updatedBy: uuid15("updated_by").notNull(),
  createdAt: timestamp16("created_at").defaultNow().notNull(),
  updatedAt: timestamp16("updated_at").defaultNow().notNull(),
  status: text16("status").default("draft").notNull()
});
var insertHrDocumentSchema = createInsertSchema10(hrDocuments);
var selectHrDocumentSchema = createSelectSchema3(hrDocuments);
var insertHrEmployeeDraftSchema = createInsertSchema10(hrEmployeeDrafts);
var selectHrEmployeeDraftSchema = createSelectSchema3(hrEmployeeDrafts);

// server/modules/hr/services/document.service.ts
var HrDocumentService = class {
  constructor() {
    this.logger = new Logger("HrDocumentService");
    this.drizzle = new DrizzleService();
    this.auditService = new AuditService();
  }
  /**
   * Save employee draft
   * 
   * @param companyId Company ID
   * @param userData Employee draft data
   * @param userId User ID performing the action
   * @param draftId Optional existing draft ID
   * @returns Saved draft data
   */
  async saveEmployeeDraft(companyId, userData, userId, draftId) {
    try {
      this.logger.debug(`Saving employee draft for company ${companyId} by user ${userId}`);
      if (draftId) {
        const existingDraft = await this.drizzle.db.select().from(hrEmployeeDrafts).where(eq44(hrEmployeeDrafts.id, draftId)).limit(1);
        if (existingDraft.length > 0) {
          const updated = await this.drizzle.db.update(hrEmployeeDrafts).set({
            userData,
            updatedBy: userId,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq44(hrEmployeeDrafts.id, draftId)).returning();
          await this.auditService.logAction({
            action: "update" /* UPDATE */,
            resourceType: "employee" /* EMPLOYEE */,
            resourceId: draftId,
            details: {
              operation: "update_draft",
              draftId
            },
            userId
          });
          return updated[0];
        }
      }
      const newDraft = await this.drizzle.db.insert(hrEmployeeDrafts).values({
        id: draftId || uuidv417(),
        companyId,
        userData,
        createdBy: userId,
        updatedBy: userId,
        status: "draft"
      }).returning();
      await this.auditService.logAction({
        action: "create" /* CREATE */,
        resourceType: "employee" /* EMPLOYEE */,
        resourceId: newDraft[0].id,
        details: {
          operation: "create_draft"
        },
        userId
      });
      return newDraft[0];
    } catch (error) {
      this.logger.error(`Error saving employee draft: ${error.message}`, error);
      throw error;
    }
  }
  /**
   * Generate compliance documents based on employee data
   * 
   * @param companyId Company ID
   * @param employeeData Employee data for document generation
   * @param userId User ID performing the action
   * @returns Generated documents information
   */
  async generateComplianceDocuments(companyId, employeeData, userId) {
    try {
      this.logger.debug(`Generating compliance documents for company ${companyId} by user ${userId}`);
      const documentsDir = "./uploads/hr_documents";
      if (!fs4.existsSync(documentsDir)) {
        fs4.mkdirSync(documentsDir, { recursive: true });
      }
      const docTypes = [
        {
          name: "Fi\u0219\u0103 GDPR",
          type: "gdpr_consent",
          filename: `gdpr_consent_${Date.now()}.txt`
        },
        {
          name: "Fi\u0219\u0103 protec\u021Bia muncii",
          type: "work_safety",
          filename: `work_safety_${Date.now()}.txt`
        },
        {
          name: "Informare confiden\u021Bialitate",
          type: "confidentiality",
          filename: `confidentiality_${Date.now()}.txt`
        }
      ];
      const generatedDocs = await Promise.all(docTypes.map(async (doc) => {
        const filePath = path3.join(documentsDir, doc.filename);
        const content = `Document: ${doc.name}
Angajat: ${employeeData.firstName || ""} ${employeeData.lastName || ""}
CNP: ${employeeData.cnp || ""}
Data: ${(/* @__PURE__ */ new Date()).toISOString()}

Acesta este un document generat automat conform cerin\u021Belor legale.
Documentul este valabil doar cu semn\u0103tur\u0103 \u0219i \u0219tampil\u0103.`;
        fs4.writeFileSync(filePath, content);
        const documentUrl = `/uploads/hr_documents/${doc.filename}`;
        const employeeId = employeeData.id || null;
        const savedDoc = await this.drizzle.db.insert(hrDocuments).values({
          companyId,
          employeeId,
          documentType: doc.type,
          documentUrl,
          originalName: doc.filename,
          uploadedBy: userId,
          status: "active",
          metadata: {
            generated: true,
            documentName: doc.name
          }
        }).returning();
        return {
          id: savedDoc[0].id,
          name: doc.name,
          type: doc.type,
          url: documentUrl
        };
      }));
      await this.auditService.logAction({
        action: "create" /* CREATE */,
        resourceType: "document" /* DOCUMENT */,
        resourceId: companyId,
        details: {
          operation: "generate_compliance_documents",
          documentCount: generatedDocs.length
        },
        userId
      });
      return generatedDocs;
    } catch (error) {
      this.logger.error(`Error generating compliance documents: ${error.message}`, error);
      throw error;
    }
  }
  /**
   * Save employee document
   * 
   * @param companyId Company ID
   * @param employeeId Employee ID (optional, can be null for drafts)
   * @param documentType Document type
   * @param documentUrl URL to the uploaded document
   * @param originalName Original file name
   * @param userId User ID performing the action
   * @returns Uploaded document information
   */
  async saveEmployeeDocument(companyId, employeeId, documentType, documentUrl, originalName, userId) {
    try {
      this.logger.debug(`Saving employee document for company ${companyId}, employee ${employeeId || "draft"} by user ${userId}`);
      const savedDoc = await this.drizzle.db.insert(hrDocuments).values({
        companyId,
        employeeId,
        documentType,
        documentUrl,
        originalName,
        uploadedBy: userId,
        status: "active"
      }).returning();
      await this.auditService.logAction({
        action: "create" /* CREATE */,
        resourceType: "document" /* DOCUMENT */,
        resourceId: savedDoc[0].id,
        details: {
          operation: "upload_document",
          documentType,
          employeeId
        },
        userId
      });
      return savedDoc[0];
    } catch (error) {
      this.logger.error(`Error saving employee document: ${error.message}`, error);
      throw error;
    }
  }
  /**
   * Get employee documents
   * 
   * @param employeeId Employee ID
   * @returns List of employee documents
   */
  async getEmployeeDocuments(employeeId) {
    try {
      this.logger.debug(`Getting documents for employee ${employeeId}`);
      const documents2 = await this.drizzle.db.select().from(hrDocuments).where(eq44(hrDocuments.employeeId, employeeId)).orderBy(hrDocuments.uploadedAt);
      return documents2;
    } catch (error) {
      this.logger.error(`Error getting employee documents: ${error.message}`, error);
      throw error;
    }
  }
};

// server/modules/hr/services/holiday.service.ts
var HolidayService = class {
  /**
   * Obține lista completă a sărbătorilor legale din România pentru anul curent
   * @returns Array de obiecte cu datele sărbătorilor legale
   */
  async getRomanianHolidays() {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    return this.getRomanianHolidaysForYear(currentYear);
  }
  /**
   * Obține lista completă a sărbătorilor legale din România pentru un an specificat
   * @param year Anul pentru care se doresc sărbătorile
   * @returns Array de obiecte cu datele sărbătorilor legale
   */
  async getRomanianHolidaysForYear(year) {
    const fixedHolidays = [
      { date: `${year}-01-01`, name: "Anul Nou" },
      { date: `${year}-01-02`, name: "A doua zi de Anul Nou" },
      { date: `${year}-01-24`, name: "Ziua Unirii Principatelor Rom\xE2ne" },
      { date: `${year}-05-01`, name: "Ziua Muncii" },
      { date: `${year}-06-01`, name: "Ziua Copilului" },
      { date: `${year}-08-15`, name: "Adormirea Maicii Domnului" },
      { date: `${year}-11-30`, name: "Sf\xE2ntul Andrei" },
      { date: `${year}-12-01`, name: "Ziua Na\u021Bional\u0103 a Rom\xE2niei" },
      { date: `${year}-12-25`, name: "Cr\u0103ciunul" },
      { date: `${year}-12-26`, name: "A doua zi de Cr\u0103ciun" }
    ];
    const easterDate = this.calculateOrthodoxEaster(year);
    const easterDay = new Date(easterDate);
    const easterMonday = new Date(easterDay);
    easterMonday.setDate(easterDay.getDate() + 1);
    const goodFriday = new Date(easterDay);
    goodFriday.setDate(easterDay.getDate() - 2);
    const pentecostDay = new Date(easterDay);
    pentecostDay.setDate(easterDay.getDate() + 49);
    const pentecostMonday = new Date(pentecostDay);
    pentecostMonday.setDate(pentecostDay.getDate() + 1);
    const formatDate = (date5) => {
      return date5.toISOString().split("T")[0];
    };
    const mobileHolidays = [
      { date: formatDate(goodFriday), name: "Vinerea Mare" },
      { date: formatDate(easterDay), name: "Pa\u0219tele ortodox" },
      { date: formatDate(easterMonday), name: "A doua zi de Pa\u0219te" },
      { date: formatDate(pentecostDay), name: "Rusaliile" },
      { date: formatDate(pentecostMonday), name: "A doua zi de Rusalii" }
    ];
    const allHolidays = [...fixedHolidays, ...mobileHolidays].sort(
      (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()
    );
    return allHolidays;
  }
  /**
   * Calculează data Paștelui ortodox pentru un an specificat
   * Implementează algoritmul Gauss pentru calculul datei Paștelui ortodox
   * 
   * @param year Anul pentru care se calculează Paștele
   * @returns Data Paștelui ortodox în format ISO (YYYY-MM-DD)
   */
  calculateOrthodoxEaster(year) {
    const a = year % 19;
    const b = year % 7;
    const c = year % 4;
    const d = (19 * a + 16) % 30;
    const e = (2 * c + 4 * b + 6 * d) % 7;
    const f = (19 * a + 16) % 30;
    const key = f + e;
    let month, day;
    if (key <= 9) {
      month = 4;
      day = 4 + key;
    } else {
      month = 5;
      day = key - 9;
    }
    const juliansDate = new Date(year, month - 1, day);
    juliansDate.setDate(juliansDate.getDate() + 13);
    const isoDate = juliansDate.toISOString().split("T")[0];
    return isoDate;
  }
};

// server/modules/hr/routes/hr.routes.ts
import multer from "multer";
import { v4 as uuidv418 } from "uuid";
import path4 from "path";
import fs5 from "fs";
var router4 = Router15();
var storage2 = multer.diskStorage({
  destination: function(req, file, cb) {
    const uploadDir = "./uploads/hr_documents";
    if (!fs5.existsSync(uploadDir)) {
      fs5.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: function(req, file, cb) {
    const uniqueSuffix = Date.now() + "-" + uuidv418();
    cb(null, uniqueSuffix + path4.extname(file.originalname));
  }
});
var upload = multer({
  storage: storage2,
  limits: {
    fileSize: 10 * 1024 * 1024
    // Limită de 10MB
  }
});
var employeeService = new EmployeeService();
var documentService = new HrDocumentService();
var holidayService = new HolidayService();
router4.get(
  "/settings",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      await SettingsService.getSettings(req, res);
    } catch (error) {
      console.error("Error in settings endpoint:", error);
      res.status(500).json({
        success: false,
        message: "Eroare la ob\u021Binerea set\u0103rilor",
        error: error.message
      });
    }
  }
);
router4.put(
  "/settings/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      await SettingsService.updateSettings(req, res);
    } catch (error) {
      console.error("Error in settings update endpoint:", error);
      res.status(500).json({
        success: false,
        message: "Eroare la actualizarea set\u0103rilor",
        error: error.message
      });
    }
  }
);
router4.post(
  "/employees/draft",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const { userData, draftId } = req.body;
      const userId = req.user?.id || "";
      const companyId = req.user?.companyId || "";
      const savedDraft = await documentService.saveEmployeeDraft(
        companyId,
        userData,
        userId,
        draftId
      );
      res.status(200).json({
        success: true,
        data: savedDraft,
        message: "Ciorna angajatului a fost salvat\u0103 cu succes"
      });
    } catch (error) {
      console.error("Error saving employee draft:", error);
      res.status(500).json({
        success: false,
        message: "Eroare la salvarea ciornei angajatului",
        error: error.message
      });
    }
  }
);
router4.post(
  "/documents/generate-compliance",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const { employeeData } = req.body;
      const userId = req.user?.id || "";
      const companyId = req.user?.companyId || "";
      const documents2 = await documentService.generateComplianceDocuments(
        companyId,
        employeeData,
        userId
      );
      res.status(200).json({
        success: true,
        data: documents2,
        message: "Documentele au fost generate cu succes"
      });
    } catch (error) {
      console.error("Error generating compliance documents:", error);
      res.status(500).json({
        success: false,
        message: "Eroare la generarea documentelor de conformitate",
        error: error.message
      });
    }
  }
);
router4.post(
  "/documents/upload",
  AuthGuard.protect("required" /* REQUIRED */),
  upload.single("file"),
  async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: "Niciun fi\u0219ier primit"
        });
      }
      const { employeeId, documentType } = req.body;
      const userId = req.user?.id || "";
      const companyId = req.user?.companyId || "";
      const documentUrl = `/uploads/hr_documents/${req.file.filename}`;
      const uploadedDocument = await documentService.saveEmployeeDocument(
        companyId,
        employeeId || null,
        documentType || "other",
        documentUrl,
        req.file.originalname,
        userId
      );
      res.status(200).json({
        success: true,
        data: {
          documentUrl,
          document: uploadedDocument
        },
        message: "Documentul a fost \xEEnc\u0103rcat cu succes"
      });
    } catch (error) {
      console.error("Error uploading document:", error);
      res.status(500).json({
        success: false,
        message: "Eroare la \xEEnc\u0103rcarea documentului",
        error: error.message
      });
    }
  }
);
router4.get(
  "/holidays",
  async (req, res) => {
    try {
      const holidays = await holidayService.getRomanianHolidays();
      res.status(200).json({
        success: true,
        data: holidays,
        message: "Zilele de s\u0103rb\u0103toare legal\u0103 au fost ob\u021Binute cu succes"
      });
    } catch (error) {
      console.error("Error fetching Romanian holidays:", error);
      res.status(500).json({
        success: false,
        message: "Eroare la ob\u021Binerea zilelor de s\u0103rb\u0103toare legal\u0103",
        error: error.message
      });
    }
  }
);
var hr_routes_default = router4;

// server/modules/hr/init.ts
function initHrModule(app2) {
  const { router: router14, services } = HrModule.register();
  app2.use("/api/hr", router14);
  app2.use("/api/hr", hr_routes_default);
  console.log("HR module routes registered at /api/hr");
  return {
    name: "HR Module",
    version: "1.0.0",
    services
  };
}

// server/modules/ecommerce/ecommerce.module.ts
init_logger();

// server/modules/ecommerce/services/orders.service.ts
import { v4 as uuidv419 } from "uuid";
import { eq as eq45, and as and34, desc as desc16, sql as sql38 } from "drizzle-orm";

// shared/schema/ecommerce.schema.ts
import {
  pgTable as pgTable17,
  uuid as uuid16,
  text as text17,
  timestamp as timestamp17,
  pgEnum as pgEnum8,
  numeric as numeric8,
  boolean as boolean15,
  json as json8,
  integer as integer12,
  index as index8,
  unique as unique6
} from "drizzle-orm/pg-core";
import { sql as sql37 } from "drizzle-orm";
import { createInsertSchema as createInsertSchema11 } from "drizzle-zod";
import { z as z16 } from "zod";
var OrderStatus2 = /* @__PURE__ */ ((OrderStatus3) => {
  OrderStatus3["DRAFT"] = "draft";
  OrderStatus3["PENDING"] = "pending";
  OrderStatus3["PROCESSING"] = "processing";
  OrderStatus3["ON_HOLD"] = "on_hold";
  OrderStatus3["COMPLETED"] = "completed";
  OrderStatus3["CANCELED"] = "canceled";
  OrderStatus3["REFUNDED"] = "refunded";
  OrderStatus3["FAILED"] = "failed";
  OrderStatus3["SHIPPED"] = "shipped";
  OrderStatus3["DELIVERED"] = "delivered";
  OrderStatus3["RETURNED"] = "returned";
  return OrderStatus3;
})(OrderStatus2 || {});
var PaymentStatus2 = /* @__PURE__ */ ((PaymentStatus3) => {
  PaymentStatus3["PENDING"] = "pending";
  PaymentStatus3["COMPLETED"] = "completed";
  PaymentStatus3["FAILED"] = "failed";
  PaymentStatus3["REFUNDED"] = "refunded";
  PaymentStatus3["PARTIALLY_REFUNDED"] = "partially_refunded";
  return PaymentStatus3;
})(PaymentStatus2 || {});
var TransactionType = /* @__PURE__ */ ((TransactionType2) => {
  TransactionType2["PAYMENT"] = "payment";
  TransactionType2["REFUND"] = "refund";
  TransactionType2["PARTIAL_REFUND"] = "partial_refund";
  TransactionType2["AUTHORIZATION"] = "authorization";
  TransactionType2["CAPTURE"] = "capture";
  TransactionType2["VOID"] = "void";
  return TransactionType2;
})(TransactionType || {});
var PaymentMethod2 = /* @__PURE__ */ ((PaymentMethod5) => {
  PaymentMethod5["CREDIT_CARD"] = "credit_card";
  PaymentMethod5["DEBIT_CARD"] = "debit_card";
  PaymentMethod5["PAYPAL"] = "paypal";
  PaymentMethod5["BANK_TRANSFER"] = "bank_transfer";
  PaymentMethod5["CASH_ON_DELIVERY"] = "cash_on_delivery";
  PaymentMethod5["STRIPE"] = "stripe";
  PaymentMethod5["OTHER"] = "other";
  return PaymentMethod5;
})(PaymentMethod2 || {});
var PlatformType = /* @__PURE__ */ ((PlatformType2) => {
  PlatformType2["WEBSITE"] = "website";
  PlatformType2["POS"] = "pos";
  PlatformType2["SHOPIFY"] = "shopify";
  PlatformType2["PRESTASHOP"] = "prestashop";
  PlatformType2["WOOCOMMERCE"] = "woocommerce";
  PlatformType2["MARKETPLACE"] = "marketplace";
  PlatformType2["OTHER"] = "other";
  return PlatformType2;
})(PlatformType || {});
var CartStatus = /* @__PURE__ */ ((CartStatus2) => {
  CartStatus2["ACTIVE"] = "active";
  CartStatus2["COMPLETED"] = "completed";
  CartStatus2["ABANDONED"] = "abandoned";
  CartStatus2["EXPIRED"] = "expired";
  return CartStatus2;
})(CartStatus || {});
var orderStatusValues = Object.values(OrderStatus2).map((val) => val.toString());
var paymentStatusValues = Object.values(PaymentStatus2).map((val) => val.toString());
var transactionTypeValues = Object.values(TransactionType).map((val) => val.toString());
var paymentMethodValues = Object.values(PaymentMethod2).map((val) => val.toString());
var platformTypeValues = Object.values(PlatformType).map((val) => val.toString());
var cartStatusValues = Object.values(CartStatus).map((val) => val.toString());
var orderStatusEnum2 = pgEnum8("order_status", orderStatusValues);
var paymentStatusEnum2 = pgEnum8("payment_status", paymentStatusValues);
var transactionTypeEnum = pgEnum8("transaction_type", transactionTypeValues);
var paymentMethodEnum2 = pgEnum8("payment_method", paymentMethodValues);
var platformTypeEnum = pgEnum8("platform_type", platformTypeValues);
var cartStatusEnum = pgEnum8("cart_status", cartStatusValues);
var ecommerceOrders = pgTable17("ecommerce_orders", {
  id: uuid16("id").primaryKey().default(sql37`gen_random_uuid()`),
  companyId: uuid16("company_id").notNull(),
  orderNumber: text17("order_number").notNull(),
  orderDate: timestamp17("order_date", { withTimezone: true }).defaultNow().notNull(),
  // Customer information
  customerId: uuid16("customer_id"),
  customerEmail: text17("customer_email"),
  customerPhone: text17("customer_phone"),
  customerName: text17("customer_name"),
  // Amounts
  subtotal: numeric8("subtotal").notNull(),
  tax: numeric8("tax").notNull(),
  shipping: numeric8("shipping").notNull(),
  discount: numeric8("discount").notNull(),
  total: numeric8("total").notNull(),
  // Status tracking
  status: orderStatusEnum2("status").default("draft" /* DRAFT */).notNull(),
  paymentStatus: paymentStatusEnum2("payment_status").default("pending" /* PENDING */).notNull(),
  paymentMethod: paymentMethodEnum2("payment_method"),
  // Shipping details
  shippingAddress: json8("shipping_address"),
  billingAddress: json8("billing_address"),
  trackingNumber: text17("tracking_number"),
  shippingMethod: text17("shipping_method"),
  shippedAt: timestamp17("shipped_at", { withTimezone: true }),
  deliveredAt: timestamp17("delivered_at", { withTimezone: true }),
  // Platform information
  platformType: platformTypeEnum("platform_type").default("website" /* WEBSITE */),
  platformOrderId: text17("platform_order_id"),
  platformData: json8("platform_data"),
  // Flags
  isInvoiced: boolean15("is_invoiced").default(false),
  needsAttention: boolean15("needs_attention").default(false),
  // Items and notes
  items: json8("items").notNull(),
  notes: text17("notes"),
  customerNotes: text17("customer_notes"),
  internalNotes: text17("internal_notes"),
  // Audit
  createdAt: timestamp17("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp17("updated_at", { withTimezone: true }).defaultNow().notNull(),
  createdBy: uuid16("created_by"),
  updatedBy: uuid16("updated_by")
}, (table) => ({
  companyIdIdx: index8("ecommerce_orders_company_id_idx").on(table.companyId),
  customerIdIdx: index8("ecommerce_orders_customer_id_idx").on(table.customerId),
  orderNumberIdx: index8("ecommerce_orders_order_number_idx").on(table.orderNumber),
  orderDateIdx: index8("ecommerce_orders_order_date_idx").on(table.orderDate),
  statusIdx: index8("ecommerce_orders_status_idx").on(table.status),
  paymentStatusIdx: index8("ecommerce_orders_payment_status_idx").on(table.paymentStatus),
  platformTypeIdx: index8("ecommerce_orders_platform_type_idx").on(table.platformType),
  uniqueOrderNumberPerCompany: unique6("unique_order_number_company").on(table.companyId, table.orderNumber)
}));
var ecommerceTransactions = pgTable17("ecommerce_transactions", {
  id: uuid16("id").primaryKey().default(sql37`gen_random_uuid()`),
  companyId: uuid16("company_id").notNull(),
  orderId: uuid16("order_id").notNull(),
  transactionType: transactionTypeEnum("transaction_type").notNull(),
  amount: numeric8("amount").notNull(),
  currency: text17("currency").notNull(),
  status: paymentStatusEnum2("status").default("pending" /* PENDING */).notNull(),
  paymentMethod: paymentMethodEnum2("payment_method"),
  // Transaction details
  transactionId: text17("transaction_id"),
  transactionReference: text17("transaction_reference"),
  authorizationCode: text17("authorization_code"),
  transactionDate: timestamp17("transaction_date", { withTimezone: true }).defaultNow().notNull(),
  // Card details (masked)
  cardLast4: text17("card_last_4"),
  cardType: text17("card_type"),
  cardExpiryMonth: integer12("card_expiry_month"),
  cardExpiryYear: integer12("card_expiry_year"),
  // Gateway information
  gatewayName: text17("gateway_name"),
  gatewayResponse: json8("gateway_response"),
  gatewayFee: numeric8("gateway_fee"),
  // Parent transaction (for refunds)
  parentTransactionId: uuid16("parent_transaction_id"),
  // Notes
  notes: text17("notes"),
  metadata: json8("metadata"),
  // Audit
  createdAt: timestamp17("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp17("updated_at", { withTimezone: true }).defaultNow().notNull(),
  createdBy: uuid16("created_by"),
  updatedBy: uuid16("updated_by")
}, (table) => ({
  companyIdIdx: index8("ecommerce_transactions_company_id_idx").on(table.companyId),
  orderIdIdx: index8("ecommerce_transactions_order_id_idx").on(table.orderId),
  transactionTypeIdx: index8("ecommerce_transactions_type_idx").on(table.transactionType),
  statusIdx: index8("ecommerce_transactions_status_idx").on(table.status),
  transactionDateIdx: index8("ecommerce_transactions_date_idx").on(table.transactionDate)
}));
var carts = pgTable17("ecommerce_carts", {
  id: uuid16("id").primaryKey().default(sql37`gen_random_uuid()`),
  companyId: uuid16("company_id").notNull(),
  userId: uuid16("user_id").notNull(),
  sessionId: text17("session_id"),
  status: cartStatusEnum("status").default("active" /* ACTIVE */).notNull(),
  // Cart totals
  subtotal: numeric8("subtotal").default("0").notNull(),
  taxAmount: numeric8("tax_amount").default("0").notNull(),
  discountAmount: numeric8("discount_amount").default("0").notNull(),
  total: numeric8("total").default("0").notNull(),
  // Currency and discounts
  currencyCode: text17("currency_code").default("RON").notNull(),
  appliedDiscountCode: text17("applied_discount_code"),
  // Expiration
  expiresAt: timestamp17("expires_at", { withTimezone: true }),
  // Metadata
  metadata: json8("metadata"),
  // Audit
  createdAt: timestamp17("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp17("updated_at", { withTimezone: true }).defaultNow().notNull()
}, (table) => ({
  companyIdIdx: index8("ecommerce_carts_company_id_idx").on(table.companyId),
  userIdIdx: index8("ecommerce_carts_user_id_idx").on(table.userId),
  sessionIdIdx: index8("ecommerce_carts_session_id_idx").on(table.sessionId),
  statusIdx: index8("ecommerce_carts_status_idx").on(table.status)
}));
var cartItems = pgTable17("ecommerce_cart_items", {
  id: uuid16("id").primaryKey().default(sql37`gen_random_uuid()`),
  cartId: uuid16("cart_id").notNull().references(() => carts.id, { onDelete: "cascade" }),
  productId: uuid16("product_id").notNull(),
  quantity: integer12("quantity").notNull().default(1),
  unitPrice: numeric8("unit_price").notNull(),
  totalPrice: numeric8("total_price").notNull(),
  // Product information (snapshot)
  name: text17("name"),
  sku: text17("sku"),
  // Customizations
  options: json8("options"),
  metadata: json8("metadata"),
  // Audit
  createdAt: timestamp17("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp17("updated_at", { withTimezone: true }).defaultNow().notNull()
}, (table) => ({
  cartIdIdx: index8("ecommerce_cart_items_cart_id_idx").on(table.cartId),
  productIdIdx: index8("ecommerce_cart_items_product_id_idx").on(table.productId)
}));
var insertEcommerceOrderSchema = createInsertSchema11(ecommerceOrders, {
  subtotal: z16.string().or(z16.number()).transform((val) => val.toString()),
  tax: z16.string().or(z16.number()).transform((val) => val.toString()),
  shipping: z16.string().or(z16.number()).transform((val) => val.toString()),
  discount: z16.string().or(z16.number()).transform((val) => val.toString()),
  total: z16.string().or(z16.number()).transform((val) => val.toString()),
  shippingAddress: z16.record(z16.any()).optional(),
  billingAddress: z16.record(z16.any()).optional(),
  platformData: z16.record(z16.any()).optional(),
  items: z16.array(z16.any()).min(1)
}).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var insertEcommerceTransactionSchema = createInsertSchema11(ecommerceTransactions, {
  amount: z16.string().or(z16.number()).transform((val) => val.toString()),
  gatewayFee: z16.string().or(z16.number()).transform((val) => val.toString()).optional(),
  gatewayResponse: z16.record(z16.any()).optional(),
  metadata: z16.record(z16.any()).optional()
}).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var insertCartSchema = createInsertSchema11(carts, {
  subtotal: z16.string().or(z16.number()).transform((val) => val.toString()).optional(),
  taxAmount: z16.string().or(z16.number()).transform((val) => val.toString()).optional(),
  discountAmount: z16.string().or(z16.number()).transform((val) => val.toString()).optional(),
  total: z16.string().or(z16.number()).transform((val) => val.toString()).optional(),
  metadata: z16.record(z16.any()).optional()
}).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var insertCartItemSchema = createInsertSchema11(cartItems, {
  unitPrice: z16.string().or(z16.number()).transform((val) => val.toString()),
  totalPrice: z16.string().or(z16.number()).transform((val) => val.toString()),
  options: z16.record(z16.any()).optional(),
  metadata: z16.record(z16.any()).optional()
}).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var ecommerceIntegrations = pgTable17("ecommerce_integrations", {
  id: uuid16("id").primaryKey().default(sql37`gen_random_uuid()`),
  companyId: uuid16("company_id").notNull(),
  type: text17("type").notNull(),
  // shopify, woocommerce, prestashop, etc.
  name: text17("name").notNull(),
  enabled: boolean15("enabled").default(true).notNull(),
  // Integration credentials (API keys, tokens, etc.)
  credentials: json8("credentials").notNull(),
  // Integration settings
  settings: json8("settings").notNull(),
  // Sync status and metadata
  syncStatus: json8("sync_status").notNull(),
  metadata: json8("metadata").notNull(),
  // Audit
  createdAt: timestamp17("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp17("updated_at", { withTimezone: true }).defaultNow().notNull()
}, (table) => ({
  companyIdIdx: index8("ecommerce_integrations_company_id_idx").on(table.companyId),
  typeIdx: index8("ecommerce_integrations_type_idx").on(table.type),
  uniqueTypePerCompany: unique6("unique_integration_type_company").on(table.companyId, table.type)
}));
var insertEcommerceIntegrationSchema = createInsertSchema11(ecommerceIntegrations, {
  credentials: z16.record(z16.any()),
  settings: z16.record(z16.any()),
  syncStatus: z16.record(z16.any()),
  metadata: z16.record(z16.any())
}).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});

// server/modules/ecommerce/services/orders.service.ts
init_logger();
var logger50 = new Logger("OrdersService");
var OrdersService = class {
  constructor(drizzleService5) {
    this.db = drizzleService5;
    logger50.info("OrdersService initialized");
  }
  /**
   * Create a new order
   * 
   * @param orderData Order data
   * @returns The created order
   */
  async createOrder(orderData) {
    try {
      const orderId = uuidv419();
      let orderDate;
      try {
        if (orderData.orderDate === null || orderData.orderDate === void 0) {
          orderDate = /* @__PURE__ */ new Date();
          logger50.info("No orderDate provided, using current date");
        } else if (orderData.orderDate instanceof Date) {
          orderDate = orderData.orderDate;
        } else if (typeof orderData.orderDate === "string" && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(orderData.orderDate)) {
          orderDate = new Date(orderData.orderDate);
        } else if (typeof orderData.orderDate === "number") {
          orderDate = new Date(orderData.orderDate);
        } else if (typeof orderData.orderDate === "string") {
          orderDate = new Date(orderData.orderDate);
        } else {
          orderDate = /* @__PURE__ */ new Date();
          logger50.warn(`Unrecognized orderDate format: ${typeof orderData.orderDate}, using current date`);
        }
        if (orderDate instanceof Date && isNaN(orderDate.getTime())) {
          logger50.warn(`Invalid date value: ${orderData.orderDate}, using current date instead`);
          orderDate = /* @__PURE__ */ new Date();
        }
      } catch (error) {
        logger50.error("Error parsing orderDate:", error);
        orderDate = /* @__PURE__ */ new Date();
      }
      const orderDateISO = orderDate instanceof Date ? orderDate.toISOString() : (/* @__PURE__ */ new Date()).toISOString();
      const subtotal = orderData.subtotal || orderData.totalAmount;
      const tax = orderData.tax || orderData.taxAmount;
      const discount = orderData.discount || orderData.discountAmount;
      const shipping = orderData.shipping || orderData.shippingAmount;
      const total = orderData.total || orderData.totalAmount;
      const notes = orderData.notes || "";
      const items = JSON.stringify(orderData.items);
      const shippingAddress = orderData.shippingAddress ? JSON.stringify(orderData.shippingAddress) : null;
      const billingAddress = orderData.billingAddress ? JSON.stringify(orderData.billingAddress) : null;
      const metadata = orderData.metadata ? JSON.stringify(orderData.metadata) : "{}";
      const now = (/* @__PURE__ */ new Date()).toISOString();
      logger50.info(`Creating order with date: ${orderDateISO}`);
      const result = await this.db.execute(sql38`
        INSERT INTO ecommerce_orders (
          id, company_id, user_id, order_number, order_date, status,
          subtotal, tax, discount, shipping, total, 
          shipping_address, billing_address, payment_method, 
          items, notes, created_at, updated_at
        )
        VALUES (
          ${orderId}, ${orderData.companyId}, ${orderData.userId}, ${orderData.orderNumber}, 
          CURRENT_TIMESTAMP, ${orderData.status},
          ${subtotal}, ${tax}, ${discount}, ${shipping}, ${total},
          ${shippingAddress}::jsonb, ${billingAddress}::jsonb, ${orderData.paymentMethod},
          ${items}::jsonb, ${notes}, ${now}::timestamptz, ${now}::timestamptz
        )
        RETURNING *;
      `);
      const order = result.rows[0];
      logger50.info(`Created order ${order.orderNumber} with ID ${order.id}`);
      return order;
    } catch (error) {
      logger50.error("Failed to create order", error);
      throw new Error(`Failed to create order: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get an order by ID
   * 
   * @param orderId Order ID
   * @param companyId Company ID
   * @returns The order
   */
  async getOrderById(orderId, companyId) {
    try {
      const orders2 = await this.db.select().from(ecommerceOrders).where(
        and34(
          eq45(ecommerceOrders.id, orderId),
          eq45(ecommerceOrders.companyId, companyId)
        )
      );
      if (orders2.length === 0) {
        return null;
      }
      return orders2[0];
    } catch (error) {
      logger50.error(`Failed to get order ${orderId}`, error);
      throw new Error(`Failed to get order: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get all orders for a company
   * 
   * @param companyId Company ID
   * @param options Query options
   * @returns Array of orders
   */
  async getCompanyOrders(companyId, options = {}) {
    try {
      const {
        limit = 50,
        offset = 0,
        status = "all",
        sortBy = "orderDate",
        sortDirection = "desc"
      } = options;
      let query = this.db.select().from(ecommerceOrders).where(eq45(ecommerceOrders.companyId, companyId));
      if (status !== "all") {
        query = query.where(eq45(ecommerceOrders.status, status));
      }
      if (sortDirection === "desc") {
        query = query.orderBy(desc16(ecommerceOrders[sortBy]));
      } else {
        query = query.orderBy(ecommerceOrders[sortBy]);
      }
      query = query.limit(limit).offset(offset);
      const orders2 = await query;
      return orders2;
    } catch (error) {
      logger50.error(`Failed to get orders for company ${companyId}`, error);
      throw new Error(`Failed to get company orders: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get orders for a user
   * 
   * @param userId User ID
   * @param companyId Company ID
   * @param options Query options
   * @returns Array of orders
   */
  async getUserOrders(userId, companyId, options = {}) {
    try {
      const {
        limit = 50,
        offset = 0,
        status = "all",
        sortBy = "orderDate",
        sortDirection = "desc"
      } = options;
      let query = this.db.select().from(ecommerceOrders).where(
        and34(
          eq45(ecommerceOrders.userId, userId),
          eq45(ecommerceOrders.companyId, companyId)
        )
      );
      if (status !== "all") {
        query = query.where(eq45(ecommerceOrders.status, status));
      }
      if (sortDirection === "desc") {
        query = query.orderBy(desc16(ecommerceOrders[sortBy]));
      } else {
        query = query.orderBy(ecommerceOrders[sortBy]);
      }
      query = query.limit(limit).offset(offset);
      const orders2 = await query;
      return orders2;
    } catch (error) {
      logger50.error(`Failed to get orders for user ${userId}`, error);
      throw new Error(`Failed to get user orders: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update an order's status
   * 
   * @param orderId Order ID
   * @param newStatus New status
   * @param companyId Company ID
   * @returns The updated order
   */
  async updateOrderStatus(orderId, newStatus, companyId) {
    try {
      const [updatedOrder] = await this.db.update(ecommerceOrders).set({
        status: newStatus,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and34(
          eq45(ecommerceOrders.id, orderId),
          eq45(ecommerceOrders.companyId, companyId)
        )
      ).returning();
      if (!updatedOrder) {
        throw new Error("Order not found");
      }
      logger50.info(`Updated order ${orderId} status to ${newStatus}`);
      return updatedOrder;
    } catch (error) {
      logger50.error(`Failed to update order ${orderId} status`, error);
      throw new Error(`Failed to update order status: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update an order
   * 
   * @param orderId Order ID
   * @param updateData Data to update
   * @param companyId Company ID
   * @returns The updated order
   */
  async updateOrder(orderId, updateData, companyId) {
    try {
      const [updatedOrder] = await this.db.update(ecommerceOrders).set({
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and34(
          eq45(ecommerceOrders.id, orderId),
          eq45(ecommerceOrders.companyId, companyId)
        )
      ).returning();
      if (!updatedOrder) {
        throw new Error("Order not found");
      }
      logger50.info(`Updated order ${orderId}`);
      return updatedOrder;
    } catch (error) {
      logger50.error(`Failed to update order ${orderId}`, error);
      throw new Error(`Failed to update order: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get orders count by status
   * 
   * @param companyId Company ID
   * @returns Count of orders by status
   */
  async getOrdersCountByStatus(companyId) {
    try {
      const orders2 = await this.db.select().from(ecommerceOrders).where(eq45(ecommerceOrders.companyId, companyId));
      const counts = {};
      Object.values(OrderStatus2).forEach((status) => {
        counts[status] = 0;
      });
      orders2.forEach((order) => {
        counts[order.status] = (counts[order.status] || 0) + 1;
      });
      counts.total = orders2.length;
      return counts;
    } catch (error) {
      logger50.error(`Failed to get orders count for company ${companyId}`, error);
      throw new Error(`Failed to get orders count: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Search orders
   * 
   * @param companyId Company ID
   * @param searchTerm Search term
   * @returns Matching orders
   */
  async searchOrders(companyId, searchTerm) {
    try {
      const orders2 = await this.db.select().from(ecommerceOrders).where(
        and34(
          eq45(ecommerceOrders.companyId, companyId)
        )
      );
      return orders2.filter(
        (order) => order.orderNumber.toLowerCase().includes(searchTerm.toLowerCase())
      );
    } catch (error) {
      logger50.error(`Failed to search orders for company ${companyId}`, error);
      throw new Error(`Failed to search orders: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/ecommerce/services/transactions.service.ts
import { v4 as uuidv420 } from "uuid";
import { eq as eq46, and as and35, desc as desc17 } from "drizzle-orm";
init_logger();
var logger51 = new Logger("TransactionsService");
var TransactionsService = class {
  constructor(drizzleService5) {
    this.db = drizzleService5;
    logger51.info("TransactionsService initialized");
  }
  /**
   * Create a new transaction
   * 
   * @param transactionData Transaction data
   * @returns The created transaction
   */
  async createTransaction(transactionData) {
    try {
      const transactionId = uuidv420();
      const [transaction] = await this.db.insert(ecommerceTransactions).values({
        id: transactionId,
        orderId: transactionData.orderId,
        userId: transactionData.userId,
        companyId: transactionData.companyId,
        transactionDate: transactionData.transactionDate,
        amount: transactionData.amount,
        currency: transactionData.currency,
        status: transactionData.status,
        paymentMethod: transactionData.paymentMethod,
        paymentGateway: transactionData.paymentGateway,
        gatewayTransactionId: transactionData.gatewayTransactionId,
        metadata: transactionData.metadata || {},
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      logger51.info(`Created transaction ${transaction.id} for order ${transaction.orderId}`);
      return transaction;
    } catch (error) {
      logger51.error("Failed to create transaction", error);
      throw new Error(`Failed to create transaction: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get a transaction by ID
   * 
   * @param transactionId Transaction ID
   * @param type Query type
   * @returns The transaction
   */
  async getTransactionById(transactionId, type = "company") {
    try {
      const transactions2 = await this.db.select().from(ecommerceTransactions).where(eq46(ecommerceTransactions.id, transactionId));
      if (transactions2.length === 0) {
        return null;
      }
      return transactions2[0];
    } catch (error) {
      logger51.error(`Failed to get transaction ${transactionId}`, error);
      throw new Error(`Failed to get transaction: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get transactions for an order
   * 
   * @param orderId Order ID
   * @param companyId Company ID
   * @returns Array of transactions
   */
  async getOrderTransactions(orderId, companyId) {
    try {
      const transactions2 = await this.db.select().from(ecommerceTransactions).where(
        and35(
          eq46(ecommerceTransactions.orderId, orderId),
          eq46(ecommerceTransactions.companyId, companyId)
        )
      ).orderBy(desc17(ecommerceTransactions.transactionDate));
      return transactions2;
    } catch (error) {
      logger51.error(`Failed to get transactions for order ${orderId}`, error);
      throw new Error(`Failed to get order transactions: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get all transactions for a company
   * 
   * @param companyId Company ID
   * @param options Query options
   * @returns Array of transactions
   */
  async getCompanyTransactions(companyId, options = {}) {
    try {
      const {
        limit = 50,
        offset = 0,
        status = "all",
        startDate,
        endDate
      } = options;
      let query = this.db.select().from(ecommerceTransactions).where(eq46(ecommerceTransactions.companyId, companyId));
      if (status !== "all") {
        query = query.where(eq46(ecommerceTransactions.status, status));
      }
      if (startDate) {
        query = query.where(ecommerceTransactions.transactionDate >= startDate);
      }
      if (endDate) {
        query = query.where(ecommerceTransactions.transactionDate <= endDate);
      }
      query = query.orderBy(desc17(ecommerceTransactions.transactionDate)).limit(limit).offset(offset);
      const transactions2 = await query;
      return transactions2;
    } catch (error) {
      logger51.error(`Failed to get transactions for company ${companyId}`, error);
      throw new Error(`Failed to get company transactions: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update a transaction's status
   * 
   * @param transactionId Transaction ID
   * @param newStatus New status
   * @param amount Transaction amount
   * @param additionalData Additional data
   * @returns The updated transaction
   */
  async updateTransactionStatus(transactionId, newStatus, amount, additionalData = {}) {
    try {
      const [updatedTransaction] = await this.db.update(ecommerceTransactions).set({
        status: newStatus,
        metadata: {
          ...additionalData,
          statusUpdatedAt: /* @__PURE__ */ new Date()
        },
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq46(ecommerceTransactions.id, transactionId)).returning();
      if (!updatedTransaction) {
        throw new Error("Transaction not found");
      }
      logger51.info(`Updated transaction ${transactionId} status to ${newStatus}`);
      return updatedTransaction;
    } catch (error) {
      logger51.error(`Failed to update transaction ${transactionId} status`, error);
      throw new Error(`Failed to update transaction status: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Record a refund for a transaction
   * 
   * @param originalTransactionId Original transaction ID
   * @param refundAmount Refund amount
   * @param companyId Company ID
   * @param userId User ID
   * @param reason Refund reason
   * @returns The refund transaction
   */
  async recordRefund(originalTransactionId, refundAmount, companyId, userId, reason) {
    try {
      const originalTransaction = await this.getTransactionById(originalTransactionId);
      if (!originalTransaction) {
        throw new Error("Original transaction not found");
      }
      if (Number(refundAmount) <= 0 || Number(refundAmount) > Number(originalTransaction.amount)) {
        throw new Error("Invalid refund amount");
      }
      const refundTransaction = await this.createTransaction({
        orderId: originalTransaction.orderId,
        userId,
        companyId,
        transactionDate: /* @__PURE__ */ new Date(),
        amount: refundAmount,
        currency: originalTransaction.currency,
        status: "completed" /* COMPLETED */,
        // Assuming refund is processed immediately
        paymentMethod: originalTransaction.paymentMethod,
        paymentGateway: originalTransaction.paymentGateway,
        gatewayTransactionId: `refund-${uuidv420()}`,
        metadata: {
          originalTransactionId,
          refundReason: reason,
          type: "refund"
        }
      });
      if (refundAmount === originalTransaction.amount) {
        await this.updateTransactionStatus(
          originalTransactionId,
          "refunded" /* REFUNDED */,
          originalTransaction.amount,
          {
            refundTransactionId: refundTransaction.id,
            refundDate: /* @__PURE__ */ new Date(),
            refundReason: reason
          }
        );
      } else {
        await this.updateTransactionStatus(
          originalTransactionId,
          "partially_refunded" /* PARTIALLY_REFUNDED */,
          originalTransaction.amount,
          {
            refundTransactionId: refundTransaction.id,
            refundAmount,
            refundDate: /* @__PURE__ */ new Date(),
            refundReason: reason
          }
        );
      }
      logger51.info(`Recorded refund of ${refundAmount} ${originalTransaction.currency} for transaction ${originalTransactionId}`);
      return refundTransaction;
    } catch (error) {
      logger51.error(`Failed to record refund for transaction ${originalTransactionId}`, error);
      throw new Error(`Failed to record refund: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get summary statistics for transactions
   * 
   * @param companyId Company ID
   * @param period Period for statistics ('day', 'week', 'month', 'year')
   * @returns Transaction statistics
   */
  async getTransactionStatistics(companyId, period = "month") {
    try {
      const now = /* @__PURE__ */ new Date();
      let startDate;
      switch (period) {
        case "day":
          startDate = new Date(now);
          startDate.setDate(now.getDate() - 1);
          break;
        case "week":
          startDate = new Date(now);
          startDate.setDate(now.getDate() - 7);
          break;
        case "month":
          startDate = new Date(now);
          startDate.setMonth(now.getMonth() - 1);
          break;
        case "year":
          startDate = new Date(now);
          startDate.setFullYear(now.getFullYear() - 1);
          break;
        default:
          startDate = new Date(now);
          startDate.setMonth(now.getMonth() - 1);
      }
      const transactions2 = await this.db.select().from(ecommerceTransactions).where(
        and35(
          eq46(ecommerceTransactions.companyId, companyId),
          ecommerceTransactions.transactionDate >= startDate,
          ecommerceTransactions.transactionDate <= now
        )
      );
      const stats = {
        totalTransactions: transactions2.length,
        totalAmount: 0,
        successfulTransactions: 0,
        failedTransactions: 0,
        pendingTransactions: 0,
        refundedTransactions: 0,
        averageTransactionAmount: 0,
        currency: transactions2.length > 0 ? transactions2[0].currency : "RON",
        // Default to Romanian currency
        period
      };
      transactions2.forEach((transaction) => {
        if (transaction.metadata && transaction.metadata.type === "refund") {
          return;
        }
        if (transaction.status === "completed" /* COMPLETED */) {
          stats.successfulTransactions++;
          stats.totalAmount += Number(transaction.amount);
        } else if (transaction.status === "failed" /* FAILED */) {
          stats.failedTransactions++;
        } else if (transaction.status === "pending" /* PENDING */) {
          stats.pendingTransactions++;
        } else if (transaction.status === "refunded" /* REFUNDED */ || transaction.status === "partially_refunded" /* PARTIALLY_REFUNDED */) {
          stats.refundedTransactions++;
        }
      });
      if (stats.successfulTransactions > 0) {
        stats.averageTransactionAmount = stats.totalAmount / stats.successfulTransactions;
      }
      return stats;
    } catch (error) {
      logger51.error(`Failed to get transaction statistics for company ${companyId}`, error);
      throw new Error(`Failed to get transaction statistics: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/ecommerce/routes/shopify.routes.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
import { Router as Router16 } from "express";
var logger52 = new Logger("ShopifyRouter");
var ShopifyRouter = class {
  constructor(shopifyService) {
    this.router = Router16();
    this.shopifyService = shopifyService;
    this.setupRoutes();
    logger52.info("ShopifyRouter initialized");
  }
  /**
   * Get the router
   * 
   * @returns Express router
   */
  getRouter() {
    return this.router;
  }
  /**
   * Setup routes
   */
  setupRoutes() {
    this.router.get("/status", AuthGuard.protect("required" /* REQUIRED */), this.getIntegrationStatus.bind(this));
    this.router.post("/credentials", AuthGuard.protect("required" /* REQUIRED */), this.saveCredentials.bind(this));
    this.router.post("/verify-credentials", AuthGuard.protect("required" /* REQUIRED */), this.verifyCredentials.bind(this));
    this.router.put("/enabled", AuthGuard.protect("required" /* REQUIRED */), this.setIntegrationEnabled.bind(this));
    this.router.post("/sync/products", AuthGuard.protect("required" /* REQUIRED */), this.syncProducts.bind(this));
    this.router.post("/import/orders", AuthGuard.protect("required" /* REQUIRED */), this.importOrders.bind(this));
    this.router.post("/webhook/:type", this.handleWebhook.bind(this));
  }
  /**
   * Get integration status
   * 
   * @param req Request
   * @param res Response
   */
  async getIntegrationStatus(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      const status = await this.shopifyService.getIntegrationStatus(companyId);
      res.json({
        success: true,
        data: status
      });
    } catch (error) {
      logger52.error("Failed to get integration status", error);
      res.status(500).json({
        success: false,
        message: `Failed to get integration status: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Save Shopify credentials
   * 
   * @param req Request
   * @param res Response
   */
  async saveCredentials(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      const credentials = req.body;
      if (!credentials.shopName || !credentials.accessToken) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: shopName and accessToken"
        });
      }
      const integration = await this.shopifyService.saveShopifyCredentials(companyId, credentials);
      res.json({
        success: true,
        data: {
          id: integration.id,
          name: integration.name,
          enabled: integration.enabled,
          syncStatus: integration.syncStatus,
          updatedAt: integration.updatedAt
        }
      });
    } catch (error) {
      logger52.error("Failed to save Shopify credentials", error);
      res.status(500).json({
        success: false,
        message: `Failed to save Shopify credentials: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Verify Shopify credentials
   * 
   * @param req Request
   * @param res Response
   */
  async verifyCredentials(req, res) {
    try {
      const credentials = req.body;
      if (!credentials.shopName || !credentials.accessToken) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields: shopName and accessToken"
        });
      }
      const isValid = await this.shopifyService.verifyCredentials(credentials);
      res.json({
        success: true,
        data: {
          valid: isValid
        }
      });
    } catch (error) {
      logger52.error("Failed to verify Shopify credentials", error);
      res.status(500).json({
        success: false,
        message: `Failed to verify Shopify credentials: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Enable/disable integration
   * 
   * @param req Request
   * @param res Response
   */
  async setIntegrationEnabled(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      const { enabled } = req.body;
      if (typeof enabled !== "boolean") {
        return res.status(400).json({
          success: false,
          message: 'Invalid request. Expected "enabled" boolean field'
        });
      }
      const integration = await this.shopifyService.setIntegrationEnabled(companyId, enabled);
      res.json({
        success: true,
        data: {
          id: integration.id,
          enabled: integration.enabled,
          updatedAt: integration.updatedAt
        }
      });
    } catch (error) {
      logger52.error("Failed to update integration status", error);
      res.status(500).json({
        success: false,
        message: `Failed to update integration status: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Sync products from Shopify
   * 
   * @param req Request
   * @param res Response
   */
  async syncProducts(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      const syncResult = await this.shopifyService.syncProducts(companyId);
      res.json({
        success: true,
        data: syncResult
      });
    } catch (error) {
      logger52.error("Failed to sync products from Shopify", error);
      res.status(500).json({
        success: false,
        message: `Failed to sync products: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Import orders from Shopify
   * 
   * @param req Request
   * @param res Response
   */
  async importOrders(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId, userId } = req.user;
      const importResult = await this.shopifyService.importOrders(companyId, userId);
      res.json({
        success: true,
        data: importResult
      });
    } catch (error) {
      logger52.error("Failed to import orders from Shopify", error);
      res.status(500).json({
        success: false,
        message: `Failed to import orders: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Handle Shopify webhook
   * 
   * @param req Request
   * @param res Response
   */
  async handleWebhook(req, res) {
    try {
      const { type } = req.params;
      const data = req.body;
      switch (type) {
        case "products":
          logger52.info("Received product webhook from Shopify");
          break;
        case "orders":
          logger52.info("Received order webhook from Shopify");
          break;
        default:
          logger52.warn(`Received unknown webhook type: ${type}`);
      }
      res.status(200).send();
    } catch (error) {
      logger52.error(`Failed to handle Shopify webhook: ${req.params.type}`, error);
      res.status(200).send();
    }
  }
};

// server/modules/ecommerce/routes/pos.routes.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
import { Router as Router17 } from "express";
var logger53 = new Logger("POSRouter");
var POSRouter = class {
  constructor(posService) {
    this.router = Router17();
    this.posService = posService;
    this.setupRoutes();
    logger53.info("POSRouter initialized");
  }
  /**
   * Get the router
   * 
   * @returns Express router
   */
  getRouter() {
    return this.router;
  }
  /**
   * Setup routes
   */
  setupRoutes() {
    this.router.post("/connect", AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["ecommerce_admin", "ecommerce_manager"]), this.connectPosSystem.bind(this));
    this.router.get("/status/:posSystem", AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["ecommerce_admin", "ecommerce_manager", "ecommerce_user"]), this.checkPosConnection.bind(this));
    this.router.post("/import-orders", AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["ecommerce_admin", "ecommerce_manager"]), this.importOrders.bind(this));
    this.router.post("/export-products", AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["ecommerce_admin", "ecommerce_manager"]), this.exportProducts.bind(this));
    this.router.post("/sync-inventory", AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["ecommerce_admin", "ecommerce_manager"]), this.syncInventory.bind(this));
  }
  /**
   * Connect to a POS system
   * 
   * @param req Request
   * @param res Response
   */
  async connectPosSystem(req, res) {
    try {
      const { posSystem, connectionDetails } = req.body;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const userId = req.user.id;
      const companyId = req.user.companyId;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      if (!posSystem || !connectionDetails) {
        return res.status(400).json({
          success: false,
          message: "POS system and connection details are required"
        });
      }
      const connectionResult = await this.posService.connectPosSystem(
        posSystem,
        connectionDetails,
        companyId,
        userId
      );
      res.json({
        success: true,
        data: connectionResult
      });
    } catch (error) {
      logger53.error("Failed to connect to POS system", error);
      res.status(500).json({
        success: false,
        message: `Failed to connect to POS system: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Check POS connection status
   * 
   * @param req Request
   * @param res Response
   */
  async checkPosConnection(req, res) {
    try {
      const { posSystem } = req.params;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const companyId = req.user.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const connectionStatus = await this.posService.checkPosConnection(posSystem, companyId);
      res.json({
        success: true,
        data: connectionStatus
      });
    } catch (error) {
      logger53.error(`Failed to check connection to POS system ${req.params.posSystem}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to check POS connection: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Import orders from POS
   * 
   * @param req Request
   * @param res Response
   */
  async importOrders(req, res) {
    try {
      const { posSystem, orders: orders2 } = req.body;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const userId = req.user.id;
      const companyId = req.user.companyId;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      if (!posSystem || !orders2 || !Array.isArray(orders2)) {
        return res.status(400).json({
          success: false,
          message: "POS system and orders array are required"
        });
      }
      const importedOrders = await this.posService.importOrders(
        posSystem,
        orders2,
        companyId,
        userId
      );
      res.json({
        success: true,
        data: {
          posSystem,
          importedCount: importedOrders.length,
          importedOrders
        }
      });
    } catch (error) {
      logger53.error("Failed to import orders from POS", error);
      res.status(500).json({
        success: false,
        message: `Failed to import orders from POS: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Export products to POS
   * 
   * @param req Request
   * @param res Response
   */
  async exportProducts(req, res) {
    try {
      const { posSystem, productIds } = req.body;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const userId = req.user.id;
      const companyId = req.user.companyId;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      if (!posSystem || !productIds || !Array.isArray(productIds)) {
        return res.status(400).json({
          success: false,
          message: "POS system and product IDs array are required"
        });
      }
      const exportResult = await this.posService.exportProducts(
        posSystem,
        productIds,
        companyId,
        userId
      );
      res.json({
        success: true,
        data: exportResult
      });
    } catch (error) {
      logger53.error("Failed to export products to POS", error);
      res.status(500).json({
        success: false,
        message: `Failed to export products to POS: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Sync inventory with POS
   * 
   * @param req Request
   * @param res Response
   */
  async syncInventory(req, res) {
    try {
      const { posSystem, inventoryUpdates } = req.body;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const userId = req.user.id;
      const companyId = req.user.companyId;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      if (!posSystem || !inventoryUpdates || !Array.isArray(inventoryUpdates)) {
        return res.status(400).json({
          success: false,
          message: "POS system and inventory updates array are required"
        });
      }
      const syncResult = await this.posService.syncInventory(
        posSystem,
        inventoryUpdates,
        companyId,
        userId
      );
      res.json({
        success: true,
        data: syncResult
      });
    } catch (error) {
      logger53.error("Failed to sync inventory with POS", error);
      res.status(500).json({
        success: false,
        message: `Failed to sync inventory with POS: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
};

// server/modules/ecommerce/services/shopify-integration.service.ts
import axios4 from "axios";
import { v4 as uuidv421 } from "uuid";
import { eq as eq47, and as and36 } from "drizzle-orm";
init_logger();
var logger54 = new Logger("ShopifyIntegrationService");
var SHOPIFY_API_VERSION = "2023-10";
var ShopifyIntegrationService = class {
  constructor(db4, ordersService, transactionsService) {
    this.db = db4;
    this.ordersService = ordersService;
    this.transactionsService = transactionsService;
    logger54.info("ShopifyIntegrationService initialized");
  }
  /**
   * Get Shopify credentials for a company
   * 
   * @param companyId Company ID
   * @returns Shopify credentials
   */
  async getShopifyCredentials(companyId) {
    try {
      const integrations2 = await this.db.select().from(ecommerceIntegrations).where(
        and36(
          eq47(ecommerceIntegrations.companyId, companyId),
          eq47(ecommerceIntegrations.type, "shopify")
        )
      );
      if (integrations2.length === 0) {
        return null;
      }
      const integration = integrations2[0];
      const integrationCredentials = integration.credentials;
      const credentials = {
        shopName: integrationCredentials.shopName,
        apiKey: integrationCredentials.apiKey,
        apiSecretKey: integrationCredentials.apiSecretKey,
        accessToken: integrationCredentials.accessToken
      };
      return credentials;
    } catch (error) {
      logger54.error(`Failed to get Shopify credentials for company ${companyId}`, error);
      throw new Error(`Failed to get Shopify credentials: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Save Shopify credentials for a company
   * 
   * @param companyId Company ID
   * @param credentials Shopify credentials
   * @returns The created or updated integration
   */
  async saveShopifyCredentials(companyId, credentials) {
    try {
      const existingIntegrations = await this.db.select().from(ecommerceIntegrations).where(
        and36(
          eq47(ecommerceIntegrations.companyId, companyId),
          eq47(ecommerceIntegrations.type, "shopify")
        )
      );
      if (existingIntegrations.length > 0) {
        const [updatedIntegration] = await this.db.update(ecommerceIntegrations).set({
          credentials,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and36(
            eq47(ecommerceIntegrations.companyId, companyId),
            eq47(ecommerceIntegrations.type, "shopify")
          )
        ).returning();
        logger54.info(`Updated Shopify integration for company ${companyId}`);
        return updatedIntegration;
      } else {
        const integrationId = uuidv421();
        const [newIntegration] = await this.db.insert(ecommerceIntegrations).values({
          id: integrationId,
          companyId,
          type: "shopify",
          name: "Shopify",
          enabled: true,
          credentials,
          settings: {},
          metadata: {},
          syncStatus: {
            lastSyncTime: null,
            status: "idle"
          },
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        logger54.info(`Created Shopify integration for company ${companyId}`);
        return newIntegration;
      }
    } catch (error) {
      logger54.error(`Failed to save Shopify credentials for company ${companyId}`, error);
      throw new Error(`Failed to save Shopify credentials: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Verify Shopify credentials
   * 
   * @param credentials Shopify credentials
   * @returns True if credentials are valid
   */
  async verifyCredentials(credentials) {
    try {
      const { shopName, accessToken } = credentials;
      const url = `https://${shopName}.myshopify.com/admin/api/${SHOPIFY_API_VERSION}/shop.json`;
      const response = await axios4.get(url, {
        headers: {
          "X-Shopify-Access-Token": accessToken,
          "Content-Type": "application/json"
        }
      });
      return response.status === 200;
    } catch (error) {
      logger54.error("Failed to verify Shopify credentials", error);
      return false;
    }
  }
  /**
   * Sync products from Shopify
   * 
   * @param companyId Company ID
   * @returns Sync status
   */
  async syncProducts(companyId) {
    try {
      const credentials = await this.getShopifyCredentials(companyId);
      if (!credentials) {
        throw new Error("Shopify credentials not found");
      }
      await this.updateSyncStatus(companyId, "in_progress");
      const { shopName, accessToken } = credentials;
      const url = `https://${shopName}.myshopify.com/admin/api/${SHOPIFY_API_VERSION}/products.json`;
      const response = await axios4.get(url, {
        headers: {
          "X-Shopify-Access-Token": accessToken,
          "Content-Type": "application/json"
        }
      });
      await this.updateSyncStatus(companyId, "completed", {
        productsCount: response.data.products.length
      });
      logger54.info(`Synced ${response.data.products.length} products from Shopify for company ${companyId}`);
      return {
        status: "success",
        productsCount: response.data.products.length
      };
    } catch (error) {
      logger54.error(`Failed to sync products for company ${companyId}`, error);
      await this.updateSyncStatus(companyId, "failed", {
        error: error instanceof Error ? error.message : String(error)
      });
      throw new Error(`Failed to sync products: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Import orders from Shopify
   * 
   * @param companyId Company ID
   * @param userId User ID performing the import
   * @returns Import status
   */
  async importOrders(companyId, userId) {
    try {
      const credentials = await this.getShopifyCredentials(companyId);
      if (!credentials) {
        throw new Error("Shopify credentials not found");
      }
      await this.updateSyncStatus(companyId, "in_progress");
      const { shopName, accessToken } = credentials;
      const url = `https://${shopName}.myshopify.com/admin/api/${SHOPIFY_API_VERSION}/orders.json`;
      const response = await axios4.get(url, {
        headers: {
          "X-Shopify-Access-Token": accessToken,
          "Content-Type": "application/json"
        },
        params: {
          status: "any",
          limit: 50
        }
      });
      const shopifyOrders = response.data.orders;
      const importedOrders = [];
      for (const shopifyOrder of shopifyOrders) {
        const orderData = this.mapShopifyOrderToErpOrder(shopifyOrder, companyId, userId);
        const newOrder = await this.ordersService.createOrder(orderData);
        importedOrders.push(newOrder);
        if (shopifyOrder.financial_status === "paid") {
          const transactionData = {
            orderId: newOrder.id,
            userId,
            companyId,
            transactionDate: new Date(shopifyOrder.processed_at),
            amount: shopifyOrder.total_price,
            currency: shopifyOrder.currency,
            status: "completed" /* COMPLETED */,
            paymentMethod: shopifyOrder.gateway,
            paymentGateway: "shopify",
            gatewayTransactionId: `shopify-${shopifyOrder.id}`,
            metadata: {
              shopifyOrderId: shopifyOrder.id,
              shopifyOrderNumber: shopifyOrder.order_number
            }
          };
          await this.transactionsService.createTransaction(transactionData);
        }
      }
      await this.updateSyncStatus(companyId, "completed", {
        ordersCount: importedOrders.length
      });
      logger54.info(`Imported ${importedOrders.length} orders from Shopify for company ${companyId}`);
      return {
        status: "success",
        ordersCount: importedOrders.length
      };
    } catch (error) {
      logger54.error(`Failed to import orders for company ${companyId}`, error);
      await this.updateSyncStatus(companyId, "failed", {
        error: error instanceof Error ? error.message : String(error)
      });
      throw new Error(`Failed to import orders: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Map a Shopify order to ERP order format
   * 
   * @param shopifyOrder Shopify order
   * @param companyId Company ID
   * @param userId User ID
   * @returns Mapped order data
   */
  mapShopifyOrderToErpOrder(shopifyOrder, companyId, userId) {
    let orderStatus;
    switch (shopifyOrder.financial_status) {
      case "paid":
        orderStatus = "completed" /* COMPLETED */;
        break;
      case "pending":
        orderStatus = "pending" /* PENDING */;
        break;
      case "refunded":
        orderStatus = "refunded" /* REFUNDED */;
        break;
      case "partially_refunded":
        orderStatus = "refunded" /* REFUNDED */;
        break;
      case "voided":
        orderStatus = "canceled" /* CANCELED */;
        break;
      default:
        orderStatus = "pending" /* PENDING */;
    }
    const shippingAddress = shopifyOrder.shipping_address ? {
      firstName: shopifyOrder.shipping_address.first_name,
      lastName: shopifyOrder.shipping_address.last_name,
      company: shopifyOrder.shipping_address.company || "",
      address1: shopifyOrder.shipping_address.address1,
      address2: shopifyOrder.shipping_address.address2 || "",
      city: shopifyOrder.shipping_address.city,
      state: shopifyOrder.shipping_address.province,
      postalCode: shopifyOrder.shipping_address.zip,
      country: shopifyOrder.shipping_address.country,
      phone: shopifyOrder.shipping_address.phone || ""
    } : {};
    const billingAddress = shopifyOrder.billing_address ? {
      firstName: shopifyOrder.billing_address.first_name,
      lastName: shopifyOrder.billing_address.last_name,
      company: shopifyOrder.billing_address.company || "",
      address1: shopifyOrder.billing_address.address1,
      address2: shopifyOrder.billing_address.address2 || "",
      city: shopifyOrder.billing_address.city,
      state: shopifyOrder.billing_address.province,
      postalCode: shopifyOrder.billing_address.zip,
      country: shopifyOrder.billing_address.country,
      phone: shopifyOrder.billing_address.phone || ""
    } : {};
    const items = shopifyOrder.line_items.map((item) => ({
      productId: String(item.product_id),
      quantity: item.quantity,
      unitPrice: item.price,
      totalPrice: String(Number(item.price) * item.quantity),
      metadata: {
        shopifyLineItemId: item.id,
        shopifyVariantId: item.variant_id,
        sku: item.sku,
        title: item.title
      }
    }));
    return {
      userId,
      companyId,
      orderNumber: `SHOPIFY-${shopifyOrder.order_number}`,
      orderDate: new Date(shopifyOrder.created_at),
      status: orderStatus,
      totalAmount: shopifyOrder.total_price,
      taxAmount: shopifyOrder.total_tax,
      discountAmount: shopifyOrder.total_discounts,
      shippingAmount: shopifyOrder.shipping_lines.reduce((sum2, line) => sum2 + Number(line.price), 0).toString(),
      currencyCode: shopifyOrder.currency,
      shippingAddress,
      billingAddress,
      paymentMethod: shopifyOrder.gateway,
      items,
      notes: shopifyOrder.note || "",
      metadata: {
        shopifyOrderId: shopifyOrder.id,
        shopifyOrderNumber: shopifyOrder.order_number,
        tags: shopifyOrder.tags,
        shopifyCustomerId: shopifyOrder.customer?.id
      }
    };
  }
  /**
   * Update integration sync status
   * 
   * @param companyId Company ID
   * @param status New status
   * @param metadata Additional metadata
   */
  async updateSyncStatus(companyId, status, metadata = {}) {
    try {
      await this.db.update(ecommerceIntegrations).set({
        syncStatus: {
          lastSyncTime: /* @__PURE__ */ new Date(),
          status,
          ...metadata
        },
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and36(
          eq47(ecommerceIntegrations.companyId, companyId),
          eq47(ecommerceIntegrations.type, "shopify")
        )
      );
    } catch (error) {
      logger54.error(`Failed to update sync status for company ${companyId}`, error);
    }
  }
  /**
   * Get integration status
   * 
   * @param companyId Company ID
   * @returns Integration status
   */
  async getIntegrationStatus(companyId) {
    try {
      const integrations2 = await this.db.select().from(ecommerceIntegrations).where(
        and36(
          eq47(ecommerceIntegrations.companyId, companyId),
          eq47(ecommerceIntegrations.type, "shopify")
        )
      );
      if (integrations2.length === 0) {
        return {
          exists: false,
          enabled: false,
          syncStatus: {
            status: "not_configured"
          }
        };
      }
      const integration = integrations2[0];
      return {
        exists: true,
        enabled: integration.enabled,
        syncStatus: integration.syncStatus,
        lastUpdated: integration.updatedAt
      };
    } catch (error) {
      logger54.error(`Failed to get integration status for company ${companyId}`, error);
      throw new Error(`Failed to get integration status: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Enable or disable Shopify integration
   * 
   * @param companyId Company ID
   * @param enabled Enable status
   * @returns Updated integration
   */
  async setIntegrationEnabled(companyId, enabled) {
    try {
      const [updatedIntegration] = await this.db.update(ecommerceIntegrations).set({
        enabled,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(
        and36(
          eq47(ecommerceIntegrations.companyId, companyId),
          eq47(ecommerceIntegrations.type, "shopify")
        )
      ).returning();
      logger54.info(`${enabled ? "Enabled" : "Disabled"} Shopify integration for company ${companyId}`);
      return updatedIntegration;
    } catch (error) {
      logger54.error(`Failed to ${enabled ? "enable" : "disable"} Shopify integration for company ${companyId}`, error);
      throw new Error(`Failed to update integration status: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/ecommerce/services/cart.service.ts
import { v4 as uuidv422 } from "uuid";
import { eq as eq48, and as and37 } from "drizzle-orm";
init_logger();
var logger55 = new Logger("CartService");
var CartService = class {
  constructor(drizzleService5) {
    this.db = drizzleService5;
    logger55.info("CartService initialized");
  }
  /**
   * Create a new cart for a user
   * 
   * @param userId User ID
   * @param companyId Company ID
   * @returns The created cart
   */
  async createCart(userId, companyId) {
    try {
      const cartId = uuidv422();
      const [newCart] = await this.db.insert(carts).values({
        userId,
        companyId,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        status: "active" /* ACTIVE */,
        subtotal: "0",
        taxAmount: "0",
        discountAmount: "0",
        total: "0",
        currencyCode: "RON",
        // Default to Romanian currency
        metadata: {}
      }).returning();
      logger55.info(`Created new cart with ID for user ${userId}`);
      return newCart;
    } catch (error) {
      logger55.error("Failed to create cart", error);
      throw new Error("Failed to create cart");
    }
  }
  /**
   * Get an active cart for a user, creating one if it doesn't exist
   * 
   * @param userId User ID
   * @param companyId Company ID
   * @returns The user's active cart
   */
  async getOrCreateCart(userId, companyId) {
    try {
      const existingCarts = await this.db.select().from(carts).where(
        and37(
          eq48(carts.userId, userId),
          eq48(carts.companyId, companyId),
          eq48(carts.status, "active" /* ACTIVE */)
        )
      );
      if (existingCarts.length > 0) {
        return existingCarts[0];
      }
      return this.createCart(userId, companyId);
    } catch (error) {
      logger55.error("Failed to get or create cart", error);
      throw new Error("Failed to get or create cart");
    }
  }
  /**
   * Add an item to a cart
   * 
   * @param cartId Cart ID
   * @param productId Product ID
   * @param quantity Quantity
   * @param unitPrice Unit price
   * @param metadata Additional metadata
   * @returns The updated cart
   */
  async addItem(cartId, productId, quantity, unitPrice, metadata = {}) {
    try {
      const existingItems = await this.db.select().from(cartItems).where(
        and37(
          eq48(cartItems.cartId, cartId),
          eq48(cartItems.productId, productId)
        )
      );
      if (existingItems.length > 0) {
        const existingItem = existingItems[0];
        const newQuantity = existingItem.quantity + quantity;
        await this.db.update(cartItems).set({
          quantity: newQuantity,
          totalPrice: String(newQuantity * Number(existingItem.unitPrice)),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq48(cartItems.id, existingItem.id));
      } else {
        await this.db.insert(cartItems).values({
          cartId,
          productId,
          quantity,
          unitPrice: String(unitPrice),
          totalPrice: String(quantity * unitPrice),
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          metadata
        });
      }
      await this.updateCartTotals(cartId);
      return this.getCartWithItems(cartId);
    } catch (error) {
      logger55.error(`Failed to add item to cart ${cartId}`, error);
      throw new Error("Failed to add item to cart");
    }
  }
  /**
   * Update the quantity of an item in the cart
   * 
   * @param cartItemId Cart item ID
   * @param quantity New quantity
   * @returns The updated cart
   */
  async updateItemQuantity(cartItemId, quantity) {
    try {
      const items = await this.db.select().from(cartItems).where(eq48(cartItems.id, cartItemId));
      if (items.length === 0) {
        throw new Error("Cart item not found");
      }
      const item = items[0];
      if (quantity <= 0) {
        await this.db.delete(cartItems).where(eq48(cartItems.id, cartItemId));
      } else {
        await this.db.update(cartItems).set({
          quantity,
          totalPrice: String(quantity * Number(item.unitPrice)),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq48(cartItems.id, cartItemId));
      }
      await this.updateCartTotals(item.cartId);
      return this.getCartWithItems(item.cartId);
    } catch (error) {
      logger55.error(`Failed to update cart item ${cartItemId}`, error);
      throw new Error("Failed to update cart item");
    }
  }
  /**
   * Remove an item from the cart
   * 
   * @param cartItemId Cart item ID
   * @returns The updated cart
   */
  async removeItem(cartItemId) {
    try {
      const items = await this.db.select().from(cartItems).where(eq48(cartItems.id, cartItemId));
      if (items.length === 0) {
        throw new Error("Cart item not found");
      }
      const item = items[0];
      await this.db.delete(cartItems).where(eq48(cartItems.id, cartItemId));
      await this.updateCartTotals(item.cartId);
      return this.getCartWithItems(item.cartId);
    } catch (error) {
      logger55.error(`Failed to remove cart item ${cartItemId}`, error);
      throw new Error("Failed to remove cart item");
    }
  }
  /**
   * Clear all items from a cart
   * 
   * @param cartId Cart ID
   * @returns The updated cart
   */
  async clearCart(cartId) {
    try {
      await this.db.delete(cartItems).where(eq48(cartItems.cartId, cartId));
      await this.updateCartTotals(cartId);
      const [cart] = await this.db.select().from(carts).where(eq48(carts.id, cartId));
      return cart;
    } catch (error) {
      logger55.error(`Failed to clear cart ${cartId}`, error);
      throw new Error("Failed to clear cart");
    }
  }
  /**
   * Get a cart with all its items
   * 
   * @param cartId Cart ID
   * @returns The cart with items
   */
  async getCartWithItems(cartId) {
    try {
      const [cart] = await this.db.select().from(carts).where(eq48(carts.id, cartId));
      if (!cart) {
        throw new Error("Cart not found");
      }
      const items = await this.db.select().from(cartItems).where(eq48(cartItems.cartId, cartId));
      return {
        ...cart,
        items
      };
    } catch (error) {
      logger55.error(`Failed to get cart ${cartId} with items`, error);
      throw new Error("Failed to get cart with items");
    }
  }
  /**
   * Update the calculated totals for a cart
   * 
   * @param cartId Cart ID
   */
  async updateCartTotals(cartId) {
    try {
      const items = await this.db.select().from(cartItems).where(eq48(cartItems.cartId, cartId));
      const subtotal = items.reduce((sum2, item) => sum2 + Number(item.totalPrice), 0);
      const taxAmount = 0;
      const discountAmount = 0;
      const total = subtotal + taxAmount - discountAmount;
      await this.db.update(carts).set({
        subtotal: String(subtotal),
        taxAmount: String(taxAmount),
        discountAmount: String(discountAmount),
        total: String(total),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq48(carts.id, cartId));
    } catch (error) {
      logger55.error(`Failed to update cart totals for ${cartId}`, error);
      throw new Error("Failed to update cart totals");
    }
  }
  /**
   * Apply a discount to a cart
   * 
   * @param cartId Cart ID
   * @param discountAmount Discount amount
   * @param discountCode Discount code
   * @returns The updated cart
   */
  async applyDiscount(cartId, discountAmount, discountCode) {
    try {
      await this.db.update(carts).set({
        discountAmount: String(discountAmount),
        appliedDiscountCode: discountCode,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq48(carts.id, cartId));
      const [cart] = await this.db.select().from(carts).where(eq48(carts.id, cartId));
      const total = Number(cart.subtotal) + Number(cart.taxAmount) - Number(cart.discountAmount);
      await this.db.update(carts).set({
        total: String(total),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq48(carts.id, cartId));
      return this.getCartWithItems(cartId);
    } catch (error) {
      logger55.error(`Failed to apply discount to cart ${cartId}`, error);
      throw new Error("Failed to apply discount");
    }
  }
  /**
   * Set the cart status
   * 
   * @param cartId Cart ID
   * @param status New status
   * @returns The updated cart
   */
  async setCartStatus(cartId, status) {
    try {
      await this.db.update(carts).set({
        status,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq48(carts.id, cartId));
      const [cart] = await this.db.select().from(carts).where(eq48(carts.id, cartId));
      return cart;
    } catch (error) {
      logger55.error(`Failed to update cart ${cartId} status to ${status}`, error);
      throw new Error("Failed to update cart status");
    }
  }
};

// server/modules/ecommerce/services/checkout.service.ts
init_logger();
import { v4 as uuidv424 } from "uuid";

// server/modules/ecommerce/services/payment.service.ts
init_logger();
import { sql as sql39 } from "drizzle-orm";
import { v4 as uuidv423 } from "uuid";
import Stripe from "stripe";

// server/modules/ecommerce/utils/payment-methods.util.ts
function mapPaymentMethodToGateway(paymentMethod) {
  switch (paymentMethod) {
    case "credit_card":
    case "debit_card":
    case "stripe":
      return "stripe";
    case "paypal":
      return "paypal";
    case "bank_transfer":
    case "cash_on_delivery":
    case "other":
      return "manual";
    default:
      return "manual";
  }
}

// server/modules/ecommerce/services/payment.service.ts
var logger56 = new Logger("PaymentService");
var PaymentService = class {
  /**
   * Create a new PaymentService instance
   * 
   * @param db Database connection
   * @param integrationService Integration service for retrieving payment gateway credentials
   */
  constructor(db4, integrationService) {
    this.db = db4;
    this.integrationService = integrationService;
    this.stripeClient = null;
    logger56.info("PaymentService initialized");
  }
  /**
   * Get integration client configuration
   * 
   * @param provider Integration provider name
   * @param companyId Company ID
   * @returns Client configuration or null if not found
   */
  async getIntegrationConfig(provider, companyId) {
    try {
      if (typeof this.integrationService.getIntegrationCredentials === "function") {
        return await this.integrationService.getIntegrationCredentials(provider, companyId, "system");
      }
      if (typeof this.integrationService.getClientConfig === "function") {
        return await this.integrationService.getClientConfig(provider, companyId);
      }
      if (this.integrationService.db) {
        const integrations2 = this.integrationService.db.query.integrations;
        if (integrations2) {
          const result = await this.db.select().from(integrations2).where(sql39`${integrations2.provider} = ${provider} AND ${integrations2.companyId} = ${companyId} AND ${integrations2.status} = 'active'`).limit(1);
          if (result && result.length > 0) {
            return result[0].config;
          }
        }
      }
      return null;
    } catch (error) {
      logger56.warn(`Error getting integration config for ${provider}: ${error}`);
      return null;
    }
  }
  /**
   * Initialize payment gateway clients
   * 
   * @param companyId Company ID
   */
  async initializeClients(companyId) {
    try {
      if (!this.stripeClient) {
        const stripeConfig = await this.getIntegrationConfig("stripe", companyId);
        if (stripeConfig && stripeConfig.secretKey) {
          this.stripeClient = new Stripe(stripeConfig.secretKey, {
            apiVersion: "2023-10-16"
          });
          logger56.info(`Stripe client initialized for company ${companyId}`);
        } else {
          logger56.warn(`No Stripe configuration found for company ${companyId}`);
        }
      }
    } catch (error) {
      logger56.error(`Error initializing payment gateway clients for company ${companyId}`, error);
    }
    if (!this.stripeClient && process.env.STRIPE_SECRET_KEY) {
      this.stripeClient = new Stripe(process.env.STRIPE_SECRET_KEY, {
        apiVersion: "2023-10-16"
      });
      logger56.info("Stripe client initialized using environment variables");
    }
  }
  /**
   * Process a payment using the appropriate payment gateway
   * 
   * @param companyId Company ID
   * @param userId User ID
   * @param paymentMethod Payment method
   * @param amount Amount in cents/smallest currency unit
   * @param currency Currency code (e.g., 'usd')
   * @param options Payment options
   * @returns Payment result
   */
  async processPayment(companyId, userId, paymentMethod, amount, currency, options = {}) {
    try {
      await this.initializeClients(companyId);
      const gateway = mapPaymentMethodToGateway(paymentMethod);
      logger56.info(`Processing payment for company ${companyId} using ${gateway} gateway (payment method: ${paymentMethod})`);
      switch (gateway) {
        case "stripe":
          return await this.processStripePayment(companyId, userId, amount, currency, paymentMethod, options);
        case "paypal":
          throw new Error("PayPal payment processing not implemented yet");
        case "manual":
          return this.processManualPayment(companyId, userId, amount, currency, paymentMethod, options);
        default:
          throw new Error(`Unsupported payment gateway: ${gateway}`);
      }
    } catch (error) {
      logger56.error(`Error processing payment for company ${companyId}`, error);
      return {
        status: "failed" /* FAILED */,
        data: null,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Process a payment using Stripe
   * 
   * @param companyId Company ID
   * @param userId User ID
   * @param amount Amount in cents/smallest currency unit
   * @param currency Currency code (e.g., 'usd')
   * @param paymentMethod Payment method
   * @param options Payment options
   * @returns Payment result
   */
  async processStripePayment(companyId, userId, amount, currency, paymentMethod, options) {
    try {
      if (!this.stripeClient) {
        throw new Error("Stripe client is not initialized. Please check your Stripe configuration.");
      }
      const paymentIntent = await this.stripeClient.paymentIntents.create({
        amount,
        currency,
        payment_method_types: ["card"],
        capture_method: options.capture === false ? "manual" : "automatic",
        description: options.description,
        receipt_email: options.receiptEmail,
        statement_descriptor: options.statementDescriptor?.substring(0, 22),
        // Stripe limits to 22 chars
        metadata: {
          ...options.metadata,
          companyId,
          userId
        }
      }, {
        idempotencyKey: options.idempotencyKey || uuidv423()
      });
      logger56.info(`Stripe payment intent created: ${paymentIntent.id}`);
      let status;
      switch (paymentIntent.status) {
        case "requires_payment_method":
        case "requires_confirmation":
        case "requires_action":
        case "processing":
          status = "pending" /* PENDING */;
          break;
        case "requires_capture":
          status = "success" /* SUCCESS */;
          break;
        case "canceled":
          status = "canceled" /* CANCELED */;
          break;
        case "succeeded":
          status = "success" /* SUCCESS */;
          break;
        default:
          status = "pending" /* PENDING */;
      }
      const paymentData = {
        id: paymentIntent.id,
        clientSecret: paymentIntent.client_secret || void 0,
        amount: paymentIntent.amount,
        currency: paymentIntent.currency,
        status: paymentIntent.status,
        paymentMethod: paymentIntent.payment_method?.toString() || void 0,
        customerId: paymentIntent.customer?.toString() || void 0,
        receiptUrl: paymentIntent.charges?.data?.[0]?.receipt_url || void 0,
        createdAt: paymentIntent.created,
        metadata: paymentIntent.metadata
      };
      return {
        status,
        data: paymentData
      };
    } catch (error) {
      logger56.error(`Stripe payment processing error for company ${companyId}`, error);
      let errorMessage = "Payment processing failed";
      if (error instanceof Stripe.errors.StripeError) {
        switch (error.type) {
          case "StripeCardError":
            errorMessage = `Card error: ${error.message}`;
            break;
          case "StripeRateLimitError":
            errorMessage = "Rate limit exceeded. Please try again later.";
            break;
          case "StripeInvalidRequestError":
            errorMessage = `Invalid request: ${error.message}`;
            break;
          case "StripeAPIError":
            errorMessage = "Payment system temporarily unavailable. Please try again later.";
            break;
          case "StripeAuthenticationError":
            errorMessage = "Authentication with payment provider failed. Please contact support.";
            break;
          default:
            errorMessage = error.message;
        }
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      return {
        status: "failed" /* FAILED */,
        data: null,
        error: errorMessage
      };
    }
  }
  /**
   * Process a refund through the appropriate payment gateway
   * 
   * @param companyId Company ID
   * @param userId User ID
   * @param paymentIntentId Payment intent ID to refund
   * @param amount Amount to refund (null for full refund)
   * @param reason Reason for the refund
   * @param metadata Additional metadata
   * @returns Refund result
   */
  async processRefund(companyId, userId, paymentIntentId, amount, reason, metadata) {
    try {
      await this.initializeClients(companyId);
      if (!this.stripeClient) {
        throw new Error("Stripe client is not initialized. Please check your Stripe configuration.");
      }
      const refund = await this.stripeClient.refunds.create({
        payment_intent: paymentIntentId,
        amount,
        reason,
        metadata: {
          ...metadata,
          companyId,
          userId,
          refundedBy: userId
        }
      }, {
        idempotencyKey: uuidv423()
      });
      logger56.info(`Refund processed for payment intent ${paymentIntentId}: ${refund.id}`);
      const refundData = {
        id: refund.id,
        amount: refund.amount,
        currency: refund.currency,
        status: refund.status || "unknown",
        paymentIntentId,
        reason: refund.reason || reason,
        createdAt: refund.created,
        metadata: refund.metadata
      };
      return {
        success: true,
        data: refundData
      };
    } catch (error) {
      logger56.error(`Error processing refund for payment intent ${paymentIntentId}`, error);
      let errorMessage = "Refund processing failed";
      if (error instanceof Stripe.errors.StripeError) {
        errorMessage = error.message;
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      return {
        success: false,
        data: null,
        error: errorMessage
      };
    }
  }
  /**
   * Process a manual payment (e.g., bank transfer, cash)
   * 
   * @param companyId Company ID
   * @param userId User ID
   * @param amount Amount in cents/smallest currency unit
   * @param currency Currency code (e.g., 'usd')
   * @param paymentMethod Payment method
   * @param options Payment options
   * @returns Payment result
   */
  processManualPayment(companyId, userId, amount, currency, paymentMethod, options) {
    logger56.info(`Processing manual payment for company ${companyId} (payment method: ${paymentMethod})`);
    const paymentId = uuidv423();
    const paymentData = {
      id: paymentId,
      amount,
      currency,
      status: "pending",
      // Manual payments are initially pending
      createdAt: Math.floor(Date.now() / 1e3),
      metadata: {
        ...options.metadata,
        companyId,
        userId,
        paymentMethod,
        manual: true
      }
    };
    return {
      status: "pending" /* PENDING */,
      data: paymentData
    };
  }
  /**
   * Check if a specific payment gateway is available
   * 
   * @param companyId Company ID
   * @param gateway Payment gateway to check
   * @returns Boolean indicating if the gateway is available
   */
  async isGatewayAvailable(companyId, gateway) {
    try {
      if (gateway === "manual") {
        return true;
      }
      await this.initializeClients(companyId);
      switch (gateway) {
        case "stripe":
          return this.stripeClient !== null;
        case "paypal":
          return false;
        // PayPal not implemented yet
        default:
          return false;
      }
    } catch (error) {
      logger56.error(`Error checking gateway availability for ${gateway}`, error);
      return false;
    }
  }
  /**
   * Get the Stripe client
   * 
   * @returns Stripe client or null if not initialized
   */
  getStripeClient() {
    return this.stripeClient;
  }
  /**
   * Manually set the Stripe client (useful for testing)
   * 
   * @param config Stripe configuration
   */
  setStripeClient(config3) {
    this.stripeClient = new Stripe(config3.secretKey, {
      apiVersion: config3.apiVersion
    });
  }
  /**
   * Manually reset all clients (useful for testing)
   */
  resetClients(config3) {
    if (config3) {
      this.setStripeClient(config3);
    } else {
      this.stripeClient = null;
    }
  }
};

// server/modules/ecommerce/services/checkout.service.ts
var logger57 = new Logger("CheckoutService");
var CheckoutService = class {
  constructor(drizzleService5, ordersService, transactionsService, cartService, paymentService) {
    this.db = drizzleService5;
    this.ordersService = ordersService;
    this.transactionsService = transactionsService;
    this.cartService = cartService;
    this.paymentService = paymentService;
    logger57.info("CheckoutService initialized");
  }
  /**
   * Process a checkout from a cart
   * 
   * @param cartId Cart ID
   * @param userId User ID
   * @param companyId Company ID
   * @param paymentMethod Payment method
   * @param shippingAddress Shipping address
   * @param billingAddress Billing address
   * @param additionalDetails Additional checkout details
   * @returns The created order and transaction
   */
  async processCheckout(cartId, userId, companyId, paymentMethod, shippingAddress, billingAddress, additionalDetails = {}) {
    try {
      const cart = await this.cartService.getCartWithItems(cartId);
      if (!cart) {
        throw new Error("Cart not found");
      }
      if (cart.items.length === 0) {
        throw new Error("Cart is empty");
      }
      const orderData = {
        userId,
        companyId,
        orderNumber: this.generateOrderNumber(),
        orderDate: /* @__PURE__ */ new Date(),
        status: "pending" /* PENDING */,
        totalAmount: cart.total,
        taxAmount: cart.taxAmount,
        discountAmount: cart.discountAmount,
        shippingAmount: "0",
        // Would be calculated based on shipping options
        currencyCode: cart.currencyCode,
        shippingAddress,
        billingAddress,
        paymentMethod,
        items: cart.items.map((item) => ({
          productId: item.productId,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          totalPrice: item.totalPrice,
          metadata: item.metadata
        })),
        notes: additionalDetails.notes || "",
        metadata: {
          ...additionalDetails,
          cartId
        }
      };
      const order = await this.ordersService.createOrder(orderData);
      const transactionData = {
        orderId: order.id,
        userId,
        companyId,
        transactionType: "payment" /* PAYMENT */,
        transactionDate: /* @__PURE__ */ new Date(),
        amount: cart.total,
        currency: cart.currencyCode,
        status: "pending" /* PENDING */,
        paymentMethod,
        paymentGateway: this.getPaymentGatewayForMethod(paymentMethod),
        gatewayTransactionId: uuidv424(),
        // Would be provided by the payment gateway
        metadata: {
          ...additionalDetails,
          cartId,
          orderNumber: order.orderNumber
        }
      };
      const transaction = await this.transactionsService.createTransaction(transactionData);
      await this.cartService.setCartStatus(cartId, "completed" /* COMPLETED */);
      const processedTransaction = await this.authorizePayment(transaction.id);
      let updatedOrder = order;
      if (processedTransaction.status === "completed" /* COMPLETED */) {
        updatedOrder = await this.ordersService.updateOrderStatus(order.id, "completed" /* COMPLETED */, companyId);
      } else if (processedTransaction.status === "failed" /* FAILED */) {
        updatedOrder = await this.ordersService.updateOrderStatus(order.id, "failed" /* FAILED */, companyId);
      }
      return {
        order: updatedOrder,
        transaction: processedTransaction
      };
    } catch (error) {
      logger57.error("Failed to process checkout", error);
      throw new Error(`Failed to process checkout: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Process a direct checkout (without a cart)
   * 
   * @param userId User ID
   * @param companyId Company ID
   * @param items Order items
   * @param paymentMethod Payment method
   * @param shippingAddress Shipping address
   * @param billingAddress Billing address
   * @param additionalDetails Additional checkout details
   * @returns The created order and transaction
   */
  async processDirectCheckout(userId, companyId, items, paymentMethod, shippingAddress, billingAddress, additionalDetails = {}) {
    try {
      const itemsWithTotals = items.map((item) => ({
        ...item,
        totalPrice: String(item.quantity * item.unitPrice),
        unitPrice: String(item.unitPrice),
        metadata: item.metadata || {}
      }));
      const subtotal = itemsWithTotals.reduce((sum2, item) => sum2 + Number(item.totalPrice), 0);
      const taxAmount = 0;
      const discountAmount = 0;
      const total = subtotal + taxAmount - discountAmount;
      const orderData = {
        userId,
        companyId,
        orderNumber: this.generateOrderNumber(),
        orderDate: /* @__PURE__ */ new Date(),
        status: "pending" /* PENDING */,
        totalAmount: String(total),
        taxAmount: String(taxAmount),
        discountAmount: String(discountAmount),
        shippingAmount: "0",
        currencyCode: "RON",
        // Default to Romanian currency
        shippingAddress,
        billingAddress,
        paymentMethod,
        items: itemsWithTotals,
        notes: additionalDetails.notes || "",
        metadata: additionalDetails
      };
      const order = await this.ordersService.createOrder(orderData);
      const transactionData = {
        orderId: order.id,
        userId,
        companyId,
        transactionType: "payment" /* PAYMENT */,
        transactionDate: /* @__PURE__ */ new Date(),
        amount: String(total),
        currency: "RON",
        status: "pending" /* PENDING */,
        paymentMethod,
        paymentGateway: this.getPaymentGatewayForMethod(paymentMethod),
        gatewayTransactionId: uuidv424(),
        // Would be provided by the payment gateway
        metadata: {
          ...additionalDetails,
          orderNumber: order.orderNumber
        }
      };
      const transaction = await this.transactionsService.createTransaction(transactionData);
      const processedTransaction = await this.authorizePayment(transaction.id);
      let updatedOrder = order;
      if (processedTransaction.status === "completed" /* COMPLETED */) {
        updatedOrder = await this.ordersService.updateOrderStatus(order.id, "completed" /* COMPLETED */, companyId);
      } else if (processedTransaction.status === "failed" /* FAILED */) {
        updatedOrder = await this.ordersService.updateOrderStatus(order.id, "failed" /* FAILED */, companyId);
      }
      return {
        order: updatedOrder,
        transaction: processedTransaction
      };
    } catch (error) {
      logger57.error("Failed to process direct checkout", error);
      throw new Error(`Failed to process direct checkout: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Authorize a payment with the payment gateway
   * 
   * @param transactionId Transaction ID
   * @returns The processed transaction
   */
  async authorizePayment(transactionId) {
    try {
      logger57.info(`Authorizing payment for transaction ${transactionId}`);
      const transaction = await this.transactionsService.getTransactionById(transactionId, "all");
      if (!transaction) {
        throw new Error("Transaction not found");
      }
      const order = await this.ordersService.getOrderById(transaction.orderId);
      if (!order) {
        throw new Error(`Order not found with ID: ${transaction.orderId}`);
      }
      const paymentRequest = {
        orderId: transaction.orderId,
        amount: transaction.amount,
        currency: transaction.currency || "RON",
        paymentMethod: transaction.paymentMethod || "credit_card",
        customerId: order.customerId || void 0,
        description: `Payment for order ${order.orderNumber || transaction.orderId}`,
        metadata: {
          transactionId: transaction.id,
          orderNumber: order.orderNumber,
          ...transaction.metadata
        },
        userId: transaction.createdBy || "0",
        companyId: transaction.companyId
      };
      const paymentResponse = await this.paymentService.processPayment(paymentRequest);
      const mappedStatus = this.mapPaymentServiceStatus(paymentResponse.status);
      const paymentIntentId = paymentResponse.data?.id || "";
      const clientSecret = paymentResponse.data?.client_secret || "";
      const receiptUrl = paymentResponse.data?.receipt_url || "";
      const updatedTransaction = await this.transactionsService.updateTransactionStatus(
        transactionId,
        mappedStatus,
        transaction.amount,
        {
          authorizationCode: this.generateAuthorizationCode(),
          gatewayTransactionId: paymentIntentId,
          clientSecret,
          processingDetails: {
            processingDate: /* @__PURE__ */ new Date(),
            processorResponseCode: mappedStatus === "completed" /* COMPLETED */ ? "00" : "05",
            processorResponseMessage: paymentResponse.error || "Payment processed",
            paymentIntentId,
            receiptUrl
          }
        }
      );
      logger57.info(`Payment processed for transaction ${transactionId}`, {
        status: mappedStatus,
        paymentIntentId
      });
      return updatedTransaction;
    } catch (error) {
      logger57.error(`Error authorizing payment for transaction ${transactionId}`, error);
      const updatedTransaction = await this.transactionsService.updateTransactionStatus(
        transactionId,
        "failed" /* FAILED */,
        "0",
        {
          error: error instanceof Error ? error.message : String(error),
          processingDetails: {
            processingDate: /* @__PURE__ */ new Date(),
            processorResponseCode: "05",
            processorResponseMessage: "Payment processing error"
          }
        }
      );
      return updatedTransaction;
    }
  }
  /**
   * Map PaymentService status to schema PaymentStatus
   * 
   * @param resultStatus Status from PaymentService
   * @returns Schema-compatible PaymentStatus
   */
  mapPaymentServiceStatus(resultStatus) {
    const statusMap = {
      ["success" /* SUCCESS */]: "completed" /* COMPLETED */,
      ["pending" /* PENDING */]: "pending" /* PENDING */,
      ["failed" /* FAILED */]: "failed" /* FAILED */,
      ["canceled" /* CANCELED */]: "failed" /* FAILED */,
      ["requires_action" /* REQUIRES_ACTION */]: "pending" /* PENDING */
    };
    return statusMap[resultStatus] || "pending" /* PENDING */;
  }
  // Legacy payment processing methods have been replaced by the new PaymentService
  /**
   * Generate a unique order number
   * 
   * @returns Order number
   */
  generateOrderNumber() {
    const timestamp24 = (/* @__PURE__ */ new Date()).getTime().toString().slice(-8);
    const random = Math.floor(Math.random() * 1e4).toString().padStart(4, "0");
    return `ORD-${timestamp24}-${random}`;
  }
  /**
   * Generate an authorization code
   * 
   * @returns Authorization code
   */
  generateAuthorizationCode() {
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    let result = "";
    for (let i = 0; i < 6; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
  }
  /**
   * Determine payment gateway based on payment method
   * 
   * @param paymentMethod Payment method
   * @returns Payment gateway name
   */
  getPaymentGatewayForMethod(paymentMethod) {
    return mapPaymentMethodToGateway(paymentMethod);
  }
};

// server/modules/ecommerce/services/pos-integration.service.ts
init_logger();
var logger58 = new Logger("POSIntegrationService");
var POSIntegrationService = class {
  constructor(db4, ordersService, transactionsService) {
    this.db = db4;
    this.ordersService = ordersService;
    this.transactionsService = transactionsService;
    logger58.info("POSIntegrationService initialized");
  }
  /**
   * Import orders from a POS system
   * 
   * @param posSystem POS system identifier
   * @param orders Orders to import
   * @param companyId Company ID
   * @param userId User ID initiating the import
   * @returns The imported orders
   */
  async importOrders(posSystem, orders2, companyId, userId) {
    try {
      logger58.info(`Importing ${orders2.length} orders from ${posSystem}`);
      const importedOrders = [];
      for (const posOrder of orders2) {
        const existingOrder = await this.findExistingPosOrder(posSystem, posOrder.posOrderId, companyId);
        if (existingOrder) {
          logger58.info(`Order ${posOrder.posOrderId} from ${posSystem} already exists, skipping`);
          importedOrders.push(existingOrder);
          continue;
        }
        const orderData = {
          userId,
          companyId,
          orderNumber: this.generateOrderNumber(),
          orderDate: posOrder.posOrderDate,
          status: "completed" /* COMPLETED */,
          // POS orders are typically already completed
          totalAmount: String(posOrder.totalAmount),
          taxAmount: String(posOrder.taxAmount),
          discountAmount: String(posOrder.discountAmount),
          shippingAmount: "0",
          // POS typically doesn't have shipping
          currencyCode: posOrder.currency,
          shippingAddress: {},
          // POS typically doesn't have shipping
          billingAddress: {},
          // Could be populated if available
          paymentMethod: posOrder.paymentMethod,
          items: posOrder.items.map((item) => ({
            productId: item.productId,
            quantity: item.quantity,
            unitPrice: String(item.unitPrice),
            totalPrice: String(item.quantity * item.unitPrice),
            metadata: {}
          })),
          notes: `Imported from ${posSystem}`,
          metadata: {
            posSystem,
            posOrderId: posOrder.posOrderId,
            customerId: posOrder.customerId || null,
            importDate: /* @__PURE__ */ new Date()
          }
        };
        const order = await this.ordersService.createOrder(orderData);
        const transactionData = {
          orderId: order.id,
          userId,
          companyId,
          transactionDate: posOrder.posOrderDate,
          amount: String(posOrder.totalAmount),
          currency: posOrder.currency,
          status: "completed" /* COMPLETED */,
          // POS transactions are typically already completed
          paymentMethod: posOrder.paymentMethod,
          paymentGateway: "pos",
          gatewayTransactionId: `${posSystem}-${posOrder.posOrderId}`,
          metadata: {
            posSystem,
            posOrderId: posOrder.posOrderId,
            importDate: /* @__PURE__ */ new Date()
          }
        };
        await this.transactionsService.createTransaction(transactionData);
        importedOrders.push(order);
        logger58.info(`Imported order ${posOrder.posOrderId} from ${posSystem}`);
      }
      return importedOrders;
    } catch (error) {
      logger58.error(`Failed to import orders from ${posSystem}`, error);
      throw new Error(`Failed to import orders from ${posSystem}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Export products to a POS system
   * 
   * @param posSystem POS system identifier
   * @param productIds Product IDs to export
   * @param companyId Company ID
   * @param userId User ID initiating the export
   * @returns Result of the export operation
   */
  async exportProducts(posSystem, productIds, companyId, userId) {
    try {
      logger58.info(`Exporting ${productIds.length} products to ${posSystem}`);
      return {
        success: true,
        posSystem,
        exportedCount: productIds.length,
        timestamp: /* @__PURE__ */ new Date(),
        message: `${productIds.length} products exported to ${posSystem} successfully`
      };
    } catch (error) {
      logger58.error(`Failed to export products to ${posSystem}`, error);
      throw new Error(`Failed to export products to ${posSystem}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Synchronize inventory levels with a POS system
   * 
   * @param posSystem POS system identifier
   * @param inventoryUpdates Inventory updates to sync
   * @param companyId Company ID
   * @param userId User ID initiating the sync
   * @returns Result of the sync operation
   */
  async syncInventory(posSystem, inventoryUpdates, companyId, userId) {
    try {
      logger58.info(`Syncing inventory for ${inventoryUpdates.length} products with ${posSystem}`);
      return {
        success: true,
        posSystem,
        syncedCount: inventoryUpdates.length,
        timestamp: /* @__PURE__ */ new Date(),
        message: `Inventory synced with ${posSystem} successfully`
      };
    } catch (error) {
      logger58.error(`Failed to sync inventory with ${posSystem}`, error);
      throw new Error(`Failed to sync inventory with ${posSystem}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Connect to a POS system
   * 
   * @param posSystem POS system identifier
   * @param connectionDetails Connection details
   * @param companyId Company ID
   * @param userId User ID initiating the connection
   * @returns Result of the connection operation
   */
  async connectPosSystem(posSystem, connectionDetails, companyId, userId) {
    try {
      logger58.info(`Connecting to POS system ${posSystem}`);
      return {
        success: true,
        posSystem,
        connectionStatus: "connected",
        timestamp: /* @__PURE__ */ new Date(),
        message: `Connected to ${posSystem} successfully`
      };
    } catch (error) {
      logger58.error(`Failed to connect to POS system ${posSystem}`, error);
      throw new Error(`Failed to connect to POS system ${posSystem}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Check the connection status to a POS system
   * 
   * @param posSystem POS system identifier
   * @param companyId Company ID
   * @returns Connection status
   */
  async checkPosConnection(posSystem, companyId) {
    try {
      logger58.info(`Checking connection to POS system ${posSystem}`);
      return {
        posSystem,
        connectionStatus: "connected",
        timestamp: /* @__PURE__ */ new Date(),
        message: `Connection to ${posSystem} is active`
      };
    } catch (error) {
      logger58.error(`Failed to check connection to POS system ${posSystem}`, error);
      return {
        posSystem,
        connectionStatus: "error",
        timestamp: /* @__PURE__ */ new Date(),
        message: `Failed to check connection to ${posSystem}: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
  /**
   * Find an existing order imported from a POS system
   * 
   * @param posSystem POS system identifier
   * @param posOrderId POS order ID
   * @param companyId Company ID
   * @returns The existing order, if found
   */
  async findExistingPosOrder(posSystem, posOrderId, companyId) {
    return null;
  }
  /**
   * Generate a unique order number
   * 
   * @returns Order number
   */
  generateOrderNumber() {
    const timestamp24 = (/* @__PURE__ */ new Date()).getTime().toString().slice(-8);
    const random = Math.floor(Math.random() * 1e4).toString().padStart(4, "0");
    return `POS-${timestamp24}-${random}`;
  }
};

// server/modules/ecommerce/controllers/ecommerce.controller.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
import { Router as Router18 } from "express";
import { v4 as uuidv425 } from "uuid";
var logger59 = new Logger("ECommerceController");
var ECommerceController = class {
  constructor(paymentService) {
    this.router = Router18();
    if (paymentService) {
      this.paymentService = paymentService;
    } else {
      logger59.warn("PaymentService not provided to ECommerceController, some features may be unavailable");
      this.paymentService = null;
    }
    this.setupRoutes();
    logger59.info("ECommerceController initialized");
  }
  /**
   * Get the router
   * 
   * @returns Express router
   */
  getRouter() {
    return this.router;
  }
  /**
   * Setup routes
   */
  setupRoutes() {
    this.router.post(
      "/order-placeholder",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["ecommerce_admin", "ecommerce_manager", "ecommerce_user"]),
      AuthGuard.companyGuard("companyId"),
      this.orderPlaceholder.bind(this)
    );
    this.router.post(
      "/payment",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["ecommerce_admin", "ecommerce_manager", "sales_team"]),
      AuthGuard.companyGuard("companyId"),
      this.processPayment.bind(this)
    );
  }
  /**
   * Order creation placeholder
   * 
   * @param req Request
   * @param res Response
   */
  async orderPlaceholder(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { id, companyId } = req.user;
      if (!companyId || !id) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      const orderData = req.body;
      res.status(200).json({
        success: true,
        message: "E-commerce order creation placeholder",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        user: {
          id,
          companyId
        },
        data: orderData
      });
    } catch (error) {
      logger59.error("Error in order placeholder endpoint", error);
      res.status(500).json({
        success: false,
        message: `Error processing request: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Process a payment directly through the payment service
   * 
   * This endpoint provides direct access to process payments via Stripe integration
   * 
   * @param req Request
   * @param res Response
   */
  async processPayment(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      if (!this.paymentService) {
        return res.status(503).json({
          success: false,
          message: "Payment service is not available. Please try again later or contact support."
        });
      }
      const { id: userId, companyId } = req.user;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      const {
        amount,
        currency = "usd",
        paymentMethod = "credit_card",
        paymentMethodId,
        customerId,
        description = "Direct payment",
        capture = true,
        receiptEmail,
        metadata = {}
      } = req.body;
      if (!amount) {
        return res.status(400).json({
          success: false,
          message: "Amount is required"
        });
      }
      const requestId = req.body.requestId || uuidv425();
      const amountInSmallestUnit = Math.round(parseFloat(amount) * 100);
      const paymentResult = await this.paymentService.processPayment(
        companyId,
        userId,
        paymentMethod,
        amountInSmallestUnit,
        currency,
        {
          idempotencyKey: requestId,
          description,
          capture,
          receiptEmail,
          metadata: {
            ...metadata,
            directPayment: true,
            requestId,
            paymentMethodId
          }
        }
      );
      const isSuccess = paymentResult.status === "success" /* SUCCESS */;
      res.status(isSuccess ? 200 : 402).json({
        success: isSuccess,
        status: paymentResult.status,
        data: paymentResult.data,
        message: paymentResult.error || "Payment processed successfully",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      logger59.error("Error processing payment", error);
      res.status(500).json({
        success: false,
        message: `Error processing payment: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
};
var ecommerce_controller_default = new ECommerceController().getRouter();

// server/modules/ecommerce/controllers/orders.controller.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router19 } from "express";
init_logger();
var logger60 = new Logger("OrdersController");
var OrdersController = class {
  constructor(ordersService) {
    this.router = Router19();
    this.ordersService = ordersService;
    this.setupRoutes();
    logger60.info("OrdersController initialized");
  }
  /**
   * Get the router
   * 
   * @returns Express router
   */
  getRouter() {
    return this.router;
  }
  /**
   * Setup routes
   */
  setupRoutes() {
    this.router.get("/", AuthGuard.protect("required" /* REQUIRED */), this.getOrders.bind(this));
    this.router.get("/:orderId", AuthGuard.protect("required" /* REQUIRED */), this.getOrderById.bind(this));
    this.router.post("/", AuthGuard.protect("required" /* REQUIRED */), this.createOrder.bind(this));
    this.router.put("/:orderId", AuthGuard.protect("required" /* REQUIRED */), this.updateOrder.bind(this));
    this.router.patch("/:orderId/status", AuthGuard.protect("required" /* REQUIRED */), this.updateOrderStatus.bind(this));
    this.router.get("/stats/count-by-status", AuthGuard.protect("required" /* REQUIRED */), this.getOrdersCountByStatus.bind(this));
    this.router.get("/search/:query", AuthGuard.protect("required" /* REQUIRED */), this.searchOrders.bind(this));
  }
  /**
   * Get all orders
   * 
   * @param req Request
   * @param res Response
   */
  async getOrders(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId, userId } = req.user;
      const {
        limit = 50,
        offset = 0,
        status = "all",
        sortBy = "orderDate",
        sortDirection = "desc",
        user = "false"
        // Whether to filter by current user
      } = req.query;
      const options = {
        limit: Number(limit),
        offset: Number(offset),
        status,
        sortBy,
        sortDirection: sortDirection === "asc" ? "asc" : "desc"
      };
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      let orders2;
      if (user === "true") {
        orders2 = await this.ordersService.getUserOrders(userId, companyId, options);
      } else {
        orders2 = await this.ordersService.getCompanyOrders(companyId, options);
      }
      res.json({
        success: true,
        data: orders2
      });
    } catch (error) {
      logger60.error("Failed to get orders", error);
      res.status(500).json({
        success: false,
        message: `Failed to get orders: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Get order by ID
   * 
   * @param req Request
   * @param res Response
   */
  async getOrderById(req, res) {
    try {
      const { orderId } = req.params;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const order = await this.ordersService.getOrderById(orderId, companyId);
      if (!order) {
        return res.status(404).json({
          success: false,
          message: "Order not found"
        });
      }
      res.json({
        success: true,
        data: order
      });
    } catch (error) {
      logger60.error(`Failed to get order ${req.params.orderId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to get order: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Create new order
   * 
   * @param req Request
   * @param res Response
   */
  async createOrder(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId, userId } = req.user;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      const orderData = req.body;
      delete orderData.orderDate;
      logger60.info("Creating order with database default timestamp");
      const fullOrderData = {
        ...orderData,
        companyId,
        userId
      };
      const newOrder = await this.ordersService.createOrder(fullOrderData);
      res.status(201).json({
        success: true,
        data: newOrder
      });
    } catch (error) {
      logger60.error("Failed to create order", error);
      res.status(500).json({
        success: false,
        message: `Failed to create order: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Update order
   * 
   * @param req Request
   * @param res Response
   */
  async updateOrder(req, res) {
    try {
      const { orderId } = req.params;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const updateData = req.body;
      const updatedOrder = await this.ordersService.updateOrder(orderId, updateData, companyId);
      res.json({
        success: true,
        data: updatedOrder
      });
    } catch (error) {
      logger60.error(`Failed to update order ${req.params.orderId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to update order: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Update order status
   * 
   * @param req Request
   * @param res Response
   */
  async updateOrderStatus(req, res) {
    try {
      const { orderId } = req.params;
      const { status } = req.body;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      if (!status || !Object.values(OrderStatus2).includes(status)) {
        return res.status(400).json({
          success: false,
          message: "Invalid order status"
        });
      }
      const updatedOrder = await this.ordersService.updateOrderStatus(
        orderId,
        status,
        companyId
      );
      res.json({
        success: true,
        data: updatedOrder
      });
    } catch (error) {
      logger60.error(`Failed to update order status for ${req.params.orderId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to update order status: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Get orders count by status
   * 
   * @param req Request
   * @param res Response
   */
  async getOrdersCountByStatus(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      const counts = await this.ordersService.getOrdersCountByStatus(companyId);
      res.json({
        success: true,
        data: counts
      });
    } catch (error) {
      logger60.error("Failed to get orders count", error);
      res.status(500).json({
        success: false,
        message: `Failed to get orders count: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Search orders
   * 
   * @param req Request
   * @param res Response
   */
  async searchOrders(req, res) {
    try {
      const { query } = req.params;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      const orders2 = await this.ordersService.searchOrders(companyId, query);
      res.json({
        success: true,
        data: orders2
      });
    } catch (error) {
      logger60.error(`Failed to search orders with query ${req.params.query}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to search orders: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
};

// server/modules/ecommerce/controllers/transactions.controller.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router20 } from "express";
init_logger();
var logger61 = new Logger("TransactionsController");
var TransactionsController = class {
  constructor(transactionsService) {
    this.router = Router20();
    this.transactionsService = transactionsService;
    this.setupRoutes();
    logger61.info("TransactionsController initialized");
  }
  /**
   * Get the router
   * 
   * @returns Express router
   */
  getRouter() {
    return this.router;
  }
  /**
   * Setup routes
   */
  setupRoutes() {
    this.router.get("/", AuthGuard.protect("required" /* REQUIRED */), this.getTransactions.bind(this));
    this.router.get("/:transactionId", AuthGuard.protect("required" /* REQUIRED */), this.getTransactionById.bind(this));
    this.router.get("/order/:orderId", AuthGuard.protect("required" /* REQUIRED */), this.getOrderTransactions.bind(this));
    this.router.post("/", AuthGuard.protect("required" /* REQUIRED */), this.createTransaction.bind(this));
    this.router.patch("/:transactionId/status", AuthGuard.protect("required" /* REQUIRED */), this.updateTransactionStatus.bind(this));
    this.router.post("/:transactionId/refund", AuthGuard.protect("required" /* REQUIRED */), this.processRefund.bind(this));
    this.router.get("/stats/summary", AuthGuard.protect("required" /* REQUIRED */), this.getTransactionStatistics.bind(this));
  }
  /**
   * Get all transactions for a company
   * 
   * @param req Request
   * @param res Response
   */
  async getTransactions(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      const {
        limit = "50",
        offset = "0",
        status = "all",
        startDate,
        endDate
      } = req.query;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const options = {
        limit: Number(limit),
        offset: Number(offset),
        status,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0
      };
      const transactions2 = await this.transactionsService.getCompanyTransactions(companyId, options);
      res.json({
        success: true,
        data: transactions2
      });
    } catch (error) {
      logger61.error("Failed to get transactions", error);
      res.status(500).json({
        success: false,
        message: `Failed to get transactions: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Get transaction by ID
   * 
   * @param req Request
   * @param res Response
   */
  async getTransactionById(req, res) {
    try {
      const { transactionId } = req.params;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const transaction = await this.transactionsService.getTransactionById(transactionId);
      if (!transaction) {
        return res.status(404).json({
          success: false,
          message: "Transaction not found"
        });
      }
      res.json({
        success: true,
        data: transaction
      });
    } catch (error) {
      logger61.error(`Failed to get transaction ${req.params.transactionId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to get transaction: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Get transactions for an order
   * 
   * @param req Request
   * @param res Response
   */
  async getOrderTransactions(req, res) {
    try {
      const { orderId } = req.params;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const transactions2 = await this.transactionsService.getOrderTransactions(orderId, companyId);
      res.json({
        success: true,
        data: transactions2
      });
    } catch (error) {
      logger61.error(`Failed to get transactions for order ${req.params.orderId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to get order transactions: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Create transaction
   * 
   * @param req Request
   * @param res Response
   */
  async createTransaction(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId, userId } = req.user;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      const transactionData = {
        ...req.body,
        companyId,
        userId,
        transactionDate: /* @__PURE__ */ new Date()
      };
      const transaction = await this.transactionsService.createTransaction(transactionData);
      res.status(201).json({
        success: true,
        data: transaction
      });
    } catch (error) {
      logger61.error("Failed to create transaction", error);
      res.status(500).json({
        success: false,
        message: `Failed to create transaction: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Update transaction status
   * 
   * @param req Request
   * @param res Response
   */
  async updateTransactionStatus(req, res) {
    try {
      const { transactionId } = req.params;
      const { status, amount, additionalData } = req.body;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      if (!status || !Object.values(PaymentStatus2).includes(status)) {
        return res.status(400).json({
          success: false,
          message: "Invalid payment status"
        });
      }
      const updatedTransaction = await this.transactionsService.updateTransactionStatus(
        transactionId,
        status,
        amount,
        additionalData
      );
      res.json({
        success: true,
        data: updatedTransaction
      });
    } catch (error) {
      logger61.error(`Failed to update transaction status for ${req.params.transactionId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to update transaction status: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Process refund
   * 
   * @param req Request
   * @param res Response
   */
  async processRefund(req, res) {
    try {
      const { transactionId } = req.params;
      const { refundAmount, reason } = req.body;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId, userId } = req.user;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      if (!refundAmount || isNaN(Number(refundAmount)) || Number(refundAmount) <= 0) {
        return res.status(400).json({
          success: false,
          message: "Valid refund amount is required"
        });
      }
      const refundTransaction = await this.transactionsService.recordRefund(
        transactionId,
        refundAmount.toString(),
        companyId,
        userId,
        reason || "Customer requested refund"
      );
      res.json({
        success: true,
        data: refundTransaction
      });
    } catch (error) {
      logger61.error(`Failed to process refund for transaction ${req.params.transactionId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to process refund: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Get transaction statistics
   * 
   * @param req Request
   * @param res Response
   */
  async getTransactionStatistics(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId } = req.user;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const { period = "month" } = req.query;
      const stats = await this.transactionsService.getTransactionStatistics(
        companyId,
        period
      );
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      logger61.error("Failed to get transaction statistics", error);
      res.status(500).json({
        success: false,
        message: `Failed to get transaction statistics: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
};

// server/modules/ecommerce/controllers/cart.controller.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router21 } from "express";
init_logger();
var logger62 = new Logger("CartController");
var CartController = class {
  constructor(cartService) {
    this.router = Router21();
    this.cartService = cartService;
    this.setupRoutes();
    logger62.info("CartController initialized");
  }
  /**
   * Get the router
   * 
   * @returns Express router
   */
  getRouter() {
    return this.router;
  }
  /**
   * Setup routes
   */
  setupRoutes() {
    this.router.get("/", AuthGuard.protect("required" /* REQUIRED */), this.getCart.bind(this));
    this.router.get("/:cartId", AuthGuard.protect("required" /* REQUIRED */), this.getCartById.bind(this));
    this.router.post("/items", AuthGuard.protect("required" /* REQUIRED */), this.addItem.bind(this));
    this.router.put("/items/:itemId", AuthGuard.protect("required" /* REQUIRED */), this.updateItemQuantity.bind(this));
    this.router.delete("/items/:itemId", AuthGuard.protect("required" /* REQUIRED */), this.removeItem.bind(this));
    this.router.delete("/:cartId", AuthGuard.protect("required" /* REQUIRED */), this.clearCart.bind(this));
    this.router.post("/:cartId/discount", AuthGuard.protect("required" /* REQUIRED */), this.applyDiscount.bind(this));
    this.router.patch("/:cartId/status", AuthGuard.protect("required" /* REQUIRED */), this.updateCartStatus.bind(this));
  }
  /**
   * Get or create cart for current user
   * 
   * @param req Request
   * @param res Response
   */
  async getCart(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId, userId } = req.user;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      const cart = await this.cartService.getOrCreateCart(userId, companyId);
      const cartWithItems = await this.cartService.getCartWithItems(cart.id);
      res.json({
        success: true,
        data: cartWithItems
      });
    } catch (error) {
      logger62.error("Failed to get cart", error);
      res.status(500).json({
        success: false,
        message: `Failed to get cart: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Get cart by ID
   * 
   * @param req Request
   * @param res Response
   */
  async getCartById(req, res) {
    try {
      const { cartId } = req.params;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const cartWithItems = await this.cartService.getCartWithItems(cartId);
      res.json({
        success: true,
        data: cartWithItems
      });
    } catch (error) {
      logger62.error(`Failed to get cart ${req.params.cartId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to get cart: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Add item to cart
   * 
   * @param req Request
   * @param res Response
   */
  async addItem(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { companyId, userId } = req.user;
      const { cartId, productId, quantity, unitPrice, metadata } = req.body;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      if (!cartId || !productId || !quantity || !unitPrice) {
        return res.status(400).json({
          success: false,
          message: "Cart ID, product ID, quantity, and unit price are required"
        });
      }
      const updatedCart = await this.cartService.addItem(
        cartId,
        productId,
        Number(quantity),
        Number(unitPrice),
        metadata
      );
      res.json({
        success: true,
        data: updatedCart
      });
    } catch (error) {
      logger62.error("Failed to add item to cart", error);
      res.status(500).json({
        success: false,
        message: `Failed to add item to cart: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Update item quantity
   * 
   * @param req Request
   * @param res Response
   */
  async updateItemQuantity(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { itemId } = req.params;
      const { quantity } = req.body;
      if (!quantity && quantity !== 0) {
        return res.status(400).json({
          success: false,
          message: "Quantity is required"
        });
      }
      const updatedCart = await this.cartService.updateItemQuantity(itemId, Number(quantity));
      res.json({
        success: true,
        data: updatedCart
      });
    } catch (error) {
      logger62.error(`Failed to update cart item ${req.params.itemId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to update cart item: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Remove item from cart
   * 
   * @param req Request
   * @param res Response
   */
  async removeItem(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { itemId } = req.params;
      const updatedCart = await this.cartService.removeItem(itemId);
      res.json({
        success: true,
        data: updatedCart
      });
    } catch (error) {
      logger62.error(`Failed to remove cart item ${req.params.itemId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to remove cart item: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Clear cart
   * 
   * @param req Request
   * @param res Response
   */
  async clearCart(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { cartId } = req.params;
      const cart = await this.cartService.clearCart(cartId);
      res.json({
        success: true,
        data: cart
      });
    } catch (error) {
      logger62.error(`Failed to clear cart ${req.params.cartId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to clear cart: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Apply discount
   * 
   * @param req Request
   * @param res Response
   */
  async applyDiscount(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { cartId } = req.params;
      const { discountAmount, discountCode } = req.body;
      if (!discountAmount || !discountCode) {
        return res.status(400).json({
          success: false,
          message: "Discount amount and code are required"
        });
      }
      const updatedCart = await this.cartService.applyDiscount(
        cartId,
        Number(discountAmount),
        discountCode
      );
      res.json({
        success: true,
        data: updatedCart
      });
    } catch (error) {
      logger62.error(`Failed to apply discount to cart ${req.params.cartId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to apply discount: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Update cart status
   * 
   * @param req Request
   * @param res Response
   */
  async updateCartStatus(req, res) {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const { cartId } = req.params;
      const { status } = req.body;
      if (!status || !Object.values(CartStatus).includes(status)) {
        return res.status(400).json({
          success: false,
          message: "Invalid cart status"
        });
      }
      const updatedCart = await this.cartService.setCartStatus(
        cartId,
        status
      );
      res.json({
        success: true,
        data: updatedCart
      });
    } catch (error) {
      logger62.error(`Failed to update cart status for ${req.params.cartId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to update cart status: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
};

// server/modules/ecommerce/controllers/checkout.controller.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
import { Router as Router22 } from "express";
var logger63 = new Logger("CheckoutController");
var CheckoutController = class {
  constructor(checkoutService) {
    this.router = Router22();
    this.checkoutService = checkoutService;
    this.setupRoutes();
    logger63.info("CheckoutController initialized");
  }
  /**
   * Get the router
   * 
   * @returns Express router
   */
  getRouter() {
    return this.router;
  }
  /**
   * Setup routes
   */
  setupRoutes() {
    this.router.post(
      "/cart/:cartId",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["ecommerce_admin", "ecommerce_user"]),
      this.processCartCheckout.bind(this)
    );
    this.router.post(
      "/direct",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["ecommerce_admin", "ecommerce_user"]),
      this.processDirectCheckout.bind(this)
    );
  }
  /**
   * Process checkout from a cart
   * 
   * @param req Request
   * @param res Response
   */
  async processCartCheckout(req, res) {
    try {
      const { cartId } = req.params;
      const {
        paymentMethod,
        shippingAddress,
        billingAddress,
        ...additionalDetails
      } = req.body;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const userId = req.user.id;
      const companyId = req.user.companyId;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      if (!paymentMethod || !shippingAddress || !billingAddress) {
        return res.status(400).json({
          success: false,
          message: "Payment method, shipping address, and billing address are required"
        });
      }
      const checkoutResult = await this.checkoutService.processCheckout(
        cartId,
        userId,
        companyId,
        paymentMethod,
        shippingAddress,
        billingAddress,
        additionalDetails
      );
      res.json({
        success: true,
        data: checkoutResult
      });
    } catch (error) {
      logger63.error(`Failed to process checkout for cart ${req.params.cartId}`, error);
      res.status(500).json({
        success: false,
        message: `Failed to process checkout: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
  /**
   * Process direct checkout (without using a cart)
   * 
   * @param req Request
   * @param res Response
   */
  async processDirectCheckout(req, res) {
    try {
      const {
        items,
        paymentMethod,
        shippingAddress,
        billingAddress,
        ...additionalDetails
      } = req.body;
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized - User not authenticated" });
      }
      const userId = req.user.id;
      const companyId = req.user.companyId;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and User ID are required"
        });
      }
      if (!items || !paymentMethod || !shippingAddress || !billingAddress) {
        return res.status(400).json({
          success: false,
          message: "Items, payment method, shipping address, and billing address are required"
        });
      }
      const checkoutResult = await this.checkoutService.processDirectCheckout(
        userId,
        companyId,
        items,
        paymentMethod,
        shippingAddress,
        billingAddress,
        additionalDetails
      );
      res.json({
        success: true,
        data: checkoutResult
      });
    } catch (error) {
      logger63.error("Failed to process direct checkout", error);
      res.status(500).json({
        success: false,
        message: `Failed to process direct checkout: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }
};

// server/common/services/integration.service.ts
init_logger();
import { eq as eq49, and as and38 } from "drizzle-orm";
import { v4 as uuidv426 } from "uuid";
var logger64 = new Logger("IntegrationService");
var IntegrationService = class {
  constructor(db4) {
    this.db = db4;
    logger64.info("IntegrationService initialized");
  }
  /**
   * Get active integration configuration for a company and provider
   * 
   * @param companyId Company ID
   * @param provider Integration provider
   * @returns Integration configuration or null if not found
   */
  async getActiveIntegration(companyId, provider) {
    try {
      const integrations2 = this.db.dynamic.table("integrations");
      const integration = await this.db.select().from(integrations2).where(
        and38(
          eq49(integrations2.companyId, companyId),
          eq49(integrations2.provider, provider),
          eq49(integrations2.status, "active" /* ACTIVE */)
        )
      ).limit(1).then((results) => results[0] || null);
      return integration;
    } catch (error) {
      logger64.error(`Error getting active integration for company ${companyId} and provider ${provider}`, error);
      return null;
    }
  }
  /**
   * Get integration credentials for a provider and company
   * 
   * @param provider Integration provider
   * @param companyId Company ID
   * @param userId User ID (for audit purposes)
   * @returns Integration credentials or null if not found
   */
  async getIntegrationCredentials(provider, companyId, userId) {
    try {
      const integration = await this.getActiveIntegration(companyId, provider);
      if (!integration) {
        return this.getEnvironmentCredentials(provider);
      }
      logger64.info(`User ${userId} accessed ${provider} credentials for company ${companyId}`);
      return integration.config;
    } catch (error) {
      logger64.error(`Error getting integration credentials for provider ${provider} and company ${companyId}`, error);
      return this.getEnvironmentCredentials(provider);
    }
  }
  /**
   * Get credentials from environment variables
   * 
   * @param provider Integration provider
   * @returns Credentials from environment variables or null
   */
  getEnvironmentCredentials(provider) {
    try {
      switch (provider) {
        case "stripe" /* STRIPE */:
          if (process.env.STRIPE_SECRET_KEY) {
            return {
              secretKey: process.env.STRIPE_SECRET_KEY,
              publishableKey: process.env.STRIPE_PUBLISHABLE_KEY
            };
          }
          break;
        case "paypal" /* PAYPAL */:
          if (process.env.PAYPAL_CLIENT_ID && process.env.PAYPAL_CLIENT_SECRET) {
            return {
              clientId: process.env.PAYPAL_CLIENT_ID,
              clientSecret: process.env.PAYPAL_CLIENT_SECRET,
              environment: process.env.PAYPAL_ENVIRONMENT || "sandbox"
            };
          }
          break;
        case "pandadoc" /* PANDADOC */:
          if (process.env.PANDADOC_API_KEY) {
            return {
              apiKey: process.env.PANDADOC_API_KEY
            };
          }
          break;
        case "google" /* GOOGLE */:
          if (process.env.GOOGLE_API_KEY) {
            return {
              apiKey: process.env.GOOGLE_API_KEY,
              clientId: process.env.GOOGLE_CLIENT_ID,
              clientSecret: process.env.GOOGLE_CLIENT_SECRET
            };
          }
          break;
      }
      return null;
    } catch (error) {
      logger64.error(`Error getting environment credentials for provider ${provider}`, error);
      return null;
    }
  }
  /**
   * Create or update an integration for a company
   * 
   * @param companyId Company ID
   * @param provider Integration provider
   * @param config Integration configuration
   * @param userId User ID (for audit)
   * @returns Created or updated integration
   */
  async saveIntegration(companyId, provider, config3, userId) {
    try {
      const integrations2 = this.db.dynamic.table("integrations");
      const existingIntegration = await this.db.select().from(integrations2).where(
        and38(
          eq49(integrations2.companyId, companyId),
          eq49(integrations2.provider, provider)
        )
      ).limit(1).then((results) => results[0] || null);
      const timestamp24 = /* @__PURE__ */ new Date();
      if (existingIntegration) {
        await this.db.update(integrations2).set({
          config: config3,
          status: "active" /* ACTIVE */,
          updatedAt: timestamp24,
          updatedBy: userId
        }).where(eq49(integrations2.id, existingIntegration.id));
        logger64.info(`Updated ${provider} integration for company ${companyId}`);
        return {
          ...existingIntegration,
          config: config3,
          status: "active" /* ACTIVE */,
          updatedAt: timestamp24,
          updatedBy: userId
        };
      } else {
        const newIntegration = {
          id: uuidv426(),
          companyId,
          provider,
          name: this.getDefaultName(provider),
          config: config3,
          status: "active" /* ACTIVE */,
          isConnected: true,
          createdAt: timestamp24,
          createdBy: userId,
          updatedAt: timestamp24,
          updatedBy: userId
        };
        await this.db.insert(integrations2).values(newIntegration);
        logger64.info(`Created new ${provider} integration for company ${companyId}`);
        return newIntegration;
      }
    } catch (error) {
      logger64.error(`Error saving integration for company ${companyId} and provider ${provider}`, error);
      throw new Error(`Failed to save integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Check if company has an active integration with a provider
   * 
   * @param companyId Company ID
   * @param provider Integration provider
   * @returns Boolean indicating if integration exists and is active
   */
  async hasActiveIntegration(companyId, provider) {
    try {
      const integration = await this.getActiveIntegration(companyId, provider);
      return integration !== null;
    } catch (error) {
      logger64.error(`Error checking active integration for company ${companyId} and provider ${provider}`, error);
      return false;
    }
  }
  /**
   * Get default name for integration based on provider
   * 
   * @param provider Integration provider
   * @returns Default name
   */
  getDefaultName(provider) {
    switch (provider) {
      case "stripe" /* STRIPE */:
        return "Stripe Payment Gateway";
      case "paypal" /* PAYPAL */:
        return "PayPal Payment Gateway";
      case "shopify" /* SHOPIFY */:
        return "Shopify E-commerce";
      case "pandadoc" /* PANDADOC */:
        return "PandaDoc Document Signing";
      case "anaf_efactura" /* ANAF_EFACTURA */:
        return "ANAF eFactura Integration";
      case "google" /* GOOGLE */:
        return "Google API Integration";
      case "microsoft" /* MICROSOFT */:
        return "Microsoft API Integration";
      case "amazon" /* AMAZON */:
        return "Amazon API Integration";
      case "facebook" /* FACEBOOK */:
        return "Facebook API Integration";
      case "twitter" /* TWITTER */:
        return "Twitter API Integration";
      case "hubspot" /* HUBSPOT */:
        return "HubSpot CRM Integration";
      case "mailchimp" /* MAILCHIMP */:
        return "Mailchimp Marketing Integration";
      case "quickbooks" /* QUICKBOOKS */:
        return "QuickBooks Accounting";
      case "xero" /* XERO */:
        return "Xero Accounting";
      default:
        return `${provider} Integration`;
    }
  }
};

// server/modules/ecommerce/ecommerce.module.ts
init_audit_service();
var logger65 = new Logger("ECommerceModule");
function initECommerceModule(app2, drizzleService5) {
  logger65.info("Initializing E-Commerce module");
  try {
    const ordersService = new OrdersService(drizzleService5);
    const transactionsService = new TransactionsService(drizzleService5);
    const integrationService = new IntegrationService(drizzleService5);
    const auditService4 = new AuditService(drizzleService5);
    const paymentService = new PaymentService(integrationService, auditService4);
    const cartService = new CartService(drizzleService5);
    const checkoutService = new CheckoutService(drizzleService5, ordersService, transactionsService, cartService, paymentService);
    const shopifyService = new ShopifyIntegrationService(drizzleService5, ordersService, transactionsService);
    const posService = new POSIntegrationService(drizzleService5, ordersService, transactionsService);
    const shopifyRouter = new ShopifyRouter(shopifyService);
    const posRouter = new POSRouter(posService);
    const checkoutController = new CheckoutController(checkoutService);
    const ordersController = new OrdersController(ordersService);
    const transactionsController = new TransactionsController(transactionsService);
    const cartController = new CartController(cartService);
    const ecommerceController = new ECommerceController(paymentService);
    app2.use("/api/ecommerce/orders", ordersController.getRouter());
    app2.use("/api/ecommerce/transactions", transactionsController.getRouter());
    app2.use("/api/ecommerce/shopify", shopifyRouter.getRouter());
    app2.use("/api/ecommerce/cart", cartController.getRouter());
    app2.use("/api/ecommerce/checkout", checkoutController.getRouter());
    app2.use("/api/ecommerce/pos", posRouter.getRouter());
    app2.use("/api/ecommerce", ecommerceController.getRouter());
    logger65.info("E-Commerce module initialized successfully");
    return {
      name: ECommerceModule.name,
      version: ECommerceModule.version,
      services: {
        ordersService,
        transactionsService,
        cartService,
        checkoutService,
        shopifyService,
        posService
      }
    };
  } catch (error) {
    logger65.error("Failed to initialize E-Commerce module", error);
    throw new Error("E-Commerce module initialization failed");
  }
}
var ECommerceModule = {
  name: "ecommerce",
  displayName: "E-Commerce",
  description: "Manage online sales, orders, and payments including integrations with e-commerce platforms",
  version: "1.0.0",
  initialize: initECommerceModule,
  /**
   * Register the module with the application
   * @param app Express application
   * @param drizzleService DrizzleService instance
   * @returns Information about the registered module
   */
  register: (app2, drizzleService5) => {
    const moduleInfo = initECommerceModule(app2, drizzleService5);
    try {
      const { registerModule } = (init_services(), __toCommonJS(services_exports));
      registerModule("ecommerce", {
        name: ECommerceModule.name,
        version: ECommerceModule.version,
        services: moduleInfo.services,
        permissions: ECommerceModule.permissions
      });
      logger65.info("E-Commerce module registered with service registry");
    } catch (error) {
      logger65.warn("Service registry not available, module services will not be globally accessible", error);
    }
    return moduleInfo;
  },
  defaultRoles: [
    "ecommerce_admin",
    "ecommerce_user",
    "ecommerce_viewer"
  ],
  permissions: [
    "ecommerce.orders.create",
    "ecommerce.orders.read",
    "ecommerce.orders.update",
    "ecommerce.orders.delete",
    "ecommerce.transactions.create",
    "ecommerce.transactions.read",
    "ecommerce.transactions.update",
    "ecommerce.integrations.configure",
    "ecommerce.integrations.sync",
    "ecommerce.pos.manage",
    "ecommerce.cart.manage",
    "ecommerce.checkout.process"
  ],
  routes: [
    {
      path: "/api/ecommerce/orders",
      methods: ["GET", "POST", "PUT", "DELETE"],
      description: "Manage e-commerce orders"
    },
    {
      path: "/api/ecommerce/transactions",
      methods: ["GET", "POST", "PUT"],
      description: "Manage payment transactions"
    },
    {
      path: "/api/ecommerce/shopify",
      methods: ["GET", "POST", "PUT"],
      description: "Shopify integration and synchronization"
    },
    {
      path: "/api/ecommerce/cart",
      methods: ["GET", "POST", "PUT", "DELETE"],
      description: "Shopping cart management"
    },
    {
      path: "/api/ecommerce/checkout",
      methods: ["GET", "POST"],
      description: "Checkout process management"
    },
    {
      path: "/api/ecommerce/pos",
      methods: ["GET", "POST", "PUT"],
      description: "POS integration and management"
    },
    {
      path: "/api/ecommerce/order-placeholder",
      methods: ["POST"],
      description: "E-commerce order creation placeholder endpoint"
    },
    {
      path: "/api/ecommerce/payment",
      methods: ["POST"],
      description: "Direct payment processing endpoint using Stripe integration"
    }
  ],
  dependencies: ["settings", "customers", "products", "inventory", "crm"]
};

// server/modules/integrations/services/integrations.service.ts
init_drizzle();
init_integrations_schema();
init_audit_service();
init_logger();
import { v4 as uuidv427 } from "uuid";
import { eq as eq50, and as and39, desc as desc18 } from "drizzle-orm";
var RESOURCE_TYPE = "integration";
var logger66 = new Logger("IntegrationsService");
var IntegrationsService = class {
  constructor() {
    this.drizzle = new DrizzleService();
    this.auditService = new AuditService();
    logger66.info("IntegrationsService initialized");
  }
  /**
   * Create a new integration
   * @param provider Integration provider
   * @param companyId Company ID
   * @param config Integration configuration
   * @param userId User ID creating the integration
   * @param franchiseId Optional franchise ID
   * @param name Optional integration name
   * @param description Optional integration description
   * @param webhookUrl Optional webhook URL
   * @param webhookSecret Optional webhook secret
   */
  async createIntegration(provider, companyId, config3 = {}, userId, franchiseId, name, description, webhookUrl, webhookSecret) {
    try {
      const id = uuidv427();
      const now = /* @__PURE__ */ new Date();
      const [integration] = await this.drizzle.insert(integrations).values({
        id,
        companyId,
        provider,
        name: name || null,
        description: description || null,
        franchiseId: franchiseId || null,
        config: config3,
        status: "pending" /* PENDING */,
        isConnected: false,
        webhookUrl: webhookUrl || null,
        webhookSecret: webhookSecret || null,
        createdAt: now,
        updatedAt: now,
        createdBy: userId,
        updatedBy: userId
      }).returning();
      await this.auditService.createAuditLog({
        userId,
        companyId,
        action: "create",
        resourceType: RESOURCE_TYPE,
        resourceId: id,
        details: {
          provider,
          franchiseId
        }
      });
      return integration;
    } catch (error) {
      console.error("[IntegrationsService] Create integration error:", error instanceof Error ? error.message : String(error));
      throw new Error(`Failed to create ${provider} integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get integration by ID
   * @param id Integration ID
   * @param companyId Company ID
   */
  async getIntegration(id, companyId) {
    try {
      const [integration] = await this.drizzle.select().from(integrations).where(
        and39(
          eq50(integrations.id, id),
          eq50(integrations.companyId, companyId)
        )
      );
      return integration || null;
    } catch (error) {
      console.error("[IntegrationsService] Get integration error:", error instanceof Error ? error.message : String(error));
      return null;
    }
  }
  /**
   * Get integration by provider
   * @param provider Integration provider
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  async getIntegrationByProvider(provider, companyId, franchiseId) {
    try {
      let query = this.drizzle.select().from(integrations).where(
        and39(
          eq50(integrations.provider, provider),
          eq50(integrations.companyId, companyId)
        )
      );
      if (franchiseId) {
        query = query.where(eq50(integrations.franchiseId, franchiseId));
      } else {
        query = query.where(eq50(integrations.franchiseId, null));
      }
      const [integration] = await query;
      return integration || null;
    } catch (error) {
      console.error("[IntegrationsService] Get integration by provider error:", error instanceof Error ? error.message : String(error));
      return null;
    }
  }
  /**
   * List integrations for a company
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID to filter by
   */
  async listIntegrations(companyId, franchiseId) {
    try {
      let query = this.drizzle.select().from(integrations).where(eq50(integrations.companyId, companyId)).orderBy(desc18(integrations.updatedAt));
      if (franchiseId) {
        query = query.where(eq50(integrations.franchiseId, franchiseId));
      }
      const integrationsList = await query;
      return integrationsList;
    } catch (error) {
      console.error("[IntegrationsService] List integrations error:", error instanceof Error ? error.message : String(error));
      return [];
    }
  }
  /**
   * Update integration
   * @param id Integration ID
   * @param companyId Company ID
   * @param updates Fields to update
   * @param userId User ID performing the update
   */
  async updateIntegration(id, companyId, updates, userId) {
    try {
      const {
        id: _id,
        companyId: _companyId,
        createdAt: _createdAt,
        createdBy: _createdBy,
        ...validUpdates
      } = updates;
      const updateData = {
        ...validUpdates,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      };
      const [updatedIntegration] = await this.drizzle.update(integrations).set(updateData).where(
        and39(
          eq50(integrations.id, id),
          eq50(integrations.companyId, companyId)
        )
      ).returning();
      if (!updatedIntegration) {
        return null;
      }
      await this.auditService.createAuditLog({
        userId,
        companyId,
        action: "update",
        resourceType: RESOURCE_TYPE,
        resourceId: id,
        details: {
          updates: validUpdates
        }
      });
      return updatedIntegration;
    } catch (error) {
      console.error("[IntegrationsService] Update integration error:", error instanceof Error ? error.message : String(error));
      return null;
    }
  }
  /**
   * Update integration status
   * @param id Integration ID
   * @param companyId Company ID
   * @param status New status
   * @param userId User ID updating the status
   */
  async updateIntegrationStatus(id, companyId, status, userId) {
    try {
      const [updatedIntegration] = await this.drizzle.update(integrations).set({
        status,
        isConnected: status === "active" /* ACTIVE */,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(
        and39(
          eq50(integrations.id, id),
          eq50(integrations.companyId, companyId)
        )
      ).returning();
      if (!updatedIntegration) {
        return false;
      }
      await this.auditService.createAuditLog({
        userId,
        companyId,
        action: "update",
        resourceType: RESOURCE_TYPE,
        resourceId: id,
        details: {
          status,
          isConnected: status === "active" /* ACTIVE */
        }
      });
      return true;
    } catch (error) {
      console.error("[IntegrationsService] Update integration status error:", error instanceof Error ? error.message : String(error));
      return false;
    }
  }
  /**
   * Update last synced timestamp
   * @param id Integration ID
   * @param companyId Company ID
   * @param userId User ID who initiated the sync
   */
  async updateLastSyncedAt(id, companyId, userId) {
    try {
      const now = /* @__PURE__ */ new Date();
      const [updatedIntegration] = await this.drizzle.update(integrations).set({
        lastSyncedAt: now,
        updatedAt: now,
        updatedBy: userId
      }).where(
        and39(
          eq50(integrations.id, id),
          eq50(integrations.companyId, companyId)
        )
      ).returning();
      return !!updatedIntegration;
    } catch (error) {
      console.error("[IntegrationsService] Update last sync error:", error instanceof Error ? error.message : String(error));
      return false;
    }
  }
  /**
   * Delete integration (soft delete)
   * @param id Integration ID
   * @param companyId Company ID
   * @param userId User ID performing the deletion
   */
  async deleteIntegration(id, companyId, userId) {
    try {
      const integration = await this.getIntegration(id, companyId);
      if (!integration) {
        return false;
      }
      await this.drizzle.delete(integrations).where(
        and39(
          eq50(integrations.id, id),
          eq50(integrations.companyId, companyId)
        )
      );
      await this.auditService.createAuditLog({
        userId,
        companyId,
        action: "delete",
        resourceType: RESOURCE_TYPE,
        resourceId: id,
        details: {
          provider: integration.provider,
          franchiseId: integration.franchiseId
        }
      });
      return true;
    } catch (error) {
      console.error("[IntegrationsService] Delete integration error:", error instanceof Error ? error.message : String(error));
      return false;
    }
  }
};

// server/modules/integrations/services/bnr-exchange-rate.service.ts
init_registry();
init_schema4();
import { parseStringPromise } from "xml2js";
import { eq as eq51, and as and40, desc as desc19 } from "drizzle-orm";
import cron from "node-cron";
var BNR_CURRENCY_RSS_FEEDS = {
  EUR: "https://www.bnro.ro/RSS_200003_EUR.aspx",
  // Corrected domain from bnr.ro to bnro.ro
  USD: "https://www.bnro.ro/RSS_200004_USD.aspx",
  // Corrected domain from bnr.ro to bnro.ro
  TRY: "https://www.bnro.ro/RSS_200023_TRY.aspx"
  // Corrected domain from bnr.ro to bnro.ro
};
var BNR_XML_URL = "https://www.bnr.ro/nbrfxrates.xml";
var BnrExchangeRateService = class {
  constructor() {
    this.httpClient = createHttpClient({
      timeout: 1e4
    });
  }
  /**
   * Get drizzle db instance
   */
  get db() {
    return Services.db.db;
  }
  /**
   * Initialize the BNR exchange rate service with cron jobs
   */
  initialize() {
    cron.schedule("0 */3 * * *", async () => {
      try {
        await this.fetchAndStoreRatesFromRss();
        log("\u{1F504} Scheduled BNR exchange rate update (RSS) completed successfully", "bnr-exchange");
      } catch (error) {
        log(`\u274C Scheduled BNR exchange rate update (RSS) failed: ${error.message}`, "bnr-exchange");
      }
    }, {
      timezone: "Europe/Bucharest"
    });
    cron.schedule("30 14 * * *", async () => {
      try {
        await this.fetchAndStoreRatesFromRss();
        log("\u{1F504} BNR daily update check (14:30) completed successfully", "bnr-exchange");
      } catch (error) {
        log(`\u274C BNR daily update check failed: ${error.message}`, "bnr-exchange");
      }
    }, {
      timezone: "Europe/Bucharest"
    });
    log("\u{1F4C5} BNR exchange rate sync scheduled every 3 hours and at 14:30 Romania time (using only RSS feeds)", "bnr-exchange");
  }
  /**
   * Fetch rates from RSS feeds for specific currencies including historical data
   */
  async fetchAndStoreRatesFromRss() {
    try {
      log("\u{1F310} Fetching exchange rates from BNR RSS feeds (including historical data)...", "bnr-exchange");
      const currencies = Object.keys(BNR_CURRENCY_RSS_FEEDS);
      let totalRatesStored = 0;
      let successfulCurrencies = 0;
      for (const currency of currencies) {
        try {
          const feedUrl = BNR_CURRENCY_RSS_FEEDS[currency];
          log(`\u{1F4E1} Fetching RSS feed for ${currency}: ${feedUrl}`, "bnr-exchange");
          const response = await this.httpClient.get(feedUrl, {
            responseType: "text",
            timeout: 15e3,
            headers: {
              "Accept": "application/xml, text/xml, */*",
              "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
            }
          });
          const parsed = await parseStringPromise(response);
          if (!parsed || !parsed.rss || !parsed.rss.channel || !parsed.rss.channel[0] || !parsed.rss.channel[0].item || !parsed.rss.channel[0].item.length) {
            log(`\u26A0\uFE0F Invalid RSS structure for ${currency}`, "bnr-exchange");
            continue;
          }
          const items = parsed.rss.channel[0].item;
          log(`\u{1F4CA} Found ${items.length} historical items in RSS feed for ${currency}`, "bnr-exchange");
          let currencyRatesStored = 0;
          for (const item of items) {
            try {
              const title = item.title?.[0] || "";
              const pubDate = item.pubDate?.[0] || "";
              const rateMatch = title.match(/1\s+\w+\s+=\s+(\d+(?:\.\d+)?)\s+RON/);
              if (!rateMatch) {
                log(`\u26A0\uFE0F Could not extract rate from title: "${title}" for ${currency}`, "bnr-exchange");
                continue;
              }
              const rateValue = parseFloat(rateMatch[1]);
              const date5 = new Date(pubDate);
              const dateStr = date5.toISOString().split("T")[0];
              await this.db.insert(fx_rates).values({
                currency,
                rate: rateValue.toString(),
                source: "BNR_RSS",
                baseCurrency: "RON",
                date: date5
              }).onConflictDoUpdate({
                target: [fx_rates.currency, fx_rates.date, fx_rates.source, fx_rates.baseCurrency],
                set: { rate: rateValue.toString(), updatedAt: /* @__PURE__ */ new Date() }
              });
              currencyRatesStored++;
              totalRatesStored++;
              if (currencyRatesStored === 1) {
                log(`\u2705 Stored latest RSS rate for ${currency}: ${rateValue} (${dateStr})`, "bnr-exchange");
              }
            } catch (itemError) {
              log(`\u26A0\uFE0F Error processing RSS item for ${currency}: ${itemError.message}`, "bnr-exchange");
            }
          }
          if (currencyRatesStored > 0) {
            successfulCurrencies++;
            log(`\u{1F4CA} Stored ${currencyRatesStored} historical rates for ${currency} from RSS feed`, "bnr-exchange");
          } else {
            log(`\u274C Failed to store any rates for ${currency} from RSS feed`, "bnr-exchange");
          }
        } catch (currencyError) {
          log(`\u274C Error processing RSS feed for ${currency}: ${currencyError.message}`, "bnr-exchange");
        }
      }
      if (successfulCurrencies === 0) {
        throw new Error("Failed to process any RSS feeds successfully");
      }
      log(`\u2705 Successfully stored ${totalRatesStored} BNR exchange rates from ${successfulCurrencies}/${currencies.length} RSS feeds`, "bnr-exchange");
    } catch (error) {
      log(`\u274C Error fetching BNR exchange rates from RSS: ${error.message}`, "bnr-exchange");
      throw new Error(`Failed to fetch and store BNR exchange rates from RSS: ${error.message}`);
    }
  }
  /**
   * Fetch rates from the BNR XML feed
   */
  async fetchAndStoreRatesFromXml() {
    try {
      log("\u{1F310} Fetching exchange rates from BNR XML feed...", "bnr-exchange");
      const response = await this.httpClient.get(BNR_XML_URL, {
        responseType: "text"
      });
      const parsed = await parseStringPromise(response);
      if (!parsed || !parsed.DataSet || !parsed.DataSet.Body || !parsed.DataSet.Body[0] || !parsed.DataSet.Body[0].Cube || !parsed.DataSet.Body[0].Cube[0] || !parsed.DataSet.Body[0].Cube[0].Rate) {
        throw new Error("Invalid XML structure from BNR");
      }
      const rates = parsed.DataSet.Body[0].Cube[0].Rate;
      const dateStr = parsed.DataSet.Body[0].Cube[0].$.date;
      const date5 = new Date(dateStr);
      log(`\u{1F4CA} Processing ${rates.length} exchange rates from BNR XML for date ${dateStr}`, "bnr-exchange");
      for (const rate of rates) {
        const currency = rate.$.currency;
        const rateValue = parseFloat(rate._);
        await this.db.insert(fx_rates).values({
          currency,
          rate: rateValue.toString(),
          // Convert numeric value to string for Drizzle/PostgreSQL
          source: "BNR",
          baseCurrency: "RON",
          date: date5
        }).onConflictDoUpdate({
          target: [fx_rates.currency, fx_rates.date, fx_rates.source, fx_rates.baseCurrency],
          set: { rate: rateValue.toString(), updatedAt: /* @__PURE__ */ new Date() }
        });
      }
      log(`\u2705 Successfully stored ${rates.length} BNR exchange rates in database from XML`, "bnr-exchange");
    } catch (error) {
      log(`\u274C Error fetching BNR exchange rates from XML: ${error.message}`, "bnr-exchange");
      throw new Error(`Failed to fetch and store BNR exchange rates from XML: ${error.message}`);
    }
  }
  /**
   * Main method to fetch and store rates - using only RSS feeds as requested
   */
  async fetchAndStoreRates() {
    try {
      await this.fetchAndStoreRatesFromRss();
      log("\u2705 RSS method completed successfully", "bnr-exchange");
    } catch (error) {
      log(`\u274C RSS method failed: ${error.message}`, "bnr-exchange");
      throw new Error(`Failed to fetch exchange rates from RSS: ${error.message}`);
    }
  }
  /**
   * Get the latest BNR exchange rates from the database
   * If no rates are found, fetches from BNR and stores them
   */
  async getLatestRates() {
    try {
      const allRates = await this.db.select().from(fx_rates).where(
        eq51(fx_rates.baseCurrency, "RON")
      ).orderBy(desc19(fx_rates.date)).limit(200);
      if (!allRates || allRates.length === 0) {
        log("\u{1F504} No exchange rates found in database, fetching from sources...", "bnr-exchange");
        await this.fetchAndStoreRates();
        return this.getLatestRates();
      }
      const ratesObject = {};
      const processedCurrencies = /* @__PURE__ */ new Set();
      for (const rate of allRates) {
        if (rate.source === "BNR_RSS" && !processedCurrencies.has(rate.currency)) {
          ratesObject[rate.currency] = parseFloat(rate.rate.toString());
          processedCurrencies.add(rate.currency);
        }
      }
      for (const rate of allRates) {
        if (rate.source === "BNR" && !processedCurrencies.has(rate.currency)) {
          ratesObject[rate.currency] = parseFloat(rate.rate.toString());
          processedCurrencies.add(rate.currency);
        }
      }
      for (const rate of allRates) {
        if (!processedCurrencies.has(rate.currency)) {
          ratesObject[rate.currency] = parseFloat(rate.rate.toString());
          processedCurrencies.add(rate.currency);
        }
      }
      log(`\u{1F4C8} Retrieved ${Object.keys(ratesObject).length} exchange rates from database (combined sources)`, "bnr-exchange");
      return ratesObject;
    } catch (error) {
      log(`\u274C Error getting exchange rates: ${error.message}`, "bnr-exchange");
      throw new Error(`Failed to get exchange rates: ${error.message}`);
    }
  }
  /**
   * Manually trigger a fetch of BNR rates from RSS feeds
   * Useful for testing or initial setup
   */
  async manualFetch() {
    log("\u{1F50D} Starting manual BNR exchange rate update from RSS feeds...", "bnr-exchange");
    try {
      log("\u{1F50D} Fetching RSS feeds for all configured currencies...", "bnr-exchange");
      const currencies = Object.keys(BNR_CURRENCY_RSS_FEEDS);
      for (const currency of currencies) {
        try {
          const feedUrl = BNR_CURRENCY_RSS_FEEDS[currency];
          log(`\u{1F50D} Testing RSS feed URL for ${currency}: ${feedUrl}`, "bnr-exchange");
          const response = await this.httpClient.get(feedUrl, {
            responseType: "text",
            timeout: 15e3,
            headers: {
              "Accept": "application/xml, text/xml, */*",
              "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
            }
          });
          log(`\u2705 Successfully fetched RSS feed for ${currency}. Response length: ${response.length}`, "bnr-exchange");
        } catch (urlError) {
          log(`\u26A0\uFE0F Failed to fetch RSS feed for ${currency}: ${urlError.message}`, "bnr-exchange");
        }
      }
      try {
        await this.fetchAndStoreRatesFromRss();
        log("\u2705 Manual RSS feed update completed successfully", "bnr-exchange");
      } catch (rssError) {
        log(`\u274C RSS feed update failed: ${rssError.message}`, "bnr-exchange");
        throw rssError;
      }
    } catch (error) {
      log(`\u274C Manual exchange rate update failed: ${error.message}`, "bnr-exchange");
      throw new Error(`Failed to manually fetch exchange rates from RSS: ${error.message}`);
    }
    return this.getLatestRates();
  }
  /**
   * Get the RSS feeds URLs for currencies
   */
  getRssFeeds() {
    return { ...BNR_CURRENCY_RSS_FEEDS };
  }
  /**
   * Get the exchange rate for a specific currency
   */
  async getRateForCurrency(currency) {
    try {
      const results = await this.db.select().from(fx_rates).where(and40(
        eq51(fx_rates.currency, currency),
        eq51(fx_rates.baseCurrency, "RON")
      )).orderBy(desc19(fx_rates.date)).limit(10);
      if (results && results.length > 0) {
        const rssRate = results.find((r) => r.source === "BNR_RSS");
        if (rssRate) {
          return parseFloat(rssRate.rate.toString());
        }
        const bnrRate = results.find((r) => r.source === "BNR");
        if (bnrRate) {
          return parseFloat(bnrRate.rate.toString());
        }
        return parseFloat(results[0].rate.toString());
      }
      const rates = await this.getLatestRates();
      return rates[currency] || null;
    } catch (error) {
      log(`\u274C Error getting rate for ${currency}: ${error.message}`, "bnr-exchange");
      throw new Error(`Failed to get rate for ${currency}: ${error.message}`);
    }
  }
};
var bnrExchangeRateService = new BnrExchangeRateService();

// server/modules/integrations/services/anaf.service.ts
var AnafService2 = class {
  constructor(config3 = {}) {
    const baseURL = config3.apiBaseUrl || "https://webservicesp.anaf.ro/PlatitorTvaRest/api/v8";
    this.httpClient = createHttpClient({
      baseURL,
      timeout: 1e4,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json",
        ...config3.apiKey ? { "X-API-KEY": config3.apiKey } : {}
      }
    });
    log("\u{1F3DB}\uFE0F ANAF service initialized", "anaf");
  }
  /**
   * Validate a Romanian VAT number (CUI)
   * @param vatNumber - The VAT number to validate (without RO prefix)
   */
  async validateVat(vatNumber) {
    try {
      const cleanVat = vatNumber.replace(/^RO/i, "").trim();
      log(`\u{1F50D} Validating VAT number: ${cleanVat}`, "anaf");
      const payload = [{
        cui: cleanVat,
        data: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
      }];
      const response = await this.httpClient.post("/ws/tva", payload);
      if (!response || !response.length || !response[0]) {
        return {
          valid: false,
          fiscalCode: cleanVat,
          message: "No data returned from ANAF"
        };
      }
      const result = response[0];
      return {
        valid: result.valid === true || result.valid === 1,
        name: result.denumire,
        address: result.adresa,
        fiscalCode: cleanVat,
        vatNumber: result.scpTVA ? `RO${cleanVat}` : cleanVat,
        registrationDate: result.data_inregistrare,
        active: result.statusInactivi !== "INACTIV",
        message: result.mesaj
      };
    } catch (error) {
      log(`\u274C Error validating VAT number: ${error.message}`, "anaf");
      return {
        valid: false,
        fiscalCode: vatNumber,
        message: `Failed to validate VAT number: ${error.message}`
      };
    }
  }
  /**
   * Get detailed information about a company by fiscal code (CUI)
   * @param fiscalCode - The fiscal code (CUI) of the company
   */
  async getCompanyInfo(fiscalCode) {
    try {
      const cleanFiscalCode = fiscalCode.replace(/^RO/i, "").trim();
      log(`\u{1F50D} Retrieving company info for fiscal code: ${cleanFiscalCode}`, "anaf");
      const vatValidation = await this.validateVat(cleanFiscalCode);
      if (!vatValidation.valid) {
        log(`\u274C Invalid fiscal code: ${cleanFiscalCode}`, "anaf");
        return null;
      }
      return {
        name: vatValidation.name || "",
        fiscalCode: cleanFiscalCode,
        address: vatValidation.address,
        active: vatValidation.active || false,
        vatPayer: !!vatValidation.vatNumber?.startsWith("RO"),
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      log(`\u274C Error retrieving company info: ${error.message}`, "anaf");
      return null;
    }
  }
  /**
   * Check if a company is registered for e-Factura
   * @param fiscalCode - The fiscal code (CUI) of the company
   */
  async checkEFacturaRegistration(fiscalCode) {
    try {
      log(`\u{1F50D} Checking e-Factura registration for: ${fiscalCode}`, "anaf");
      const companyInfo = await this.getCompanyInfo(fiscalCode);
      if (!companyInfo) {
        return false;
      }
      const isRegistered = companyInfo.active && companyInfo.vatPayer;
      log(`\u2139\uFE0F e-Factura registration status for ${fiscalCode}: ${isRegistered ? "Registered" : "Not registered"}`, "anaf");
      return isRegistered;
    } catch (error) {
      log(`\u274C Error checking e-Factura registration: ${error.message}`, "anaf");
      return false;
    }
  }
  /**
   * Validates that a fiscal code is properly formatted according to Romanian rules
   * This is a client-side validation, doesn't make an API call
   */
  validateFiscalCodeFormat(fiscalCode) {
    const cleanFiscalCode = fiscalCode.replace(/^RO/i, "").trim();
    if (!/^\d{2,10}$/.test(cleanFiscalCode)) {
      return false;
    }
    if (cleanFiscalCode.length < 2) {
      return false;
    }
    return true;
  }
};
var anafService2 = new AnafService2();

// server/modules/integrations/services/e-factura.service.ts
var EFacturaService = class {
  constructor(config3 = {}) {
    this.environment = config3.environment || "test";
    const baseURL = config3.apiBaseUrl || (this.environment === "production" ? "https://api.anaf.ro/prod/CUIIO/rest/efactura" : "https://api.anaf.ro/test/CUIIO/rest/efactura");
    this.httpClient = createHttpClient({
      baseURL,
      timeout: 3e4,
      // Longer timeout for government services
      headers: {
        "Content-Type": "application/xml",
        "Accept": "application/json",
        ...config3.apiKey ? { "X-API-KEY": config3.apiKey } : {}
      }
    });
    log(`\u{1F9FE} e-Factura service initialized in ${this.environment} environment`, "e-factura");
  }
  /**
   * Submit an invoice to e-Factura system in UBL format
   * @param invoiceXml - The invoice in UBL XML format
   * @param metadata - Additional metadata required by e-Factura
   */
  async submitInvoice(invoiceXml, metadata = {}) {
    try {
      log(`\u{1F4E4} Submitting invoice to e-Factura (${this.environment})`, "e-factura");
      const response = await this.httpClient.post("/upload", invoiceXml, {
        headers: {
          "X-Transaction-ID": metadata.transactionId || (/* @__PURE__ */ new Date()).getTime().toString(),
          "X-Company-CUI": metadata.companyCui,
          "X-Company-Name": metadata.companyName
        }
      });
      log(`\u2705 Successfully submitted invoice to e-Factura`, "e-factura");
      return {
        success: true,
        message: "Invoice submitted successfully",
        referenceId: response.referenceId,
        timestamp: response.timestamp
      };
    } catch (error) {
      log(`\u274C Error submitting invoice to e-Factura: ${error.message}`, "e-factura");
      return {
        success: false,
        message: `Failed to submit invoice: ${error.message}`,
        errors: error.response?.data?.errors || [error.message]
      };
    }
  }
  /**
   * Check the status of a submitted invoice
   * @param referenceId - The reference ID returned from submitInvoice
   */
  async checkInvoiceStatus(referenceId) {
    try {
      log(`\u{1F50D} Checking e-Factura invoice status for reference: ${referenceId}`, "e-factura");
      const response = await this.httpClient.get(`/status/${referenceId}`);
      return {
        referenceId,
        status: response.status,
        message: response.message,
        timestamp: response.timestamp,
        details: response.details
      };
    } catch (error) {
      log(`\u274C Error checking e-Factura invoice status: ${error.message}`, "e-factura");
      throw new Error(`Failed to check invoice status: ${error.message}`);
    }
  }
  /**
   * Generate UBL XML format for an invoice
   * @param invoiceData - The invoice data to convert to UBL XML
   */
  generateUblXml(invoiceData) {
    log(`\u{1F4DD} Generating UBL XML for invoice ${invoiceData.invoiceNumber}`, "e-factura");
    return `<?xml version="1.0" encoding="UTF-8"?>
<Invoice xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2" 
         xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2"
         xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2">
  <cbc:ID>${invoiceData.invoiceNumber}</cbc:ID>
  <cbc:IssueDate>${invoiceData.issueDate}</cbc:IssueDate>
  <cbc:InvoiceTypeCode>380</cbc:InvoiceTypeCode>
  <cbc:DocumentCurrencyCode>${invoiceData.currency}</cbc:DocumentCurrencyCode>
  <!-- Additional invoice data would go here -->
</Invoice>`;
  }
  /**
   * Download an invoice from e-Factura system
   * @param referenceId - The reference ID of the invoice to download
   */
  async downloadInvoice(referenceId) {
    try {
      log(`\u{1F4E5} Downloading invoice from e-Factura for reference: ${referenceId}`, "e-factura");
      const response = await this.httpClient.get(`/download/${referenceId}`, {
        responseType: "arraybuffer"
      });
      log(`\u2705 Successfully downloaded invoice from e-Factura`, "e-factura");
      return Buffer.from(response);
    } catch (error) {
      log(`\u274C Error downloading invoice from e-Factura: ${error.message}`, "e-factura");
      throw new Error(`Failed to download invoice: ${error.message}`);
    }
  }
};
var eFacturaService = new EFacturaService();

// server/modules/integrations/routes/index.ts
import express5 from "express";

// server/modules/integrations/routes/pandadoc.route.ts
import express3 from "express";

// server/modules/integrations/clients/index.ts
var clients_exports = {};
__export(clients_exports, {
  AnafEfacturaClient: () => AnafEfacturaClient,
  BaseIntegrationClient: () => BaseIntegrationClient,
  ElevenLabsClient: () => ElevenLabsClient,
  MicrosoftGraphClient: () => MicrosoftGraphClient,
  OpenAIClient: () => OpenAIClient,
  PandaDocClient: () => PandaDocClient,
  RevolutBusinessClient: () => RevolutBusinessClient,
  SameDayClient: () => SameDayClient,
  ShopifyClient: () => ShopifyClient,
  ShopifyIntegrationType: () => ShopifyIntegrationType,
  StripeClient: () => StripeClient,
  TermeneRoClient: () => TermeneRoClient,
  getIntegrationClient: () => getIntegrationClient
});

// server/modules/integrations/clients/base-integration.client.ts
var BaseIntegrationClient = class {
  /**
   * Initialize the base integration client
   * @param provider Integration provider type
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID for multi-company setups
   */
  constructor(provider, companyId, franchiseId) {
    this.provider = provider;
    this.companyId = companyId;
    this.franchiseId = franchiseId;
    this.integrationsService = new IntegrationsService();
  }
  /**
   * Get the integration record
   */
  async getIntegrationRecord() {
    const existingIntegration = await this.integrationsService.getIntegrationByProvider(
      this.provider,
      this.companyId,
      this.franchiseId
    );
    return existingIntegration;
  }
  /**
   * Create a new integration record
   * @param config Configuration object with API keys and settings
   * @param userId User ID creating the integration
   */
  async createIntegrationRecord(config3, userId, webhookUrl, webhookSecret) {
    return await this.integrationsService.createIntegration(
      this.provider,
      this.companyId,
      config3,
      userId,
      this.franchiseId,
      void 0,
      // name
      void 0,
      // description
      webhookUrl,
      webhookSecret
    );
  }
  /**
   * Update an integration record
   * @param integrationId Integration ID to update
   * @param updates Fields to update
   * @param userId User ID performing the update
   */
  async updateIntegrationRecord(integrationId, updates, userId) {
    return await this.integrationsService.updateIntegration(
      integrationId,
      this.companyId,
      updates,
      userId
    );
  }
  /**
   * Update integration status
   * @param integrationId Integration ID
   * @param status New status
   * @param userId User ID updating the status
   */
  async updateStatus(integrationId, status, userId) {
    await this.integrationsService.updateIntegrationStatus(
      integrationId,
      this.companyId,
      status,
      userId
    );
  }
  /**
   * Update last synced timestamp
   * @param integrationId Integration ID
   * @param userId User ID who initiated the sync
   */
  async updateLastSynced(integrationId, userId) {
    await this.integrationsService.updateLastSyncedAt(
      integrationId,
      this.companyId,
      userId
    );
  }
};

// server/modules/integrations/clients/pandadoc.client.ts
import axios5 from "axios";
import * as fs6 from "fs";
import FormData from "form-data";
init_integrations_schema();
var PandaDocClient = class extends BaseIntegrationClient {
  /**
   * Initialize PandaDoc client
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(companyId, franchiseId) {
    super(IntegrationProvider.PANDADOC, companyId, franchiseId);
    this.apiUrl = "https://api.pandadoc.com/public/v1";
    this.integration = null;
    this.axios = axios5.create({
      baseURL: this.apiUrl,
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
  /**
   * Initialize integration with PandaDoc
   * @param apiKey PandaDoc API key
   * @param userId User ID initializing the integration
   */
  async initialize(apiKey, userId) {
    try {
      const existingIntegration = await this.getIntegrationRecord();
      if (existingIntegration) {
        throw new Error("PandaDoc integration already exists for this company");
      }
      await this.testConnection(apiKey);
      const integration = await this.createIntegrationRecord(
        { apiKey },
        userId
      );
      this.integration = integration;
      await this.updateStatus(
        integration.id,
        "active" /* ACTIVE */,
        userId
      );
      return integration;
    } catch (error) {
      throw new Error(`Failed to initialize PandaDoc integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Test connection to PandaDoc API
   * @param apiKey Optional API key to use for testing
   */
  async testConnection(apiKey) {
    try {
      if (!apiKey) {
        const integration = await this.getIntegrationRecord();
        if (!integration) {
          throw new Error("PandaDoc integration not found");
        }
        this.integration = integration;
        apiKey = integration.config.apiKey;
      }
      if (!apiKey) {
        throw new Error("API key not found");
      }
      await this.axios.get("/templates", {
        headers: {
          "Authorization": `API-Key ${apiKey}`
        }
      });
      return true;
    } catch (error) {
      console.error("[PandaDocClient] Connection test failed:", error instanceof Error ? error.message : String(error));
      return false;
    }
  }
  /**
   * List templates available in PandaDoc
   * @param userId User ID making the request
   */
  async listTemplates(userId) {
    try {
      const integration = await this.ensureIntegration();
      const response = await this.axios.get("/templates", {
        headers: {
          "Authorization": `API-Key ${integration.config.apiKey}`
        }
      });
      await this.updateLastSynced(integration.id, userId);
      return response.data.results;
    } catch (error) {
      throw new Error(`Failed to list templates: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get template details
   * @param templateId Template ID
   * @param userId User ID making the request
   */
  async getTemplate(templateId, userId) {
    try {
      const integration = await this.ensureIntegration();
      const response = await this.axios.get(`/templates/${templateId}`, {
        headers: {
          "Authorization": `API-Key ${integration.config.apiKey}`
        }
      });
      await this.updateLastSynced(integration.id, userId);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get template details: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Create document from template
   * @param name Document name
   * @param templateId Template ID
   * @param recipients Document recipients
   * @param metadata Document metadata
   * @param tokens Template tokens to replace
   * @param fields Template fields to fill
   * @param tags Document tags
   * @param pricingTables Pricing tables data
   * @param userId User ID creating the document
   */
  async createDocumentFromTemplate(name, templateId, recipients, metadata, tokens, fields, tags2, pricingTables, userId) {
    try {
      const integration = await this.ensureIntegration();
      const payload = {
        name,
        template_uuid: templateId,
        recipients,
        metadata,
        tokens,
        fields,
        tags: tags2,
        pricing_tables: pricingTables
      };
      const response = await this.axios.post("/documents", payload, {
        headers: {
          "Authorization": `API-Key ${integration.config.apiKey}`
        }
      });
      if (userId) {
        await this.updateLastSynced(integration.id, userId);
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create document from template: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Create document from PDF file
   * @param name Document name
   * @param filePath Path to PDF file
   * @param recipients Document recipients
   * @param metadata Document metadata
   * @param tags Document tags
   * @param fields Document fields
   * @param userId User ID creating the document
   */
  async createDocumentFromPdf(name, filePath, recipients, metadata, tags2, fields, userId) {
    try {
      const integration = await this.ensureIntegration();
      const formData = new FormData();
      formData.append("file", fs6.createReadStream(filePath));
      formData.append("name", name);
      formData.append("recipients", JSON.stringify(recipients));
      if (metadata) {
        formData.append("metadata", JSON.stringify(metadata));
      }
      if (tags2) {
        formData.append("tags", JSON.stringify(tags2));
      }
      if (fields) {
        formData.append("fields", JSON.stringify(fields));
      }
      const response = await this.axios.post("/documents", formData, {
        headers: {
          "Authorization": `API-Key ${integration.config.apiKey}`,
          "Content-Type": `multipart/form-data; boundary=${formData.getBoundary()}`
        }
      });
      if (userId) {
        await this.updateLastSynced(integration.id, userId);
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create document from PDF: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Create document from buffer
   * @param name Document name
   * @param fileBuffer PDF file buffer
   * @param fileName Filename
   * @param recipients Document recipients
   * @param metadata Document metadata
   * @param tags Document tags
   * @param fields Document fields
   * @param userId User ID creating the document
   */
  async createDocumentFromBuffer(name, fileBuffer, fileName, recipients, metadata, tags2, fields, userId) {
    try {
      const integration = await this.ensureIntegration();
      const formData = new FormData();
      formData.append("file", fileBuffer, { filename: fileName });
      formData.append("name", name);
      formData.append("recipients", JSON.stringify(recipients));
      if (metadata) {
        formData.append("metadata", JSON.stringify(metadata));
      }
      if (tags2) {
        formData.append("tags", JSON.stringify(tags2));
      }
      if (fields) {
        formData.append("fields", JSON.stringify(fields));
      }
      const response = await this.axios.post("/documents", formData, {
        headers: {
          "Authorization": `API-Key ${integration.config.apiKey}`,
          "Content-Type": `multipart/form-data; boundary=${formData.getBoundary()}`
        }
      });
      if (userId) {
        await this.updateLastSynced(integration.id, userId);
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create document from buffer: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get document details
   * @param documentId Document ID
   * @param userId User ID making the request
   */
  async getDocument(documentId, userId) {
    try {
      const integration = await this.ensureIntegration();
      const response = await this.axios.get(`/documents/${documentId}`, {
        headers: {
          "Authorization": `API-Key ${integration.config.apiKey}`
        }
      });
      await this.updateLastSynced(integration.id, userId);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get document details: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get document status
   * @param documentId Document ID
   * @param userId User ID making the request
   */
  async getDocumentStatus(documentId, userId) {
    try {
      const document = await this.getDocument(documentId, userId);
      const statusResponse = {
        id: document.id,
        status: document.status,
        statusTimestamps: {}
        // We don't have timestamp details from the document endpoint
      };
      return statusResponse;
    } catch (error) {
      throw new Error(`Failed to get document status: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Download document
   * @param documentId Document ID
   * @param userId User ID making the request
   */
  async downloadDocument(documentId, userId) {
    try {
      const integration = await this.ensureIntegration();
      const response = await this.axios.get(`/documents/${documentId}/download`, {
        headers: {
          "Authorization": `API-Key ${integration.config.apiKey}`
        },
        responseType: "arraybuffer"
      });
      await this.updateLastSynced(integration.id, userId);
      return Buffer.from(response.data);
    } catch (error) {
      throw new Error(`Failed to download document: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Send document for signing
   * @param documentId Document ID
   * @param subject Email subject
   * @param message Email message
   * @param silent Whether to send without email
   * @param userId User ID making the request
   */
  async sendDocument(documentId, subject, message, silent = false, userId) {
    try {
      const integration = await this.ensureIntegration();
      const payload = {
        subject,
        message,
        silent
      };
      const response = await this.axios.post(`/documents/${documentId}/send`, payload, {
        headers: {
          "Authorization": `API-Key ${integration.config.apiKey}`
        }
      });
      if (userId) {
        await this.updateLastSynced(integration.id, userId);
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to send document: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Create a document session (for embedding)
   * @param documentId Document ID
   * @param recipient Recipient email
   * @param lifetime Session lifetime in seconds
   * @param userId User ID making the request
   */
  async createDocumentSession(documentId, recipient, lifetime = 3600, userId) {
    try {
      const integration = await this.ensureIntegration();
      const payload = {
        recipient,
        lifetime
      };
      const response = await this.axios.post(`/documents/${documentId}/session`, payload, {
        headers: {
          "Authorization": `API-Key ${integration.config.apiKey}`
        }
      });
      if (userId) {
        await this.updateLastSynced(integration.id, userId);
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create document session: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Ensure integration is available
   */
  async ensureIntegration() {
    if (this.integration) {
      return this.integration;
    }
    const integration = await this.getIntegrationRecord();
    if (!integration) {
      throw new Error("PandaDoc integration not found. Initialize the integration first.");
    }
    this.integration = integration;
    return integration;
  }
};

// server/modules/integrations/clients/anaf-efactura.client.ts
init_integrations_schema();
import axios6 from "axios";
var AnafEfacturaClient = class extends BaseIntegrationClient {
  /**
   * Constructor
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(companyId, franchiseId) {
    super(IntegrationProvider.ANAF_EFACTURA, companyId, franchiseId);
  }
  /**
   * Initialize integration with provided credentials
   * @param apiKey API key for ANAF oauth authorization
   * @param clientId Client ID for ANAF oauth authorization
   * @param clientSecret Client secret for ANAF oauth authorization
   * @param apiUrl API URL (optional, defaults to production URL)
   * @param userId User ID for audit
   * @returns Created integration configuration
   */
  async initialize(apiKey, clientId, clientSecret, apiUrl = "https://api.anaf.ro/prod/FCTEL/rest", userId) {
    try {
      const isConnected = await this.isConnected();
      if (isConnected) {
        throw new Error("ANAF e-Factura integration already connected");
      }
      const config3 = {
        apiKey,
        clientId,
        clientSecret,
        apiUrl,
        lastSyncAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const integration = await this.integrationsService.createIntegration(
        this.provider,
        this.companyId,
        config3,
        userId,
        this.franchiseId
      );
      const isValid = await this.testConnection();
      if (!isValid) {
        await this.updateStatus("error" /* ERROR */, userId);
        throw new Error("Could not connect to ANAF e-Factura API, please check your credentials");
      }
      return integration;
    } catch (error) {
      console.error("[AnafEfacturaClient] Error initializing integration:", error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Test the connection to ANAF e-Factura API
   * @returns Boolean indicating if the connection test succeeded
   */
  async testConnection() {
    try {
      const config3 = await this.getConfig();
      if (!config3) {
        return false;
      }
      const accessToken = await this.getAccessToken();
      if (!accessToken) {
        return false;
      }
      const response = await axios6.get(`${config3.apiUrl}/account/info`, {
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": "application/json"
        }
      });
      return response.status === 200;
    } catch (error) {
      console.error("[AnafEfacturaClient] Error testing connection:", error instanceof Error ? error.message : String(error));
      return false;
    }
  }
  /**
   * Get an access token for API operations
   * @returns Access token or null if failed
   */
  async getAccessToken() {
    try {
      const config3 = await this.getConfig();
      if (!config3) {
        throw new Error("Integration not configured");
      }
      if (config3.accessToken && config3.tokenExpiresAt && new Date(config3.tokenExpiresAt) > /* @__PURE__ */ new Date()) {
        return config3.accessToken;
      }
      const response = await axios6.post(
        `${config3.apiUrl}/oauth2/token`,
        {
          grant_type: "client_credentials",
          client_id: config3.clientId,
          client_secret: config3.clientSecret
        },
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "x-api-key": config3.apiKey
          }
        }
      );
      if (response.status !== 200 || !response.data.access_token) {
        throw new Error("Failed to get access token");
      }
      const expiresIn = response.data.expires_in || 3600;
      const tokenExpiresAt = /* @__PURE__ */ new Date();
      tokenExpiresAt.setSeconds(tokenExpiresAt.getSeconds() + expiresIn - 60);
      await this.updateConfig(
        {
          accessToken: response.data.access_token,
          tokenExpiresAt: tokenExpiresAt.toISOString()
        },
        "system"
        // Using 'system' as the user ID for system operations
      );
      return response.data.access_token;
    } catch (error) {
      console.error("[AnafEfacturaClient] Error getting access token:", error instanceof Error ? error.message : String(error));
      return null;
    }
  }
  /**
   * Send an invoice to ANAF e-Factura
   * @param invoiceXml Invoice XML in UBL format
   * @param userId User ID for audit
   * @returns Response from ANAF or error
   */
  async sendInvoice(invoiceXml, userId) {
    try {
      const config3 = await this.getConfig();
      if (!config3) {
        throw new Error("Integration not configured");
      }
      const accessToken = await this.getAccessToken();
      if (!accessToken) {
        throw new Error("Failed to get access token");
      }
      const response = await axios6.post(
        `${config3.apiUrl}/upload`,
        {
          xml_data: invoiceXml
        },
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
            "x-api-key": config3.apiKey
          }
        }
      );
      await this.updateLastSync(userId);
      return response.data;
    } catch (error) {
      console.error("[AnafEfacturaClient] Error sending invoice:", error instanceof Error ? error.message : String(error));
      if (axios6.isAxiosError(error) && (error.response?.status === 401 || error.response?.status === 403)) {
        await this.updateStatus("error" /* ERROR */, userId);
      }
      throw error;
    }
  }
  /**
   * Get invoices from ANAF e-Factura
   * @param startDate Start date for invoice filter (ISO format)
   * @param endDate End date for invoice filter (ISO format)
   * @param userId User ID for audit
   * @returns List of invoices
   */
  async getInvoices(startDate, endDate, userId) {
    try {
      const config3 = await this.getConfig();
      if (!config3) {
        throw new Error("Integration not configured");
      }
      const accessToken = await this.getAccessToken();
      if (!accessToken) {
        throw new Error("Failed to get access token");
      }
      const response = await axios6.get(
        `${config3.apiUrl}/invoices`,
        {
          params: {
            startDate,
            endDate
          },
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
            "x-api-key": config3.apiKey
          }
        }
      );
      await this.updateLastSync(userId);
      return response.data;
    } catch (error) {
      console.error("[AnafEfacturaClient] Error getting invoices:", error instanceof Error ? error.message : String(error));
      if (axios6.isAxiosError(error) && (error.response?.status === 401 || error.response?.status === 403)) {
        await this.updateStatus("error" /* ERROR */, userId);
      }
      throw error;
    }
  }
  /**
   * Get a specific invoice by ID
   * @param invoiceId Invoice ID
   * @param userId User ID for audit
   * @returns Invoice data
   */
  async getInvoice(invoiceId, userId) {
    try {
      const config3 = await this.getConfig();
      if (!config3) {
        throw new Error("Integration not configured");
      }
      const accessToken = await this.getAccessToken();
      if (!accessToken) {
        throw new Error("Failed to get access token");
      }
      const response = await axios6.get(
        `${config3.apiUrl}/invoices/${invoiceId}`,
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
            "x-api-key": config3.apiKey
          }
        }
      );
      return response.data;
    } catch (error) {
      console.error("[AnafEfacturaClient] Error getting invoice:", error instanceof Error ? error.message : String(error));
      if (axios6.isAxiosError(error) && (error.response?.status === 401 || error.response?.status === 403)) {
        await this.updateStatus("error" /* ERROR */, userId);
      }
      throw error;
    }
  }
  /**
   * Get the status of a specific invoice
   * @param invoiceId Invoice ID
   * @param userId User ID for audit
   * @returns Invoice status
   */
  async getInvoiceStatus(invoiceId, userId) {
    try {
      const config3 = await this.getConfig();
      if (!config3) {
        throw new Error("Integration not configured");
      }
      const accessToken = await this.getAccessToken();
      if (!accessToken) {
        throw new Error("Failed to get access token");
      }
      const response = await axios6.get(
        `${config3.apiUrl}/invoices/${invoiceId}/status`,
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
            "x-api-key": config3.apiKey
          }
        }
      );
      return response.data;
    } catch (error) {
      console.error("[AnafEfacturaClient] Error getting invoice status:", error instanceof Error ? error.message : String(error));
      if (axios6.isAxiosError(error) && (error.response?.status === 401 || error.response?.status === 403)) {
        await this.updateStatus("error" /* ERROR */, userId);
      }
      throw error;
    }
  }
  /**
   * Download invoice XML
   * @param invoiceId Invoice ID
   * @param userId User ID for audit
   * @returns Invoice XML content
   */
  async downloadInvoiceXml(invoiceId, userId) {
    try {
      const config3 = await this.getConfig();
      if (!config3) {
        throw new Error("Integration not configured");
      }
      const accessToken = await this.getAccessToken();
      if (!accessToken) {
        throw new Error("Failed to get access token");
      }
      const response = await axios6.get(
        `${config3.apiUrl}/invoices/${invoiceId}/download`,
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
            "x-api-key": config3.apiKey
          }
        }
      );
      return response.data;
    } catch (error) {
      console.error("[AnafEfacturaClient] Error downloading invoice XML:", error instanceof Error ? error.message : String(error));
      if (axios6.isAxiosError(error) && (error.response?.status === 401 || error.response?.status === 403)) {
        await this.updateStatus("error" /* ERROR */, userId);
      }
      throw error;
    }
  }
};

// server/modules/integrations/clients/stripe.client.ts
init_logger();
init_integrations_schema();
import Stripe2 from "stripe";
var logger67 = new Logger("StripeClient");
var StripeClient = class extends BaseIntegrationClient {
  /**
   * Constructor
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(companyId, franchiseId) {
    super("stripe" /* STRIPE */, companyId, franchiseId);
    this.apiVersion = "2023-10-16";
    this.stripe = null;
    logger67.info("StripeClient initialized for company", { companyId, franchiseId });
  }
  /**
   * Initialize integration with provided credentials
   * @param apiKey Stripe API key
   * @param webhookSecret Stripe webhook secret
   * @param userId User ID for audit
   * @returns Created integration configuration
   */
  async initialize(apiKey, webhookSecret, userId) {
    try {
      const isConnected = await this.isConnected();
      if (isConnected) {
        throw new Error("Stripe integration already connected");
      }
      const config3 = {
        apiKey,
        webhookSecret,
        apiVersion: this.apiVersion
      };
      const integration = await this.integrationsService.createIntegration(
        this.provider,
        this.companyId,
        config3,
        userId,
        this.franchiseId
      );
      const isValid = await this.testConnection();
      if (!isValid) {
        await this.updateStatus("error" /* ERROR */, userId);
        throw new Error("Could not connect to Stripe API, please check your credentials");
      }
      return integration;
    } catch (error) {
      logger67.error("Error initializing Stripe integration", {
        error: error instanceof Error ? error.message : String(error),
        companyId: this.companyId
      });
      throw error;
    }
  }
  /**
   * Get Stripe instance
   * @returns Configured Stripe instance
   */
  async getStripeInstance() {
    if (this.stripe) {
      return this.stripe;
    }
    const config3 = await this.getIntegrationConfig();
    if (!config3 || !config3.apiKey) {
      throw new Error("Stripe integration not configured");
    }
    this.stripe = new Stripe2(config3.apiKey, {
      apiVersion: config3.apiVersion || this.apiVersion
    });
    return this.stripe;
  }
  /**
   * Test the connection to Stripe API
   * @returns Boolean indicating if the connection test succeeded
   */
  async testConnection() {
    try {
      const stripe = await this.getStripeInstance();
      const account = await stripe.accounts.retrieve();
      return !!account.id;
    } catch (error) {
      logger67.error("Error testing Stripe connection", {
        error: error instanceof Error ? error.message : String(error),
        companyId: this.companyId
      });
      return false;
    }
  }
  /**
   * Create a payment intent
   * @param amount Amount in the smallest currency unit (e.g., cents for USD)
   * @param currency Three-letter ISO currency code
   * @param description Payment description
   * @param metadata Optional metadata
   * @param customerId Optional Stripe customer ID
   * @param paymentMethodId Optional payment method ID
   * @param userId User ID for audit
   * @returns Created payment intent
   */
  async createPaymentIntent(amount, currency, description, metadata = {}, customerId, paymentMethodId, userId) {
    try {
      const stripe = await this.getStripeInstance();
      const params = {
        amount,
        currency,
        description,
        metadata
      };
      if (customerId) {
        params.customer = customerId;
      }
      if (paymentMethodId) {
        params.payment_method = paymentMethodId;
        params.confirm = true;
      }
      const paymentIntent = await stripe.paymentIntents.create(params);
      if (userId) {
        await this.updateLastSynced(userId);
      }
      const result = {
        id: paymentIntent.id,
        amount: paymentIntent.amount,
        currency: paymentIntent.currency,
        paymentMethod: paymentIntent.payment_method,
        paymentMethodType: paymentIntent.payment_method_types?.[0] || "card",
        customerId: paymentIntent.customer,
        description: paymentIntent.description || "",
        metadata: paymentIntent.metadata,
        status: paymentIntent.status,
        clientSecret: paymentIntent.client_secret || void 0,
        createdAt: new Date(paymentIntent.created * 1e3).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      logger67.info("Payment intent created successfully", {
        paymentIntentId: result.id,
        amount: result.amount,
        currency: result.currency
      });
      return result;
    } catch (error) {
      logger67.error("Error creating payment intent", {
        error: error instanceof Error ? error.message : String(error),
        amount,
        currency,
        companyId: this.companyId
      });
      if (error instanceof Stripe2.errors.StripeAuthenticationError) {
        await this.updateStatus("error" /* ERROR */, userId || "system");
      }
      throw error;
    }
  }
  /**
   * Get payment intent by ID
   * @param paymentIntentId Payment intent ID
   * @param userId User ID for audit
   * @returns Payment intent data
   */
  async getPaymentIntent(paymentIntentId, userId) {
    try {
      const stripe = await this.getStripeInstance();
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId, {
        expand: ["charges"]
      });
      const charges = paymentIntent.charges;
      const receiptUrl = charges?.data?.[0]?.receipt_url;
      const result = {
        id: paymentIntent.id,
        amount: paymentIntent.amount,
        currency: paymentIntent.currency,
        paymentMethod: paymentIntent.payment_method,
        paymentMethodType: paymentIntent.payment_method_types?.[0] || "card",
        customerId: paymentIntent.customer,
        description: paymentIntent.description || "",
        metadata: paymentIntent.metadata,
        status: paymentIntent.status,
        clientSecret: paymentIntent.client_secret || void 0,
        receiptUrl,
        createdAt: new Date(paymentIntent.created * 1e3).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      return result;
    } catch (error) {
      logger67.error("Error retrieving payment intent", {
        error: error instanceof Error ? error.message : String(error),
        paymentIntentId,
        companyId: this.companyId
      });
      if (error instanceof Stripe2.errors.StripeAuthenticationError) {
        await this.updateStatus("error" /* ERROR */, userId);
      }
      throw error;
    }
  }
  /**
   * Create a Stripe customer
   * @param name Customer name
   * @param email Customer email
   * @param phone Optional customer phone
   * @param address Optional customer address
   * @param metadata Optional metadata
   * @param userId User ID for audit
   * @returns Created customer
   */
  async createCustomer(name, email, phone, address, metadata = {}, userId) {
    try {
      const stripe = await this.getStripeInstance();
      const params = {
        name,
        email,
        metadata
      };
      if (phone) {
        params.phone = phone;
      }
      if (address) {
        params.address = {
          line1: address.line1,
          line2: address.line2,
          city: address.city,
          state: address.state,
          postal_code: address.postalCode,
          country: address.country
        };
      }
      const customer = await stripe.customers.create(params);
      if (userId) {
        await this.updateLastSynced(userId);
      }
      const result = {
        id: customer.id,
        name: customer.name || "",
        email: customer.email || "",
        phone: customer.phone || void 0,
        address: customer.address ? {
          line1: customer.address.line1 || void 0,
          line2: customer.address.line2 || void 0,
          city: customer.address.city || void 0,
          state: customer.address.state || void 0,
          postalCode: customer.address.postal_code || void 0,
          country: customer.address.country || void 0
        } : void 0,
        metadata: customer.metadata,
        defaultPaymentMethodId: customer.invoice_settings?.default_payment_method,
        createdAt: new Date(customer.created * 1e3).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      logger67.info("Customer created successfully", {
        customerId: result.id,
        email: result.email
      });
      return result;
    } catch (error) {
      logger67.error("Error creating customer", {
        error: error instanceof Error ? error.message : String(error),
        name,
        email,
        companyId: this.companyId
      });
      if (error instanceof Stripe2.errors.StripeAuthenticationError) {
        await this.updateStatus("error" /* ERROR */, userId || "system");
      }
      throw error;
    }
  }
  /**
   * Get customer by ID
   * @param customerId Customer ID
   * @param userId User ID for audit
   * @returns Customer data
   */
  async getCustomer(customerId, userId) {
    try {
      const stripe = await this.getStripeInstance();
      const customer = await stripe.customers.retrieve(customerId);
      if (customer.deleted) {
        throw new Error("Customer has been deleted");
      }
      const result = {
        id: customer.id,
        name: customer.name || "",
        email: customer.email || "",
        phone: customer.phone || void 0,
        address: customer.address ? {
          line1: customer.address.line1 || void 0,
          line2: customer.address.line2 || void 0,
          city: customer.address.city || void 0,
          state: customer.address.state || void 0,
          postalCode: customer.address.postal_code || void 0,
          country: customer.address.country || void 0
        } : void 0,
        metadata: customer.metadata,
        defaultPaymentMethodId: customer.invoice_settings?.default_payment_method,
        createdAt: new Date(customer.created * 1e3).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      return result;
    } catch (error) {
      logger67.error("Error retrieving customer", {
        error: error instanceof Error ? error.message : String(error),
        customerId,
        companyId: this.companyId
      });
      if (error instanceof Stripe2.errors.StripeAuthenticationError) {
        await this.updateStatus("error" /* ERROR */, userId);
      }
      throw error;
    }
  }
  /**
   * Verify Stripe webhook signature
   * @param payload Request body as a string
   * @param signature Stripe signature from the request headers
   * @returns Boolean indicating if the signature is valid
   */
  async verifyWebhookSignature(payload, signature) {
    try {
      const stripe = await this.getStripeInstance();
      const config3 = await this.getIntegrationConfig();
      if (!config3?.webhookSecret) {
        logger67.warn("Webhook secret not configured for Stripe integration", { companyId: this.companyId });
        return false;
      }
      const event = stripe.webhooks.constructEvent(
        payload,
        signature,
        config3.webhookSecret
      );
      logger67.info("Webhook signature verified successfully", {
        eventType: event.type,
        eventId: event.id
      });
      return true;
    } catch (error) {
      logger67.error("Error verifying webhook signature", {
        error: error instanceof Error ? error.message : String(error),
        companyId: this.companyId
      });
      return false;
    }
  }
  /**
   * Get integration configuration
   * @returns Integration configuration or null if not found
   */
  async getIntegrationConfig() {
    try {
      const integration = await this.integrationsService.getIntegrationByProvider(
        this.provider,
        this.companyId,
        this.franchiseId
      );
      if (integration && integration.config) {
        return integration.config;
      }
      const envApiKey = process.env.STRIPE_SECRET_KEY;
      const envWebhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
      if (envApiKey) {
        logger67.info("Using Stripe API key from environment variables", {
          companyId: this.companyId,
          usingEnvVars: true
        });
        return {
          apiKey: envApiKey,
          webhookSecret: envWebhookSecret,
          apiVersion: this.apiVersion
        };
      }
      return null;
    } catch (error) {
      logger67.error("Error retrieving integration configuration", {
        error: error instanceof Error ? error.message : String(error),
        provider: this.provider,
        companyId: this.companyId
      });
      return null;
    }
  }
  /**
   * Update last synced timestamp
   * @param userId User ID for audit
   */
  async updateLastSynced(userId) {
    try {
      await this.integrationsService.updateLastSyncedAt(
        this.provider,
        this.companyId,
        userId,
        this.franchiseId
      );
    } catch (error) {
      logger67.warn("Error updating last synced timestamp", {
        error: error instanceof Error ? error.message : String(error),
        provider: this.provider,
        companyId: this.companyId
      });
    }
  }
};

// server/modules/integrations/clients/revolut-business.client.ts
import axios7 from "axios";
import { v4 as uuidv428 } from "uuid";
init_integrations_schema();
var RevolutBusinessClient = class _RevolutBusinessClient extends BaseIntegrationClient {
  static {
    this.BASE_SANDBOX_URL = "https://sandbox-b2b.revolut.com/api/1.0";
  }
  static {
    this.BASE_PRODUCTION_URL = "https://b2b.revolut.com/api/1.0";
  }
  /**
   * Initialize the Revolut Business client
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(companyId, franchiseId) {
    super(IntegrationProvider.REVOLUT_BUSINESS, companyId, franchiseId);
  }
  /**
   * Initialize the Revolut Business integration
   * @param apiKey Revolut Business API key
   * @param environment API environment (sandbox or production)
   * @param userId User ID initializing the integration
   * @param webhookUrl Optional webhook URL for notifications
   * @param webhookSecret Optional webhook secret for signature verification
   */
  async initialize(apiKey, environment = "sandbox" /* SANDBOX */, userId, webhookUrl, webhookSecret) {
    try {
      const existingIntegration = await this.getIntegrationRecord();
      if (existingIntegration) {
        const updatedIntegration = await this.updateIntegrationRecord(
          existingIntegration.id,
          {
            config: {
              apiKey,
              environment,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            },
            isConnected: true,
            status: "active" /* ACTIVE */,
            webhookUrl,
            webhookSecret
          },
          userId
        );
        return updatedIntegration || existingIntegration;
      }
      const integration = await this.createIntegrationRecord(
        {
          apiKey,
          environment,
          lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
        },
        userId,
        webhookUrl,
        webhookSecret
      );
      const isConnected = await this.testConnection();
      if (isConnected) {
        await this.updateStatus(integration.id, "active" /* ACTIVE */, userId);
      } else {
        await this.updateStatus(integration.id, "error" /* ERROR */, userId);
        throw new Error("Failed to connect to Revolut Business API");
      }
      return integration;
    } catch (error) {
      throw new Error(`Failed to initialize Revolut Business integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Test the connection to Revolut Business API
   */
  async testConnection() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        return false;
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      const environment = config3.environment || "sandbox" /* SANDBOX */;
      if (!apiKey) {
        return false;
      }
      const baseUrl = environment === "production" /* PRODUCTION */ ? _RevolutBusinessClient.BASE_PRODUCTION_URL : _RevolutBusinessClient.BASE_SANDBOX_URL;
      const response = await axios7.get(`${baseUrl}/accounts`, {
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        }
      });
      const isConnected = response.status === 200;
      if (isConnected && integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: true,
            status: "active" /* ACTIVE */,
            config: {
              ...config3,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            }
          },
          "system"
        );
      }
      return isConnected;
    } catch (error) {
      if (error instanceof Error) {
        console.error(`Revolut Business connection test failed: ${error.message}`);
      }
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...integration.config,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString(),
              lastError: error instanceof Error ? error.message : String(error)
            }
          },
          "system"
        );
      }
      return false;
    }
  }
  /**
   * Get account information
   */
  async getAccounts() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      const environment = config3.environment || "sandbox" /* SANDBOX */;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const baseUrl = environment === "production" /* PRODUCTION */ ? _RevolutBusinessClient.BASE_PRODUCTION_URL : _RevolutBusinessClient.BASE_SANDBOX_URL;
      const response = await axios7.get(`${baseUrl}/accounts`, {
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        }
      });
      await this.updateLastSynced(integration.id, "system");
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get Revolut accounts: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Create a payment
   * @param fromAccountId Source account ID
   * @param amount Amount to transfer
   * @param currency Currency code (e.g., RON, EUR, USD)
   * @param toAccountId Destination account ID (for internal transfers)
   * @param recipientId Recipient ID (for external transfers)
   * @param reference Payment reference
   */
  async createPayment(fromAccountId, amount, currency, toAccountId, recipientId, reference) {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      const environment = config3.environment || "sandbox" /* SANDBOX */;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const baseUrl = environment === "production" /* PRODUCTION */ ? _RevolutBusinessClient.BASE_PRODUCTION_URL : _RevolutBusinessClient.BASE_SANDBOX_URL;
      const payload = {
        request_id: uuidv428(),
        account_id: fromAccountId,
        amount,
        currency,
        reference: reference || `Payment ${(/* @__PURE__ */ new Date()).toISOString()}`
      };
      if (toAccountId) {
        payload.receiver = { account_id: toAccountId };
      } else if (recipientId) {
        payload.receiver = { counterparty_id: recipientId };
      } else {
        throw new Error("Either toAccountId or recipientId must be provided");
      }
      const response = await axios7.post(`${baseUrl}/pay`, payload, {
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        }
      });
      await this.updateLastSynced(integration.id, "system");
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create Revolut payment: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get transactions for an account
   * @param accountId Account ID
   * @param from Start date (ISO string)
   * @param to End date (ISO string)
   * @param count Maximum number of transactions
   */
  async getTransactions(accountId, from, to, count5) {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      const environment = config3.environment || "sandbox" /* SANDBOX */;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const baseUrl = environment === "production" /* PRODUCTION */ ? _RevolutBusinessClient.BASE_PRODUCTION_URL : _RevolutBusinessClient.BASE_SANDBOX_URL;
      const params = {};
      if (from) params.from = from;
      if (to) params.to = to;
      if (count5) params.count = count5;
      const queryString = new URLSearchParams(params).toString();
      const response = await axios7.get(
        `${baseUrl}/accounts/${accountId}/transactions${queryString ? `?${queryString}` : ""}`,
        {
          headers: {
            "Authorization": `Bearer ${apiKey}`,
            "Content-Type": "application/json"
          }
        }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get Revolut transactions: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/integrations/clients/microsoft-graph.client.ts
import axios8 from "axios";
import { v4 as uuidv429 } from "uuid";
init_integrations_schema();
var MicrosoftGraphClient = class _MicrosoftGraphClient extends BaseIntegrationClient {
  static {
    this.AUTH_URL = "https://login.microsoftonline.com/common/oauth2/v2.0/authorize";
  }
  static {
    this.TOKEN_URL = "https://login.microsoftonline.com/common/oauth2/v2.0/token";
  }
  static {
    this.API_URL = "https://graph.microsoft.com/v1.0";
  }
  /**
   * Initialize the Microsoft Graph client
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(companyId, franchiseId) {
    super(IntegrationProvider.MICROSOFT_GRAPH, companyId, franchiseId);
  }
  /**
   * Initialize the Microsoft Graph integration
   * @param clientId Microsoft app client ID
   * @param clientSecret Microsoft app client secret
   * @param tenantId Microsoft tenant ID
   * @param redirectUri OAuth redirect URI
   * @param scopes API permission scopes
   * @param userId User ID initializing the integration
   * @param webhookUrl Optional webhook URL for notifications
   * @param webhookSecret Optional webhook secret for signature verification
   */
  async initialize(clientId, clientSecret, tenantId, redirectUri, scopes = ["Mail.Read Mail.Send" /* EMAIL */, "User.Read" /* USER_INFO */], userId, webhookUrl, webhookSecret) {
    try {
      const existingIntegration = await this.getIntegrationRecord();
      if (existingIntegration) {
        const updatedIntegration = await this.updateIntegrationRecord(
          existingIntegration.id,
          {
            config: {
              clientId,
              clientSecret,
              tenantId,
              redirectUri,
              scopes,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            },
            isConnected: false,
            // Requires OAuth flow to be completed
            status: "pending" /* PENDING */,
            webhookUrl,
            webhookSecret
          },
          userId
        );
        return updatedIntegration || existingIntegration;
      }
      const integration = await this.createIntegrationRecord(
        {
          clientId,
          clientSecret,
          tenantId,
          redirectUri,
          scopes,
          lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
        },
        userId,
        webhookUrl,
        webhookSecret
      );
      return integration;
    } catch (error) {
      throw new Error(`Failed to initialize Microsoft Graph integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Complete OAuth flow after user grants permission
   * @param code Authorization code from OAuth redirect
   * @param userId User ID completing the OAuth flow
   */
  async completeOAuthFlow(code, userId) {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const clientId = config3.clientId;
      const clientSecret = config3.clientSecret;
      const redirectUri = config3.redirectUri;
      if (!clientId || !clientSecret || !redirectUri) {
        throw new Error("Microsoft Graph credentials not configured");
      }
      const tokenResponse = await axios8.post(
        _MicrosoftGraphClient.TOKEN_URL,
        new URLSearchParams({
          client_id: clientId,
          client_secret: clientSecret,
          code,
          redirect_uri: redirectUri,
          grant_type: "authorization_code"
        }),
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          }
        }
      );
      const { access_token, refresh_token, expires_in } = tokenResponse.data;
      const expiresAt = /* @__PURE__ */ new Date();
      expiresAt.setSeconds(expiresAt.getSeconds() + expires_in);
      const updatedIntegration = await this.updateIntegrationRecord(
        integration.id,
        {
          config: {
            ...config3,
            accessToken: access_token,
            refreshToken: refresh_token,
            expiresAt: expiresAt.toISOString(),
            lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
          },
          isConnected: true,
          status: "active" /* ACTIVE */
        },
        userId
      );
      const isConnected = await this.testConnection();
      if (!isConnected) {
        await this.updateStatus(integration.id, "error" /* ERROR */, userId);
        throw new Error("Failed to connect to Microsoft Graph API");
      }
      return updatedIntegration || integration;
    } catch (error) {
      throw new Error(`Failed to complete Microsoft Graph OAuth flow: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get OAuth authorization URL for user to grant permissions
   */
  async getAuthorizationUrl() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const clientId = config3.clientId;
      const redirectUri = config3.redirectUri;
      const scopes = config3.scopes || ["Mail.Read Mail.Send" /* EMAIL */, "User.Read" /* USER_INFO */];
      if (!clientId || !redirectUri) {
        throw new Error("Microsoft Graph credentials not configured");
      }
      const state = uuidv429();
      await this.updateIntegrationRecord(
        integration.id,
        {
          config: {
            ...config3,
            oauthState: state
          }
        },
        "system"
      );
      const queryParams = new URLSearchParams({
        client_id: clientId,
        response_type: "code",
        redirect_uri: redirectUri,
        scope: Array.isArray(scopes) ? scopes.join(" ") : scopes,
        state
      });
      return `${_MicrosoftGraphClient.AUTH_URL}?${queryParams.toString()}`;
    } catch (error) {
      throw new Error(`Failed to generate Microsoft Graph authorization URL: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Refresh access token when expired
   */
  async refreshToken() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const clientId = config3.clientId;
      const clientSecret = config3.clientSecret;
      const refreshToken = config3.refreshToken;
      if (!clientId || !clientSecret || !refreshToken) {
        throw new Error("Microsoft Graph credentials or refresh token not configured");
      }
      const tokenResponse = await axios8.post(
        _MicrosoftGraphClient.TOKEN_URL,
        new URLSearchParams({
          client_id: clientId,
          client_secret: clientSecret,
          refresh_token: refreshToken,
          grant_type: "refresh_token"
        }),
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          }
        }
      );
      const { access_token, refresh_token, expires_in } = tokenResponse.data;
      const expiresAt = /* @__PURE__ */ new Date();
      expiresAt.setSeconds(expiresAt.getSeconds() + expires_in);
      await this.updateIntegrationRecord(
        integration.id,
        {
          config: {
            ...config3,
            accessToken: access_token,
            refreshToken: refresh_token || config3.refreshToken,
            expiresAt: expiresAt.toISOString(),
            lastTokenRefresh: (/* @__PURE__ */ new Date()).toISOString()
          },
          isConnected: true,
          status: "active" /* ACTIVE */
        },
        "system"
      );
    } catch (error) {
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...integration.config,
              lastError: error instanceof Error ? error.message : String(error),
              lastErrorTime: (/* @__PURE__ */ new Date()).toISOString()
            }
          },
          "system"
        );
      }
      throw new Error(`Failed to refresh Microsoft Graph token: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get valid access token, refreshing if necessary
   */
  async getAccessToken() {
    const integration = await this.getIntegrationRecord();
    if (!integration || !integration.config) {
      throw new Error("Integration not configured");
    }
    const config3 = integration.config;
    const accessToken = config3.accessToken;
    const expiresAt = config3.expiresAt ? new Date(config3.expiresAt) : null;
    if (!accessToken) {
      throw new Error("Microsoft Graph access token not available");
    }
    const now = /* @__PURE__ */ new Date();
    const expirationBuffer = 5 * 60 * 1e3;
    if (expiresAt && now.getTime() + expirationBuffer >= expiresAt.getTime()) {
      await this.refreshToken();
      const updatedIntegration = await this.getIntegrationRecord();
      if (!updatedIntegration || !updatedIntegration.config) {
        throw new Error("Failed to get updated integration after token refresh");
      }
      const updatedConfig = updatedIntegration.config;
      return updatedConfig.accessToken;
    }
    return accessToken;
  }
  /**
   * Test the connection to Microsoft Graph API
   */
  async testConnection() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        return false;
      }
      const config3 = integration.config;
      if (!config3.accessToken) {
        return false;
      }
      try {
        const accessToken = await this.getAccessToken();
        const response = await axios8.get(`${_MicrosoftGraphClient.API_URL}/me`, {
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json"
          }
        });
        const isConnected = response.status === 200;
        if (isConnected && integration) {
          await this.updateIntegrationRecord(
            integration.id,
            {
              isConnected: true,
              status: "active" /* ACTIVE */,
              config: {
                ...config3,
                lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
              }
            },
            "system"
          );
        }
        return isConnected;
      } catch (error) {
        if (axios8.isAxiosError(error) && error.response?.status === 401) {
          try {
            await this.refreshToken();
            const accessToken = await this.getAccessToken();
            const retryResponse = await axios8.get(`${_MicrosoftGraphClient.API_URL}/me`, {
              headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
              }
            });
            const isConnected = retryResponse.status === 200;
            if (isConnected && integration) {
              await this.updateIntegrationRecord(
                integration.id,
                {
                  isConnected: true,
                  status: "active" /* ACTIVE */,
                  config: {
                    ...config3,
                    lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
                  }
                },
                "system"
              );
            }
            return isConnected;
          } catch (refreshError) {
            await this.updateIntegrationRecord(
              integration.id,
              {
                isConnected: false,
                status: "error" /* ERROR */,
                config: {
                  ...config3,
                  lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString(),
                  lastError: refreshError instanceof Error ? refreshError.message : String(refreshError)
                }
              },
              "system"
            );
            return false;
          }
        }
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...config3,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString(),
              lastError: error instanceof Error ? error.message : String(error)
            }
          },
          "system"
        );
        return false;
      }
    } catch (error) {
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...integration.config,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString(),
              lastError: error instanceof Error ? error.message : String(error)
            }
          },
          "system"
        );
      }
      return false;
    }
  }
  /**
   * Get user emails
   * @param filter Optional OData filter
   * @param top Number of emails to retrieve (default: 10)
   */
  async getEmails(filter, top = 10) {
    try {
      const accessToken = await this.getAccessToken();
      const queryParams = new URLSearchParams();
      if (filter) queryParams.append("$filter", filter);
      queryParams.append("$top", top.toString());
      const response = await axios8.get(
        `${_MicrosoftGraphClient.API_URL}/me/messages?${queryParams.toString()}`,
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json"
          }
        }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data.value;
    } catch (error) {
      throw new Error(`Failed to get emails: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Send an email
   * @param to Recipient email address
   * @param subject Email subject
   * @param body Email body content
   * @param isHtml Whether body is HTML (default: true)
   * @param cc Optional CC recipients
   * @param bcc Optional BCC recipients
   */
  async sendEmail(to, subject, body, isHtml = true, cc, bcc) {
    try {
      const accessToken = await this.getAccessToken();
      const toRecipients = Array.isArray(to) ? to : [to];
      const ccRecipients = cc ? Array.isArray(cc) ? cc : [cc] : [];
      const bccRecipients = bcc ? Array.isArray(bcc) ? bcc : [bcc] : [];
      const emailPayload = {
        message: {
          subject,
          body: {
            contentType: isHtml ? "HTML" : "Text",
            content: body
          },
          toRecipients: toRecipients.map((email) => ({ emailAddress: { address: email } })),
          ccRecipients: ccRecipients.map((email) => ({ emailAddress: { address: email } })),
          bccRecipients: bccRecipients.map((email) => ({ emailAddress: { address: email } }))
        },
        saveToSentItems: true
      };
      const response = await axios8.post(
        `${_MicrosoftGraphClient.API_URL}/me/sendMail`,
        emailPayload,
        {
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json"
          }
        }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to send email: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get calendar events
   * @param startDateTime Start date (ISO string)
   * @param endDateTime End date (ISO string)
   */
  async getCalendarEvents(startDateTime, endDateTime) {
    try {
      const accessToken = await this.getAccessToken();
      let url = `${_MicrosoftGraphClient.API_URL}/me/events`;
      if (startDateTime && endDateTime) {
        url = `${_MicrosoftGraphClient.API_URL}/me/calendarView?startDateTime=${startDateTime}&endDateTime=${endDateTime}`;
      }
      const response = await axios8.get(url, {
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": "application/json"
        }
      });
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data.value;
    } catch (error) {
      throw new Error(`Failed to get calendar events: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/integrations/clients/openai.client.ts
import axios9 from "axios";
init_integrations_schema();
var OpenAIClient = class _OpenAIClient extends BaseIntegrationClient {
  static {
    this.API_URL = "https://api.openai.com/v1";
  }
  /**
   * Initialize the OpenAI client
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(companyId, franchiseId) {
    super(IntegrationProvider.OPENAI, companyId, franchiseId);
  }
  /**
   * Initialize the OpenAI integration
   * @param apiKey OpenAI API key
   * @param organization Optional OpenAI organization ID
   * @param defaultModel Default model to use
   * @param userId User ID initializing the integration
   */
  async initialize(apiKey, organization, defaultModel = "gpt-3.5-turbo" /* GPT_3_5_TURBO */, userId) {
    try {
      const existingIntegration = await this.getIntegrationRecord();
      if (existingIntegration) {
        const updatedIntegration = await this.updateIntegrationRecord(
          existingIntegration.id,
          {
            config: {
              apiKey,
              organization,
              defaultModel,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            },
            isConnected: true,
            status: "active" /* ACTIVE */
          },
          userId
        );
        return updatedIntegration || existingIntegration;
      }
      const integration = await this.createIntegrationRecord(
        {
          apiKey,
          organization,
          defaultModel,
          lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
        },
        userId
      );
      const isConnected = await this.testConnection();
      if (isConnected) {
        await this.updateStatus(integration.id, "active" /* ACTIVE */, userId);
      } else {
        await this.updateStatus(integration.id, "error" /* ERROR */, userId);
        throw new Error("Failed to connect to OpenAI API");
      }
      return integration;
    } catch (error) {
      throw new Error(`Failed to initialize OpenAI integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Test the connection to OpenAI API
   */
  async testConnection() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        return false;
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      const organization = config3.organization;
      if (!apiKey) {
        return false;
      }
      const headers = {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      };
      if (organization) {
        headers["OpenAI-Organization"] = organization;
      }
      const response = await axios9.get(`${_OpenAIClient.API_URL}/models`, { headers });
      const isConnected = response.status === 200;
      if (isConnected && integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: true,
            status: "active" /* ACTIVE */,
            config: {
              ...config3,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            }
          },
          "system"
        );
      }
      return isConnected;
    } catch (error) {
      if (error instanceof Error) {
        console.error(`OpenAI connection test failed: ${error.message}`);
      }
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...integration.config,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString(),
              lastError: error instanceof Error ? error.message : String(error)
            }
          },
          "system"
        );
      }
      return false;
    }
  }
  /**
   * Get available models from OpenAI
   */
  async getModels() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      const organization = config3.organization;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const headers = {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      };
      if (organization) {
        headers["OpenAI-Organization"] = organization;
      }
      const response = await axios9.get(`${_OpenAIClient.API_URL}/models`, { headers });
      await this.updateLastSynced(integration.id, "system");
      return response.data.data;
    } catch (error) {
      throw new Error(`Failed to get OpenAI models: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Generate text completions
   * @param prompt Text prompt
   * @param model OpenAI model to use
   * @param maxTokens Maximum tokens to generate
   * @param temperature Sampling temperature (0-2)
   */
  async createCompletion(prompt, model, maxTokens = 256, temperature = 0.7) {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      const organization = config3.organization;
      const defaultModel = config3.defaultModel || "gpt-3.5-turbo" /* GPT_3_5_TURBO */;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const headers = {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      };
      if (organization) {
        headers["OpenAI-Organization"] = organization;
      }
      const payload = {
        model: model || defaultModel,
        messages: [{ role: "user", content: prompt }],
        max_tokens: maxTokens,
        temperature
      };
      const response = await axios9.post(
        `${_OpenAIClient.API_URL}/chat/completions`,
        payload,
        { headers }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data.choices[0]?.message?.content || "";
    } catch (error) {
      throw new Error(`Failed to create OpenAI completion: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Generate text embeddings
   * @param input Text to embed
   * @param model Embedding model to use
   */
  async createEmbedding(input, model = "text-embedding-ada-002") {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      const organization = config3.organization;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const headers = {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      };
      if (organization) {
        headers["OpenAI-Organization"] = organization;
      }
      const payload = {
        model,
        input
      };
      const response = await axios9.post(
        `${_OpenAIClient.API_URL}/embeddings`,
        payload,
        { headers }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data.data.map((item) => item.embedding);
    } catch (error) {
      throw new Error(`Failed to create OpenAI embedding: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get estimated token usage and pricing
   * @param model Model to use
   * @param inputText Input text for which to calculate tokens
   */
  async estimateTokenUsage(model, inputText) {
    const averageCharsPerToken = 4;
    const estimatedTokens = Math.ceil(inputText.length / averageCharsPerToken);
    let ratePerThousandTokens = 2e-3;
    if (model === "gpt-4" /* GPT_4 */) {
      ratePerThousandTokens = 0.06;
    } else if (model === "gpt-4-turbo" /* GPT_4_TURBO */) {
      ratePerThousandTokens = 0.03;
    }
    const cost = estimatedTokens / 1e3 * ratePerThousandTokens;
    return {
      tokens: estimatedTokens,
      cost
    };
  }
};

// server/modules/integrations/clients/termene-ro.client.ts
import axios10 from "axios";
init_integrations_schema();
var TermeneRoClient = class _TermeneRoClient extends BaseIntegrationClient {
  static {
    this.API_URL = "https://api.termene.ro";
  }
  static {
    this.API_VERSION = "v1.0";
  }
  /**
   * Initialize the Termene.ro client
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(companyId, franchiseId) {
    super(IntegrationProvider.TERMENE_RO, companyId, franchiseId);
  }
  /**
   * Initialize the Termene.ro integration
   * @param apiKey Termene.ro API key
   * @param userId User ID initializing the integration
   */
  async initialize(apiKey, userId) {
    try {
      const existingIntegration = await this.getIntegrationRecord();
      if (existingIntegration) {
        const updatedIntegration = await this.updateIntegrationRecord(
          existingIntegration.id,
          {
            config: {
              apiKey,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            },
            isConnected: true,
            status: "active" /* ACTIVE */
          },
          userId
        );
        return updatedIntegration || existingIntegration;
      }
      const integration = await this.createIntegrationRecord(
        {
          apiKey,
          lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
        },
        userId
      );
      const isConnected = await this.testConnection();
      if (isConnected) {
        await this.updateStatus(integration.id, "active" /* ACTIVE */, userId);
      } else {
        await this.updateStatus(integration.id, "error" /* ERROR */, userId);
        throw new Error("Failed to connect to Termene.ro API");
      }
      return integration;
    } catch (error) {
      throw new Error(`Failed to initialize Termene.ro integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Test the connection to Termene.ro API
   */
  async testConnection() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        return false;
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      if (!apiKey) {
        return false;
      }
      const response = await axios10.get(`${_TermeneRoClient.API_URL}/${_TermeneRoClient.API_VERSION}/companies/info`, {
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        }
      });
      const isConnected = response.status === 200;
      if (isConnected && integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: true,
            status: "active" /* ACTIVE */,
            config: {
              ...config3,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            }
          },
          "system"
        );
      }
      return isConnected;
    } catch (error) {
      if (error instanceof Error) {
        console.error(`Termene.ro connection test failed: ${error.message}`);
      }
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...integration.config,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString(),
              lastError: error instanceof Error ? error.message : String(error)
            }
          },
          "system"
        );
      }
      return false;
    }
  }
  /**
   * Get private headers with API key
   */
  async getHeaders() {
    const integration = await this.getIntegrationRecord();
    if (!integration || !integration.config) {
      throw new Error("Integration not configured");
    }
    const config3 = integration.config;
    const apiKey = config3.apiKey;
    if (!apiKey) {
      throw new Error("API key not configured");
    }
    return {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    };
  }
  /**
   * Search for companies by CUI (tax ID)
   * @param cui Company tax ID (CUI/CIF)
   */
  async getCompanyByCui(cui) {
    try {
      const headers = await this.getHeaders();
      const response = await axios10.get(
        `${_TermeneRoClient.API_URL}/${_TermeneRoClient.API_VERSION}/company/cui/${cui}`,
        { headers }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get company by CUI: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Search for companies by name
   * @param name Company name
   * @param exact Whether to match the name exactly
   */
  async searchCompanyByName(name, exact = false) {
    try {
      const headers = await this.getHeaders();
      const params = new URLSearchParams({
        name,
        exact: exact ? "1" : "0"
      });
      const response = await axios10.get(
        `${_TermeneRoClient.API_URL}/${_TermeneRoClient.API_VERSION}/company/search?${params.toString()}`,
        { headers }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to search company by name: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get company financial data
   * @param cui Company tax ID (CUI/CIF)
   */
  async getCompanyFinancials(cui) {
    try {
      const headers = await this.getHeaders();
      const response = await axios10.get(
        `${_TermeneRoClient.API_URL}/${_TermeneRoClient.API_VERSION}/company/financial/${cui}`,
        { headers }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get company financials: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Check if a company is in insolvency
   * @param cui Company tax ID (CUI/CIF)
   */
  async checkInsolvency(cui) {
    try {
      const headers = await this.getHeaders();
      const response = await axios10.get(
        `${_TermeneRoClient.API_URL}/${_TermeneRoClient.API_VERSION}/company/insolvency/${cui}`,
        { headers }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to check insolvency status: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Add company to monitoring list
   * @param cui Company tax ID (CUI/CIF)
   */
  async addCompanyToMonitoring(cui) {
    try {
      const headers = await this.getHeaders();
      const response = await axios10.post(
        `${_TermeneRoClient.API_URL}/${_TermeneRoClient.API_VERSION}/company/monitoring/add`,
        { cui },
        { headers }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to add company to monitoring: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Remove company from monitoring list
   * @param cui Company tax ID (CUI/CIF)
   */
  async removeCompanyFromMonitoring(cui) {
    try {
      const headers = await this.getHeaders();
      const response = await axios10.post(
        `${_TermeneRoClient.API_URL}/${_TermeneRoClient.API_VERSION}/company/monitoring/remove`,
        { cui },
        { headers }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to remove company from monitoring: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get monitored companies list
   */
  async getMonitoredCompanies() {
    try {
      const headers = await this.getHeaders();
      const response = await axios10.get(
        `${_TermeneRoClient.API_URL}/${_TermeneRoClient.API_VERSION}/company/monitoring/list`,
        { headers }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get monitored companies: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Validate Romanian VAT number
   * @param vatNumber VAT number to validate
   */
  async validateVatNumber(vatNumber) {
    try {
      const headers = await this.getHeaders();
      const formattedVat = vatNumber.replace(/^RO/i, "");
      const response = await axios10.get(
        `${_TermeneRoClient.API_URL}/${_TermeneRoClient.API_VERSION}/company/vat/${formattedVat}`,
        { headers }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to validate VAT number: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/integrations/clients/shopify.client.ts
import axios11 from "axios";
init_integrations_schema();
var ShopifyIntegrationType = /* @__PURE__ */ ((ShopifyIntegrationType2) => {
  ShopifyIntegrationType2["ADMIN"] = "admin";
  ShopifyIntegrationType2["STOREFRONT"] = "storefront";
  ShopifyIntegrationType2["INBOX"] = "inbox";
  return ShopifyIntegrationType2;
})(ShopifyIntegrationType || {});
var ShopifyClient = class extends BaseIntegrationClient {
  /**
   * Initialize the Shopify client
   * @param type Shopify integration type (admin, storefront, inbox)
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(type, companyId, franchiseId) {
    let provider;
    switch (type) {
      case "admin" /* ADMIN */:
        provider = "shopify_admin" /* SHOPIFY_ADMIN */;
        break;
      case "storefront" /* STOREFRONT */:
        provider = "shopify_storefront" /* SHOPIFY_STOREFRONT */;
        break;
      case "inbox" /* INBOX */:
        provider = IntegrationProvider.SHOPIFY_INBOX;
        break;
      default:
        provider = "shopify_admin" /* SHOPIFY_ADMIN */;
    }
    super(provider, companyId, franchiseId);
    this.integrationType = type;
  }
  /**
   * Initialize the Shopify integration
   * @param shopUrl Shopify store URL (e.g., 'my-store.myshopify.com')
   * @param accessToken Access token for API access
   * @param apiVersion Shopify API version
   * @param userId User ID initializing the integration
   * @param webhookUrl Optional webhook URL for notifications
   * @param webhookSecret Optional webhook secret for signature verification
   */
  async initialize(shopUrl, accessToken, apiVersion = "2023-10" /* LATEST */, userId, webhookUrl, webhookSecret) {
    try {
      const formattedShopUrl = shopUrl.replace(/^https?:\/\//i, "").replace(/\/$/i, "");
      const existingIntegration = await this.getIntegrationRecord();
      if (existingIntegration) {
        const updatedIntegration = await this.updateIntegrationRecord(
          existingIntegration.id,
          {
            config: {
              shopUrl: formattedShopUrl,
              accessToken,
              apiVersion,
              integrationType: this.integrationType,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            },
            isConnected: true,
            status: "active" /* ACTIVE */,
            webhookUrl,
            webhookSecret
          },
          userId
        );
        return updatedIntegration || existingIntegration;
      }
      const integration = await this.createIntegrationRecord(
        {
          shopUrl: formattedShopUrl,
          accessToken,
          apiVersion,
          integrationType: this.integrationType,
          lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
        },
        userId,
        webhookUrl,
        webhookSecret
      );
      const isConnected = await this.testConnection();
      if (isConnected) {
        await this.updateStatus(integration.id, "active" /* ACTIVE */, userId);
      } else {
        await this.updateStatus(integration.id, "error" /* ERROR */, userId);
        throw new Error("Failed to connect to Shopify API");
      }
      return integration;
    } catch (error) {
      throw new Error(`Failed to initialize Shopify integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Test the connection to Shopify API
   */
  async testConnection() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        return false;
      }
      const config3 = integration.config;
      const shopUrl = config3.shopUrl;
      const accessToken = config3.accessToken;
      const apiVersion = config3.apiVersion || "2023-10" /* LATEST */;
      if (!shopUrl || !accessToken) {
        return false;
      }
      let endpoint = "";
      switch (this.integrationType) {
        case "admin" /* ADMIN */:
          endpoint = `https://${shopUrl}/admin/api/${apiVersion}/shop.json`;
          break;
        case "storefront" /* STOREFRONT */:
          endpoint = `https://${shopUrl}/api/${apiVersion}/graphql.json`;
          break;
        case "inbox" /* INBOX */:
          endpoint = `https://${shopUrl}/admin/api/${apiVersion}/shop.json`;
          break;
      }
      let response;
      if (this.integrationType === "storefront" /* STOREFRONT */) {
        response = await axios11.post(
          endpoint,
          {
            query: `{
              shop {
                name
              }
            }`
          },
          {
            headers: {
              "X-Shopify-Storefront-Access-Token": accessToken,
              "Content-Type": "application/json"
            }
          }
        );
      } else {
        response = await axios11.get(endpoint, {
          headers: {
            "X-Shopify-Access-Token": accessToken,
            "Content-Type": "application/json"
          }
        });
      }
      const isConnected = response.status === 200;
      if (isConnected && integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: true,
            status: "active" /* ACTIVE */,
            config: {
              ...config3,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            }
          },
          "system"
        );
      }
      return isConnected;
    } catch (error) {
      if (error instanceof Error) {
        console.error(`Shopify connection test failed: ${error.message}`);
      }
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...integration.config,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString(),
              lastError: error instanceof Error ? error.message : String(error)
            }
          },
          "system"
        );
      }
      return false;
    }
  }
  /**
   * Get Shopify store information
   */
  async getShopInfo() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const shopUrl = config3.shopUrl;
      const accessToken = config3.accessToken;
      const apiVersion = config3.apiVersion || "2023-10" /* LATEST */;
      if (!shopUrl || !accessToken) {
        throw new Error("Shopify credentials not configured");
      }
      if (this.integrationType === "storefront" /* STOREFRONT */) {
        const response2 = await axios11.post(
          `https://${shopUrl}/api/${apiVersion}/graphql.json`,
          {
            query: `{
              shop {
                name
                description
                moneyFormat
                primaryDomain {
                  url
                  host
                }
              }
            }`
          },
          {
            headers: {
              "X-Shopify-Storefront-Access-Token": accessToken,
              "Content-Type": "application/json"
            }
          }
        );
        await this.updateLastSynced(integration.id, "system");
        return response2.data.data.shop;
      }
      const response = await axios11.get(
        `https://${shopUrl}/admin/api/${apiVersion}/shop.json`,
        {
          headers: {
            "X-Shopify-Access-Token": accessToken,
            "Content-Type": "application/json"
          }
        }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data.shop;
    } catch (error) {
      throw new Error(`Failed to get Shopify shop info: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get products from Shopify store
   * @param limit Number of products to retrieve
   * @param page Page number for pagination
   */
  async getProducts(limit = 50, page = 1) {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const shopUrl = config3.shopUrl;
      const accessToken = config3.accessToken;
      const apiVersion = config3.apiVersion || "2023-10" /* LATEST */;
      if (!shopUrl || !accessToken) {
        throw new Error("Shopify credentials not configured");
      }
      if (this.integrationType === "storefront" /* STOREFRONT */) {
        const response2 = await axios11.post(
          `https://${shopUrl}/api/${apiVersion}/graphql.json`,
          {
            query: `{
              products(first: ${limit}, sortKey: TITLE) {
                edges {
                  node {
                    id
                    title
                    description
                    handle
                    priceRange {
                      minVariantPrice {
                        amount
                        currencyCode
                      }
                      maxVariantPrice {
                        amount
                        currencyCode
                      }
                    }
                    variants(first: 10) {
                      edges {
                        node {
                          id
                          title
                          price {
                            amount
                            currencyCode
                          }
                          sku
                          availableForSale
                        }
                      }
                    }
                    images(first: 5) {
                      edges {
                        node {
                          id
                          url
                          altText
                        }
                      }
                    }
                  }
                }
              }
            }`
          },
          {
            headers: {
              "X-Shopify-Storefront-Access-Token": accessToken,
              "Content-Type": "application/json"
            }
          }
        );
        await this.updateLastSynced(integration.id, "system");
        return response2.data.data.products;
      }
      const response = await axios11.get(
        `https://${shopUrl}/admin/api/${apiVersion}/products.json?limit=${limit}&page=${page}`,
        {
          headers: {
            "X-Shopify-Access-Token": accessToken,
            "Content-Type": "application/json"
          }
        }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data.products;
    } catch (error) {
      throw new Error(`Failed to get Shopify products: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get orders from Shopify store
   * @param limit Number of orders to retrieve
   * @param status Order status filter
   * @param sinceId Retrieve orders after this ID
   */
  async getOrders(limit = 50, status = "any", sinceId) {
    try {
      if (this.integrationType !== "admin" /* ADMIN */) {
        throw new Error("Orders can only be retrieved with Admin API access");
      }
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const shopUrl = config3.shopUrl;
      const accessToken = config3.accessToken;
      const apiVersion = config3.apiVersion || "2023-10" /* LATEST */;
      if (!shopUrl || !accessToken) {
        throw new Error("Shopify credentials not configured");
      }
      const params = new URLSearchParams({
        limit: limit.toString(),
        status
      });
      if (sinceId) {
        params.append("since_id", sinceId);
      }
      const response = await axios11.get(
        `https://${shopUrl}/admin/api/${apiVersion}/orders.json?${params.toString()}`,
        {
          headers: {
            "X-Shopify-Access-Token": accessToken,
            "Content-Type": "application/json"
          }
        }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data.orders;
    } catch (error) {
      throw new Error(`Failed to get Shopify orders: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get customers from Shopify store
   * @param limit Number of customers to retrieve
   * @param sinceId Retrieve customers after this ID
   */
  async getCustomers(limit = 50, sinceId) {
    try {
      if (this.integrationType !== "admin" /* ADMIN */) {
        throw new Error("Customers can only be retrieved with Admin API access");
      }
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const shopUrl = config3.shopUrl;
      const accessToken = config3.accessToken;
      const apiVersion = config3.apiVersion || "2023-10" /* LATEST */;
      if (!shopUrl || !accessToken) {
        throw new Error("Shopify credentials not configured");
      }
      const params = new URLSearchParams({
        limit: limit.toString()
      });
      if (sinceId) {
        params.append("since_id", sinceId);
      }
      const response = await axios11.get(
        `https://${shopUrl}/admin/api/${apiVersion}/customers.json?${params.toString()}`,
        {
          headers: {
            "X-Shopify-Access-Token": accessToken,
            "Content-Type": "application/json"
          }
        }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data.customers;
    } catch (error) {
      throw new Error(`Failed to get Shopify customers: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Create a webhook to receive notifications from Shopify
   * @param topic Webhook topic (e.g., 'orders/create')
   * @param address Webhook URL
   * @param format Response format ('json' or 'xml')
   */
  async createWebhook(topic, address, format = "json") {
    try {
      if (this.integrationType !== "admin" /* ADMIN */) {
        throw new Error("Webhooks can only be created with Admin API access");
      }
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const shopUrl = config3.shopUrl;
      const accessToken = config3.accessToken;
      const apiVersion = config3.apiVersion || "2023-10" /* LATEST */;
      if (!shopUrl || !accessToken) {
        throw new Error("Shopify credentials not configured");
      }
      const response = await axios11.post(
        `https://${shopUrl}/admin/api/${apiVersion}/webhooks.json`,
        {
          webhook: {
            topic,
            address,
            format
          }
        },
        {
          headers: {
            "X-Shopify-Access-Token": accessToken,
            "Content-Type": "application/json"
          }
        }
      );
      await this.updateIntegrationRecord(
        integration.id,
        {
          webhookUrl: address
        },
        "system"
      );
      return response.data.webhook;
    } catch (error) {
      throw new Error(`Failed to create Shopify webhook: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Synchronize product inventory between Shopify and local database
   * @param syncInventoryOnly Only sync inventory levels (not product data)
   * @param limit Maximum number of products to sync
   */
  async syncProducts(syncInventoryOnly = false, limit = 100) {
    try {
      const products = await this.getProducts(limit);
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return {
        status: "success",
        syncedAt: (/* @__PURE__ */ new Date()).toISOString(),
        productCount: Array.isArray(products) ? products.length : products?.edges?.length || 0
      };
    } catch (error) {
      throw new Error(`Failed to sync Shopify products: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/integrations/clients/elevenlabs.client.ts
import axios12 from "axios";
init_integrations_schema();
var ElevenLabsClient = class _ElevenLabsClient extends BaseIntegrationClient {
  static {
    this.API_URL = "https://api.elevenlabs.io/v1";
  }
  /**
   * Initialize the ElevenLabs client
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(companyId, franchiseId) {
    super(IntegrationProvider.ELEVENLABS, companyId, franchiseId);
  }
  /**
   * Initialize the ElevenLabs integration
   * @param apiKey ElevenLabs API key
   * @param defaultVoiceId Optional default voice ID
   * @param userId User ID initializing the integration
   */
  async initialize(apiKey, defaultVoiceId, userId) {
    try {
      const existingIntegration = await this.getIntegrationRecord();
      if (existingIntegration) {
        const updatedIntegration = await this.updateIntegrationRecord(
          existingIntegration.id,
          {
            config: {
              apiKey,
              defaultVoiceId,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            },
            isConnected: true,
            status: "active" /* ACTIVE */
          },
          userId
        );
        return updatedIntegration || existingIntegration;
      }
      const integration = await this.createIntegrationRecord(
        {
          apiKey,
          defaultVoiceId,
          lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
        },
        userId
      );
      const isConnected = await this.testConnection();
      if (isConnected) {
        await this.updateStatus(integration.id, "active" /* ACTIVE */, userId);
      } else {
        await this.updateStatus(integration.id, "error" /* ERROR */, userId);
        throw new Error("Failed to connect to ElevenLabs API");
      }
      return integration;
    } catch (error) {
      throw new Error(`Failed to initialize ElevenLabs integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Test the connection to ElevenLabs API
   */
  async testConnection() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        return false;
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      if (!apiKey) {
        return false;
      }
      const response = await axios12.get(`${_ElevenLabsClient.API_URL}/user`, {
        headers: {
          "xi-api-key": apiKey,
          "Content-Type": "application/json"
        }
      });
      const isConnected = response.status === 200;
      if (isConnected && integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: true,
            status: "active" /* ACTIVE */,
            config: {
              ...config3,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            }
          },
          "system"
        );
      }
      return isConnected;
    } catch (error) {
      if (error instanceof Error) {
        console.error(`ElevenLabs connection test failed: ${error.message}`);
      }
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...integration.config,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString(),
              lastError: error instanceof Error ? error.message : String(error)
            }
          },
          "system"
        );
      }
      return false;
    }
  }
  /**
   * Get available voices
   */
  async getVoices() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const response = await axios12.get(`${_ElevenLabsClient.API_URL}/voices`, {
        headers: {
          "xi-api-key": apiKey,
          "Content-Type": "application/json"
        }
      });
      await this.updateLastSynced(integration.id, "system");
      return response.data.voices;
    } catch (error) {
      throw new Error(`Failed to get ElevenLabs voices: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get user subscription information
   */
  async getUserInfo() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const response = await axios12.get(`${_ElevenLabsClient.API_URL}/user/subscription`, {
        headers: {
          "xi-api-key": apiKey,
          "Content-Type": "application/json"
        }
      });
      await this.updateLastSynced(integration.id, "system");
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get ElevenLabs user info: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Convert text to speech
   * @param text Text to convert to speech
   * @param voiceId Voice ID to use (if not provided, uses default)
   * @param model TTS model to use
   * @param optimization Voice optimization setting (0 = quality, 1 = performance)
   * @param stability Voice stability (0-1)
   * @param similarityBoost Voice similarity boost (0-1)
   * @returns Audio data as ArrayBuffer
   */
  async textToSpeech(text24, voiceId, model = "eleven_multilingual_v2" /* ELEVEN_MULTILINGUAL_V2 */, optimization = 0 /* QUALITY */, stability = 0.5, similarityBoost = 0.75) {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      const defaultVoiceId = config3.defaultVoiceId;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const selectedVoiceId = voiceId || defaultVoiceId;
      if (!selectedVoiceId) {
        throw new Error("No voice ID provided or configured");
      }
      const payload = {
        text: text24,
        model_id: model,
        voice_settings: {
          stability,
          similarity_boost: similarityBoost
        },
        optimize_streaming_latency: optimization
      };
      const response = await axios12.post(
        `${_ElevenLabsClient.API_URL}/text-to-speech/${selectedVoiceId}`,
        payload,
        {
          headers: {
            "xi-api-key": apiKey,
            "Content-Type": "application/json",
            "Accept": "audio/mpeg"
          },
          responseType: "arraybuffer"
        }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data;
    } catch (error) {
      throw new Error(`Failed to convert text to speech: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get voice settings
   * @param voiceId Voice ID
   */
  async getVoiceSettings(voiceId) {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const response = await axios12.get(
        `${_ElevenLabsClient.API_URL}/voices/${voiceId}/settings`,
        {
          headers: {
            "xi-api-key": apiKey,
            "Content-Type": "application/json"
          }
        }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get voice settings: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get available models
   */
  async getModels() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const apiKey = config3.apiKey;
      if (!apiKey) {
        throw new Error("API key not configured");
      }
      const response = await axios12.get(
        `${_ElevenLabsClient.API_URL}/models`,
        {
          headers: {
            "xi-api-key": apiKey,
            "Content-Type": "application/json"
          }
        }
      );
      await this.updateLastSynced(integration.id, "system");
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get models: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Convert text to speech in streaming mode
   * @param text Text to convert to speech
   * @param voiceId Voice ID to use (if not provided, uses default)
   * @param model TTS model to use
   * @param optimization Voice optimization setting (0 = quality, 1 = performance)
   * @param stability Voice stability (0-1)
   * @param similarityBoost Voice similarity boost (0-1)
   * @returns URL for streaming audio
   */
  async getTextToSpeechStreamingUrl(text24, voiceId, model = "eleven_multilingual_v2" /* ELEVEN_MULTILINGUAL_V2 */, optimization = 0 /* QUALITY */, stability = 0.5, similarityBoost = 0.75) {
    const integration = await this.getIntegrationRecord();
    if (!integration || !integration.config) {
      throw new Error("Integration not configured");
    }
    const config3 = integration.config;
    const apiKey = config3.apiKey;
    const defaultVoiceId = config3.defaultVoiceId;
    if (!apiKey) {
      throw new Error("API key not configured");
    }
    const selectedVoiceId = voiceId || defaultVoiceId;
    if (!selectedVoiceId) {
      throw new Error("No voice ID provided or configured");
    }
    const params = new URLSearchParams({
      text: encodeURIComponent(text24),
      model_id: model,
      optimize_streaming_latency: optimization.toString(),
      stability: stability.toString(),
      similarity_boost: similarityBoost.toString(),
      key: apiKey
    });
    return `${_ElevenLabsClient.API_URL}/text-to-speech/${selectedVoiceId}/stream?${params.toString()}`;
  }
};

// server/modules/integrations/clients/sameday.client.ts
import axios13 from "axios";
init_integrations_schema();
var SameDayClient = class _SameDayClient extends BaseIntegrationClient {
  static {
    this.DEMO_API_URL = "https://api.demo.sameday.ro";
  }
  static {
    this.PRODUCTION_API_URL = "https://api.sameday.ro";
  }
  /**
   * Initialize the SameDay client
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   */
  constructor(companyId, franchiseId) {
    super(IntegrationProvider.SAMEDAY, companyId, franchiseId);
  }
  /**
   * Initialize the SameDay integration
   * @param username SameDay username
   * @param password SameDay password
   * @param environment API environment (demo or production)
   * @param userId User ID initializing the integration
   */
  async initialize(username, password, environment = "demo" /* DEMO */, userId) {
    try {
      const existingIntegration = await this.getIntegrationRecord();
      if (existingIntegration) {
        const updatedIntegration = await this.updateIntegrationRecord(
          existingIntegration.id,
          {
            config: {
              username,
              password,
              environment,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            },
            isConnected: true,
            status: "active" /* ACTIVE */
          },
          userId
        );
        return updatedIntegration || existingIntegration;
      }
      const integration = await this.createIntegrationRecord(
        {
          username,
          password,
          environment,
          lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
        },
        userId
      );
      const token = await this.getAuthToken();
      if (token) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            config: {
              username,
              password,
              environment,
              accessToken: token.token,
              tokenExpiresAt: token.expires_at,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString()
            },
            isConnected: true,
            status: "active" /* ACTIVE */
          },
          userId
        );
      } else {
        await this.updateStatus(integration.id, "error" /* ERROR */, userId);
        throw new Error("Failed to connect to SameDay API");
      }
      return integration;
    } catch (error) {
      throw new Error(`Failed to initialize SameDay integration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get base URL based on environment
   */
  getBaseUrl() {
    return this.getEnvironment() === "production" /* PRODUCTION */ ? _SameDayClient.PRODUCTION_API_URL : _SameDayClient.DEMO_API_URL;
  }
  /**
   * Get configured environment
   */
  async getEnvironment() {
    const integration = await this.getIntegrationRecord();
    if (!integration || !integration.config) {
      return "demo" /* DEMO */;
    }
    const config3 = integration.config;
    return config3.environment || "demo" /* DEMO */;
  }
  /**
   * Get authentication token
   */
  async getAuthToken() {
    try {
      const integration = await this.getIntegrationRecord();
      if (!integration || !integration.config) {
        throw new Error("Integration not configured");
      }
      const config3 = integration.config;
      const username = config3.username;
      const password = config3.password;
      if (!username || !password) {
        throw new Error("SameDay credentials not configured");
      }
      if (config3.accessToken && config3.tokenExpiresAt) {
        const tokenExpiry = new Date(config3.tokenExpiresAt);
        const now = /* @__PURE__ */ new Date();
        const expirationBuffer = 5 * 60 * 1e3;
        if (now.getTime() + expirationBuffer < tokenExpiry.getTime()) {
          return {
            token: config3.accessToken,
            expires_at: config3.tokenExpiresAt
          };
        }
      }
      const baseUrl = this.getBaseUrl();
      const response = await axios13.post(
        `${baseUrl}/api/authenticate`,
        {
          username,
          password
        },
        {
          headers: {
            "Content-Type": "application/json"
          }
        }
      );
      if (response.status === 200 && response.data.token) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            config: {
              ...config3,
              accessToken: response.data.token,
              tokenExpiresAt: response.data.expires_at,
              lastTokenRefresh: (/* @__PURE__ */ new Date()).toISOString()
            },
            isConnected: true,
            status: "active" /* ACTIVE */
          },
          "system"
        );
        return {
          token: response.data.token,
          expires_at: response.data.expires_at
        };
      }
      return null;
    } catch (error) {
      console.error(`Failed to get SameDay auth token: ${error instanceof Error ? error.message : String(error)}`);
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...integration.config,
              lastError: error instanceof Error ? error.message : String(error),
              lastErrorTime: (/* @__PURE__ */ new Date()).toISOString()
            }
          },
          "system"
        );
      }
      return null;
    }
  }
  /**
   * Test the connection to SameDay API
   */
  async testConnection() {
    try {
      const token = await this.getAuthToken();
      return !!token;
    } catch (error) {
      if (error instanceof Error) {
        console.error(`SameDay connection test failed: ${error.message}`);
      }
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateIntegrationRecord(
          integration.id,
          {
            isConnected: false,
            status: "error" /* ERROR */,
            config: {
              ...integration.config,
              lastConnectionCheck: (/* @__PURE__ */ new Date()).toISOString(),
              lastError: error instanceof Error ? error.message : String(error)
            }
          },
          "system"
        );
      }
      return false;
    }
  }
  /**
   * Get pickup points
   */
  async getPickupPoints() {
    try {
      const token = await this.getAuthToken();
      if (!token) {
        throw new Error("Failed to authenticate with SameDay API");
      }
      const baseUrl = this.getBaseUrl();
      const response = await axios13.get(`${baseUrl}/api/client/pickup-points`, {
        headers: {
          "Authorization": `Bearer ${token.token}`,
          "Content-Type": "application/json"
        }
      });
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get pickup points: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get service list
   */
  async getServices() {
    try {
      const token = await this.getAuthToken();
      if (!token) {
        throw new Error("Failed to authenticate with SameDay API");
      }
      const baseUrl = this.getBaseUrl();
      const response = await axios13.get(`${baseUrl}/api/client/services`, {
        headers: {
          "Authorization": `Bearer ${token.token}`,
          "Content-Type": "application/json"
        }
      });
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get services: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Create an AWB (shipping label)
   * @param pickupPointId Pickup point ID
   * @param contactPerson Contact person name
   * @param phoneNumber Contact phone number
   * @param serviceId Service ID
   * @param packageType Package type
   * @param packageWeight Package weight in kg
   * @param packageLength Package length in cm
   * @param packageWidth Package width in cm
   * @param packageHeight Package height in cm
   * @param deliveryAddress Delivery address details
   * @param awbPayment Payment method for AWB ('sender' or 'recipient')
   * @param cashOnDelivery Optional cash on delivery amount
   * @param insuranceValue Optional insurance value
   * @param observation Optional observation text
   */
  async createAwb(pickupPointId, contactPerson, phoneNumber, serviceId, packageType, packageWeight, packageLength, packageWidth, packageHeight, deliveryAddress, awbPayment, cashOnDelivery, insuranceValue, observation) {
    try {
      const token = await this.getAuthToken();
      if (!token) {
        throw new Error("Failed to authenticate with SameDay API");
      }
      const baseUrl = this.getBaseUrl();
      const payload = {
        pickupPoint: pickupPointId,
        contactPerson,
        phone: phoneNumber,
        service: serviceId,
        packageType,
        packageWeight,
        packageLength,
        packageWidth,
        packageHeight,
        county: deliveryAddress.county,
        city: deliveryAddress.city,
        address: deliveryAddress.address,
        postalCode: deliveryAddress.postalCode,
        personWhoReceives: deliveryAddress.contactPerson,
        phoneWhoReceives: deliveryAddress.phoneNumber,
        emailWhoReceives: deliveryAddress.email,
        companyWhoReceives: deliveryAddress.companyName,
        awbPayment,
        cashOnDelivery,
        insuredValue: insuranceValue,
        observation
      };
      const response = await axios13.post(
        `${baseUrl}/api/awb`,
        payload,
        {
          headers: {
            "Authorization": `Bearer ${token.token}`,
            "Content-Type": "application/json"
          }
        }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create AWB: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get AWB status by AWB number
   * @param awbNumber AWB number to track
   */
  async getAwbStatus(awbNumber) {
    try {
      const token = await this.getAuthToken();
      if (!token) {
        throw new Error("Failed to authenticate with SameDay API");
      }
      const baseUrl = this.getBaseUrl();
      const response = await axios13.get(`${baseUrl}/api/awb/${awbNumber}/status`, {
        headers: {
          "Authorization": `Bearer ${token.token}`,
          "Content-Type": "application/json"
        }
      });
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get AWB status: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Download AWB PDF
   * @param awbNumber AWB number
   * @returns PDF file as Buffer
   */
  async downloadAwbPdf(awbNumber) {
    try {
      const token = await this.getAuthToken();
      if (!token) {
        throw new Error("Failed to authenticate with SameDay API");
      }
      const baseUrl = this.getBaseUrl();
      const response = await axios13.get(`${baseUrl}/api/awb/${awbNumber}/download`, {
        headers: {
          "Authorization": `Bearer ${token.token}`
        },
        responseType: "arraybuffer"
      });
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return Buffer.from(response.data);
    } catch (error) {
      throw new Error(`Failed to download AWB PDF: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Cancel AWB
   * @param awbNumber AWB number to cancel
   */
  async cancelAwb(awbNumber) {
    try {
      const token = await this.getAuthToken();
      if (!token) {
        throw new Error("Failed to authenticate with SameDay API");
      }
      const baseUrl = this.getBaseUrl();
      const response = await axios13.delete(`${baseUrl}/api/awb/${awbNumber}`, {
        headers: {
          "Authorization": `Bearer ${token.token}`,
          "Content-Type": "application/json"
        }
      });
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to cancel AWB: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Request courier pickup
   * @param pickupPointId Pickup point ID
   * @param contactPerson Contact person name
   * @param phoneNumber Contact phone number
   * @param pickupDate Pickup date (YYYY-MM-DD)
   * @param pickupStartHour Pickup start hour (HH:MM)
   * @param pickupEndHour Pickup end hour (HH:MM)
   * @param awbNumbers List of AWB numbers for pickup
   * @param observation Optional observation text
   */
  async requestCourierPickup(pickupPointId, contactPerson, phoneNumber, pickupDate, pickupStartHour, pickupEndHour, awbNumbers, observation) {
    try {
      const token = await this.getAuthToken();
      if (!token) {
        throw new Error("Failed to authenticate with SameDay API");
      }
      const baseUrl = this.getBaseUrl();
      const payload = {
        pickupPoint: pickupPointId,
        contactPerson,
        phone: phoneNumber,
        pickupDate,
        pickupStartHour,
        pickupEndHour,
        awbCodes: awbNumbers,
        observation
      };
      const response = await axios13.post(
        `${baseUrl}/api/pickup`,
        payload,
        {
          headers: {
            "Authorization": `Bearer ${token.token}`,
            "Content-Type": "application/json"
          }
        }
      );
      const integration = await this.getIntegrationRecord();
      if (integration) {
        await this.updateLastSynced(integration.id, "system");
      }
      return response.data;
    } catch (error) {
      throw new Error(`Failed to request courier pickup: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/integrations/clients/index.ts
init_integrations_schema();
function getIntegrationClient(provider, companyId, franchiseId) {
  switch (provider) {
    // Romanian e-Factura
    case IntegrationProvider.ANAF_EFACTURA:
      return new AnafEfacturaClient(companyId, franchiseId);
    // Payments
    case "stripe" /* STRIPE */:
      return new StripeClient(companyId, franchiseId);
    case IntegrationProvider.REVOLUT_BUSINESS:
      return new RevolutBusinessClient(companyId, franchiseId);
    // Document Signing
    case IntegrationProvider.PANDADOC:
      return new PandaDocClient(companyId, franchiseId);
    // Email/Messaging
    case IntegrationProvider.MICROSOFT_GRAPH:
      return new MicrosoftGraphClient(companyId, franchiseId);
    // eCommerce
    case "shopify_admin" /* SHOPIFY_ADMIN */:
      return new ShopifyClient("admin" /* ADMIN */, companyId, franchiseId);
    case "shopify_storefront" /* SHOPIFY_STOREFRONT */:
      return new ShopifyClient("storefront" /* STOREFRONT */, companyId, franchiseId);
    case IntegrationProvider.SHOPIFY_INBOX:
      return new ShopifyClient("inbox" /* INBOX */, companyId, franchiseId);
    // Shipping
    case IntegrationProvider.SAMEDAY:
      return new SameDayClient(companyId, franchiseId);
    // Company Registry & Validation
    case IntegrationProvider.TERMENE_RO:
      return new TermeneRoClient(companyId, franchiseId);
    // AI Integrations
    case IntegrationProvider.OPENAI:
      return new OpenAIClient(companyId, franchiseId);
    case IntegrationProvider.ELEVENLABS:
      return new ElevenLabsClient(companyId, franchiseId);
    default:
      throw new Error(`Unsupported integration provider: ${provider}`);
  }
}

// server/modules/integrations/routes/pandadoc.route.ts
init_auth_guard();
init_auth_mode_enum();
init_audit_service();
var router5 = express3.Router();
var integrationsService = new IntegrationsService();
var auditService = new AuditService();
var RESOURCE_TYPE2 = "pandadoc";
router5.post(
  "/initialize",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["admin", "manager"]),
  async (req, res) => {
    try {
      const { apiKey } = req.body;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!apiKey) {
        return res.status(400).json({
          success: false,
          error: "API key is required"
        });
      }
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const existingIntegration = await integrationsService.getIntegrationByProvider(
        "pandadoc",
        companyId
      );
      if (existingIntegration) {
        return res.status(400).json({
          success: false,
          error: "PandaDoc integration already exists for this company",
          data: existingIntegration
        });
      }
      const pandaDocClient = new PandaDocClient(companyId);
      const isConnected = await pandaDocClient.testConnection(apiKey);
      if (!isConnected) {
        return res.status(400).json({
          success: false,
          error: "Failed to connect to PandaDoc API"
        });
      }
      const integration = await pandaDocClient.initialize(apiKey, userId);
      await auditService.createAuditLog({
        userId,
        companyId,
        action: "create",
        resourceType: RESOURCE_TYPE2,
        resourceId: integration.id,
        details: {
          message: "PandaDoc integration initialized"
        }
      });
      return res.status(201).json({
        success: true,
        data: integration
      });
    } catch (error) {
      console.error("[PandaDocRoutes] Initialize error:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to initialize PandaDoc integration"
      });
    }
  }
);
router5.get(
  "/templates",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const integration = await integrationsService.getIntegrationByProvider(
        "pandadoc",
        companyId
      );
      if (!integration) {
        return res.status(404).json({
          success: false,
          error: "PandaDoc integration not found"
        });
      }
      const pandaDocClient = new PandaDocClient(companyId);
      const templates = await pandaDocClient.listTemplates(userId);
      return res.status(200).json({
        success: true,
        data: templates
      });
    } catch (error) {
      console.error("[PandaDocRoutes] List templates error:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to list PandaDoc templates"
      });
    }
  }
);
router5.get(
  "/templates/:templateId",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const { templateId } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const integration = await integrationsService.getIntegrationByProvider(
        "pandadoc",
        companyId
      );
      if (!integration) {
        return res.status(404).json({
          success: false,
          error: "PandaDoc integration not found"
        });
      }
      const pandaDocClient = new PandaDocClient(companyId);
      const template = await pandaDocClient.getTemplate(templateId, userId);
      return res.status(200).json({
        success: true,
        data: template
      });
    } catch (error) {
      console.error("[PandaDocRoutes] Get template error:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to get PandaDoc template details"
      });
    }
  }
);
router5.post(
  "/documents/from-template",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const {
        name,
        templateId,
        recipients,
        metadata,
        tokens,
        fields,
        tags: tags2,
        pricingTables
      } = req.body;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      if (!name || !templateId || !recipients || !Array.isArray(recipients) || recipients.length === 0) {
        return res.status(400).json({
          success: false,
          error: "Name, templateId, and recipients are required"
        });
      }
      const integration = await integrationsService.getIntegrationByProvider(
        "pandadoc",
        companyId
      );
      if (!integration) {
        return res.status(404).json({
          success: false,
          error: "PandaDoc integration not found"
        });
      }
      const pandaDocClient = new PandaDocClient(companyId);
      const document = await pandaDocClient.createDocumentFromTemplate(
        name,
        templateId,
        recipients,
        metadata,
        tokens,
        fields,
        tags2,
        pricingTables,
        userId
      );
      await auditService.createAuditLog({
        userId,
        companyId,
        action: "create",
        resourceType: "document",
        resourceId: document.id,
        details: {
          name,
          templateId,
          recipientCount: recipients.length
        }
      });
      return res.status(201).json({
        success: true,
        data: document
      });
    } catch (error) {
      console.error("[PandaDocRoutes] Create document error:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to create document from template"
      });
    }
  }
);
router5.get(
  "/documents/:documentId",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const { documentId } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const integration = await integrationsService.getIntegrationByProvider(
        "pandadoc",
        companyId
      );
      if (!integration) {
        return res.status(404).json({
          success: false,
          error: "PandaDoc integration not found"
        });
      }
      const pandaDocClient = new PandaDocClient(companyId);
      const document = await pandaDocClient.getDocument(documentId, userId);
      return res.status(200).json({
        success: true,
        data: document
      });
    } catch (error) {
      console.error("[PandaDocRoutes] Get document error:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to get document details"
      });
    }
  }
);
router5.post(
  "/documents/:documentId/send",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const { documentId } = req.params;
      const { subject, message, silent = false } = req.body;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const integration = await integrationsService.getIntegrationByProvider(
        "pandadoc",
        companyId
      );
      if (!integration) {
        return res.status(404).json({
          success: false,
          error: "PandaDoc integration not found"
        });
      }
      const pandaDocClient = new PandaDocClient(companyId);
      const document = await pandaDocClient.sendDocument(
        documentId,
        subject,
        message,
        silent,
        userId
      );
      await auditService.createAuditLog({
        userId,
        companyId,
        action: "update",
        resourceType: "document",
        resourceId: documentId,
        details: {
          message: "Document sent for signing",
          silent
        }
      });
      return res.status(200).json({
        success: true,
        data: document
      });
    } catch (error) {
      console.error("[PandaDocRoutes] Send document error:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to send document"
      });
    }
  }
);
router5.get(
  "/documents/:documentId/status",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const { documentId } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const integration = await integrationsService.getIntegrationByProvider(
        "pandadoc",
        companyId
      );
      if (!integration) {
        return res.status(404).json({
          success: false,
          error: "PandaDoc integration not found"
        });
      }
      const pandaDocClient = new PandaDocClient(companyId);
      const documentStatus = await pandaDocClient.getDocumentStatus(documentId, userId);
      return res.status(200).json({
        success: true,
        data: documentStatus
      });
    } catch (error) {
      console.error("[PandaDoc Route] Failed to get document status:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to get document status"
      });
    }
  }
);
router5.get(
  "/documents/:documentId/download",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const { documentId } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const integration = await integrationsService.getIntegrationByProvider(
        "pandadoc",
        companyId
      );
      if (!integration) {
        return res.status(404).json({
          success: false,
          error: "PandaDoc integration not found"
        });
      }
      const pandaDocClient = new PandaDocClient(companyId);
      const fileBuffer = await pandaDocClient.downloadDocument(documentId, userId);
      await auditService.createAuditLog({
        userId,
        companyId,
        action: "read",
        resourceType: "document",
        resourceId: documentId,
        details: {
          message: "Document downloaded"
        }
      });
      res.set("Content-Type", "application/pdf");
      res.set("Content-Disposition", `attachment; filename="document-${documentId}.pdf"`);
      return res.send(fileBuffer);
    } catch (error) {
      console.error("[PandaDocRoutes] Download document error:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to download document"
      });
    }
  }
);
var pandadoc_route_default = router5;

// server/modules/integrations/routes/integrations.route.ts
import express4 from "express";
import { z as z17 } from "zod";
init_auth_guard();
init_audit_service();
init_integrations_schema();
var router6 = express4.Router();
var integrationsService2 = new IntegrationsService();
router6.get("/", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
  try {
    const userId = req.user?.id;
    const companyId = req.user?.companyId;
    if (!userId || !companyId) {
      return res.status(401).json({
        success: false,
        message: "Unauthorized - User ID or company ID missing"
      });
    }
    const franchiseId = req.query.franchiseId;
    const integrations2 = await integrationsService2.listIntegrations(companyId, franchiseId);
    const safeIntegrations = integrations2.map((integration) => {
      const { config: config3, webhookSecret, ...safeIntegration } = integration;
      return safeIntegration;
    });
    return res.status(200).json({
      success: true,
      count: safeIntegrations.length,
      data: safeIntegrations
    });
  } catch (error) {
    console.error("[IntegrationsRoute] Error getting integrations:", error instanceof Error ? error.message : String(error));
    return res.status(500).json({
      success: false,
      message: "Failed to get integrations",
      error: error instanceof Error ? error.message : String(error)
    });
  }
});
router6.get("/:id", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
  try {
    const userId = req.user?.id;
    const companyId = req.user?.companyId;
    if (!userId || !companyId) {
      return res.status(401).json({
        success: false,
        message: "Unauthorized - User ID or company ID missing"
      });
    }
    const integrationId = req.params.id;
    const integration = await integrationsService2.getIntegration(integrationId, companyId);
    if (!integration) {
      return res.status(404).json({
        success: false,
        message: "Integration not found"
      });
    }
    const { config: config3, webhookSecret, ...safeIntegration } = integration;
    return res.status(200).json({
      success: true,
      data: safeIntegration
    });
  } catch (error) {
    console.error("[IntegrationsRoute] Error getting integration:", error instanceof Error ? error.message : String(error));
    return res.status(500).json({
      success: false,
      message: "Failed to get integration",
      error: error instanceof Error ? error.message : String(error)
    });
  }
});
router6.post(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */]),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          message: "Unauthorized - User ID or company ID missing"
        });
      }
      const schema = z17.object({
        provider: z17.string(),
        franchiseId: z17.string().optional(),
        name: z17.string().optional(),
        description: z17.string().optional(),
        config: z17.record(z17.any()).optional()
      });
      const validationResult = schema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid request body",
          errors: validationResult.error.errors
        });
      }
      const { provider: providerString, franchiseId, name, description, config: config3 } = validationResult.data;
      let provider;
      try {
        if (!Object.values(IntegrationProvider).includes(providerString)) {
          return res.status(400).json({
            success: false,
            message: `Invalid provider. Available providers: ${Object.values(IntegrationProvider).join(", ")}`
          });
        }
        provider = providerString;
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: `Invalid provider. Available providers: ${Object.values(IntegrationProvider).join(", ")}`
        });
      }
      const existingIntegration = await integrationsService2.getIntegrationByProvider(
        provider,
        companyId,
        franchiseId
      );
      if (existingIntegration) {
        return res.status(409).json({
          success: false,
          message: `Integration for provider ${provider} already exists for this company`
        });
      }
      const integration = await integrationsService2.createIntegration(
        provider,
        companyId,
        config3 || {},
        userId,
        franchiseId
      );
      const { config: configData, webhookSecret, ...safeIntegration } = integration;
      return res.status(201).json({
        success: true,
        message: "Integration created successfully",
        data: safeIntegration
      });
    } catch (error) {
      console.error("[IntegrationsRoute] Error creating integration:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        message: "Failed to create integration",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
);
router6.patch(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */]),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          message: "Unauthorized - User ID or company ID missing"
        });
      }
      const integrationId = req.params.id;
      const existingIntegration = await integrationsService2.getIntegration(integrationId, companyId);
      if (!existingIntegration) {
        return res.status(404).json({
          success: false,
          message: "Integration not found"
        });
      }
      const schema = z17.object({
        name: z17.string().optional(),
        description: z17.string().optional(),
        status: z17.enum([
          "active" /* ACTIVE */,
          "inactive" /* INACTIVE */,
          "error" /* ERROR */,
          "pending" /* PENDING */
        ]).optional(),
        config: z17.record(z17.any()).optional(),
        webhookUrl: z17.string().optional(),
        webhookSecret: z17.string().optional()
      });
      const validationResult = schema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid request body",
          errors: validationResult.error.errors
        });
      }
      const updatedIntegration = await integrationsService2.updateIntegration(
        integrationId,
        companyId,
        validationResult.data,
        userId
      );
      if (!updatedIntegration) {
        return res.status(500).json({
          success: false,
          message: "Failed to update integration"
        });
      }
      const { config: config3, webhookSecret, ...safeIntegration } = updatedIntegration;
      return res.status(200).json({
        success: true,
        message: "Integration updated successfully",
        data: safeIntegration
      });
    } catch (error) {
      console.error("[IntegrationsRoute] Error updating integration:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        message: "Failed to update integration",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
);
router6.delete(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */]),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          message: "Unauthorized - User ID or company ID missing"
        });
      }
      const integrationId = req.params.id;
      const existingIntegration = await integrationsService2.getIntegration(integrationId, companyId);
      if (!existingIntegration) {
        return res.status(404).json({
          success: false,
          message: "Integration not found"
        });
      }
      const result = await integrationsService2.deleteIntegration(integrationId, companyId, userId);
      if (!result) {
        return res.status(500).json({
          success: false,
          message: "Failed to delete integration"
        });
      }
      return res.status(200).json({
        success: true,
        message: "Integration deleted successfully"
      });
    } catch (error) {
      console.error("[IntegrationsRoute] Error deleting integration:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        message: "Failed to delete integration",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
);
router6.post(
  "/:provider/initialize",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */]),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          message: "Unauthorized - User ID or company ID missing"
        });
      }
      const providerString = req.params.provider;
      const franchiseId = req.query.franchiseId;
      let provider;
      try {
        if (!Object.values(IntegrationProvider).includes(providerString)) {
          return res.status(400).json({
            success: false,
            message: `Invalid provider. Available providers: ${Object.values(IntegrationProvider).join(", ")}`
          });
        }
        provider = providerString;
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: `Invalid provider. Available providers: ${Object.values(IntegrationProvider).join(", ")}`
        });
      }
      const existingIntegration = await integrationsService2.getIntegrationByProvider(
        provider,
        companyId,
        franchiseId
      );
      if (existingIntegration) {
        return res.status(409).json({
          success: false,
          message: `Integration for provider ${provider} already exists for this company`
        });
      }
      try {
        const client = getIntegrationClient(provider, companyId, franchiseId);
        let integration;
        switch (provider) {
          case IntegrationProvider.ANAF_EFACTURA:
            const anafSchema = z17.object({
              apiKey: z17.string(),
              clientId: z17.string(),
              clientSecret: z17.string(),
              apiUrl: z17.string().optional()
            });
            const anafValidation = anafSchema.safeParse(req.body);
            if (!anafValidation.success) {
              return res.status(400).json({
                success: false,
                message: "Invalid ANAF e-Factura initialization parameters",
                errors: anafValidation.error.errors
              });
            }
            const { apiKey, clientId, clientSecret, apiUrl } = anafValidation.data;
            integration = await client.initialize(
              apiKey,
              clientId,
              clientSecret,
              apiUrl,
              userId
            );
            break;
          case "stripe" /* STRIPE */:
            const stripeSchema = z17.object({
              apiKey: z17.string(),
              webhookSecret: z17.string()
            });
            const stripeValidation = stripeSchema.safeParse(req.body);
            if (!stripeValidation.success) {
              return res.status(400).json({
                success: false,
                message: "Invalid Stripe initialization parameters",
                errors: stripeValidation.error.errors
              });
            }
            const { apiKey: stripeApiKey, webhookSecret } = stripeValidation.data;
            integration = await client.initialize(
              stripeApiKey,
              webhookSecret,
              userId
            );
            break;
          case IntegrationProvider.PANDADOC:
            const pandaDocSchema = z17.object({
              apiKey: z17.string()
            });
            const pandaDocValidation = pandaDocSchema.safeParse(req.body);
            if (!pandaDocValidation.success) {
              return res.status(400).json({
                success: false,
                message: "Invalid PandaDoc initialization parameters",
                errors: pandaDocValidation.error.errors
              });
            }
            const { apiKey: pandaDocApiKey } = pandaDocValidation.data;
            integration = await client.initialize(
              pandaDocApiKey,
              userId
            );
            break;
          default:
            return res.status(400).json({
              success: false,
              message: `Provider ${provider} initialization not implemented`
            });
        }
        return res.status(201).json({
          success: true,
          message: `${provider} integration initialized successfully`,
          data: {
            id: integration.id,
            provider: integration.provider,
            status: integration.status,
            isConnected: integration.isConnected
          }
        });
      } catch (error) {
        return res.status(400).json({
          success: false,
          message: `Failed to initialize ${provider} integration`,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    } catch (error) {
      console.error("[IntegrationsRoute] Error initializing integration:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        message: "Failed to initialize integration",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
);
router6.post(
  "/:id/test",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */]),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          message: "Unauthorized - User ID or company ID missing"
        });
      }
      const integrationId = req.params.id;
      const existingIntegration = await integrationsService2.getIntegration(integrationId, companyId);
      if (!existingIntegration) {
        return res.status(404).json({
          success: false,
          message: "Integration not found"
        });
      }
      const client = getIntegrationClient(
        existingIntegration.provider,
        companyId,
        existingIntegration.franchiseId || void 0
      );
      const isConnected = await client.testConnection();
      if (isConnected) {
        await integrationsService2.updateIntegrationStatus(
          integrationId,
          companyId,
          "active" /* ACTIVE */,
          userId
        );
      } else {
        await integrationsService2.updateIntegrationStatus(
          integrationId,
          companyId,
          "error" /* ERROR */,
          userId
        );
      }
      return res.status(200).json({
        success: true,
        data: {
          id: integrationId,
          isConnected,
          status: isConnected ? "active" /* ACTIVE */ : "error" /* ERROR */
        }
      });
    } catch (error) {
      console.error("[IntegrationsRoute] Error testing integration connection:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        message: "Failed to test integration connection",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
);
router6.post("/activate-placeholder", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
  try {
    const userId = req.user?.id;
    const companyId = req.user?.companyId;
    if (!userId || !companyId) {
      return res.status(401).json({
        success: false,
        message: "Unauthorized - User ID or company ID missing"
      });
    }
    await AuditService.log({
      userId,
      companyId,
      action: "INTEGRATION_ACTIVATE" /* INTEGRATION_ACTIVATE */,
      entity: "integration",
      entityId: "placeholder",
      details: {
        requestBody: req.body,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
    return res.status(200).json({
      success: true,
      message: "Integration activation placeholder",
      data: {
        requestData: req.body,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    console.error("[IntegrationsRoute] Error in activate-placeholder:", error instanceof Error ? error.message : String(error));
    return res.status(500).json({
      success: false,
      message: "Failed to process integration activation",
      error: error instanceof Error ? error.message : String(error)
    });
  }
});
var integrations_route_default = router6;

// server/modules/integrations/routes/index.ts
var router7 = express5.Router();
router7.use("/", integrations_route_default);
router7.use("/pandadoc", pandadoc_route_default);
var routes_default = router7;

// server/modules/integrations/routes/public.routes.ts
import { Router as Router23 } from "express";
init_registry();
init_schema4();
import { and as and41, eq as eq52, gte as gte4, lte as lte4, inArray, asc as asc10 } from "drizzle-orm";
var router8 = Router23();
router8.get("/exchange-rates/bnr/all", async (req, res) => {
  try {
    res.setHeader("Content-Type", "application/json");
    log("\u{1F4E3} Public access to BNR exchange rates", "api");
    let date5;
    if (req.query.date) {
      date5 = new Date(req.query.date);
      if (isNaN(date5.getTime())) {
        return res.status(400).json({ error: "Invalid date format. Use YYYY-MM-DD" });
      }
    }
    const rates = await CurrencyService.getRates(date5);
    return res.json({
      base: "RON",
      date: date5 ? date5.toISOString().split("T")[0] : (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      rates,
      count: Object.keys(rates).length,
      source: "BNR Official (RSS)",
      public: true
    });
  } catch (error) {
    log(`\u274C Error in public BNR rates API: ${error.message}`, "api");
    return res.status(500).json({
      success: false,
      error: error.message,
      public: true
    });
  }
});
router8.get("/exchange-rates/historical", async (req, res) => {
  try {
    res.setHeader("Content-Type", "application/json");
    log("\u{1F4E3} Public access to historical exchange rates", "api");
    const currencies = req.query.currencies ? req.query.currencies.split(",") : ["USD", "EUR", "TRY"];
    const days = parseInt(req.query.days || "10");
    const maxDays = 90;
    const source = req.query.source || "";
    if (isNaN(days) || days <= 0 || days > maxDays) {
      return res.status(400).json({
        success: false,
        error: `Invalid number of days. Must be between 1 and ${maxDays}`
      });
    }
    log(`\u{1F4C8} Fetching historical rates for currencies: ${currencies.join(", ")} for the past ${days} days ${source ? `(source: ${source})` : ""}`, "api");
    const db4 = Services.db.db;
    const endDate = /* @__PURE__ */ new Date();
    endDate.setHours(23, 59, 59, 999);
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - days);
    startDate.setHours(0, 0, 0, 0);
    let query = db4.select({
      currency: fx_rates.currency,
      rate: fx_rates.rate,
      date: fx_rates.date,
      source: fx_rates.source
    }).from(fx_rates).where(
      and41(
        eq52(fx_rates.baseCurrency, "RON"),
        inArray(fx_rates.currency, currencies),
        gte4(fx_rates.date, startDate),
        lte4(fx_rates.date, endDate)
      )
    );
    if (source) {
      query = query.where(eq52(fx_rates.source, source));
    }
    const ratesData = await query.orderBy(asc10(fx_rates.date));
    const dateMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < days; i++) {
      const date5 = new Date(endDate);
      date5.setDate(date5.getDate() - i);
      const dateStr = date5.toISOString().split("T")[0];
      dateMap.set(dateStr, { date: dateStr });
      currencies.forEach((currency) => {
        dateMap.get(dateStr)[currency] = null;
      });
    }
    const bestRatesByDateAndCurrency = /* @__PURE__ */ new Map();
    ratesData.forEach((record) => {
      const dateStr = record.date.toISOString().split("T")[0];
      const key = `${dateStr}_${record.currency}`;
      const existingRecord = bestRatesByDateAndCurrency.get(key);
      if (!existingRecord || record.source === "BNR_RSS" && existingRecord.source === "BNR") {
        bestRatesByDateAndCurrency.set(key, {
          currency: record.currency,
          rate: parseFloat(record.rate.toString()),
          date: dateStr,
          source: record.source
        });
      }
    });
    bestRatesByDateAndCurrency.forEach((bestRate) => {
      const dateStr = bestRate.date;
      if (dateMap.has(dateStr)) {
        const entry = dateMap.get(dateStr);
        entry[bestRate.currency] = bestRate.rate;
      }
    });
    const historicalRates = Array.from(dateMap.values()).sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    const actualDataCount = bestRatesByDateAndCurrency.size;
    return res.json({
      success: true,
      base: "RON",
      currencies,
      days,
      data: historicalRates,
      count: historicalRates.length,
      dataPoints: actualDataCount,
      source: source || "Combined BNR Sources (RSS preferred)",
      startDate: startDate.toISOString().split("T")[0],
      endDate: endDate.toISOString().split("T")[0],
      public: true
    });
  } catch (error) {
    log(`\u274C Error in historical exchange rates API: ${error.message}`, "api");
    return res.status(500).json({
      success: false,
      error: error.message,
      public: true
    });
  }
});
router8.post("/exchange-rates/bnr/update", async (req, res) => {
  try {
    res.setHeader("Content-Type", "application/json");
    log("\u{1F504} Manual BNR exchange rate update triggered (public access)", "api");
    const rates = await bnrExchangeRateService.manualFetch();
    return res.json({
      success: true,
      message: "BNR exchange rates updated successfully",
      base: "RON",
      date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      rates,
      source: "BNR Official (RSS)",
      currencyCount: Object.keys(rates).length,
      public: true
    });
  } catch (error) {
    log(`\u274C Error in public BNR update API: ${error.message}`, "api");
    return res.status(500).json({
      success: false,
      error: error.message,
      date: (/* @__PURE__ */ new Date()).toISOString(),
      public: true
    });
  }
});
var public_routes_default = router8;

// server/modules/integrations/integrations.module.ts
var integrationsService3;
function initializeIntegrationsModule(app2) {
  console.log("\u{1F310} Initializing Integrations Module...");
  integrationsService3 = new IntegrationsService();
  bnrExchangeRateService.initialize();
  app2.use("/api", public_routes_default);
  console.log("\u{1F30D} Registered public exchange rate routes at /api/exchange-rates/bnr/*");
  app2.use("/api/integrations", routes_default);
  console.log(`\u{1F4CA} Loaded ${Object.keys(clients_exports).length} integration clients`);
  console.log("\u{1F50C} Registered integrations routes at /api/integrations");
  return {
    // Export services for use by other modules
    integrationsService: integrationsService3,
    bnrExchangeRateService,
    CurrencyService,
    anafService: anafService2,
    eFacturaService,
    exchangeRateService,
    // Export integration clients
    integrationClients: clients_exports
  };
}

// server/modules/bpm/bpm.module.ts
init_logger();

// server/modules/bpm/init.ts
init_logger();
init_drizzle();
init_drizzle_service();

// server/modules/bpm/services/process.service.ts
init_logger();
import { eq as eq54, and as and43, like as like7, or as or11, desc as desc21, sql as sql41 } from "drizzle-orm";
import { v4 as uuidv431 } from "uuid";

// server/modules/bpm/schema/bpm.schema.ts
import { pgTable as pgTable18, uuid as uuid17, text as text18, timestamp as timestamp18, boolean as boolean16, jsonb as jsonb5 } from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema12, createSelectSchema as createSelectSchema4 } from "drizzle-zod";
import { z as z18 } from "zod";
var BpmProcessStatus = /* @__PURE__ */ ((BpmProcessStatus2) => {
  BpmProcessStatus2["DRAFT"] = "DRAFT";
  BpmProcessStatus2["ACTIVE"] = "ACTIVE";
  BpmProcessStatus2["INACTIVE"] = "INACTIVE";
  BpmProcessStatus2["ARCHIVED"] = "ARCHIVED";
  return BpmProcessStatus2;
})(BpmProcessStatus || {});
var BpmProcessInstanceStatus = /* @__PURE__ */ ((BpmProcessInstanceStatus2) => {
  BpmProcessInstanceStatus2["PENDING"] = "PENDING";
  BpmProcessInstanceStatus2["RUNNING"] = "RUNNING";
  BpmProcessInstanceStatus2["COMPLETED"] = "COMPLETED";
  BpmProcessInstanceStatus2["CANCELLED"] = "CANCELLED";
  BpmProcessInstanceStatus2["ERROR"] = "ERROR";
  return BpmProcessInstanceStatus2;
})(BpmProcessInstanceStatus || {});
var BpmTriggerType = /* @__PURE__ */ ((BpmTriggerType3) => {
  BpmTriggerType3["WEBHOOK"] = "WEBHOOK";
  BpmTriggerType3["SCHEDULED"] = "SCHEDULED";
  BpmTriggerType3["EVENT"] = "EVENT";
  BpmTriggerType3["MANUAL"] = "MANUAL";
  BpmTriggerType3["DATA_CHANGE"] = "DATA_CHANGE";
  BpmTriggerType3["EXTERNAL_API"] = "EXTERNAL_API";
  return BpmTriggerType3;
})(BpmTriggerType || {});
var BpmStepTemplateType = /* @__PURE__ */ ((BpmStepTemplateType3) => {
  BpmStepTemplateType3["ACTION"] = "ACTION";
  BpmStepTemplateType3["DECISION"] = "DECISION";
  BpmStepTemplateType3["DELAY"] = "DELAY";
  BpmStepTemplateType3["NOTIFICATION"] = "NOTIFICATION";
  BpmStepTemplateType3["APPROVAL"] = "APPROVAL";
  BpmStepTemplateType3["SUBPROCESS"] = "SUBPROCESS";
  BpmStepTemplateType3["API_CALL"] = "API_CALL";
  BpmStepTemplateType3["DOCUMENT_GENERATION"] = "DOCUMENT_GENERATION";
  return BpmStepTemplateType3;
})(BpmStepTemplateType || {});
var BpmStepTemplateTargetType = /* @__PURE__ */ ((BpmStepTemplateTargetType3) => {
  BpmStepTemplateTargetType3["INVOICING"] = "INVOICING";
  BpmStepTemplateTargetType3["INVENTORY"] = "INVENTORY";
  BpmStepTemplateTargetType3["CRM"] = "CRM";
  BpmStepTemplateTargetType3["LOGISTICS"] = "LOGISTICS";
  BpmStepTemplateTargetType3["ACCOUNTING"] = "ACCOUNTING";
  BpmStepTemplateTargetType3["DOCUMENTS"] = "DOCUMENTS";
  BpmStepTemplateTargetType3["COMMUNICATIONS"] = "COMMUNICATIONS";
  BpmStepTemplateTargetType3["MARKETING"] = "MARKETING";
  BpmStepTemplateTargetType3["EXTERNAL_API"] = "EXTERNAL_API";
  return BpmStepTemplateTargetType3;
})(BpmStepTemplateTargetType || {});
var BpmStepExecutionStatus = /* @__PURE__ */ ((BpmStepExecutionStatus2) => {
  BpmStepExecutionStatus2["PENDING"] = "PENDING";
  BpmStepExecutionStatus2["RUNNING"] = "RUNNING";
  BpmStepExecutionStatus2["COMPLETED"] = "COMPLETED";
  BpmStepExecutionStatus2["FAILED"] = "FAILED";
  BpmStepExecutionStatus2["SKIPPED"] = "SKIPPED";
  BpmStepExecutionStatus2["WAITING_MANUAL"] = "WAITING_MANUAL";
  return BpmStepExecutionStatus2;
})(BpmStepExecutionStatus || {});
var BpmApiConnectionType = /* @__PURE__ */ ((BpmApiConnectionType3) => {
  BpmApiConnectionType3["REST"] = "REST";
  BpmApiConnectionType3["GRAPHQL"] = "GRAPHQL";
  BpmApiConnectionType3["SOAP"] = "SOAP";
  BpmApiConnectionType3["WEBHOOK"] = "WEBHOOK";
  BpmApiConnectionType3["DATABASE"] = "DATABASE";
  return BpmApiConnectionType3;
})(BpmApiConnectionType || {});
var bpmProcesses = pgTable18("bpm_processes", {
  id: uuid17("id").primaryKey().notNull().defaultRandom(),
  name: text18("name").notNull(),
  description: text18("description"),
  companyId: text18("company_id").notNull(),
  steps: jsonb5("steps").notNull().default({}),
  status: text18("status").notNull().default("DRAFT"),
  isTemplate: boolean16("is_template").notNull().default(false),
  version: text18("version").notNull().default("1.0"),
  createdAt: timestamp18("created_at").notNull().defaultNow(),
  updatedAt: timestamp18("updated_at").notNull().defaultNow(),
  createdBy: text18("created_by").notNull(),
  updatedBy: text18("updated_by").notNull(),
  franchiseId: text18("franchise_id")
});
var bpmTriggers = pgTable18("bpm_triggers", {
  id: uuid17("id").primaryKey().notNull().defaultRandom(),
  name: text18("name").notNull(),
  description: text18("description"),
  companyId: text18("company_id").notNull(),
  type: text18("type").notNull(),
  processId: text18("process_id").notNull(),
  configuration: jsonb5("configuration").notNull().default({}),
  isActive: boolean16("is_active").notNull().default(true),
  createdAt: timestamp18("created_at").notNull().defaultNow(),
  updatedAt: timestamp18("updated_at").notNull().defaultNow(),
  createdBy: text18("created_by").notNull(),
  updatedBy: text18("updated_by").notNull()
});
var bpmProcessInstances = pgTable18("bpm_process_instances", {
  id: uuid17("id").primaryKey().notNull().defaultRandom(),
  processId: text18("process_id").notNull(),
  companyId: text18("company_id").notNull(),
  status: text18("status").notNull(),
  currentStep: text18("current_step"),
  startedBy: text18("started_by").notNull(),
  inputData: jsonb5("input_data").notNull().default({}),
  outputData: jsonb5("output_data").notNull().default({}),
  variables: jsonb5("variables").notNull().default({}),
  createdAt: timestamp18("created_at").notNull().defaultNow(),
  updatedAt: timestamp18("updated_at").notNull().defaultNow(),
  completedAt: timestamp18("completed_at")
});
var bpmProcessInstanceHistory = pgTable18("bpm_process_instance_history", {
  id: uuid17("id").primaryKey().notNull().defaultRandom(),
  instanceId: text18("instance_id").notNull(),
  action: text18("action").notNull(),
  status: text18("status").notNull(),
  details: jsonb5("details").notNull().default({}),
  userId: text18("user_id"),
  createdAt: timestamp18("created_at").notNull().defaultNow()
});
var bpmStepTemplates = pgTable18("bpm_step_templates", {
  id: uuid17("id").primaryKey().notNull().defaultRandom(),
  name: text18("name").notNull(),
  description: text18("description"),
  companyId: text18("company_id").notNull(),
  type: text18("type").notNull(),
  configuration: jsonb5("configuration").notNull().default({}),
  targetType: text18("target_type"),
  isGlobal: boolean16("is_global").notNull().default(false),
  createdAt: timestamp18("created_at").notNull().defaultNow(),
  updatedAt: timestamp18("updated_at").notNull().defaultNow(),
  createdBy: text18("created_by").notNull(),
  updatedBy: text18("updated_by").notNull()
});
var bpmStepExecutions = pgTable18("bpm_step_executions", {
  id: uuid17("id").primaryKey().notNull().defaultRandom(),
  instanceId: text18("instance_id").notNull(),
  stepId: text18("step_id").notNull(),
  companyId: text18("company_id").notNull(),
  status: text18("status").notNull(),
  inputData: jsonb5("input_data").notNull().default({}),
  outputData: jsonb5("output_data").notNull().default({}),
  errorData: jsonb5("error_data").default({}),
  startedAt: timestamp18("started_at").notNull().defaultNow(),
  completedAt: timestamp18("completed_at"),
  assignedTo: text18("assigned_to"),
  executedBy: text18("executed_by")
});
var bpmApiConnections = pgTable18("bpm_api_connections", {
  id: uuid17("id").primaryKey().notNull().defaultRandom(),
  name: text18("name").notNull(),
  description: text18("description"),
  companyId: text18("company_id").notNull(),
  type: text18("type").notNull(),
  configuration: jsonb5("configuration").notNull().default({}),
  isActive: boolean16("is_active").notNull().default(true),
  createdAt: timestamp18("created_at").notNull().defaultNow(),
  updatedAt: timestamp18("updated_at").notNull().defaultNow(),
  createdBy: text18("created_by").notNull(),
  updatedBy: text18("updated_by").notNull(),
  lastUsedAt: timestamp18("last_used_at")
});
var bpmScheduledJobs = pgTable18("bpm_scheduled_jobs", {
  id: uuid17("id").primaryKey().notNull().defaultRandom(),
  name: text18("name").notNull(),
  description: text18("description"),
  companyId: text18("company_id").notNull(),
  schedule: text18("schedule").notNull(),
  action: text18("action").notNull(),
  configuration: jsonb5("configuration").notNull().default({}),
  isActive: boolean16("is_active").notNull().default(true),
  createdAt: timestamp18("created_at").notNull().defaultNow(),
  updatedAt: timestamp18("updated_at").notNull().defaultNow(),
  createdBy: text18("created_by").notNull(),
  updatedBy: text18("updated_by").notNull(),
  lastRunAt: timestamp18("last_run_at")
});
var insertProcessSchema = createInsertSchema12(bpmProcesses);
var insertTriggerSchema = createInsertSchema12(bpmTriggers);
var insertProcessInstanceSchema = createInsertSchema12(bpmProcessInstances);
var insertProcessInstanceHistorySchema = createInsertSchema12(bpmProcessInstanceHistory);
var insertStepTemplateSchema = createInsertSchema12(bpmStepTemplates);
var insertStepExecutionSchema = createInsertSchema12(bpmStepExecutions);
var insertApiConnectionSchema = createInsertSchema12(bpmApiConnections);
var insertScheduledJobSchema = createInsertSchema12(bpmScheduledJobs);
var selectProcessSchema = createSelectSchema4(bpmProcesses);
var selectTriggerSchema = createSelectSchema4(bpmTriggers);
var selectProcessInstanceSchema = createSelectSchema4(bpmProcessInstances);
var selectProcessInstanceHistorySchema = createSelectSchema4(bpmProcessInstanceHistory);
var selectStepTemplateSchema = createSelectSchema4(bpmStepTemplates);
var selectStepExecutionSchema = createSelectSchema4(bpmStepExecutions);
var selectApiConnectionSchema = createSelectSchema4(bpmApiConnections);
var selectScheduledJobSchema = createSelectSchema4(bpmScheduledJobs);
var createProcessSchema = insertProcessSchema.omit({ id: true, createdAt: true, updatedAt: true }).extend({
  name: z18.string().min(3).max(100),
  status: z18.nativeEnum(BpmProcessStatus)
});
var updateProcessSchema = createProcessSchema.partial().extend({
  updatedBy: z18.string()
});
var createTriggerSchema = insertTriggerSchema.omit({ id: true, createdAt: true, updatedAt: true }).extend({
  name: z18.string().min(3).max(100),
  type: z18.nativeEnum(BpmTriggerType)
});
var updateTriggerSchema = createTriggerSchema.partial().extend({
  updatedBy: z18.string()
});
var startProcessSchema = z18.object({
  processId: z18.string().uuid(),
  companyId: z18.string(),
  startedBy: z18.string(),
  inputData: z18.record(z18.any()).optional()
});
var createStepTemplateSchema = insertStepTemplateSchema.omit({ id: true, createdAt: true, updatedAt: true }).extend({
  name: z18.string().min(3).max(100),
  type: z18.nativeEnum(BpmStepTemplateType),
  targetType: z18.nativeEnum(BpmStepTemplateTargetType).optional()
});
var updateStepTemplateSchema = createStepTemplateSchema.partial().extend({
  updatedBy: z18.string()
});
var createStepExecutionSchema = insertStepExecutionSchema.omit({ id: true, startedAt: true, completedAt: true }).extend({
  status: z18.nativeEnum(BpmStepExecutionStatus)
});
var updateStepExecutionSchema = createStepExecutionSchema.partial().extend({
  status: z18.nativeEnum(BpmStepExecutionStatus).optional()
});
var createApiConnectionSchema = insertApiConnectionSchema.omit({ id: true, createdAt: true, updatedAt: true, lastUsedAt: true }).extend({
  name: z18.string().min(3).max(100),
  type: z18.nativeEnum(BpmApiConnectionType)
});
var updateApiConnectionSchema = createApiConnectionSchema.partial().extend({
  updatedBy: z18.string()
});
var createScheduledJobSchema = insertScheduledJobSchema.omit({ id: true, createdAt: true, updatedAt: true, lastRunAt: true }).extend({
  name: z18.string().min(3).max(100),
  schedule: z18.string().min(5)
});
var updateScheduledJobSchema = createScheduledJobSchema.partial().extend({
  updatedBy: z18.string()
});

// server/modules/bpm/services/process-instance.service.ts
init_logger();
import { eq as eq53, and as and42, or as or10, desc as desc20, sql as sql40, asc as asc11, inArray as inArray2 } from "drizzle-orm";
import { v4 as uuidv430 } from "uuid";
var ProcessInstanceService = class {
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    this._logger = new Logger("ProcessInstanceService");
  }
  /**
   * Create a new process instance
   */
  async createInstance(data) {
    this._logger.info("Creating process instance", { processId: data.processId });
    try {
      const now = /* @__PURE__ */ new Date();
      const result = await this.drizzleService.query(
        (tx) => tx.insert(bpmProcessInstances).values({
          id: uuidv430(),
          processId: data.processId,
          companyId: data.companyId,
          status: data.status,
          currentStep: data.currentStep || null,
          startedBy: data.startedBy,
          inputData: data.inputData || {},
          outputData: data.outputData || {},
          variables: data.variables || {},
          createdAt: now,
          updatedAt: now,
          completedAt: null
        }).returning()
      );
      const instance = result[0];
      await this.addHistoryEntry({
        instanceId: instance.id,
        action: "CREATED",
        status: instance.status,
        details: {
          processId: data.processId,
          initialStep: data.currentStep
        },
        userId: data.startedBy
      });
      this._logger.info("Created process instance", { id: instance.id, processId: data.processId });
      return instance;
    } catch (error) {
      this._logger.error("Failed to create process instance", { error, processId: data.processId });
      throw error;
    }
  }
  /**
   * Get process instance by ID
   */
  async getInstanceById(id, companyId) {
    this._logger.debug("Getting process instance by ID", { id, companyId });
    try {
      const results = await this.drizzleService.query((tx) => {
        let query = tx.select().from(bpmProcessInstances).where(eq53(bpmProcessInstances.id, id));
        if (companyId) {
          query = query.where(eq53(bpmProcessInstances.companyId, companyId));
        }
        return query;
      });
      const instance = results.length > 0 ? results[0] : null;
      if (!instance) {
        this._logger.debug("Process instance not found", { id });
        return null;
      }
      return instance;
    } catch (error) {
      this._logger.error("Failed to get process instance by ID", { error, id });
      throw error;
    }
  }
  /**
   * Get process instances with filtering and pagination
   */
  async getInstances(companyId, filter = {}) {
    this._logger.debug("Getting process instances with filter", { companyId, filter });
    try {
      const page = filter.page || 1;
      const limit = filter.limit || 20;
      const offset = (page - 1) * limit;
      let conditions = and42(
        eq53(bpmProcessInstances.companyId, companyId)
      );
      if (filter.processId) {
        conditions = and42(conditions, eq53(bpmProcessInstances.processId, filter.processId));
      }
      if (filter.startedBy) {
        conditions = and42(conditions, eq53(bpmProcessInstances.startedBy, filter.startedBy));
      }
      if (filter.status && filter.status.length > 0) {
        conditions = and42(conditions, or10(...filter.status.map(
          (status) => eq53(bpmProcessInstances.status, status)
        )));
      }
      const countResults = await this.drizzleService.query(
        (tx) => tx.select({
          count: sql40`cast(count(*) as int)`
        }).from(bpmProcessInstances).where(conditions)
      );
      const [{ count: count5 }] = countResults;
      const data = await this.drizzleService.query(
        (tx) => tx.select().from(bpmProcessInstances).where(conditions).orderBy(desc20(bpmProcessInstances.createdAt)).limit(limit).offset(offset)
      );
      return {
        data,
        total: count5
      };
    } catch (error) {
      this._logger.error("Failed to get process instances", { error, companyId });
      throw error;
    }
  }
  /**
   * Update a process instance
   */
  async updateInstance(id, data, userId) {
    this._logger.info("Updating process instance", { id });
    try {
      const instance = await this.getInstanceById(id);
      if (!instance) {
        return null;
      }
      const updateData = {
        updatedAt: /* @__PURE__ */ new Date()
      };
      let changes = {};
      if (data.status !== void 0) {
        updateData.status = data.status;
        changes.status = { from: instance.status, to: data.status };
      }
      if (data.currentStep !== void 0) {
        updateData.currentStep = data.currentStep;
        changes.currentStep = { from: instance.currentStep, to: data.currentStep };
      }
      if (data.outputData !== void 0) {
        updateData.outputData = data.outputData;
        changes.outputDataUpdated = true;
      }
      if (data.variables !== void 0) {
        updateData.variables = {
          ...instance.variables,
          ...data.variables
        };
        changes.variablesUpdated = true;
      }
      if (data.completedAt !== void 0) {
        updateData.completedAt = data.completedAt;
        changes.completedAt = data.completedAt;
      }
      const result = await this.drizzleService.query(
        (tx) => tx.update(bpmProcessInstances).set(updateData).where(eq53(bpmProcessInstances.id, id)).returning()
      );
      const updatedInstance = result[0];
      if (Object.keys(changes).length > 0) {
        await this.addHistoryEntry({
          instanceId: id,
          action: "UPDATED",
          status: updatedInstance.status,
          details: changes,
          userId
        });
      }
      this._logger.info("Updated process instance", { id });
      return updatedInstance;
    } catch (error) {
      this._logger.error("Failed to update process instance", { error, id });
      throw error;
    }
  }
  /**
   * Complete a process instance
   */
  async completeInstance(id, outputData, userId) {
    this._logger.info("Completing process instance", { id });
    try {
      const instance = await this.getInstanceById(id);
      if (!instance) {
        return null;
      }
      if (instance.status === "COMPLETED" /* COMPLETED */) {
        this._logger.warn("Process instance already completed", { id });
        return instance;
      }
      const updateData = {
        status: "COMPLETED" /* COMPLETED */,
        completedAt: /* @__PURE__ */ new Date()
      };
      if (outputData) {
        updateData.outputData = {
          ...instance.outputData,
          ...outputData
        };
      }
      await this.addHistoryEntry({
        instanceId: id,
        action: "COMPLETED",
        status: "COMPLETED" /* COMPLETED */,
        details: {
          completedAt: updateData.completedAt,
          previousStatus: instance.status
        },
        userId
      });
      return this.updateInstance(id, updateData, userId);
    } catch (error) {
      this._logger.error("Failed to complete process instance", { error, id });
      throw error;
    }
  }
  /**
   * Cancel a process instance
   */
  async cancelInstance(id, reason, userId) {
    this._logger.info("Canceling process instance", { id });
    try {
      const instance = await this.getInstanceById(id);
      if (!instance) {
        return null;
      }
      if (instance.status === "COMPLETED" /* COMPLETED */ || instance.status === "CANCELLED" /* CANCELLED */) {
        this._logger.warn("Process instance already completed or cancelled", { id, status: instance.status });
        return instance;
      }
      const updateData = {
        status: "CANCELLED" /* CANCELLED */,
        completedAt: /* @__PURE__ */ new Date(),
        variables: {
          ...instance.variables,
          cancellationReason: reason || "Manual cancellation",
          cancellationTime: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      await this.addHistoryEntry({
        instanceId: id,
        action: "CANCELLED",
        status: "CANCELLED" /* CANCELLED */,
        details: {
          reason: reason || "Manual cancellation",
          previousStatus: instance.status
        },
        userId
      });
      return this.updateInstance(id, updateData, userId);
    } catch (error) {
      this._logger.error("Failed to cancel process instance", { error, id });
      throw error;
    }
  }
  /**
   * Add a history entry for a process instance
   */
  async addHistoryEntry(data) {
    this._logger.debug("Adding process instance history entry", {
      instanceId: data.instanceId,
      action: data.action
    });
    try {
      const result = await this.drizzleService.query(
        (tx) => tx.insert(bpmProcessInstanceHistory).values({
          id: uuidv430(),
          instanceId: data.instanceId,
          action: data.action,
          status: data.status,
          details: data.details || {},
          userId: data.userId || null,
          createdAt: /* @__PURE__ */ new Date()
        }).returning()
      );
      const historyEntry = result[0];
      return historyEntry;
    } catch (error) {
      this._logger.error("Failed to add process instance history entry", {
        error,
        instanceId: data.instanceId
      });
      throw error;
    }
  }
  /**
   * Get history entries for a process instance
   */
  async getInstanceHistory(instanceId) {
    this._logger.debug("Getting process instance history", { instanceId });
    try {
      const history = await this.drizzleService.query(
        (tx) => tx.select().from(bpmProcessInstanceHistory).where(eq53(bpmProcessInstanceHistory.instanceId, instanceId)).orderBy(asc11(bpmProcessInstanceHistory.createdAt))
      );
      return history;
    } catch (error) {
      this._logger.error("Failed to get process instance history", { error, instanceId });
      throw error;
    }
  }
  /**
   * Get active instances count
   */
  async getActiveInstancesCount(companyId) {
    this._logger.debug("Getting active process instances count", { companyId });
    try {
      const result = await this.drizzleService.query(
        (tx) => tx.select({
          count: sql40`cast(count(*) as int)`
        }).from(bpmProcessInstances).where(
          and42(
            eq53(bpmProcessInstances.companyId, companyId),
            inArray2(bpmProcessInstances.status, [
              "PENDING" /* PENDING */,
              "RUNNING" /* RUNNING */
            ])
          )
        )
      );
      const [{ count: count5 }] = result;
      return count5;
    } catch (error) {
      this._logger.error("Failed to get active process instances count", { error, companyId });
      throw error;
    }
  }
  /**
   * Get completed instances count
   */
  async getCompletedInstancesCount(companyId) {
    this._logger.debug("Getting completed process instances count", { companyId });
    try {
      const result = await this.drizzleService.query(
        (tx) => tx.select({
          count: sql40`cast(count(*) as int)`
        }).from(bpmProcessInstances).where(
          and42(
            eq53(bpmProcessInstances.companyId, companyId),
            eq53(bpmProcessInstances.status, "COMPLETED" /* COMPLETED */)
          )
        )
      );
      const [{ count: count5 }] = result;
      return count5;
    } catch (error) {
      this._logger.error("Failed to get completed process instances count", { error, companyId });
      throw error;
    }
  }
  /**
   * Execute process instance step
   * In a real implementation, this would execute the step logic
   * For this implementation, it simply updates the current step
   */
  async executeStep(id, stepId, stepData, userId) {
    this._logger.info("Executing process instance step", { id, stepId });
    try {
      const instance = await this.getInstanceById(id);
      if (!instance) {
        return null;
      }
      if (instance.status === "COMPLETED" /* COMPLETED */ || instance.status === "CANCELLED" /* CANCELLED */) {
        this._logger.warn("Cannot execute step on completed or cancelled process instance", {
          id,
          status: instance.status
        });
        return instance;
      }
      const updateData = {
        status: "RUNNING" /* RUNNING */,
        currentStep: stepId,
        variables: {
          ...instance.variables,
          lastExecutedStep: stepId,
          lastExecutedStepTime: (/* @__PURE__ */ new Date()).toISOString(),
          ...stepData ? { [`step_${stepId}_data`]: stepData } : {}
        }
      };
      await this.addHistoryEntry({
        instanceId: id,
        action: "EXECUTE_STEP",
        status: "RUNNING" /* RUNNING */,
        details: {
          stepId,
          previousStep: instance.currentStep,
          stepData: stepData || {}
        },
        userId
      });
      return this.updateInstance(id, updateData, userId);
    } catch (error) {
      this._logger.error("Failed to execute process instance step", {
        error,
        id,
        stepId
      });
      throw error;
    }
  }
};

// server/modules/bpm/services/process.service.ts
var ProcessService = class {
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    this._logger = new Logger("ProcessService");
    this._processInstanceService = new ProcessInstanceService(drizzleService5);
  }
  /**
   * Create a new process workflow
   */
  async createProcess(data) {
    this._logger.info("Creating process", { name: data.name });
    try {
      const now = /* @__PURE__ */ new Date();
      const [process2] = await this.drizzleService.query(
        (tx) => tx.insert(bpmProcesses).values({
          id: uuidv431(),
          name: data.name,
          description: data.description || null,
          companyId: data.companyId,
          steps: data.steps || {},
          status: data.status || "DRAFT" /* DRAFT */,
          isTemplate: data.isTemplate !== void 0 ? data.isTemplate : false,
          version: "1.0",
          createdAt: now,
          updatedAt: now,
          createdBy: data.createdBy,
          updatedBy: data.updatedBy,
          franchiseId: data.franchiseId || null
        }).returning()
      );
      this._logger.info("Created process", { id: process2.id, name: process2.name });
      return process2;
    } catch (error) {
      this._logger.error("Failed to create process", { error, name: data.name });
      throw error;
    }
  }
  /**
   * Get process by ID
   */
  async getProcessById(id, companyId) {
    this._logger.debug("Getting process by ID", { id, companyId });
    try {
      let query = this.drizzleService.query((tx) => {
        let baseQuery = tx.select().from(bpmProcesses).where(eq54(bpmProcesses.id, id));
        if (companyId) {
          baseQuery = baseQuery.where(eq54(bpmProcesses.companyId, companyId));
        }
        return baseQuery;
      });
      const results = await query;
      const process2 = results.length > 0 ? results[0] : null;
      if (!process2) {
        this._logger.debug("Process not found", { id });
        return null;
      }
      return process2;
    } catch (error) {
      this._logger.error("Failed to get process by ID", { error, id });
      throw error;
    }
  }
  /**
   * Get processes with filtering and pagination
   */
  async getProcesses(companyId, filter = {}) {
    this._logger.debug("Getting processes with filter", { companyId, filter });
    try {
      const page = filter.page || 1;
      const limit = filter.limit || 20;
      const offset = (page - 1) * limit;
      let conditions = and43(
        eq54(bpmProcesses.companyId, companyId)
      );
      if (filter.status && filter.status.length > 0) {
        conditions = and43(conditions, or11(...filter.status.map((status) => eq54(bpmProcesses.status, status))));
      }
      if (filter.isTemplate !== void 0) {
        conditions = and43(conditions, eq54(bpmProcesses.isTemplate, filter.isTemplate));
      }
      if (filter.search) {
        conditions = and43(conditions, or11(
          like7(bpmProcesses.name, `%${filter.search}%`),
          like7(bpmProcesses.description, `%${filter.search}%`)
        ));
      }
      const countResult = await this.drizzleService.query(
        (tx) => tx.select({
          count: sql41`cast(count(*) as int)`
        }).from(bpmProcesses).where(conditions)
      );
      const count5 = countResult[0].count;
      const data = await this.drizzleService.query(
        (tx) => tx.select().from(bpmProcesses).where(conditions).orderBy(desc21(bpmProcesses.createdAt)).limit(limit).offset(offset)
      );
      return {
        data,
        total: count5
      };
    } catch (error) {
      this._logger.error("Failed to get processes", { error, companyId });
      throw error;
    }
  }
  /**
   * Update a process
   */
  async updateProcess(id, data) {
    this._logger.info("Updating process", { id });
    try {
      const process2 = await this.getProcessById(id);
      if (!process2) {
        return null;
      }
      const updateData = {
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: data.updatedBy
      };
      if (data.name !== void 0) {
        updateData.name = data.name;
      }
      if (data.description !== void 0) {
        updateData.description = data.description;
      }
      if (data.steps !== void 0) {
        updateData.steps = data.steps;
      }
      if (data.status !== void 0) {
        updateData.status = data.status;
      }
      if (data.isTemplate !== void 0) {
        updateData.isTemplate = data.isTemplate;
      }
      if (data.version !== void 0) {
        updateData.version = data.version;
      }
      const result = await this.drizzleService.query(
        (tx) => tx.update(bpmProcesses).set(updateData).where(eq54(bpmProcesses.id, id)).returning()
      );
      const updatedProcess = result[0];
      this._logger.info("Updated process", { id });
      return updatedProcess;
    } catch (error) {
      this._logger.error("Failed to update process", { error, id });
      throw error;
    }
  }
  /**
   * Change process status (activate, pause, archive)
   */
  async changeProcessStatus(id, status, userId) {
    this._logger.info("Changing process status", { id, status });
    return this.updateProcess(id, {
      status,
      updatedBy: userId
    });
  }
  /**
   * Duplicate a process (create a new version or template)
   */
  async duplicateProcess(id, options) {
    this._logger.info("Duplicating process", { id, asTemplate: options.asTemplate });
    try {
      const originalProcess = await this.getProcessById(id);
      if (!originalProcess) {
        return null;
      }
      const newName = options.newName || (options.asTemplate ? `Template: ${originalProcess.name}` : `${originalProcess.name} (copy)`);
      const newVersion = options.asTemplate ? originalProcess.version : this.incrementVersion(originalProcess.version);
      const newProcess = {
        name: newName,
        description: originalProcess.description || void 0,
        companyId: originalProcess.companyId,
        steps: originalProcess.steps,
        status: options.asTemplate ? "DRAFT" /* DRAFT */ : originalProcess.status,
        isTemplate: options.asTemplate !== void 0 ? options.asTemplate : originalProcess.isTemplate,
        createdBy: options.userId,
        updatedBy: options.userId,
        franchiseId: originalProcess.franchiseId
      };
      const duplicatedProcess = await this.createProcess(newProcess);
      this._logger.info("Duplicated process", {
        originalId: id,
        newId: duplicatedProcess.id,
        asTemplate: options.asTemplate
      });
      return duplicatedProcess;
    } catch (error) {
      this._logger.error("Failed to duplicate process", { error, id });
      throw error;
    }
  }
  /**
   * Delete a process
   */
  async deleteProcess(id) {
    this._logger.info("Deleting process", { id });
    try {
      const process2 = await this.getProcessById(id);
      if (!process2) {
        return false;
      }
      await this.drizzleService.query(
        (tx) => tx.delete(bpmProcesses).where(eq54(bpmProcesses.id, id))
      );
      this._logger.info("Deleted process", { id });
      return true;
    } catch (error) {
      this._logger.error("Failed to delete process", { error, id });
      throw error;
    }
  }
  /**
   * Get process templates for a company
   */
  async getProcessTemplates(companyId) {
    this._logger.debug("Getting process templates", { companyId });
    try {
      const templates = await this.drizzleService.query(
        (tx) => tx.select().from(bpmProcesses).where(
          and43(
            eq54(bpmProcesses.companyId, companyId),
            eq54(bpmProcesses.isTemplate, true)
          )
        ).orderBy(desc21(bpmProcesses.createdAt))
      );
      return templates;
    } catch (error) {
      this._logger.error("Failed to get process templates", { error, companyId });
      throw error;
    }
  }
  /**
   * Create a new process from a template
   */
  async createFromTemplate(templateId, data) {
    this._logger.info("Creating process from template", { templateId });
    try {
      const template = await this.getProcessById(templateId);
      if (!template) {
        return null;
      }
      if (!template.isTemplate) {
        throw new Error(`Process with ID ${templateId} is not a template`);
      }
      const newProcess = {
        name: data.name,
        description: template.description || void 0,
        companyId: data.companyId,
        steps: template.steps,
        status: "DRAFT" /* DRAFT */,
        isTemplate: false,
        createdBy: data.userId,
        updatedBy: data.userId,
        franchiseId: template.franchiseId
      };
      const createdProcess = await this.createProcess(newProcess);
      this._logger.info("Created process from template", {
        templateId,
        newId: createdProcess.id
      });
      return createdProcess;
    } catch (error) {
      this._logger.error("Failed to create process from template", { error, templateId });
      throw error;
    }
  }
  /**
   * Start a new process instance
   * This is simplified - real implementation would create process instance
   * and execute first step
   */
  async startProcess(data) {
    this._logger.info("Starting process", { processId: data.processId });
    try {
      const process2 = await this.getProcessById(data.processId, data.companyId);
      if (!process2) {
        throw new Error(`Process with ID ${data.processId} not found`);
      }
      if (process2.status !== "ACTIVE" /* ACTIVE */) {
        throw new Error(`Process with ID ${data.processId} is not active. Status: ${process2.status}`);
      }
      const firstStep = this.getFirstStep(process2.steps);
      if (!firstStep) {
        throw new Error(`Process with ID ${data.processId} has no steps defined`);
      }
      const instanceData = {
        processId: data.processId,
        companyId: data.companyId,
        status: "PENDING",
        currentStep: firstStep.id,
        startedBy: data.startedBy,
        inputData: data.inputData,
        variables: {
          processName: process2.name,
          firstStep: firstStep.id,
          startTime: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      const instance = await this._processInstanceService.createInstance(instanceData);
      const updatedInstance = await this._processInstanceService.executeStep(
        instance.id,
        firstStep.id,
        { auto: true },
        data.startedBy
      );
      this._logger.info("Started process", {
        processId: data.processId,
        instanceId: instance.id,
        firstStep: firstStep.id
      });
      return updatedInstance;
    } catch (error) {
      this._logger.error("Failed to start process", { error, processId: data.processId });
      throw error;
    }
  }
  /**
   * Helper function to find the first step in a process definition
   * In a real implementation, this would be more sophisticated based on process definition
   */
  getFirstStep(steps) {
    if (!steps || !steps.nodes || !Array.isArray(steps.nodes) || steps.nodes.length === 0) {
      return null;
    }
    const startNodes = steps.nodes.filter(
      (node) => node.type === "startEvent" || node.type === "start"
    );
    if (startNodes.length > 0) {
      return {
        id: startNodes[0].id,
        name: startNodes[0].name || startNodes[0].label || "Start"
      };
    }
    return {
      id: steps.nodes[0].id,
      name: steps.nodes[0].name || steps.nodes[0].label || "First Step"
    };
  }
  /**
   * Helper function to increment a version string (e.g. 1.0 -> 1.1)
   */
  incrementVersion(version) {
    const parts = version.split(".");
    if (parts.length < 2) {
      return `${version}.1`;
    }
    const major = parseInt(parts[0], 10);
    const minor = parseInt(parts[1], 10);
    return `${major}.${minor + 1}`;
  }
};

// server/modules/bpm/services/trigger.service.ts
init_logger();
import { eq as eq55, and as and44, like as like8, or as or12, desc as desc22, sql as sql42 } from "drizzle-orm";
import { v4 as uuidv432 } from "uuid";
var TriggerService = class {
  constructor(db4) {
    this.db = db4;
    this._logger = new Logger("TriggerService");
    this._processService = new ProcessService(db4);
  }
  /**
   * Create a new trigger
   */
  async createTrigger(data) {
    this._logger.info("Creating trigger", { name: data.name, type: data.type });
    try {
      const now = /* @__PURE__ */ new Date();
      const [trigger] = await this.db.insert(bpmTriggers).values({
        id: uuidv432(),
        name: data.name,
        description: data.description || null,
        companyId: data.companyId,
        type: data.type,
        processId: data.processId,
        configuration: data.configuration || {},
        isActive: data.isActive !== void 0 ? data.isActive : true,
        createdAt: now,
        updatedAt: now,
        createdBy: data.createdBy,
        updatedBy: data.updatedBy
      }).returning();
      this._logger.info("Created trigger", { id: trigger.id, name: trigger.name });
      return trigger;
    } catch (error) {
      this._logger.error("Failed to create trigger", { error, name: data.name });
      throw error;
    }
  }
  /**
   * Get trigger by ID
   */
  async getTriggerById(id, companyId) {
    this._logger.debug("Getting trigger by ID", { id, companyId });
    try {
      let query = this.db.select().from(bpmTriggers).where(eq55(bpmTriggers.id, id));
      if (companyId) {
        query = query.where(eq55(bpmTriggers.companyId, companyId));
      }
      const [trigger] = await query;
      if (!trigger) {
        this._logger.debug("Trigger not found", { id });
        return null;
      }
      return trigger;
    } catch (error) {
      this._logger.error("Failed to get trigger by ID", { error, id });
      throw error;
    }
  }
  /**
   * Get triggers with filtering and pagination
   */
  async getTriggers(companyId, filter = {}) {
    this._logger.debug("Getting triggers with filter", { companyId, filter });
    try {
      const page = filter.page || 1;
      const limit = filter.limit || 20;
      const offset = (page - 1) * limit;
      let conditions = and44(
        eq55(bpmTriggers.companyId, companyId)
      );
      if (filter.processId) {
        conditions = and44(conditions, eq55(bpmTriggers.processId, filter.processId));
      }
      if (filter.type) {
        conditions = and44(conditions, eq55(bpmTriggers.type, filter.type));
      }
      if (filter.isActive !== void 0) {
        conditions = and44(conditions, eq55(bpmTriggers.isActive, filter.isActive));
      }
      if (filter.search) {
        conditions = and44(conditions, or12(
          like8(bpmTriggers.name, `%${filter.search}%`),
          like8(bpmTriggers.description, `%${filter.search}%`)
        ));
      }
      const [{ count: count5 }] = await this.db.select({
        count: sql42`cast(count(*) as int)`
      }).from(bpmTriggers).where(conditions);
      const data = await this.db.select().from(bpmTriggers).where(conditions).orderBy(desc22(bpmTriggers.createdAt)).limit(limit).offset(offset);
      return {
        data,
        total: count5
      };
    } catch (error) {
      this._logger.error("Failed to get triggers", { error, companyId });
      throw error;
    }
  }
  /**
   * Update a trigger
   */
  async updateTrigger(id, data) {
    this._logger.info("Updating trigger", { id });
    try {
      const trigger = await this.getTriggerById(id);
      if (!trigger) {
        return null;
      }
      const updateData = {
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: data.updatedBy
      };
      if (data.name !== void 0) {
        updateData.name = data.name;
      }
      if (data.description !== void 0) {
        updateData.description = data.description;
      }
      if (data.type !== void 0) {
        updateData.type = data.type;
      }
      if (data.processId !== void 0) {
        updateData.processId = data.processId;
      }
      if (data.configuration !== void 0) {
        updateData.configuration = data.configuration;
      }
      if (data.isActive !== void 0) {
        updateData.isActive = data.isActive;
      }
      const [updatedTrigger] = await this.db.update(bpmTriggers).set(updateData).where(eq55(bpmTriggers.id, id)).returning();
      this._logger.info("Updated trigger", { id });
      return updatedTrigger;
    } catch (error) {
      this._logger.error("Failed to update trigger", { error, id });
      throw error;
    }
  }
  /**
   * Delete a trigger
   */
  async deleteTrigger(id) {
    this._logger.info("Deleting trigger", { id });
    try {
      const trigger = await this.getTriggerById(id);
      if (!trigger) {
        return false;
      }
      await this.db.delete(bpmTriggers).where(eq55(bpmTriggers.id, id));
      this._logger.info("Deleted trigger", { id });
      return true;
    } catch (error) {
      this._logger.error("Failed to delete trigger", { error, id });
      throw error;
    }
  }
  /**
   * Activate or deactivate a trigger
   */
  async setTriggerStatus(id, isActive, userId) {
    this._logger.info("Setting trigger status", { id, isActive });
    return this.updateTrigger(id, {
      isActive,
      updatedBy: userId
    });
  }
  /**
   * Get triggers by process ID
   */
  async getTriggersByProcess(processId, companyId) {
    this._logger.debug("Getting triggers by process ID", { processId, companyId });
    try {
      const triggers = await this.db.select().from(bpmTriggers).where(
        and44(
          eq55(bpmTriggers.processId, processId),
          eq55(bpmTriggers.companyId, companyId)
        )
      ).orderBy(desc22(bpmTriggers.createdAt));
      return triggers;
    } catch (error) {
      this._logger.error("Failed to get triggers by process ID", { error, processId });
      throw error;
    }
  }
  /**
   * Get triggers by type
   */
  async getTriggersByType(type, companyId) {
    this._logger.debug("Getting triggers by type", { type, companyId });
    try {
      const triggers = await this.db.select().from(bpmTriggers).where(
        and44(
          eq55(bpmTriggers.type, type),
          eq55(bpmTriggers.companyId, companyId),
          eq55(bpmTriggers.isActive, true)
        )
      ).orderBy(bpmTriggers.name);
      return triggers;
    } catch (error) {
      this._logger.error("Failed to get triggers by type", { error, type });
      throw error;
    }
  }
  /**
   * Execute a trigger to start a process
   */
  async executeTrigger(context) {
    this._logger.info("Executing trigger", { triggerId: context.triggerId });
    try {
      const trigger = await this.getTriggerById(context.triggerId);
      if (!trigger) {
        throw new Error(`Trigger with ID ${context.triggerId} not found`);
      }
      if (!trigger.isActive) {
        throw new Error(`Trigger with ID ${context.triggerId} is not active`);
      }
      const processStartData = {
        processId: trigger.processId,
        companyId: trigger.companyId,
        startedBy: context.userId,
        inputData: {
          ...context.inputData || {},
          triggerId: trigger.id,
          triggerType: trigger.type,
          triggerName: trigger.name,
          triggerConfig: trigger.configuration,
          executionTime: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      const processInstance = await this._processService.startProcess(processStartData);
      this._logger.info("Executed trigger", {
        triggerId: context.triggerId,
        processId: trigger.processId,
        instanceId: processInstance.id
      });
      return processInstance;
    } catch (error) {
      this._logger.error("Failed to execute trigger", { error, triggerId: context.triggerId });
      throw error;
    }
  }
};

// server/modules/bpm/services/step-template.service.ts
import { eq as eq56, and as and45, or as or13, desc as desc23 } from "drizzle-orm";
var StepTemplateService = class {
  /**
   * Constructor
   * 
   * @param db Database connection
   */
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Create a new step template
   * 
   * @param data Step template data
   * @returns Created step template
   */
  async createStepTemplate(data) {
    try {
      const [stepTemplate] = await this.db.insert(bpmStepTemplates).values({
        ...data,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return stepTemplate;
    } catch (error) {
      console.error("Error creating step template:", error);
      throw new Error(`Failed to create step template: ${error.message}`);
    }
  }
  /**
   * Get all step templates for a company
   * 
   * @param companyId Company ID
   * @param includeGlobal Whether to include global step templates
   * @returns List of step templates
   */
  async getStepTemplates(companyId, includeGlobal = true) {
    try {
      let query = this.db.select().from(bpmStepTemplates).orderBy(desc23(bpmStepTemplates.createdAt));
      if (includeGlobal) {
        query = query.where(
          or13(
            eq56(bpmStepTemplates.companyId, companyId),
            eq56(bpmStepTemplates.isGlobal, true)
          )
        );
      } else {
        query = query.where(eq56(bpmStepTemplates.companyId, companyId));
      }
      return await query;
    } catch (error) {
      console.error("Error getting step templates:", error);
      throw new Error(`Failed to get step templates: ${error.message}`);
    }
  }
  /**
   * Get a step template by ID
   * 
   * @param id Step template ID
   * @param companyId Company ID for authorization
   * @returns Step template or null if not found
   */
  async getStepTemplateById(id, companyId) {
    try {
      const [stepTemplate] = await this.db.select().from(bpmStepTemplates).where(
        and45(
          eq56(bpmStepTemplates.id, id),
          or13(
            eq56(bpmStepTemplates.companyId, companyId),
            eq56(bpmStepTemplates.isGlobal, true)
          )
        )
      );
      return stepTemplate || null;
    } catch (error) {
      console.error("Error getting step template by ID:", error);
      throw new Error(`Failed to get step template: ${error.message}`);
    }
  }
  /**
   * Update a step template
   * 
   * @param id Step template ID
   * @param data Step template update data
   * @param companyId Company ID for authorization
   * @returns Updated step template
   */
  async updateStepTemplate(id, data, companyId) {
    try {
      const stepTemplate = await this.getStepTemplateById(id, companyId);
      if (!stepTemplate) {
        throw new Error("Step template not found or you do not have permission to update it");
      }
      if (stepTemplate.isGlobal && stepTemplate.companyId !== companyId) {
        throw new Error("You do not have permission to update this global step template");
      }
      const [updatedTemplate] = await this.db.update(bpmStepTemplates).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq56(bpmStepTemplates.id, id)).returning();
      return updatedTemplate;
    } catch (error) {
      console.error("Error updating step template:", error);
      throw new Error(`Failed to update step template: ${error.message}`);
    }
  }
  /**
   * Delete a step template
   * 
   * @param id Step template ID
   * @param companyId Company ID for authorization
   * @returns Boolean indicating if the deletion was successful
   */
  async deleteStepTemplate(id, companyId) {
    try {
      const stepTemplate = await this.getStepTemplateById(id, companyId);
      if (!stepTemplate) {
        throw new Error("Step template not found or you do not have permission to delete it");
      }
      if (stepTemplate.isGlobal && stepTemplate.companyId !== companyId) {
        throw new Error("You do not have permission to delete this global step template");
      }
      const result = await this.db.delete(bpmStepTemplates).where(eq56(bpmStepTemplates.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting step template:", error);
      throw new Error(`Failed to delete step template: ${error.message}`);
    }
  }
  /**
   * Get step templates by type
   * 
   * @param type Step template type
   * @param companyId Company ID
   * @param includeGlobal Whether to include global step templates
   * @returns List of step templates of the specified type
   */
  async getStepTemplatesByType(type, companyId, includeGlobal = true) {
    try {
      let query = this.db.select().from(bpmStepTemplates).where(eq56(bpmStepTemplates.type, type)).orderBy(desc23(bpmStepTemplates.createdAt));
      if (includeGlobal) {
        query = query.where(
          or13(
            eq56(bpmStepTemplates.companyId, companyId),
            eq56(bpmStepTemplates.isGlobal, true)
          )
        );
      } else {
        query = query.where(eq56(bpmStepTemplates.companyId, companyId));
      }
      return await query;
    } catch (error) {
      console.error(`Error getting step templates by type ${type}:`, error);
      throw new Error(`Failed to get step templates by type: ${error.message}`);
    }
  }
  /**
   * Get step templates by target type
   * 
   * @param targetType Step template target type
   * @param companyId Company ID
   * @param includeGlobal Whether to include global step templates
   * @returns List of step templates of the specified target type
   */
  async getStepTemplatesByTargetType(targetType, companyId, includeGlobal = true) {
    try {
      let query = this.db.select().from(bpmStepTemplates).where(eq56(bpmStepTemplates.targetType, targetType)).orderBy(desc23(bpmStepTemplates.createdAt));
      if (includeGlobal) {
        query = query.where(
          or13(
            eq56(bpmStepTemplates.companyId, companyId),
            eq56(bpmStepTemplates.isGlobal, true)
          )
        );
      } else {
        query = query.where(eq56(bpmStepTemplates.companyId, companyId));
      }
      return await query;
    } catch (error) {
      console.error(`Error getting step templates by target type ${targetType}:`, error);
      throw new Error(`Failed to get step templates by target type: ${error.message}`);
    }
  }
  /**
   * Toggle global status of a step template
   * 
   * @param id Step template ID
   * @param isGlobal New global status
   * @param companyId Company ID for authorization
   * @returns Updated step template
   */
  async toggleGlobalTemplate(id, isGlobal, companyId) {
    try {
      const stepTemplate = await this.getStepTemplateById(id, companyId);
      if (!stepTemplate) {
        throw new Error("Step template not found or you do not have permission to update it");
      }
      if (stepTemplate.companyId !== companyId) {
        throw new Error("You do not have permission to change the global status of this template");
      }
      const [updatedTemplate] = await this.db.update(bpmStepTemplates).set({
        isGlobal,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: companyId
        // Assuming this is the user ID
      }).where(eq56(bpmStepTemplates.id, id)).returning();
      return updatedTemplate;
    } catch (error) {
      console.error("Error toggling global status of step template:", error);
      throw new Error(`Failed to toggle global status: ${error.message}`);
    }
  }
};

// server/modules/bpm/services/step-execution.service.ts
init_logger();
import { eq as eq57, and as and46 } from "drizzle-orm";
var logger68 = new Logger("StepExecutionService");
var StepExecutionService = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Create a new step execution record
   */
  async createStepExecution(data) {
    logger68.debug("Creating step execution", { data });
    try {
      const [execution] = await this.db.insert(bpmStepExecutions).values(data).returning();
      logger68.debug("Created step execution", { executionId: execution.id });
      return execution;
    } catch (error) {
      logger68.error("Failed to create step execution", { error, data });
      throw error;
    }
  }
  /**
   * Get a step execution by ID
   */
  async getStepExecution(id, companyId) {
    logger68.debug("Getting step execution", { id, companyId });
    try {
      const [execution] = await this.db.select().from(bpmStepExecutions).where(and46(
        eq57(bpmStepExecutions.id, id),
        eq57(bpmStepExecutions.companyId, companyId)
      ));
      return execution || null;
    } catch (error) {
      logger68.error("Failed to get step execution", { error, id, companyId });
      throw error;
    }
  }
  /**
   * Get all step executions for a process instance
   */
  async getStepExecutionsByInstanceId(instanceId, companyId) {
    logger68.debug("Getting step executions for instance", { instanceId, companyId });
    try {
      const executions = await this.db.select().from(bpmStepExecutions).where(and46(
        eq57(bpmStepExecutions.instanceId, instanceId),
        eq57(bpmStepExecutions.companyId, companyId)
      ));
      return executions;
    } catch (error) {
      logger68.error("Failed to get step executions for instance", { error, instanceId, companyId });
      throw error;
    }
  }
  /**
   * Update a step execution
   */
  async updateStepExecution(id, companyId, data) {
    logger68.debug("Updating step execution", { id, companyId, data });
    try {
      const [execution] = await this.db.update(bpmStepExecutions).set(data).where(and46(
        eq57(bpmStepExecutions.id, id),
        eq57(bpmStepExecutions.companyId, companyId)
      )).returning();
      return execution || null;
    } catch (error) {
      logger68.error("Failed to update step execution", { error, id, companyId, data });
      throw error;
    }
  }
  /**
   * Complete a step execution with output data
   */
  async completeStepExecution(id, companyId, userId, outputData) {
    logger68.debug("Completing step execution", { id, companyId, userId });
    try {
      const now = /* @__PURE__ */ new Date();
      const [execution] = await this.db.update(bpmStepExecutions).set({
        status: "COMPLETED" /* COMPLETED */,
        outputData,
        completedAt: now,
        executedBy: userId
      }).where(and46(
        eq57(bpmStepExecutions.id, id),
        eq57(bpmStepExecutions.companyId, companyId)
      )).returning();
      logger68.debug("Completed step execution", { executionId: id });
      return execution || null;
    } catch (error) {
      logger68.error("Failed to complete step execution", { error, id, companyId });
      throw error;
    }
  }
  /**
   * Fail a step execution with error data
   */
  async failStepExecution(id, companyId, userId, errorData, reason) {
    logger68.debug("Failing step execution", { id, companyId, userId, reason });
    try {
      const now = /* @__PURE__ */ new Date();
      const [execution] = await this.db.update(bpmStepExecutions).set({
        status: "FAILED" /* FAILED */,
        errorData: {
          ...errorData,
          reason,
          failedAt: now.toISOString(),
          failedBy: userId
        },
        completedAt: now,
        executedBy: userId
      }).where(and46(
        eq57(bpmStepExecutions.id, id),
        eq57(bpmStepExecutions.companyId, companyId)
      )).returning();
      logger68.debug("Failed step execution", { executionId: id });
      return execution || null;
    } catch (error) {
      logger68.error("Failed to mark step execution as failed", { error, id, companyId });
      throw error;
    }
  }
  /**
   * Skip a step execution
   */
  async skipStepExecution(id, companyId, userId, reason) {
    logger68.debug("Skipping step execution", { id, companyId, userId, reason });
    try {
      const now = /* @__PURE__ */ new Date();
      const [execution] = await this.db.update(bpmStepExecutions).set({
        status: "SKIPPED" /* SKIPPED */,
        outputData: {
          skipped: true,
          reason,
          skippedAt: now.toISOString(),
          skippedBy: userId
        },
        completedAt: now,
        executedBy: userId
      }).where(and46(
        eq57(bpmStepExecutions.id, id),
        eq57(bpmStepExecutions.companyId, companyId)
      )).returning();
      logger68.debug("Skipped step execution", { executionId: id });
      return execution || null;
    } catch (error) {
      logger68.error("Failed to skip step execution", { error, id, companyId });
      throw error;
    }
  }
  /**
   * Start a step execution
   */
  async startStepExecution(id, companyId, userId) {
    logger68.debug("Starting step execution", { id, companyId, userId });
    try {
      const now = /* @__PURE__ */ new Date();
      const [execution] = await this.db.update(bpmStepExecutions).set({
        status: "RUNNING" /* RUNNING */,
        startedAt: now,
        executedBy: userId
      }).where(and46(
        eq57(bpmStepExecutions.id, id),
        eq57(bpmStepExecutions.companyId, companyId),
        eq57(bpmStepExecutions.status, "PENDING" /* PENDING */)
      )).returning();
      logger68.debug("Started step execution", { executionId: id });
      return execution || null;
    } catch (error) {
      logger68.error("Failed to start step execution", { error, id, companyId });
      throw error;
    }
  }
  /**
   * Assign a step execution to a user
   */
  async assignStepExecution(id, companyId, assignToUserId, assignedByUserId) {
    logger68.debug("Assigning step execution", { id, companyId, assignToUserId, assignedByUserId });
    try {
      const [execution] = await this.db.update(bpmStepExecutions).set({
        assignedTo: assignToUserId,
        outputData: {
          ...execution.outputData,
          assignedAt: (/* @__PURE__ */ new Date()).toISOString(),
          assignedBy: assignedByUserId
        }
      }).where(and46(
        eq57(bpmStepExecutions.id, id),
        eq57(bpmStepExecutions.companyId, companyId)
      )).returning();
      logger68.debug("Assigned step execution", { executionId: id, userId: assignToUserId });
      return execution || null;
    } catch (error) {
      logger68.error("Failed to assign step execution", { error, id, companyId, assignToUserId });
      throw error;
    }
  }
};

// server/modules/bpm/services/api-connection.service.ts
init_logger();
import { eq as eq58, and as and47, like as like9, or as or14, desc as desc24 } from "drizzle-orm";
import axios14 from "axios";
var logger69 = new Logger("ApiConnectionService");
var ApiConnectionService = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Create a new API connection
   */
  async createApiConnection(data) {
    logger69.debug("Creating API connection", { data });
    try {
      const [connection] = await this.db.insert(bpmApiConnections).values(data).returning();
      logger69.debug("Created API connection", { connectionId: connection.id });
      return connection;
    } catch (error) {
      logger69.error("Failed to create API connection", { error, data });
      throw error;
    }
  }
  /**
   * Get an API connection by ID
   */
  async getApiConnection(id, companyId) {
    logger69.debug("Getting API connection", { id, companyId });
    try {
      const [connection] = await this.db.select().from(bpmApiConnections).where(and47(
        eq58(bpmApiConnections.id, id),
        eq58(bpmApiConnections.companyId, companyId)
      ));
      return connection || null;
    } catch (error) {
      logger69.error("Failed to get API connection", { error, id, companyId });
      throw error;
    }
  }
  /**
   * Get all API connections for a company with filtering and pagination
   */
  async getApiConnections(companyId, filter) {
    logger69.debug("Getting API connections", { companyId, filter });
    try {
      const { provider, isActive, search, page = 1, limit = 25 } = filter;
      const offset = (page - 1) * limit;
      const whereConditions = [eq58(bpmApiConnections.companyId, companyId)];
      if (provider) {
        whereConditions.push(eq58(bpmApiConnections.type, provider));
      }
      if (isActive !== void 0) {
        whereConditions.push(eq58(bpmApiConnections.isActive, isActive));
      }
      if (search) {
        whereConditions.push(
          or14(
            like9(bpmApiConnections.name, `%${search}%`),
            like9(bpmApiConnections.description || "", `%${search}%`)
          )
        );
      }
      const [{ count: count5 }] = await this.db.select({ count: count5() }).from(bpmApiConnections).where(and47(...whereConditions));
      const connections = await this.db.select().from(bpmApiConnections).where(and47(...whereConditions)).orderBy(desc24(bpmApiConnections.updatedAt)).limit(limit).offset(offset);
      return {
        data: connections,
        total: Number(count5),
        page,
        limit
      };
    } catch (error) {
      logger69.error("Failed to get API connections", { error, companyId, filter });
      throw error;
    }
  }
  /**
   * Update an API connection
   */
  async updateApiConnection(id, companyId, data) {
    logger69.debug("Updating API connection", { id, companyId, data });
    try {
      const [connection] = await this.db.update(bpmApiConnections).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(and47(
        eq58(bpmApiConnections.id, id),
        eq58(bpmApiConnections.companyId, companyId)
      )).returning();
      return connection || null;
    } catch (error) {
      logger69.error("Failed to update API connection", { error, id, companyId, data });
      throw error;
    }
  }
  /**
   * Delete an API connection
   */
  async deleteApiConnection(id, companyId) {
    logger69.debug("Deleting API connection", { id, companyId });
    try {
      const result = await this.db.delete(bpmApiConnections).where(and47(
        eq58(bpmApiConnections.id, id),
        eq58(bpmApiConnections.companyId, companyId)
      ));
      return result.rowCount > 0;
    } catch (error) {
      logger69.error("Failed to delete API connection", { error, id, companyId });
      throw error;
    }
  }
  /**
   * Test an API connection
   */
  async testApiConnection(id, companyId) {
    logger69.debug("Testing API connection", { id, companyId });
    try {
      const connection = await this.getApiConnection(id, companyId);
      if (!connection) {
        return { success: false, message: "API connection not found" };
      }
      const { configuration } = connection;
      const { baseUrl, testEndpoint, method = "GET", headers = {}, authData = {} } = configuration;
      if (!baseUrl) {
        return { success: false, message: "Invalid API connection configuration: missing baseUrl" };
      }
      const url = testEndpoint ? `${baseUrl}${testEndpoint}` : baseUrl;
      const requestHeaders = { ...headers };
      if (authData.type === "basic" && authData.username && authData.password) {
        const auth = Buffer.from(`${authData.username}:${authData.password}`).toString("base64");
        requestHeaders["Authorization"] = `Basic ${auth}`;
      } else if (authData.type === "bearer" && authData.token) {
        requestHeaders["Authorization"] = `Bearer ${authData.token}`;
      } else if (authData.type === "apiKey" && authData.key && authData.value) {
        requestHeaders[authData.key] = authData.value;
      }
      const requestConfig = {
        url,
        method,
        headers: requestHeaders,
        timeout: 1e4,
        // 10 seconds timeout
        validateStatus: null
        // Don't throw on non-2xx responses
      };
      if (authData.type === "apiKey" && authData.in === "query" && authData.key && authData.value) {
        requestConfig.params = { [authData.key]: authData.value };
      }
      logger69.debug("Making test request", {
        url,
        method,
        hasAuth: !!requestHeaders["Authorization"] || !!requestConfig.params
      });
      const response = await axios14(requestConfig);
      await this.db.update(bpmApiConnections).set({ lastUsedAt: /* @__PURE__ */ new Date() }).where(eq58(bpmApiConnections.id, id));
      const isSuccess = response.status >= 200 && response.status < 300;
      return {
        success: isSuccess,
        message: isSuccess ? "API connection tested successfully" : `API returned status code ${response.status}`,
        response: {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers,
          data: response.data
        }
      };
    } catch (error) {
      logger69.error("Failed to test API connection", { error, id, companyId });
      return {
        success: false,
        message: error.message || "Failed to test API connection",
        response: {
          error: error.message,
          code: error.code
        }
      };
    }
  }
  /**
   * Execute an API request using a connection
   */
  async executeApiRequest(id, companyId, endpoint, method = "GET", data, queryParams) {
    logger69.debug("Executing API request", { id, companyId, endpoint, method });
    try {
      const connection = await this.getApiConnection(id, companyId);
      if (!connection) {
        return { success: false, message: "API connection not found" };
      }
      const { configuration } = connection;
      const { baseUrl, headers = {}, authData = {} } = configuration;
      if (!baseUrl) {
        return { success: false, message: "Invalid API connection configuration: missing baseUrl" };
      }
      const url = `${baseUrl}${endpoint}`;
      const requestHeaders = { ...headers };
      if (authData.type === "basic" && authData.username && authData.password) {
        const auth = Buffer.from(`${authData.username}:${authData.password}`).toString("base64");
        requestHeaders["Authorization"] = `Basic ${auth}`;
      } else if (authData.type === "bearer" && authData.token) {
        requestHeaders["Authorization"] = `Bearer ${authData.token}`;
      } else if (authData.type === "apiKey" && authData.key && authData.value && authData.in === "header") {
        requestHeaders[authData.key] = authData.value;
      }
      const requestConfig = {
        url,
        method,
        headers: requestHeaders,
        timeout: 3e4,
        // 30 seconds timeout
        validateStatus: null
        // Don't throw on non-2xx responses
      };
      if (queryParams || authData.type === "apiKey" && authData.in === "query") {
        requestConfig.params = { ...queryParams };
        if (authData.type === "apiKey" && authData.in === "query" && authData.key && authData.value) {
          requestConfig.params[authData.key] = authData.value;
        }
      }
      if (method !== "GET" && data) {
        requestConfig.data = data;
      }
      logger69.debug("Making API request", {
        url,
        method,
        hasBody: !!requestConfig.data,
        hasParams: !!requestConfig.params
      });
      const response = await axios14(requestConfig);
      await this.db.update(bpmApiConnections).set({ lastUsedAt: /* @__PURE__ */ new Date() }).where(eq58(bpmApiConnections.id, id));
      const isSuccess = response.status >= 200 && response.status < 300;
      return {
        success: isSuccess,
        message: isSuccess ? "API request executed successfully" : `API returned status code ${response.status}`,
        data: response.data,
        statusCode: response.status
      };
    } catch (error) {
      logger69.error("Failed to execute API request", { error, id, companyId, endpoint });
      return {
        success: false,
        message: error.message || "Failed to execute API request",
        data: {
          error: error.message,
          code: error.code
        }
      };
    }
  }
};

// server/modules/bpm/services/scheduled-job.service.ts
init_logger();
import { eq as eq59, and as and48, like as like10, or as or15, desc as desc25, gte as gte5, lte as lte5 } from "drizzle-orm";
var logger70 = new Logger("ScheduledJobService");
var ScheduledJobService = class {
  constructor(db4, processService, processInstanceService) {
    this.db = db4;
    this.processService = processService;
    this.processInstanceService = processInstanceService;
  }
  /**
   * Create a new scheduled job
   */
  async createScheduledJob(data) {
    logger70.debug("Creating scheduled job", { data });
    try {
      const nextRunAt = this.calculateNextRunTime(data.schedule);
      const [job] = await this.db.insert(bpmScheduledJobs).values({
        ...data,
        lastRunAt: null
      }).returning();
      logger70.debug("Created scheduled job", { jobId: job.id, nextRunAt });
      return job;
    } catch (error) {
      logger70.error("Failed to create scheduled job", { error, data });
      throw error;
    }
  }
  /**
   * Get a scheduled job by ID
   */
  async getScheduledJob(id, companyId) {
    logger70.debug("Getting scheduled job", { id, companyId });
    try {
      const [job] = await this.db.select().from(bpmScheduledJobs).where(and48(
        eq59(bpmScheduledJobs.id, id),
        eq59(bpmScheduledJobs.companyId, companyId)
      ));
      return job || null;
    } catch (error) {
      logger70.error("Failed to get scheduled job", { error, id, companyId });
      throw error;
    }
  }
  /**
   * Get all scheduled jobs for a company with filtering and pagination
   */
  async getScheduledJobs(companyId, filter) {
    logger70.debug("Getting scheduled jobs", { companyId, filter });
    try {
      const { isActive, search, processId, startDate, endDate, page = 1, limit = 25 } = filter;
      const offset = (page - 1) * limit;
      const whereConditions = [eq59(bpmScheduledJobs.companyId, companyId)];
      if (isActive !== void 0) {
        whereConditions.push(eq59(bpmScheduledJobs.isActive, isActive));
      }
      if (processId) {
        whereConditions.push(eq59(bpmScheduledJobs.action, processId));
      }
      if (search) {
        whereConditions.push(
          or15(
            like10(bpmScheduledJobs.name, `%${search}%`),
            like10(bpmScheduledJobs.description || "", `%${search}%`)
          )
        );
      }
      if (startDate) {
        whereConditions.push(gte5(bpmScheduledJobs.createdAt, startDate));
      }
      if (endDate) {
        whereConditions.push(lte5(bpmScheduledJobs.createdAt, endDate));
      }
      const [{ count: count5 }] = await this.db.select({ count: count5() }).from(bpmScheduledJobs).where(and48(...whereConditions));
      const jobs = await this.db.select().from(bpmScheduledJobs).where(and48(...whereConditions)).orderBy(desc25(bpmScheduledJobs.updatedAt)).limit(limit).offset(offset);
      return {
        data: jobs,
        total: Number(count5),
        page,
        limit
      };
    } catch (error) {
      logger70.error("Failed to get scheduled jobs", { error, companyId, filter });
      throw error;
    }
  }
  /**
   * Update a scheduled job
   */
  async updateScheduledJob(id, companyId, data) {
    logger70.debug("Updating scheduled job", { id, companyId, data });
    try {
      let updateData = { ...data, updatedAt: /* @__PURE__ */ new Date() };
      if (data.schedule) {
        updateData = {
          ...updateData
        };
      }
      const [job] = await this.db.update(bpmScheduledJobs).set(updateData).where(and48(
        eq59(bpmScheduledJobs.id, id),
        eq59(bpmScheduledJobs.companyId, companyId)
      )).returning();
      return job || null;
    } catch (error) {
      logger70.error("Failed to update scheduled job", { error, id, companyId, data });
      throw error;
    }
  }
  /**
   * Delete a scheduled job
   */
  async deleteScheduledJob(id, companyId) {
    logger70.debug("Deleting scheduled job", { id, companyId });
    try {
      const result = await this.db.delete(bpmScheduledJobs).where(and48(
        eq59(bpmScheduledJobs.id, id),
        eq59(bpmScheduledJobs.companyId, companyId)
      ));
      return result.rowCount > 0;
    } catch (error) {
      logger70.error("Failed to delete scheduled job", { error, id, companyId });
      throw error;
    }
  }
  /**
   * Toggle a scheduled job's active status
   */
  async toggleScheduledJobActive(id, companyId, isActive, userId) {
    logger70.debug("Toggling scheduled job active status", { id, companyId, isActive });
    try {
      const [job] = await this.db.update(bpmScheduledJobs).set({
        isActive,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and48(
        eq59(bpmScheduledJobs.id, id),
        eq59(bpmScheduledJobs.companyId, companyId)
      )).returning();
      return job || null;
    } catch (error) {
      logger70.error("Failed to toggle scheduled job status", { error, id, companyId, isActive });
      throw error;
    }
  }
  /**
   * Run a scheduled job manually
   */
  async runScheduledJobManually(id, companyId, userId) {
    logger70.debug("Running scheduled job manually", { id, companyId, userId });
    try {
      const job = await this.getScheduledJob(id, companyId);
      if (!job) {
        return { success: false, error: "Scheduled job not found", status: 404 };
      }
      const process2 = await this.processService.getProcess(job.action, companyId);
      if (!process2) {
        return { success: false, error: "Process not found", status: 404 };
      }
      const processData = {
        ...job.configuration,
        _trigger: {
          type: "manual",
          jobId: job.id,
          userId
        }
      };
      const instance = await this.processInstanceService.startProcessInstance({
        processId: process2.id,
        companyId,
        initiatorId: userId,
        inputData: processData
      });
      await this.updateScheduledJob(id, companyId, {
        lastRunAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      });
      return {
        success: true,
        processInstanceId: instance.id
      };
    } catch (error) {
      logger70.error("Failed to run scheduled job manually", { error, id, companyId });
      return {
        success: false,
        error: error.message || "Failed to run scheduled job",
        status: 500
      };
    }
  }
  /**
   * Find jobs that are due to run
   */
  async findDueJobs() {
    logger70.debug("Finding due jobs");
    try {
      const now = /* @__PURE__ */ new Date();
      const dueJobs = await this.db.select().from(bpmScheduledJobs).where(and48(
        eq59(bpmScheduledJobs.isActive, true),
        lte5(bpmScheduledJobs.nextRunAt, now)
      ));
      logger70.debug(`Found ${dueJobs.length} due jobs`);
      return dueJobs;
    } catch (error) {
      logger70.error("Failed to find due jobs", { error });
      throw error;
    }
  }
  /**
   * Process due jobs
   */
  async processDueJobs() {
    logger70.debug("Processing due jobs");
    try {
      const dueJobs = await this.findDueJobs();
      let succeeded = 0;
      let failed = 0;
      for (const job of dueJobs) {
        try {
          const process2 = await this.processService.getProcess(job.action, job.companyId);
          if (!process2) {
            logger70.warn(`Process not found for job ${job.id}`);
            failed++;
            continue;
          }
          const processData = {
            ...job.configuration,
            _trigger: {
              type: "scheduled",
              jobId: job.id
            }
          };
          await this.processInstanceService.startProcessInstance({
            processId: process2.id,
            companyId: job.companyId,
            initiatorId: job.createdBy,
            inputData: processData
          });
          const nextRunAt = this.calculateNextRunTime(job.schedule);
          await this.db.update(bpmScheduledJobs).set({
            lastRunAt: /* @__PURE__ */ new Date(),
            nextRunAt
          }).where(eq59(bpmScheduledJobs.id, job.id));
          succeeded++;
        } catch (error) {
          logger70.error(`Failed to process job ${job.id}`, { error, jobId: job.id });
          failed++;
        }
      }
      return {
        processed: dueJobs.length,
        succeeded,
        failed
      };
    } catch (error) {
      logger70.error("Failed to process due jobs", { error });
      throw error;
    }
  }
  /**
   * Calculate next run time based on cron expression
   */
  calculateNextRunTime(cronExpression) {
    const nextRun = /* @__PURE__ */ new Date();
    nextRun.setHours(nextRun.getHours() + 1);
    return nextRun;
  }
};

// server/modules/bpm/init.ts
var logger71 = new Logger("BPM Init");
function initBpmServices(db4) {
  logger71.info("Initializing BPM services...");
  const dbConnection = db4 || getDrizzle();
  const drizzleService5 = new DrizzleService(dbConnection);
  const processService = new ProcessService(drizzleService5);
  const triggerService = new TriggerService(drizzleService5, processService);
  const processInstanceService = new ProcessInstanceService(drizzleService5, processService);
  const stepTemplateService = new StepTemplateService(drizzleService5);
  const stepExecutionService = new StepExecutionService(drizzleService5);
  const apiConnectionService = new ApiConnectionService(drizzleService5);
  const scheduledJobService = new ScheduledJobService(
    drizzleService5,
    processService,
    processInstanceService
  );
  logger71.info("BPM services initialized successfully");
  return {
    processService,
    triggerService,
    processInstanceService,
    stepTemplateService,
    stepExecutionService,
    apiConnectionService,
    scheduledJobService
  };
}

// server/modules/bpm/routes/process.routes.ts
import { Router as Router24 } from "express";

// server/modules/bpm/controllers/process.controller.ts
init_logger();
var ProcessController = class {
  constructor(processService, processInstanceService) {
    this.processService = processService;
    this.processInstanceService = processInstanceService;
    this._logger = new Logger("ProcessController");
  }
  /**
   * Create a new process
   */
  async createProcess(req, res) {
    try {
      const { companyId, userId } = req.user;
      const processData = {
        ...req.body,
        companyId,
        createdBy: userId,
        updatedBy: userId
      };
      const process2 = await this.processService.createProcess(processData);
      res.status(201).json(process2);
    } catch (error) {
      this._logger.error("Failed to create process", { error });
      res.status(500).json({ error: "Failed to create process" });
    }
  }
  /**
   * Get process by ID
   */
  async getProcessById(req, res) {
    try {
      const { id } = req.params;
      const { companyId } = req.user;
      const process2 = await this.processService.getProcessById(id, companyId);
      if (!process2) {
        res.status(404).json({ error: "Process not found" });
        return;
      }
      res.json(process2);
    } catch (error) {
      this._logger.error("Failed to get process by ID", { error });
      res.status(500).json({ error: "Failed to get process by ID" });
    }
  }
  /**
   * Get processes with filtering and pagination
   */
  async getProcesses(req, res) {
    try {
      const { companyId } = req.user;
      const {
        page,
        limit,
        status,
        isTemplate,
        search
      } = req.query;
      const filter = {};
      if (page) {
        filter.page = parseInt(page, 10);
      }
      if (limit) {
        filter.limit = parseInt(limit, 10);
      }
      if (status) {
        filter.status = Array.isArray(status) ? status : [status];
      }
      if (isTemplate !== void 0) {
        filter.isTemplate = isTemplate === "true";
      }
      if (search) {
        filter.search = search;
      }
      const result = await this.processService.getProcesses(companyId, filter);
      res.json(result);
    } catch (error) {
      this._logger.error("Failed to get processes", { error });
      res.status(500).json({ error: "Failed to get processes" });
    }
  }
  /**
   * Update a process
   */
  async updateProcess(req, res) {
    try {
      const { id } = req.params;
      const { userId } = req.user;
      const updateData = {
        ...req.body,
        updatedBy: userId
      };
      const process2 = await this.processService.updateProcess(id, updateData);
      if (!process2) {
        res.status(404).json({ error: "Process not found" });
        return;
      }
      res.json(process2);
    } catch (error) {
      this._logger.error("Failed to update process", { error });
      res.status(500).json({ error: "Failed to update process" });
    }
  }
  /**
   * Change process status
   */
  async changeProcessStatus(req, res) {
    try {
      const { id } = req.params;
      const { status } = req.body;
      const { userId } = req.user;
      if (!Object.values(BpmProcessStatus).includes(status)) {
        res.status(400).json({ error: "Invalid status value" });
        return;
      }
      const process2 = await this.processService.changeProcessStatus(id, status, userId);
      if (!process2) {
        res.status(404).json({ error: "Process not found" });
        return;
      }
      res.json(process2);
    } catch (error) {
      this._logger.error("Failed to change process status", { error });
      res.status(500).json({ error: "Failed to change process status" });
    }
  }
  /**
   * Duplicate a process
   */
  async duplicateProcess(req, res) {
    try {
      const { id } = req.params;
      const { asTemplate, newName } = req.body;
      const { userId } = req.user;
      const options = {
        asTemplate,
        newName,
        userId
      };
      const process2 = await this.processService.duplicateProcess(id, options);
      if (!process2) {
        res.status(404).json({ error: "Process not found" });
        return;
      }
      res.status(201).json(process2);
    } catch (error) {
      this._logger.error("Failed to duplicate process", { error });
      res.status(500).json({ error: "Failed to duplicate process" });
    }
  }
  /**
   * Delete a process
   */
  async deleteProcess(req, res) {
    try {
      const { id } = req.params;
      const success = await this.processService.deleteProcess(id);
      if (!success) {
        res.status(404).json({ error: "Process not found" });
        return;
      }
      res.status(204).send();
    } catch (error) {
      this._logger.error("Failed to delete process", { error });
      res.status(500).json({ error: "Failed to delete process" });
    }
  }
  /**
   * Get process templates
   */
  async getProcessTemplates(req, res) {
    try {
      const { companyId } = req.user;
      const templates = await this.processService.getProcessTemplates(companyId);
      res.json(templates);
    } catch (error) {
      this._logger.error("Failed to get process templates", { error });
      res.status(500).json({ error: "Failed to get process templates" });
    }
  }
  /**
   * Create from template
   */
  async createFromTemplate(req, res) {
    try {
      const { templateId } = req.params;
      const { name } = req.body;
      const { companyId, userId } = req.user;
      const process2 = await this.processService.createFromTemplate(templateId, {
        name,
        companyId,
        userId
      });
      if (!process2) {
        res.status(404).json({ error: "Template not found" });
        return;
      }
      res.status(201).json(process2);
    } catch (error) {
      this._logger.error("Failed to create from template", { error });
      res.status(500).json({ error: "Failed to create from template" });
    }
  }
  /**
   * Start a process
   */
  async startProcess(req, res) {
    try {
      const { processId } = req.params;
      const { companyId, userId } = req.user;
      const { inputData } = req.body;
      const instance = await this.processService.startProcess({
        processId,
        companyId,
        startedBy: userId,
        inputData
      });
      res.status(201).json(instance);
    } catch (error) {
      this._logger.error("Failed to start process", { error });
      res.status(500).json({ error: error.message || "Failed to start process" });
    }
  }
};

// server/modules/bpm/routes/process.routes.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
var logger72 = new Logger("ProcessRoutes");
function registerProcessRoutes(app2, processService, processInstanceService) {
  const router14 = Router24();
  const processController = new ProcessController(processService, processInstanceService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/", (req, res) => processController.getProcesses(req, res));
  router14.get("/:id", (req, res) => processController.getProcessById(req, res));
  router14.post("/", (req, res) => processController.createProcess(req, res));
  router14.patch("/:id", (req, res) => processController.updateProcess(req, res));
  router14.delete("/:id", (req, res) => processController.deleteProcess(req, res));
  router14.patch("/:id/status", (req, res) => processController.changeProcessStatus(req, res));
  router14.post("/:id/duplicate", (req, res) => processController.duplicateProcess(req, res));
  router14.get("/templates/all", (req, res) => processController.getProcessTemplates(req, res));
  router14.post("/templates/:templateId/create", (req, res) => processController.createFromTemplate(req, res));
  router14.post("/:processId/start", (req, res) => processController.startProcess(req, res));
  app2.use("/api/bpm/processes", router14);
  logger72.info("Registered BPM process routes");
}

// server/modules/bpm/routes/trigger.routes.ts
import { Router as Router25 } from "express";

// server/modules/bpm/controllers/trigger.controller.ts
init_logger();
init_audit_service();
import { z as z19 } from "zod";
var createTriggerSchema2 = z19.object({
  name: z19.string().min(3).max(100),
  description: z19.string().optional(),
  type: z19.enum(["WEBHOOK", "SCHEDULED", "EVENT", "MANUAL", "DATA_CHANGE", "EXTERNAL_API"]),
  processId: z19.string().uuid(),
  configuration: z19.record(z19.any()),
  isActive: z19.boolean().optional()
});
var updateTriggerSchema2 = z19.object({
  name: z19.string().min(3).max(100).optional(),
  description: z19.string().optional(),
  type: z19.enum(["WEBHOOK", "SCHEDULED", "EVENT", "MANUAL", "DATA_CHANGE", "EXTERNAL_API"]).optional(),
  configuration: z19.record(z19.any()).optional(),
  isActive: z19.boolean().optional()
});
var TriggerController = class {
  /**
   * Constructor
   */
  constructor(triggerService) {
    this._logger = new Logger("TriggerController");
    this._triggerService = triggerService;
    this._auditService = AuditService;
  }
  /**
   * Get all triggers with filtering and pagination
   */
  async listTriggers(req, res) {
    try {
      const companyId = req.user?.companyId;
      const { processId, type, isActive, page, limit, search } = req.query;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          error: "Company ID is required"
        });
      }
      const filter = {
        processId,
        type,
        isActive: isActive === "true",
        page: page ? parseInt(page) : 1,
        limit: limit ? parseInt(limit) : 25,
        search
      };
      const triggers = await this._triggerService.getTriggers(companyId, filter);
      return res.status(200).json({
        success: true,
        data: triggers
      });
    } catch (error) {
      this._logger.error("Error getting triggers", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to get triggers"
      });
    }
  }
  /**
   * Get a trigger by ID
   */
  async getTriggerById(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          error: "Company ID is required"
        });
      }
      const trigger = await this._triggerService.getTriggerById(id, companyId);
      if (!trigger) {
        return res.status(404).json({
          success: false,
          error: "Trigger not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: trigger
      });
    } catch (error) {
      this._logger.error("Error getting trigger", error instanceof Error ? error.message : String(error), { id: req.params.id });
      return res.status(500).json({
        success: false,
        error: "Failed to get trigger"
      });
    }
  }
  /**
   * Create a new trigger
   */
  async createTrigger(req, res) {
    try {
      const validatedData = createTriggerSchema2.parse(req.body);
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const trigger = await this._triggerService.createTrigger({
        ...validatedData,
        companyId,
        createdBy: userId,
        updatedBy: userId
      });
      await this._auditService.log({
        userId,
        companyId,
        action: "CREATE" /* CREATE */,
        entity: "bpm_trigger",
        entityId: trigger.id,
        details: {
          name: trigger.name,
          type: trigger.type,
          processId: trigger.processId
        }
      });
      return res.status(201).json({
        success: true,
        data: trigger
      });
    } catch (error) {
      if (error instanceof z19.ZodError) {
        return res.status(400).json({
          success: false,
          error: "Validation error",
          details: error.errors
        });
      }
      this._logger.error("Error creating trigger", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to create trigger"
      });
    }
  }
  /**
   * Update a trigger
   */
  async updateTrigger(req, res) {
    try {
      const { id } = req.params;
      const validatedData = updateTriggerSchema2.parse(req.body);
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const existingTrigger = await this._triggerService.getTriggerById(id, companyId);
      if (!existingTrigger) {
        return res.status(404).json({
          success: false,
          error: "Trigger not found"
        });
      }
      const trigger = await this._triggerService.updateTrigger(id, companyId, {
        ...validatedData,
        updatedBy: userId
      });
      if (!trigger) {
        return res.status(404).json({
          success: false,
          error: "Trigger not found"
        });
      }
      await this._auditService.log({
        userId,
        companyId,
        action: "UPDATE" /* UPDATE */,
        entity: "bpm_trigger",
        entityId: id,
        details: {
          changes: validatedData
        }
      });
      return res.status(200).json({
        success: true,
        data: trigger
      });
    } catch (error) {
      if (error instanceof z19.ZodError) {
        return res.status(400).json({
          success: false,
          error: "Validation error",
          details: error.errors
        });
      }
      this._logger.error("Error updating trigger", error instanceof Error ? error.message : String(error), { id: req.params.id });
      return res.status(500).json({
        success: false,
        error: "Failed to update trigger"
      });
    }
  }
  /**
   * Delete a trigger
   */
  async deleteTrigger(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const existingTrigger = await this._triggerService.getTriggerById(id, companyId);
      if (!existingTrigger) {
        return res.status(404).json({
          success: false,
          error: "Trigger not found"
        });
      }
      const success = await this._triggerService.deleteTrigger(id, companyId);
      if (!success) {
        return res.status(404).json({
          success: false,
          error: "Trigger not found"
        });
      }
      await this._auditService.log({
        userId,
        companyId,
        action: "DELETE" /* DELETE */,
        entity: "bpm_trigger",
        entityId: id,
        details: {
          name: existingTrigger.name,
          type: existingTrigger.type
        }
      });
      return res.status(200).json({
        success: true,
        message: "Trigger deleted successfully"
      });
    } catch (error) {
      this._logger.error("Error deleting trigger", error instanceof Error ? error.message : String(error), { id: req.params.id });
      return res.status(500).json({
        success: false,
        error: "Failed to delete trigger"
      });
    }
  }
  /**
   * Toggle trigger active status
   */
  async toggleTriggerActive(req, res) {
    try {
      const { id } = req.params;
      const { active } = req.body;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      if (typeof active !== "boolean") {
        return res.status(400).json({
          success: false,
          error: "Active status must be a boolean"
        });
      }
      const existingTrigger = await this._triggerService.getTriggerById(id, companyId);
      if (!existingTrigger) {
        return res.status(404).json({
          success: false,
          error: "Trigger not found"
        });
      }
      const trigger = await this._triggerService.toggleTriggerActive(id, companyId, active, userId);
      if (!trigger) {
        return res.status(404).json({
          success: false,
          error: "Trigger not found"
        });
      }
      await this._auditService.log({
        userId,
        companyId,
        action: "UPDATE" /* UPDATE */,
        entity: "bpm_trigger",
        entityId: id,
        details: {
          operation: "toggle_active",
          previousState: existingTrigger.isActive,
          newState: active
        }
      });
      return res.status(200).json({
        success: true,
        data: trigger
      });
    } catch (error) {
      this._logger.error("Error toggling trigger status", error instanceof Error ? error.message : String(error), { id: req.params.id });
      return res.status(500).json({
        success: false,
        error: "Failed to toggle trigger status"
      });
    }
  }
  /**
   * Manually execute a trigger
   */
  async executeTrigger(req, res) {
    try {
      const { id } = req.params;
      const { inputData } = req.body;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const existingTrigger = await this._triggerService.getTriggerById(id, companyId);
      if (!existingTrigger) {
        return res.status(404).json({
          success: false,
          error: "Trigger not found"
        });
      }
      const result = await this._triggerService.executeTrigger(id, companyId, userId, inputData || {});
      if (!result.success) {
        return res.status(result.status || 500).json({
          success: false,
          error: result.error
        });
      }
      await this._auditService.log({
        userId,
        companyId,
        action: AuditAction.EXECUTE,
        entity: "bpm_trigger",
        entityId: id,
        details: {
          operation: "execute_trigger",
          processInstanceId: result.processInstanceId,
          triggerType: existingTrigger.type,
          inputData: inputData || {}
        }
      });
      return res.status(200).json({
        success: true,
        data: {
          processInstanceId: result.processInstanceId
        }
      });
    } catch (error) {
      this._logger.error("Error executing trigger", error instanceof Error ? error.message : String(error), { id: req.params.id });
      return res.status(500).json({
        success: false,
        error: "Failed to execute trigger"
      });
    }
  }
};

// server/modules/bpm/routes/trigger.routes.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
var logger73 = new Logger("TriggerRoutes");
function registerTriggerRoutes(app2, triggerService) {
  const router14 = Router25();
  const triggerController = new TriggerController(triggerService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/", (req, res) => triggerController.listTriggers(req, res));
  router14.get("/:id", (req, res) => triggerController.getTriggerById(req, res));
  router14.post("/", (req, res) => triggerController.createTrigger(req, res));
  router14.patch("/:id", (req, res) => triggerController.updateTrigger(req, res));
  router14.delete("/:id", (req, res) => triggerController.deleteTrigger(req, res));
  router14.patch("/:id/toggle", (req, res) => triggerController.toggleTriggerActive(req, res));
  router14.post("/:id/execute", (req, res) => triggerController.executeTrigger(req, res));
  app2.use("/api/bpm/triggers", router14);
  logger73.info("Registered BPM trigger routes");
}

// server/modules/bpm/routes/process-instance.routes.ts
import { Router as Router26 } from "express";

// server/modules/bpm/controllers/process-instance.controller.ts
init_logger();
var ProcessInstanceController = class {
  constructor(processInstanceService) {
    this.processInstanceService = processInstanceService;
    this._logger = new Logger("ProcessInstanceController");
  }
  /**
   * Get all process instances with filtering and pagination
   */
  async listProcessInstances(req, res) {
    try {
      const { companyId } = req.user;
      const {
        page,
        limit,
        processId,
        status,
        startedBy
      } = req.query;
      const filter = {};
      if (page) {
        filter.page = parseInt(page, 10);
      }
      if (limit) {
        filter.limit = parseInt(limit, 10);
      }
      if (processId) {
        filter.processId = processId;
      }
      if (status) {
        filter.status = Array.isArray(status) ? status : [status];
      }
      if (startedBy) {
        filter.startedBy = startedBy;
      }
      const result = await this.processInstanceService.getInstances(companyId, filter);
      res.json(result);
    } catch (error) {
      this._logger.error("Failed to get process instances", { error });
      res.status(500).json({ error: "Failed to get process instances" });
    }
  }
  /**
   * Get a process instance by ID
   */
  async getProcessInstanceById(req, res) {
    try {
      const { id } = req.params;
      const { companyId } = req.user;
      const instance = await this.processInstanceService.getInstanceById(id, companyId);
      if (!instance) {
        res.status(404).json({ error: "Process instance not found" });
        return;
      }
      res.json(instance);
    } catch (error) {
      this._logger.error("Failed to get process instance by ID", { error });
      res.status(500).json({ error: "Failed to get process instance by ID" });
    }
  }
  /**
   * Start a process
   */
  async startProcess(req, res) {
    try {
      const { processId, inputData } = req.body;
      const { companyId, userId } = req.user;
      if (!processId) {
        res.status(400).json({ error: "Process ID is required" });
        return;
      }
      res.status(400).json({
        error: "Please use POST /api/bpm/processes/:processId/start to start a process instance"
      });
    } catch (error) {
      this._logger.error("Failed to start process", { error });
      res.status(500).json({ error: "Failed to start process" });
    }
  }
  /**
   * Cancel a process instance
   */
  async cancelProcessInstance(req, res) {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const { userId } = req.user;
      const instance = await this.processInstanceService.cancelInstance(id, reason, userId);
      if (!instance) {
        res.status(404).json({ error: "Process instance not found" });
        return;
      }
      res.json(instance);
    } catch (error) {
      this._logger.error("Failed to cancel process instance", { error });
      res.status(500).json({ error: "Failed to cancel process instance" });
    }
  }
  /**
   * Pause a process instance
   */
  async pauseProcessInstance(req, res) {
    try {
      const { id } = req.params;
      const { userId } = req.user;
      const instance = await this.processInstanceService.getInstanceById(id);
      if (!instance) {
        res.status(404).json({ error: "Process instance not found" });
        return;
      }
      const updatedInstance = await this.processInstanceService.updateInstance(
        id,
        {
          status: BpmProcessInstanceStatus.PAUSED,
          variables: {
            ...instance.variables,
            pausedAt: (/* @__PURE__ */ new Date()).toISOString(),
            pausedBy: userId
          }
        },
        userId
      );
      res.json(updatedInstance);
    } catch (error) {
      this._logger.error("Failed to pause process instance", { error });
      res.status(500).json({ error: "Failed to pause process instance" });
    }
  }
  /**
   * Resume a paused process instance
   */
  async resumeProcessInstance(req, res) {
    try {
      const { id } = req.params;
      const { userId } = req.user;
      const instance = await this.processInstanceService.getInstanceById(id);
      if (!instance) {
        res.status(404).json({ error: "Process instance not found" });
        return;
      }
      if (instance.status !== BpmProcessInstanceStatus.PAUSED) {
        res.status(400).json({ error: "Process instance is not paused" });
        return;
      }
      const updatedInstance = await this.processInstanceService.updateInstance(
        id,
        {
          status: "RUNNING" /* RUNNING */,
          variables: {
            ...instance.variables,
            resumedAt: (/* @__PURE__ */ new Date()).toISOString(),
            resumedBy: userId
          }
        },
        userId
      );
      res.json(updatedInstance);
    } catch (error) {
      this._logger.error("Failed to resume process instance", { error });
      res.status(500).json({ error: "Failed to resume process instance" });
    }
  }
  /**
   * Get process instance history/logs
   */
  async getProcessInstanceHistory(req, res) {
    try {
      const { id } = req.params;
      const instance = await this.processInstanceService.getInstanceById(id);
      if (!instance) {
        res.status(404).json({ error: "Process instance not found" });
        return;
      }
      const history = await this.processInstanceService.getInstanceHistory(id);
      res.json(history);
    } catch (error) {
      this._logger.error("Failed to get process instance history", { error });
      res.status(500).json({ error: "Failed to get process instance history" });
    }
  }
  /**
   * Get process instance status details
   */
  async getProcessInstanceStatus(req, res) {
    try {
      const { id } = req.params;
      const { companyId } = req.user;
      const instance = await this.processInstanceService.getInstanceById(id, companyId);
      if (!instance) {
        res.status(404).json({ error: "Process instance not found" });
        return;
      }
      const history = await this.processInstanceService.getInstanceHistory(id);
      const statusDetails = {
        id: instance.id,
        processId: instance.processId,
        status: instance.status,
        currentStep: instance.currentStep,
        startedAt: instance.createdAt,
        startedBy: instance.startedBy,
        completedAt: instance.completedAt,
        lastUpdated: instance.updatedAt,
        executionTime: instance.completedAt ? (instance.completedAt.getTime() - instance.createdAt.getTime()) / 1e3 : ((/* @__PURE__ */ new Date()).getTime() - instance.createdAt.getTime()) / 1e3,
        totalStepsExecuted: history.filter((h) => h.action === "EXECUTE_STEP").length,
        progressPercentage: calculateProgressPercentage(instance, history)
      };
      res.json(statusDetails);
    } catch (error) {
      this._logger.error("Failed to get process instance status", { error });
      res.status(500).json({ error: "Failed to get process instance status" });
    }
  }
};
function calculateProgressPercentage(instance, history) {
  if (instance.status === "COMPLETED" /* COMPLETED */) {
    return 100;
  }
  if (instance.status === "CANCELLED" /* CANCELLED */) {
    return 0;
  }
  const stepsExecuted = history.filter((h) => h.action === "EXECUTE_STEP").length;
  const estimatedTotalSteps = 5;
  return Math.min(Math.round(stepsExecuted / estimatedTotalSteps * 100), 99);
}

// server/modules/bpm/routes/process-instance.routes.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
var logger74 = new Logger("ProcessInstanceRoutes");
function registerProcessInstanceRoutes(app2, processInstanceService) {
  const router14 = Router26();
  const processInstanceController = new ProcessInstanceController(processInstanceService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/", (req, res) => processInstanceController.listProcessInstances(req, res));
  router14.get("/:id", (req, res) => processInstanceController.getProcessInstanceById(req, res));
  router14.post("/", (req, res) => processInstanceController.startProcess(req, res));
  router14.post("/:id/cancel", (req, res) => processInstanceController.cancelProcessInstance(req, res));
  router14.post("/:id/pause", (req, res) => processInstanceController.pauseProcessInstance(req, res));
  router14.post("/:id/resume", (req, res) => processInstanceController.resumeProcessInstance(req, res));
  router14.get("/:id/history", (req, res) => processInstanceController.getProcessInstanceHistory(req, res));
  router14.get("/:id/status", (req, res) => processInstanceController.getProcessInstanceStatus(req, res));
  app2.use("/api/bpm/process-instances", router14);
  logger74.info("Registered BPM process instance routes");
}

// server/modules/bpm/routes/step-template.routes.ts
import express6 from "express";

// server/shared/schema/audit.schema.js
var AuditAction3 = {
  CREATE: "CREATE",
  UPDATE: "UPDATE",
  DELETE: "DELETE",
  VIEW: "VIEW",
  LOGIN: "LOGIN",
  LOGOUT: "LOGOUT",
  EXPORT: "EXPORT",
  IMPORT: "IMPORT",
  EXECUTE: "EXECUTE",
  APPROVE: "APPROVE",
  REJECT: "REJECT",
  SUBMIT: "SUBMIT",
  CANCEL: "CANCEL",
  COMPLETE: "COMPLETE"
};

// server/modules/bpm/controllers/step-template.controller.ts
var StepTemplateController = class {
  /**
   * Constructor
   * 
   * @param stepTemplateService The step template service
   * @param auditService The audit service for logging actions
   */
  constructor(stepTemplateService, auditService4) {
    this.stepTemplateService = stepTemplateService;
    this.auditService = auditService4;
  }
  /**
   * Get all step templates
   * 
   * @param req Express request
   * @param res Express response
   */
  async getStepTemplates(req, res) {
    try {
      const { companyId } = req.user;
      const includeGlobal = req.query.includeGlobal !== "false";
      const stepTemplates = await this.stepTemplateService.getStepTemplates(companyId, includeGlobal);
      res.status(200).json({
        success: true,
        data: stepTemplates
      });
    } catch (error) {
      console.error("Error getting step templates:", error);
      res.status(500).json({
        success: false,
        message: `Error getting step templates: ${error.message}`
      });
    }
  }
  /**
   * Get a step template by ID
   * 
   * @param req Express request
   * @param res Express response
   */
  async getStepTemplateById(req, res) {
    try {
      const { id } = req.params;
      const { companyId } = req.user;
      const stepTemplate = await this.stepTemplateService.getStepTemplateById(id, companyId);
      if (!stepTemplate) {
        return res.status(404).json({
          success: false,
          message: "Step template not found"
        });
      }
      res.status(200).json({
        success: true,
        data: stepTemplate
      });
    } catch (error) {
      console.error("Error getting step template by ID:", error);
      res.status(500).json({
        success: false,
        message: `Error getting step template: ${error.message}`
      });
    }
  }
  /**
   * Create a new step template
   * 
   * @param req Express request
   * @param res Express response
   */
  async createStepTemplate(req, res) {
    try {
      const { companyId, id: userId } = req.user;
      const validation = createStepTemplateSchema.safeParse({
        ...req.body,
        companyId
      });
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }
      const data = validation.data;
      const stepTemplate = await this.stepTemplateService.createStepTemplate({
        ...data,
        createdBy: userId,
        updatedBy: userId
      });
      await this.auditService.log({
        action: AuditAction3.CREATE,
        entity: "bpm_step_templates",
        entityId: stepTemplate.id,
        userId,
        companyId,
        metadata: {
          name: stepTemplate.name,
          type: stepTemplate.type,
          targetType: stepTemplate.targetType
        }
      });
      res.status(201).json({
        success: true,
        data: stepTemplate
      });
    } catch (error) {
      console.error("Error creating step template:", error);
      res.status(500).json({
        success: false,
        message: `Error creating step template: ${error.message}`
      });
    }
  }
  /**
   * Update a step template
   * 
   * @param req Express request
   * @param res Express response
   */
  async updateStepTemplate(req, res) {
    try {
      const { id } = req.params;
      const { companyId, id: userId } = req.user;
      const validation = updateStepTemplateSchema.safeParse({
        ...req.body,
        updatedBy: userId
      });
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }
      const data = validation.data;
      const existingTemplate = await this.stepTemplateService.getStepTemplateById(id, companyId);
      if (!existingTemplate) {
        return res.status(404).json({
          success: false,
          message: "Step template not found or you do not have permission to update it"
        });
      }
      const stepTemplate = await this.stepTemplateService.updateStepTemplate(id, data, companyId);
      await this.auditService.log({
        action: AuditAction3.UPDATE,
        entity: "bpm_step_templates",
        entityId: id,
        userId,
        companyId,
        metadata: {
          name: stepTemplate.name,
          type: stepTemplate.type,
          targetType: stepTemplate.targetType,
          changes: req.body
        }
      });
      res.status(200).json({
        success: true,
        data: stepTemplate
      });
    } catch (error) {
      console.error("Error updating step template:", error);
      res.status(500).json({
        success: false,
        message: `Error updating step template: ${error.message}`
      });
    }
  }
  /**
   * Delete a step template
   * 
   * @param req Express request
   * @param res Express response
   */
  async deleteStepTemplate(req, res) {
    try {
      const { id } = req.params;
      const { companyId, id: userId } = req.user;
      const stepTemplate = await this.stepTemplateService.getStepTemplateById(id, companyId);
      if (!stepTemplate) {
        return res.status(404).json({
          success: false,
          message: "Step template not found or you do not have permission to delete it"
        });
      }
      await this.stepTemplateService.deleteStepTemplate(id, companyId);
      await this.auditService.log({
        action: AuditAction3.DELETE,
        entity: "bpm_step_templates",
        entityId: id,
        userId,
        companyId,
        metadata: {
          name: stepTemplate.name,
          type: stepTemplate.type
        }
      });
      res.status(200).json({
        success: true,
        message: "Step template deleted successfully"
      });
    } catch (error) {
      console.error("Error deleting step template:", error);
      res.status(500).json({
        success: false,
        message: `Error deleting step template: ${error.message}`
      });
    }
  }
  /**
   * Get step templates by type
   * 
   * @param req Express request
   * @param res Express response
   */
  async getStepTemplatesByType(req, res) {
    try {
      const { type } = req.params;
      const { companyId } = req.user;
      const includeGlobal = req.query.includeGlobal !== "false";
      if (!Object.values(BpmStepTemplateType).includes(type)) {
        return res.status(400).json({
          success: false,
          message: "Invalid step template type"
        });
      }
      const stepTemplates = await this.stepTemplateService.getStepTemplatesByType(
        type,
        companyId,
        includeGlobal
      );
      res.status(200).json({
        success: true,
        data: stepTemplates
      });
    } catch (error) {
      console.error("Error getting step templates by type:", error);
      res.status(500).json({
        success: false,
        message: `Error getting step templates: ${error.message}`
      });
    }
  }
  /**
   * Get step templates by target type
   * 
   * @param req Express request
   * @param res Express response
   */
  async getStepTemplatesByTargetType(req, res) {
    try {
      const { targetType } = req.params;
      const { companyId } = req.user;
      const includeGlobal = req.query.includeGlobal !== "false";
      if (!Object.values(BpmStepTemplateTargetType).includes(targetType)) {
        return res.status(400).json({
          success: false,
          message: "Invalid step template target type"
        });
      }
      const stepTemplates = await this.stepTemplateService.getStepTemplatesByTargetType(
        targetType,
        companyId,
        includeGlobal
      );
      res.status(200).json({
        success: true,
        data: stepTemplates
      });
    } catch (error) {
      console.error("Error getting step templates by target type:", error);
      res.status(500).json({
        success: false,
        message: `Error getting step templates: ${error.message}`
      });
    }
  }
  /**
   * Toggle global status of a step template
   * 
   * @param req Express request
   * @param res Express response
   */
  async toggleGlobalTemplate(req, res) {
    try {
      const { id } = req.params;
      const { companyId, id: userId } = req.user;
      const { isGlobal } = req.body;
      if (typeof isGlobal !== "boolean") {
        return res.status(400).json({
          success: false,
          message: "Invalid request data: isGlobal must be a boolean"
        });
      }
      const existingTemplate = await this.stepTemplateService.getStepTemplateById(id, companyId);
      if (!existingTemplate) {
        return res.status(404).json({
          success: false,
          message: "Step template not found or you do not have permission to update it"
        });
      }
      const stepTemplate = await this.stepTemplateService.toggleGlobalTemplate(id, isGlobal, companyId);
      await this.auditService.log({
        action: AuditAction3.UPDATE,
        entity: "bpm_step_templates",
        entityId: id,
        userId,
        companyId,
        metadata: {
          name: stepTemplate.name,
          isGlobal,
          previousIsGlobal: existingTemplate.isGlobal
        }
      });
      res.status(200).json({
        success: true,
        data: stepTemplate
      });
    } catch (error) {
      console.error("Error toggling global status:", error);
      res.status(500).json({
        success: false,
        message: `Error toggling global status: ${error.message}`
      });
    }
  }
};

// server/common/middleware/auth-guard.ts
init_logger();
init_auth_service();
import jwt5 from "jsonwebtoken";
var logger75 = new Logger("AuthGuard");
var AuthGuard2 = class _AuthGuard2 {
  /**
   * Middleware that requires authentication
   * Will reject requests without a valid JWT token
   */
  static requireAuth() {
    return (req, res, next) => {
      const token = _AuthGuard2.getTokenFromRequest(req);
      if (!token) {
        return res.status(401).json({ success: false, message: "Authentication required" });
      }
      try {
        const decoded = jwt5.verify(token, JWT_SECRET);
        req.user = decoded;
        if (!req.user.roles && req.user.role) {
          req.user.roles = [req.user.role];
        }
        next();
      } catch (error) {
        logger75.error("Invalid token", error);
        return res.status(401).json({ success: false, message: "Invalid or expired token" });
      }
    };
  }
  /**
   * Middleware that optionally authenticates the user
   * Will continue processing even without a valid token
   */
  static optionalAuth() {
    return (req, res, next) => {
      const token = _AuthGuard2.getTokenFromRequest(req);
      if (!token) {
        return next();
      }
      try {
        const decoded = jwt5.verify(token, JWT_SECRET);
        req.user = decoded;
        if (!req.user.roles && req.user.role) {
          req.user.roles = [req.user.role];
        }
        next();
      } catch (error) {
        logger75.debug("Invalid optional token", error);
        next();
      }
    };
  }
  /**
   * Middleware that requires specific role(s)
   * @param roles String or array of allowed roles
   */
  static requireRoles(roles3) {
    return (req, res, next) => {
      _AuthGuard2.requireAuth()(req, res, () => {
        if (!req.user) {
          return res.status(401).json({ success: false, message: "Authentication required" });
        }
        const userRole = req.user.role;
        const userRoles3 = req.user.roles || [userRole];
        const allowedRoles = Array.isArray(roles3) ? roles3 : [roles3];
        const hasAllowedRole = userRoles3.some((role) => allowedRoles.includes(role));
        if (hasAllowedRole) {
          return next();
        }
        return res.status(403).json({ success: false, message: "Insufficient permissions" });
      });
    };
  }
  /**
   * Middleware that requires access to a specific company
   */
  static requireCompanyAccess(paramName = "companyId") {
    return (req, res, next) => {
      _AuthGuard2.requireAuth()(req, res, () => {
        if (!req.user) {
          return res.status(401).json({ success: false, message: "Authentication required" });
        }
        const userCompanyId = req.user.companyId;
        const targetCompanyId = req.params[paramName] || req.body[paramName];
        const userRoles3 = req.user.roles || [req.user.role];
        if (userRoles3.includes("admin")) {
          return next();
        }
        if (!targetCompanyId || userCompanyId === targetCompanyId) {
          return next();
        }
        return res.status(403).json({ success: false, message: "Access denied to the requested company" });
      });
    };
  }
  /**
   * Extract JWT token from request
   * Looks for the token in Authorization header (Bearer token)
   */
  static getTokenFromRequest(req) {
    if (!req.headers.authorization) {
      return null;
    }
    const authHeader = req.headers.authorization;
    if (!authHeader.startsWith("Bearer ")) {
      return null;
    }
    const token = authHeader.split(" ")[1];
    return token || null;
  }
};

// server/modules/bpm/routes/step-template.routes.ts
var initStepTemplateRoutes = (app2, db4) => {
  const router14 = express6.Router();
  const stepTemplateService = new StepTemplateService(db4);
  const auditService4 = new AuditService2(db4);
  const stepTemplateController = new StepTemplateController(stepTemplateService, auditService4);
  router14.use(AuthGuard2.requireAuth());
  router14.get("/", (req, res) => stepTemplateController.getStepTemplates(req, res));
  router14.get("/by-type/:type", (req, res) => stepTemplateController.getStepTemplatesByType(req, res));
  router14.get("/by-target-type/:targetType", (req, res) => stepTemplateController.getStepTemplatesByTargetType(req, res));
  router14.get("/:id", (req, res) => stepTemplateController.getStepTemplateById(req, res));
  router14.post("/", (req, res) => stepTemplateController.createStepTemplate(req, res));
  router14.put("/:id", (req, res) => stepTemplateController.updateStepTemplate(req, res));
  router14.delete("/:id", (req, res) => stepTemplateController.deleteStepTemplate(req, res));
  router14.patch("/:id/toggle-global", (req, res) => stepTemplateController.toggleGlobalTemplate(req, res));
  return router14;
};

// server/modules/bpm/routes/step-execution.routes.ts
import { Router as Router27 } from "express";

// server/modules/bpm/controllers/step-execution.controller.ts
init_logger();
init_audit_service();
import { z as z20 } from "zod";
var updateExecutionSchema = z20.object({
  status: z20.nativeEnum(BpmStepExecutionStatus).optional(),
  outputData: z20.record(z20.any()).optional(),
  errorData: z20.record(z20.any()).optional()
});
var StepExecutionController = class {
  /**
   * Constructor
   */
  constructor(stepExecutionService) {
    this._logger = new Logger("StepExecutionController");
    this._stepExecutionService = stepExecutionService;
  }
  /**
   * Get all step executions for a process instance
   */
  async getStepExecutionsByInstanceId(req, res) {
    try {
      const { instanceId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          error: "Company ID is required"
        });
      }
      const executions = await this._stepExecutionService.getStepExecutionsByInstanceId(instanceId, companyId);
      return res.status(200).json({
        success: true,
        data: executions
      });
    } catch (error) {
      this._logger.error("Error getting step executions", {
        error: error instanceof Error ? error.message : String(error),
        instanceId: req.params.instanceId
      });
      return res.status(500).json({
        success: false,
        error: "Failed to get step executions"
      });
    }
  }
  /**
   * Get a step execution by ID
   */
  async getStepExecutionById(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          error: "Company ID is required"
        });
      }
      const execution = await this._stepExecutionService.getStepExecution(id, companyId);
      if (!execution) {
        return res.status(404).json({
          success: false,
          error: "Step execution not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: execution
      });
    } catch (error) {
      this._logger.error("Error getting step execution", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to get step execution"
      });
    }
  }
  /**
   * Update a step execution (for manual steps or approvals)
   */
  async updateStepExecution(req, res) {
    try {
      const { id } = req.params;
      const validatedData = updateExecutionSchema.parse(req.body);
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const execution = await this._stepExecutionService.updateStepExecution(id, companyId, {
        ...validatedData,
        executedBy: userId
      });
      if (!execution) {
        return res.status(404).json({
          success: false,
          error: "Step execution not found"
        });
      }
      await AuditService.log({
        userId,
        companyId,
        action: "UPDATE" /* UPDATE */,
        entity: "bpm_step_execution",
        entityId: id,
        details: {
          changes: validatedData,
          stepId: execution.stepId,
          instanceId: execution.instanceId
        }
      });
      return res.status(200).json({
        success: true,
        data: execution
      });
    } catch (error) {
      if (error instanceof z20.ZodError) {
        return res.status(400).json({
          success: false,
          error: "Validation error",
          details: error.errors
        });
      }
      this._logger.error("Error updating step execution", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to update step execution"
      });
    }
  }
  /**
   * Complete a manual step
   */
  async completeManualStep(req, res) {
    try {
      const { id } = req.params;
      const { outputData } = req.body;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const execution = await this._stepExecutionService.completeStepExecution(id, companyId, userId, outputData);
      if (!execution) {
        return res.status(404).json({
          success: false,
          error: "Step execution not found"
        });
      }
      await AuditService.log({
        userId,
        companyId,
        action: "BPM_PROCESS_ACTION" /* BPM_PROCESS_ACTION */,
        entity: "bpm_step_execution",
        entityId: id,
        details: {
          operation: "complete_manual_step",
          stepId: execution.stepId,
          instanceId: execution.instanceId
        }
      });
      return res.status(200).json({
        success: true,
        data: execution
      });
    } catch (error) {
      this._logger.error("Error completing manual step", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to complete manual step"
      });
    }
  }
  /**
   * Fail a step execution
   */
  async failStepExecution(req, res) {
    try {
      const { id } = req.params;
      const { errorData, reason } = req.body;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const execution = await this._stepExecutionService.failStepExecution(id, companyId, userId, errorData, reason);
      if (!execution) {
        return res.status(404).json({
          success: false,
          error: "Step execution not found"
        });
      }
      await AuditService.log({
        userId,
        companyId,
        action: "BPM_PROCESS_ACTION" /* BPM_PROCESS_ACTION */,
        entity: "bpm_step_execution",
        entityId: id,
        details: {
          operation: "fail_step",
          reason,
          stepId: execution.stepId,
          instanceId: execution.instanceId
        }
      });
      return res.status(200).json({
        success: true,
        data: execution
      });
    } catch (error) {
      this._logger.error("Error failing step execution", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to fail step execution"
      });
    }
  }
  /**
   * Skip a step execution
   */
  async skipStepExecution(req, res) {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const execution = await this._stepExecutionService.skipStepExecution(id, companyId, userId, reason);
      if (!execution) {
        return res.status(404).json({
          success: false,
          error: "Step execution not found"
        });
      }
      await AuditService.log({
        userId,
        companyId,
        action: "BPM_PROCESS_ACTION" /* BPM_PROCESS_ACTION */,
        entity: "bpm_step_execution",
        entityId: id,
        details: {
          operation: "skip_step",
          reason,
          stepId: execution.stepId,
          instanceId: execution.instanceId
        }
      });
      return res.status(200).json({
        success: true,
        data: execution
      });
    } catch (error) {
      this._logger.error("Error skipping step execution", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to skip step execution"
      });
    }
  }
};

// server/modules/bpm/routes/step-execution.routes.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
var logger76 = new Logger("StepExecutionRoutes");
function registerStepExecutionRoutes(app2, stepExecutionService) {
  const router14 = Router27();
  const stepExecutionController = new StepExecutionController(stepExecutionService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/instance/:instanceId", (req, res) => stepExecutionController.getStepExecutionsByInstanceId(req, res));
  router14.get("/:id", (req, res) => stepExecutionController.getStepExecutionById(req, res));
  router14.patch("/:id", (req, res) => stepExecutionController.updateStepExecution(req, res));
  router14.post("/:id/complete", (req, res) => stepExecutionController.completeManualStep(req, res));
  router14.post("/:id/fail", (req, res) => stepExecutionController.failStepExecution(req, res));
  router14.post("/:id/skip", (req, res) => stepExecutionController.skipStepExecution(req, res));
  app2.use("/api/bpm/executions", router14);
  logger76.info("Registered BPM step execution routes");
}

// server/modules/bpm/routes/api-connection.routes.ts
import { Router as Router28 } from "express";

// server/modules/bpm/controllers/api-connection.controller.ts
init_logger();
init_audit_service();
import { z as z21 } from "zod";
var createConnectionSchema = z21.object({
  name: z21.string().min(3).max(100),
  type: z21.nativeEnum(BpmApiConnectionType),
  description: z21.string().optional().nullable(),
  configuration: z21.record(z21.any()),
  isActive: z21.boolean().optional()
});
var updateConnectionSchema = z21.object({
  name: z21.string().min(3).max(100).optional(),
  type: z21.nativeEnum(BpmApiConnectionType).optional(),
  description: z21.string().optional().nullable(),
  configuration: z21.record(z21.any()).optional(),
  isActive: z21.boolean().optional()
});
var ApiConnectionController = class {
  /**
   * Constructor
   */
  constructor(apiConnectionService) {
    this._logger = new Logger("ApiConnectionController");
    this._apiConnectionService = apiConnectionService;
  }
  /**
   * Get all API connections for a company
   */
  async getApiConnections(req, res) {
    try {
      const companyId = req.user?.companyId;
      const { provider, isActive, page, limit, search } = req.query;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          error: "Company ID is required"
        });
      }
      const filter = {
        provider,
        isActive: isActive === "true",
        page: page ? parseInt(page) : 1,
        limit: limit ? parseInt(limit) : 25,
        search
      };
      const connections = await this._apiConnectionService.getApiConnections(companyId, filter);
      return res.status(200).json({
        success: true,
        data: connections
      });
    } catch (error) {
      this._logger.error("Error getting API connections", {
        error: error instanceof Error ? error.message : String(error)
      });
      return res.status(500).json({
        success: false,
        error: "Failed to get API connections"
      });
    }
  }
  /**
   * Get an API connection by ID
   */
  async getApiConnectionById(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          error: "Company ID is required"
        });
      }
      const connection = await this._apiConnectionService.getApiConnection(id, companyId);
      if (!connection) {
        return res.status(404).json({
          success: false,
          error: "API connection not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: connection
      });
    } catch (error) {
      this._logger.error("Error getting API connection", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to get API connection"
      });
    }
  }
  /**
   * Create a new API connection
   */
  async createApiConnection(req, res) {
    try {
      const validatedData = createConnectionSchema.parse(req.body);
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const connection = await this._apiConnectionService.createApiConnection({
        ...validatedData,
        companyId,
        createdBy: userId,
        updatedBy: userId
      });
      await AuditService.log({
        userId,
        companyId,
        action: "CREATE" /* CREATE */,
        entity: "bpm_api_connection",
        entityId: connection.id,
        details: {
          name: connection.name,
          type: connection.type
        }
      });
      return res.status(201).json({
        success: true,
        data: connection
      });
    } catch (error) {
      if (error instanceof z21.ZodError) {
        return res.status(400).json({
          success: false,
          error: "Validation error",
          details: error.errors
        });
      }
      this._logger.error("Error creating API connection", {
        error: error instanceof Error ? error.message : String(error)
      });
      return res.status(500).json({
        success: false,
        error: "Failed to create API connection"
      });
    }
  }
  /**
   * Update an API connection
   */
  async updateApiConnection(req, res) {
    try {
      const { id } = req.params;
      const validatedData = updateConnectionSchema.parse(req.body);
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const existingConnection = await this._apiConnectionService.getApiConnection(id, companyId);
      if (!existingConnection) {
        return res.status(404).json({
          success: false,
          error: "API connection not found"
        });
      }
      const connection = await this._apiConnectionService.updateApiConnection(id, companyId, {
        ...validatedData,
        updatedBy: userId
      });
      await AuditService.log({
        userId,
        companyId,
        action: "UPDATE" /* UPDATE */,
        entity: "bpm_api_connection",
        entityId: id,
        details: {
          changes: validatedData
        }
      });
      return res.status(200).json({
        success: true,
        data: connection
      });
    } catch (error) {
      if (error instanceof z21.ZodError) {
        return res.status(400).json({
          success: false,
          error: "Validation error",
          details: error.errors
        });
      }
      this._logger.error("Error updating API connection", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to update API connection"
      });
    }
  }
  /**
   * Delete an API connection
   */
  async deleteApiConnection(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const existingConnection = await this._apiConnectionService.getApiConnection(id, companyId);
      if (!existingConnection) {
        return res.status(404).json({
          success: false,
          error: "API connection not found"
        });
      }
      const success = await this._apiConnectionService.deleteApiConnection(id, companyId);
      await AuditService.log({
        userId,
        companyId,
        action: "DELETE" /* DELETE */,
        entity: "bpm_api_connection",
        entityId: id,
        details: {
          name: existingConnection.name,
          type: existingConnection.type
        }
      });
      return res.status(200).json({
        success: true,
        message: "API connection deleted successfully"
      });
    } catch (error) {
      this._logger.error("Error deleting API connection", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to delete API connection"
      });
    }
  }
  /**
   * Test an API connection
   */
  async testApiConnection(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const existingConnection = await this._apiConnectionService.getApiConnection(id, companyId);
      if (!existingConnection) {
        return res.status(404).json({
          success: false,
          error: "API connection not found"
        });
      }
      const testResult = await this._apiConnectionService.testApiConnection(id, companyId);
      await AuditService.log({
        userId,
        companyId,
        action: "BPM_PROCESS_ACTION",
        entity: "bpm_api_connection",
        entityId: id,
        details: {
          operation: "test_connection",
          success: testResult.success
        }
      });
      return res.status(200).json({
        success: true,
        data: testResult
      });
    } catch (error) {
      this._logger.error("Error testing API connection", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to test API connection"
      });
    }
  }
};

// server/modules/bpm/routes/api-connection.routes.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
var logger77 = new Logger("ApiConnectionRoutes");
function registerApiConnectionRoutes(app2, apiConnectionService) {
  const router14 = Router28();
  const apiConnectionController = new ApiConnectionController(apiConnectionService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/", (req, res) => apiConnectionController.getApiConnections(req, res));
  router14.get("/:id", (req, res) => apiConnectionController.getApiConnectionById(req, res));
  router14.post("/", (req, res) => apiConnectionController.createApiConnection(req, res));
  router14.patch("/:id", (req, res) => apiConnectionController.updateApiConnection(req, res));
  router14.delete("/:id", (req, res) => apiConnectionController.deleteApiConnection(req, res));
  router14.post("/:id/test", (req, res) => apiConnectionController.testApiConnection(req, res));
  app2.use("/api/bpm/connections", router14);
  logger77.info("Registered BPM API connection routes");
}

// server/modules/bpm/routes/scheduled-job.routes.ts
import { Router as Router29 } from "express";

// server/modules/bpm/controllers/scheduled-job.controller.ts
init_logger();
init_audit_service();
import { z as z22 } from "zod";
var createJobSchema = z22.object({
  name: z22.string().min(3).max(100),
  description: z22.string().optional().nullable(),
  schedule: z22.string().min(1),
  action: z22.string().uuid(),
  configuration: z22.record(z22.any()).optional(),
  isActive: z22.boolean().optional()
});
var updateJobSchema = z22.object({
  name: z22.string().min(3).max(100).optional(),
  description: z22.string().optional().nullable(),
  schedule: z22.string().min(1).optional(),
  action: z22.string().uuid().optional(),
  configuration: z22.record(z22.any()).optional(),
  isActive: z22.boolean().optional()
});
var ScheduledJobController = class {
  /**
   * Constructor
   */
  constructor(scheduledJobService) {
    this._logger = new Logger("ScheduledJobController");
    this._scheduledJobService = scheduledJobService;
  }
  /**
   * Get all scheduled jobs for a company
   */
  async getScheduledJobs(req, res) {
    try {
      const companyId = req.user?.companyId;
      const { processId, isActive, page, limit, search } = req.query;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          error: "Company ID is required"
        });
      }
      const filter = {
        processId,
        isActive: isActive === "true",
        page: page ? parseInt(page) : 1,
        limit: limit ? parseInt(limit) : 25,
        search
      };
      const jobs = await this._scheduledJobService.getScheduledJobs(companyId, filter);
      return res.status(200).json({
        success: true,
        data: jobs
      });
    } catch (error) {
      this._logger.error("Error getting scheduled jobs", {
        error: error instanceof Error ? error.message : String(error)
      });
      return res.status(500).json({
        success: false,
        error: "Failed to get scheduled jobs"
      });
    }
  }
  /**
   * Get a scheduled job by ID
   */
  async getScheduledJobById(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          error: "Company ID is required"
        });
      }
      const job = await this._scheduledJobService.getScheduledJob(id, companyId);
      if (!job) {
        return res.status(404).json({
          success: false,
          error: "Scheduled job not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: job
      });
    } catch (error) {
      this._logger.error("Error getting scheduled job", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to get scheduled job"
      });
    }
  }
  /**
   * Create a new scheduled job
   */
  async createScheduledJob(req, res) {
    try {
      const validatedData = createJobSchema.parse(req.body);
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const job = await this._scheduledJobService.createScheduledJob({
        name: validatedData.name,
        description: validatedData.description,
        schedule: validatedData.schedule,
        action: validatedData.action,
        configuration: validatedData.configuration || {},
        isActive: validatedData.isActive,
        companyId,
        createdBy: userId,
        updatedBy: userId
      });
      await AuditService.log({
        userId,
        companyId,
        action: "CREATE" /* CREATE */,
        entity: "bpm_scheduled_job",
        entityId: job.id,
        details: {
          name: job.name,
          action: job.action,
          schedule: job.schedule
        }
      });
      return res.status(201).json({
        success: true,
        data: job
      });
    } catch (error) {
      if (error instanceof z22.ZodError) {
        return res.status(400).json({
          success: false,
          error: "Validation error",
          details: error.errors
        });
      }
      this._logger.error("Error creating scheduled job", {
        error: error instanceof Error ? error.message : String(error)
      });
      return res.status(500).json({
        success: false,
        error: "Failed to create scheduled job"
      });
    }
  }
  /**
   * Update a scheduled job
   */
  async updateScheduledJob(req, res) {
    try {
      const { id } = req.params;
      const validatedData = updateJobSchema.parse(req.body);
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const existingJob = await this._scheduledJobService.getScheduledJob(id, companyId);
      if (!existingJob) {
        return res.status(404).json({
          success: false,
          error: "Scheduled job not found"
        });
      }
      const updateData = { updatedBy: userId };
      if (validatedData.name) updateData.name = validatedData.name;
      if (validatedData.description !== void 0) updateData.description = validatedData.description;
      if (validatedData.schedule) updateData.schedule = validatedData.schedule;
      if (validatedData.action) updateData.action = validatedData.action;
      if (validatedData.configuration) updateData.configuration = validatedData.configuration;
      if (validatedData.isActive !== void 0) updateData.isActive = validatedData.isActive;
      const job = await this._scheduledJobService.updateScheduledJob(id, companyId, updateData);
      await AuditService.log({
        userId,
        companyId,
        action: "UPDATE" /* UPDATE */,
        entity: "bpm_scheduled_job",
        entityId: id,
        details: {
          changes: validatedData
        }
      });
      return res.status(200).json({
        success: true,
        data: job
      });
    } catch (error) {
      if (error instanceof z22.ZodError) {
        return res.status(400).json({
          success: false,
          error: "Validation error",
          details: error.errors
        });
      }
      this._logger.error("Error updating scheduled job", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to update scheduled job"
      });
    }
  }
  /**
   * Delete a scheduled job
   */
  async deleteScheduledJob(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const existingJob = await this._scheduledJobService.getScheduledJob(id, companyId);
      if (!existingJob) {
        return res.status(404).json({
          success: false,
          error: "Scheduled job not found"
        });
      }
      const success = await this._scheduledJobService.deleteScheduledJob(id, companyId);
      await AuditService.log({
        userId,
        companyId,
        action: "DELETE" /* DELETE */,
        entity: "bpm_scheduled_job",
        entityId: id,
        details: {
          name: existingJob.name,
          action: existingJob.action
        }
      });
      return res.status(200).json({
        success: true,
        message: "Scheduled job deleted successfully"
      });
    } catch (error) {
      this._logger.error("Error deleting scheduled job", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to delete scheduled job"
      });
    }
  }
  /**
   * Toggle scheduled job active status
   */
  async toggleScheduledJobActive(req, res) {
    try {
      const { id } = req.params;
      const { active } = req.body;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      if (typeof active !== "boolean") {
        return res.status(400).json({
          success: false,
          error: "Active status must be a boolean"
        });
      }
      const job = await this._scheduledJobService.toggleScheduledJobActive(id, companyId, active, userId);
      if (!job) {
        return res.status(404).json({
          success: false,
          error: "Scheduled job not found"
        });
      }
      await AuditService.log({
        userId,
        companyId,
        action: "UPDATE" /* UPDATE */,
        entity: "bpm_scheduled_job",
        entityId: id,
        details: {
          operation: "toggle_active",
          active
        }
      });
      return res.status(200).json({
        success: true,
        data: job
      });
    } catch (error) {
      this._logger.error("Error toggling job status", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to toggle job status"
      });
    }
  }
  /**
   * Manually run a scheduled job immediately
   */
  async runScheduledJobManually(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          error: "User and company information are required"
        });
      }
      const result = await this._scheduledJobService.runScheduledJobManually(id, companyId, userId);
      if (!result.success) {
        return res.status(result.status || 500).json({
          success: false,
          error: result.error
        });
      }
      await AuditService.log({
        userId,
        companyId,
        action: "BPM_PROCESS_ACTION",
        entity: "bpm_scheduled_job",
        entityId: id,
        details: {
          operation: "run_manually",
          processInstanceId: result.processInstanceId
        }
      });
      return res.status(200).json({
        success: true,
        processInstanceId: result.processInstanceId
      });
    } catch (error) {
      this._logger.error("Error running job manually", {
        error: error instanceof Error ? error.message : String(error),
        id: req.params.id
      });
      return res.status(500).json({
        success: false,
        error: "Failed to run job manually"
      });
    }
  }
};

// server/modules/bpm/routes/scheduled-job.routes.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
var logger78 = new Logger("ScheduledJobRoutes");
function registerScheduledJobRoutes(app2, scheduledJobService) {
  const router14 = Router29();
  const scheduledJobController = new ScheduledJobController(scheduledJobService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/", (req, res) => scheduledJobController.getScheduledJobs(req, res));
  router14.get("/:id", (req, res) => scheduledJobController.getScheduledJobById(req, res));
  router14.post("/", (req, res) => scheduledJobController.createScheduledJob(req, res));
  router14.patch("/:id", (req, res) => scheduledJobController.updateScheduledJob(req, res));
  router14.delete("/:id", (req, res) => scheduledJobController.deleteScheduledJob(req, res));
  router14.patch("/:id/toggle", (req, res) => scheduledJobController.toggleScheduledJobActive(req, res));
  router14.post("/:id/run", (req, res) => scheduledJobController.runScheduledJobManually(req, res));
  app2.use("/api/bpm/jobs", router14);
  logger78.info("Registered BPM scheduled job routes");
}

// server/modules/bpm/routes/bpm.routes.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
import { Router as Router30 } from "express";

// server/modules/bpm/controllers/bpm.controller.ts
init_logger();
init_audit_service();
import { v4 as uuidv433 } from "uuid";
var BpmController = class {
  /**
   * Constructor
   */
  constructor() {
    this._logger = new Logger("BpmController");
    this._auditService = AuditService;
  }
  /**
   * Process placeholder endpoint for BPM functionality (GET)
   * Acts as a view operation for BPM processes
   */
  async getProcessPlaceholder(req, res) {
    try {
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "User and company information are required"
        });
      }
      try {
        await AuditService.log({
          companyId,
          userId,
          action: "BPM_PROCESS_VIEW",
          // Use string literal to avoid enum reference issues
          entity: "BPM_PROCESS",
          entityId: uuidv433(),
          details: {
            method: "GET",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        });
      } catch (auditError) {
        this._logger.error("Error in audit logging:", auditError instanceof Error ? auditError.message : String(auditError));
      }
      return res.status(200).json({
        success: true,
        message: "BPM process definition placeholder view",
        data: {
          processes: [
            { id: "1", name: "Approval Process", status: "active", steps: 5 },
            { id: "2", name: "Document Review", status: "active", steps: 3 },
            { id: "3", name: "Inventory Reconciliation", status: "inactive", steps: 7 }
          ],
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    } catch (error) {
      this._logger.error("Error in process-placeholder GET:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        message: "Failed to process BPM GET request",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Process placeholder endpoint for BPM functionality (POST)
   * This endpoint serves as a foundation for future business automation logic
   */
  async postProcessPlaceholder(req, res) {
    try {
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "User and company information are required"
        });
      }
      try {
        await AuditService.log({
          companyId,
          userId,
          action: "BPM_PROCESS_ACTION" /* BPM_PROCESS_ACTION */,
          entity: "BPM_PROCESS",
          // Use a proper UUID v4 for the entityId
          entityId: uuidv433(),
          details: {
            requestData: req.body,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        });
      } catch (auditError) {
        this._logger.error("Error in audit logging:", auditError instanceof Error ? auditError.message : String(auditError));
      }
      return res.status(200).json({
        success: true,
        message: "BPM process definition placeholder",
        data: {
          requestData: req.body,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    } catch (error) {
      this._logger.error("Error in process-placeholder POST:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        message: "Failed to process BPM request",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Process discovery endpoint
   * Provides information about available processes and capabilities
   */
  async discoverProcesses(req, res) {
    try {
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        return res.status(400).json({
          success: false,
          message: "User and company information are required"
        });
      }
      return res.status(200).json({
        success: true,
        message: "BPM process discovery information",
        data: {
          endpoints: [
            { path: "/api/bpm/processes", method: "GET", description: "List all processes" },
            { path: "/api/bpm/processes/:id", method: "GET", description: "Get process details" },
            { path: "/api/bpm/processes", method: "POST", description: "Create a process" },
            { path: "/api/bpm/processes/:id", method: "PATCH", description: "Update a process" },
            { path: "/api/bpm/processes/:id", method: "DELETE", description: "Delete a process" },
            { path: "/api/bpm/processes/:id/status", method: "PATCH", description: "Change process status" },
            { path: "/api/bpm/processes/templates/all", method: "GET", description: "Get all process templates" },
            { path: "/api/bpm/processes/templates/:templateId/create", method: "POST", description: "Create from template" },
            { path: "/api/bpm/executions/instance/:instanceId", method: "GET", description: "Get step executions" },
            { path: "/api/bpm/connections", method: "GET", description: "Get API connections" },
            { path: "/api/bpm/jobs", method: "GET", description: "Get scheduled jobs" }
          ],
          version: "1.0",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    } catch (error) {
      this._logger.error("Error in process discovery:", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        message: "Failed to get BPM discovery information",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
};

// server/modules/bpm/routes/bpm.routes.ts
var logger79 = new Logger("BpmRoutes");
function registerBpmRoutes(app2) {
  const router14 = Router30();
  const bpmController = new BpmController();
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/process-placeholder", (req, res) => bpmController.getProcessPlaceholder(req, res));
  router14.post("/process-placeholder", (req, res) => bpmController.postProcessPlaceholder(req, res));
  router14.get("/discover", (req, res) => bpmController.discoverProcesses(req, res));
  app2.use("/api/bpm", router14);
  logger79.info("Registered BPM general routes");
}

// server/modules/bpm/bpm.module.ts
var logger80 = new Logger("BpmModule");
var BpmModule = class _BpmModule {
  constructor() {
    this.initialized = false;
  }
  /**
   * Get singleton instance of BPM module
   */
  static getInstance() {
    if (!_BpmModule.instance) {
      _BpmModule.instance = new _BpmModule();
    }
    return _BpmModule.instance;
  }
  /**
   * Initialize the BPM module and its services
   */
  initialize(db4) {
    if (this.initialized) {
      logger80.warn("BPM module already initialized");
      return;
    }
    logger80.info("Initializing BPM module...");
    try {
      if (db4) {
        this.db = db4;
      }
      const services = initBpmServices(db4);
      this.processService = services.processService;
      this.triggerService = services.triggerService;
      this.processInstanceService = services.processInstanceService;
      this.stepExecutionService = services.stepExecutionService;
      this.apiConnectionService = services.apiConnectionService;
      this.scheduledJobService = services.scheduledJobService;
      this.initialized = true;
      logger80.info("BPM module initialized successfully");
    } catch (error) {
      logger80.error("Failed to initialize BPM module", { error });
      throw error;
    }
  }
  /**
   * Register all BPM routes with Express app
   */
  registerRoutes(app2) {
    if (!this.initialized) {
      throw new Error("BPM module must be initialized before registering routes");
    }
    logger80.info("Registering BPM routes...");
    registerBpmRoutes(app2);
    registerProcessRoutes(app2, this.processService, this.processInstanceService);
    registerTriggerRoutes(app2, this.triggerService);
    registerProcessInstanceRoutes(app2, this.processInstanceService);
    initStepTemplateRoutes(app2, this.db);
    registerStepExecutionRoutes(app2, this.stepExecutionService);
    registerApiConnectionRoutes(app2, this.apiConnectionService);
    registerScheduledJobRoutes(app2, this.scheduledJobService);
    logger80.info("BPM routes registered successfully");
  }
  /**
   * Start the BPM engine and scheduled tasks
   */
  start() {
    if (!this.initialized) {
      throw new Error("BPM module must be initialized before starting");
    }
    logger80.info("Starting BPM engine...");
    setInterval(() => {
      this.scheduledJobService.processDueJobs().then((result) => {
        if (result.processed > 0) {
          logger80.info(`Processed ${result.processed} scheduled jobs`, {
            processed: result.processed,
            succeeded: result.succeeded,
            failed: result.failed
          });
        }
      }).catch((error) => {
        logger80.error("Error processing scheduled jobs", { error });
      });
    }, 6e4);
    logger80.info("BPM engine started successfully");
  }
  /**
   * Stop the BPM engine and all running tasks
   */
  stop() {
    if (!this.initialized) {
      return;
    }
    logger80.info("Stopping BPM engine...");
    logger80.info("BPM engine stopped successfully");
  }
};

// server/modules/collab/collab.module.ts
init_logger();
import { Router as Router32 } from "express";

// server/modules/collab/init.ts
init_drizzle_service();
init_logger();

// server/modules/collab/services/task.service.ts
init_collaboration_schema();
init_logger();
import { eq as eq60, and as and49, desc as desc26, gte as gte6, lte as lte6, inArray as inArray3, sql as sql43 } from "drizzle-orm";
import { randomUUID as randomUUID10 } from "crypto";
var TaskService = class {
  /**
   * Constructor
   * 
   * @param drizzleService Drizzle service for database operations
   */
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    this._logger = new Logger("TaskService");
  }
  /**
   * Create a new task
   * 
   * @param task Task data
   * @param userId User ID creating the task
   * @returns Created task
   */
  async createTask(task, userId) {
    const taskId = task.id || randomUUID10();
    const now = /* @__PURE__ */ new Date();
    try {
      return await this.drizzleService.transaction(async (tx) => {
        const createdTask = await tx.insert(collaborationTasks).values({
          ...task,
          id: taskId,
          createdBy: userId,
          updatedBy: userId,
          createdAt: now,
          updatedAt: now
        }).returning();
        if (createdTask.length === 0) {
          throw new Error("Failed to create task");
        }
        await tx.insert(taskAssignmentHistory).values({
          id: randomUUID10(),
          taskId,
          companyId: task.companyId,
          assignedTo: task.assignedTo,
          assignedBy: userId,
          comments: "Initial task assignment",
          createdAt: now
        });
        await tx.insert(taskStatusHistory).values({
          id: randomUUID10(),
          taskId,
          companyId: task.companyId,
          status: task.status || "pending" /* PENDING */,
          changedBy: userId,
          comments: "Task created",
          createdAt: now
        });
        await tx.insert(taskWatchers).values({
          id: randomUUID10(),
          taskId,
          companyId: task.companyId,
          userId,
          notificationPreference: { enabled: true, mode: "all" },
          createdAt: now
        });
        return createdTask[0];
      });
    } catch (error) {
      this._logger.error(`Error creating task for company ${task.companyId}`, { error });
      throw error;
    }
  }
  /**
   * Get a task by ID
   * 
   * @param taskId Task ID
   * @param companyId Company ID
   * @returns Task or null if not found
   */
  async getTaskById(taskId, companyId) {
    try {
      this._logger.info(`Fetching task by ID ${taskId}${companyId ? ` for company ${companyId}` : ""}`);
      let whereCondition;
      if (companyId) {
        whereCondition = and49(
          eq60(collaborationTasks.id, taskId),
          eq60(collaborationTasks.companyId, companyId)
        );
      } else {
        whereCondition = eq60(collaborationTasks.id, taskId);
      }
      const tasks = await this.drizzleService.query(
        (db4) => db4.select().from(collaborationTasks).where(whereCondition)
      );
      return tasks.length > 0 ? tasks[0] : null;
    } catch (error) {
      this._logger.error(`Error fetching task by ID ${taskId}${companyId ? ` for company ${companyId}` : ""}`, { error });
      throw error;
    }
  }
  /**
   * Get all tasks for a company
   * 
   * @param companyId Company ID
   * @param options Query options (limit, offset, sort, filter)
   * @returns List of tasks
   */
  async getTasks(companyId, options = {}) {
    try {
      this._logger.info(`Fetching tasks for company ${companyId}`);
      const {
        limit = 20,
        offset = 0,
        status,
        assignedTo,
        priority,
        dueStart,
        dueEnd,
        sortBy = "createdAt",
        sortOrder = "desc"
      } = options;
      let conditions = [eq60(collaborationTasks.companyId, companyId)];
      if (status && status.length > 0) {
        conditions.push(inArray3(collaborationTasks.status, status));
      }
      if (assignedTo) {
        conditions.push(eq60(collaborationTasks.assignedTo, assignedTo));
      }
      if (priority && priority.length > 0) {
        const priorityEnums = priority.filter(
          (p) => Object.values(TaskPriority).includes(p)
        );
        if (priorityEnums.length > 0) {
          conditions.push(inArray3(collaborationTasks.priority, priorityEnums));
        }
      }
      if (dueStart) {
        conditions.push(gte6(collaborationTasks.dueDate, dueStart));
      }
      if (dueEnd) {
        conditions.push(lte6(collaborationTasks.dueDate, dueEnd));
      }
      const whereCondition = and49(...conditions);
      let orderBy;
      switch (sortBy) {
        case "title":
          orderBy = sortOrder === "asc" ? collaborationTasks.title : desc26(collaborationTasks.title);
          break;
        case "dueDate":
          orderBy = sortOrder === "asc" ? collaborationTasks.dueDate : desc26(collaborationTasks.dueDate);
          break;
        case "status":
          orderBy = sortOrder === "asc" ? collaborationTasks.status : desc26(collaborationTasks.status);
          break;
        case "priority":
          orderBy = sortOrder === "asc" ? collaborationTasks.priority : desc26(collaborationTasks.priority);
          break;
        case "updatedAt":
          orderBy = sortOrder === "asc" ? collaborationTasks.updatedAt : desc26(collaborationTasks.updatedAt);
          break;
        default:
          orderBy = sortOrder === "asc" ? collaborationTasks.createdAt : desc26(collaborationTasks.createdAt);
      }
      const tasksResult = await this.drizzleService.query(
        (db4) => db4.select().from(collaborationTasks).where(whereCondition).orderBy(orderBy).limit(limit).offset(offset)
      );
      const totalResult = await this.drizzleService.query(
        (db4) => db4.select({
          count: sql43`count(*)`
        }).from(collaborationTasks).where(whereCondition)
      );
      const total = Number(totalResult[0]?.count || 0);
      return { tasks: tasksResult, total };
    } catch (error) {
      this._logger.error(`Error fetching tasks for company ${companyId}`, { error });
      throw error;
    }
  }
  /**
   * Update a task
   * 
   * @param taskId Task ID
   * @param companyId Company ID
   * @param updates Task updates
   * @param userId User ID making the update
   * @returns Updated task
   */
  async updateTask(taskId, companyId, updates, userId) {
    try {
      return await this.drizzleService.transaction(async (tx) => {
        const currentTask = await this.getTaskById(taskId, companyId);
        if (!currentTask) {
          throw new Error(`Task not found: ${taskId}`);
        }
        if (updates.status && updates.status !== currentTask.status) {
          await tx.insert(taskStatusHistory).values({
            id: randomUUID10(),
            taskId,
            companyId,
            status: updates.status,
            previousStatus: currentTask.status,
            changedBy: userId,
            comments: updates.status === "completed" /* COMPLETED */ ? "Task completed" : `Status changed to ${updates.status}`,
            createdAt: /* @__PURE__ */ new Date()
          });
        }
        if (updates.assignedTo && updates.assignedTo !== currentTask.assignedTo) {
          await tx.insert(taskAssignmentHistory).values({
            id: randomUUID10(),
            taskId,
            companyId,
            assignedTo: updates.assignedTo,
            assignedBy: userId,
            assignedFrom: currentTask.assignedTo,
            createdAt: /* @__PURE__ */ new Date()
          });
        }
        const whereCondition = and49(
          eq60(collaborationTasks.id, taskId),
          eq60(collaborationTasks.companyId, companyId)
        );
        const updatedTasks = await tx.update(collaborationTasks).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date(),
          updatedBy: userId
        }).where(whereCondition).returning();
        if (updatedTasks.length === 0) {
          throw new Error(`Failed to update task: ${taskId}`);
        }
        return updatedTasks[0];
      });
    } catch (error) {
      this._logger.error(`Error updating task ${taskId} for company ${companyId}`, { error });
      throw error;
    }
  }
  /**
   * Delete a task
   * 
   * @param taskId Task ID
   * @param companyId Company ID
   * @returns True if deleted
   */
  async deleteTask(taskId, companyId) {
    try {
      return await this.drizzleService.transaction(async (tx) => {
        const taskHistoryCondition = and49(
          eq60(taskAssignmentHistory.taskId, taskId),
          eq60(taskAssignmentHistory.companyId, companyId)
        );
        const statusHistoryCondition = and49(
          eq60(taskStatusHistory.taskId, taskId),
          eq60(taskStatusHistory.companyId, companyId)
        );
        const watchersCondition = and49(
          eq60(taskWatchers.taskId, taskId),
          eq60(taskWatchers.companyId, companyId)
        );
        await Promise.all([
          tx.delete(taskAssignmentHistory).where(taskHistoryCondition),
          tx.delete(taskStatusHistory).where(statusHistoryCondition),
          tx.delete(taskWatchers).where(watchersCondition)
        ]);
        const taskCondition = and49(
          eq60(collaborationTasks.id, taskId),
          eq60(collaborationTasks.companyId, companyId)
        );
        const result = await tx.delete(collaborationTasks).where(taskCondition).returning();
        return result.length > 0;
      });
    } catch (error) {
      this._logger.error(`Error deleting task ${taskId} for company ${companyId}`, { error });
      throw error;
    }
  }
  /**
   * Get task assignment history
   * 
   * @param taskId Task ID
   * @param companyId Company ID
   * @returns Assignment history entries
   */
  async getTaskAssignmentHistory(taskId, companyId) {
    try {
      const whereCondition = and49(
        eq60(taskAssignmentHistory.taskId, taskId),
        eq60(taskAssignmentHistory.companyId, companyId)
      );
      return await this.drizzleService.query(
        (db4) => db4.select().from(taskAssignmentHistory).where(whereCondition).orderBy(desc26(taskAssignmentHistory.createdAt))
      );
    } catch (error) {
      this._logger.error(`Error fetching task assignment history for task ${taskId} in company ${companyId}`, { error });
      throw error;
    }
  }
  /**
   * Get task status history
   * 
   * @param taskId Task ID
   * @param companyId Company ID
   * @returns Status history entries
   */
  async getTaskStatusHistory(taskId, companyId) {
    try {
      const whereCondition = and49(
        eq60(taskStatusHistory.taskId, taskId),
        eq60(taskStatusHistory.companyId, companyId)
      );
      return await this.drizzleService.query(
        (db4) => db4.select().from(taskStatusHistory).where(whereCondition).orderBy(desc26(taskStatusHistory.createdAt))
      );
    } catch (error) {
      this._logger.error(`Error fetching task status history for task ${taskId} in company ${companyId}`, { error });
      throw error;
    }
  }
  /**
   * Assign a task to a user
   * 
   * @param taskId Task ID
   * @param companyId Company ID
   * @param assigneeId User ID being assigned the task
   * @param assignerId User ID making the assignment
   * @returns Updated task
   */
  async assignTask(taskId, companyId, assigneeId, assignerId) {
    try {
      const task = await this.getTaskById(taskId, companyId);
      if (!task) {
        throw new Error(`Task not found: ${taskId}`);
      }
      return await this.drizzleService.transaction(async (tx) => {
        await tx.insert(taskAssignmentHistory).values({
          id: randomUUID10(),
          taskId,
          companyId,
          assignedTo: assigneeId,
          assignedBy: assignerId,
          assignedFrom: task.assignedTo,
          createdAt: /* @__PURE__ */ new Date()
        });
        const whereCondition = and49(
          eq60(collaborationTasks.id, taskId),
          eq60(collaborationTasks.companyId, companyId)
        );
        const updatedTasks = await tx.update(collaborationTasks).set({
          assignedTo: assigneeId,
          updatedAt: /* @__PURE__ */ new Date(),
          updatedBy: assignerId
        }).where(whereCondition).returning();
        if (updatedTasks.length === 0) {
          throw new Error(`Failed to update task assignment: ${taskId}`);
        }
        return updatedTasks[0];
      });
    } catch (error) {
      this._logger.error(`Error assigning task ${taskId} to user ${assigneeId}`, { error });
      throw error;
    }
  }
  /**
   * Update task status
   * 
   * @param taskId Task ID
   * @param companyId Company ID
   * @param status New status
   * @param userId User ID making the change
   * @returns Updated task
   */
  async updateTaskStatus(taskId, companyId, status, userId) {
    try {
      const task = await this.getTaskById(taskId, companyId);
      if (!task) {
        throw new Error(`Task not found: ${taskId}`);
      }
      return await this.drizzleService.transaction(async (tx) => {
        if (task.status === status) {
          return task;
        }
        await tx.insert(taskStatusHistory).values({
          id: randomUUID10(),
          taskId,
          companyId,
          status,
          previousStatus: task.status,
          changedBy: userId,
          comments: status === "completed" /* COMPLETED */ ? "Task completed" : `Status changed to ${status}`,
          createdAt: /* @__PURE__ */ new Date()
        });
        const whereCondition = and49(
          eq60(collaborationTasks.id, taskId),
          eq60(collaborationTasks.companyId, companyId)
        );
        const updatedTasks = await tx.update(collaborationTasks).set({
          status,
          updatedAt: /* @__PURE__ */ new Date(),
          updatedBy: userId,
          // Set completedAt if status is COMPLETED
          ...status === "completed" /* COMPLETED */ ? { completedAt: /* @__PURE__ */ new Date(), completedBy: userId } : {}
        }).where(whereCondition).returning();
        if (updatedTasks.length === 0) {
          throw new Error(`Failed to update task status: ${taskId}`);
        }
        return updatedTasks[0];
      });
    } catch (error) {
      this._logger.error(`Error updating task ${taskId} status to ${status}`, { error });
      throw error;
    }
  }
};

// server/modules/collab/services/note.service.ts
init_collaboration_schema();
init_logger();
import { eq as eq61, desc as desc27, sql as sql44 } from "drizzle-orm";
import { randomUUID as randomUUID11 } from "crypto";
var NoteService = class {
  /**
   * Constructor
   * 
   * @param drizzleService Drizzle service for database operations
   */
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    this._logger = new Logger("NoteService");
  }
  /**
   * Create a new note for a task
   * 
   * @param note Note data
   * @param userId User ID creating the note
   * @returns Created note
   */
  async createNote(note, userId) {
    try {
      const noteId = note.id || randomUUID11();
      const now = /* @__PURE__ */ new Date();
      return await this.drizzleService.transaction(async (tx) => {
        const createdNotes = await tx.insert(collaborationNotes).values({
          ...note,
          id: noteId,
          userId,
          createdAt: now,
          updatedAt: now
        }).returning();
        if (createdNotes.length === 0) {
          throw new Error("Failed to create note");
        }
        return createdNotes[0];
      });
    } catch (error) {
      this._logger.error("Failed to create note", { error, companyId: note.companyId });
      throw error;
    }
  }
  /**
   * Get a note by ID
   * 
   * @param noteId Note ID
   * @param companyId Company ID
   * @returns Note or null if not found
   */
  async getNoteById(noteId, companyId) {
    try {
      const db4 = this.drizzleService.db;
      const notes = await db4.select().from(collaborationNotes).where(eq61(collaborationNotes.id, noteId)).where(eq61(collaborationNotes.companyId, companyId));
      return notes.length > 0 ? notes[0] : null;
    } catch (error) {
      this._logger.error("Failed to fetch note by ID", { error, noteId, companyId });
      throw error;
    }
  }
  /**
   * Get all notes for a company with pagination
   * 
   * @param companyId Company ID
   * @param options Query options (limit, offset, sort)
   * @returns List of notes and total count
   */
  async getAllNotesByCompany(companyId, options = {}) {
    try {
      const db4 = this.drizzleService.db;
      const {
        limit = 50,
        offset = 0,
        sortOrder = "desc",
        // Default to newest first
        isPinned
      } = options;
      let notesResult;
      let totalResult;
      let queryBuilder = db4.select().from(collaborationNotes).where(eq61(collaborationNotes.companyId, companyId));
      let countQuery = db4.select({ count: sql44`count(*)` }).from(collaborationNotes).where(eq61(collaborationNotes.companyId, companyId));
      if (isPinned !== void 0) {
        queryBuilder = queryBuilder.where(eq61(collaborationNotes.isPinned, isPinned));
        countQuery = countQuery.where(eq61(collaborationNotes.isPinned, isPinned));
      }
      if (sortOrder === "asc") {
        queryBuilder = queryBuilder.orderBy(collaborationNotes.createdAt);
      } else {
        queryBuilder = queryBuilder.orderBy(desc27(collaborationNotes.createdAt));
      }
      queryBuilder = queryBuilder.limit(limit).offset(offset);
      notesResult = await queryBuilder;
      totalResult = await countQuery;
      const total = Number(totalResult[0]?.count || 0);
      return {
        notes: notesResult,
        total
      };
    } catch (error) {
      this._logger.error("Failed to fetch notes for company", { error, companyId });
      throw error;
    }
  }
  /**
   * Get all notes for a task
   * 
   * @param taskId Task ID
   * @param companyId Company ID
   * @returns List of notes
   */
  async getNotesByTaskId(taskId, companyId) {
    try {
      const db4 = this.drizzleService.db;
      return await db4.select().from(collaborationNotes).where(eq61(collaborationNotes.taskId, taskId)).where(eq61(collaborationNotes.companyId, companyId)).orderBy(desc27(collaborationNotes.createdAt));
    } catch (error) {
      this._logger.error("Failed to fetch notes for task", { error, taskId, companyId });
      throw error;
    }
  }
  /**
   * Update a note
   * 
   * @param noteId Note ID
   * @param companyId Company ID
   * @param updates Note updates
   * @param userId User ID making the update
   * @returns Updated note
   */
  async updateNote(noteId, companyId, updates, userId) {
    try {
      const db4 = this.drizzleService.db;
      const updatedNotes = await db4.update(collaborationNotes).set({
        ...updates,
        updatedAt: /* @__PURE__ */ new Date(),
        editedBy: userId
      }).where(eq61(collaborationNotes.id, noteId)).where(eq61(collaborationNotes.companyId, companyId)).returning();
      if (updatedNotes.length === 0) {
        throw new Error(`Note not found: ${noteId}`);
      }
      return updatedNotes[0];
    } catch (error) {
      this._logger.error("Failed to update note", { error, noteId, companyId });
      throw error;
    }
  }
  /**
   * Delete a note
   * 
   * @param noteId Note ID
   * @param companyId Company ID
   * @returns True if deleted
   */
  async deleteNote(noteId, companyId) {
    try {
      const db4 = this.drizzleService.db;
      const result = await db4.delete(collaborationNotes).where(eq61(collaborationNotes.id, noteId)).where(eq61(collaborationNotes.companyId, companyId)).returning();
      return result.length > 0;
    } catch (error) {
      this._logger.error("Failed to delete note", { error, noteId, companyId });
      throw error;
    }
  }
};

// server/modules/collab/services/community.service.ts
init_logger();
init_collaboration_schema();
import { eq as eq63, and as and51, sql as sql46, desc as desc29, asc as asc13, like as like11 } from "drizzle-orm";

// server/modules/collab/services/thread.service.ts
init_collaboration_schema();
init_logger();
import { eq as eq62, and as and50, desc as desc28, sql as sql45 } from "drizzle-orm";
import { randomUUID as randomUUID12 } from "crypto";
var logger81 = new Logger("ThreadService");
var ThreadService = class {
  /**
   * Constructor
   * 
   * @param db Drizzle database instance
   */
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Create a new discussion thread
   * 
   * @param thread Thread data
   * @param userId User ID creating the thread
   * @returns Created thread
   */
  async createThread(thread, userId) {
    try {
      const threadId = thread.id || randomUUID12();
      const now = /* @__PURE__ */ new Date();
      const createdThreads = await this.db.insert(collaborationThreads).values({
        ...thread,
        id: threadId,
        createdBy: userId,
        updatedBy: userId,
        createdAt: now,
        updatedAt: now,
        lastMessageAt: now
      }).returning();
      if (createdThreads.length === 0) {
        throw new Error("Failed to create thread");
      }
      return createdThreads[0];
    } catch (error) {
      logger81.error(`Error creating thread: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Get a thread by ID
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @returns Thread or null if not found
   */
  async getThreadById(threadId, companyId) {
    try {
      const whereCondition = and50(
        eq62(collaborationThreads.id, threadId),
        eq62(collaborationThreads.companyId, companyId)
      );
      const threads = await this.db.select().from(collaborationThreads).where(whereCondition);
      return threads.length > 0 ? threads[0] : null;
    } catch (error) {
      logger81.error(`Error fetching thread by ID ${threadId} for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Get all threads for a company
   * 
   * @param companyId Company ID
   * @param options Query options (limit, offset, sort, filter)
   * @returns List of threads
   */
  async getThreads(companyId, options = {}) {
    try {
      const {
        limit = 20,
        offset = 0,
        category,
        search,
        createdBy,
        isPrivate,
        isClosed,
        sortBy = "lastMessageAt",
        sortOrder = "desc"
      } = options;
      let conditions = [eq62(collaborationThreads.companyId, companyId)];
      if (category) {
        conditions.push(eq62(collaborationThreads.category, category));
      }
      if (createdBy) {
        conditions.push(eq62(collaborationThreads.createdBy, createdBy));
      }
      if (isPrivate !== void 0) {
        conditions.push(eq62(collaborationThreads.isPrivate, isPrivate));
      }
      if (isClosed !== void 0) {
        conditions.push(eq62(collaborationThreads.isClosed, isClosed));
      }
      if (search) {
        conditions.push(
          sql45`(${collaborationThreads.title} ILIKE ${`%${search}%`} OR ${collaborationThreads.description} ILIKE ${`%${search}%`})`
        );
      }
      const whereCondition = and50(...conditions);
      let threadsResult;
      if (sortBy === "lastMessageAt") {
        threadsResult = sortOrder === "asc" ? await this.db.select().from(collaborationThreads).where(whereCondition).orderBy(collaborationThreads.lastMessageAt).limit(limit).offset(offset) : await this.db.select().from(collaborationThreads).where(whereCondition).orderBy(desc28(collaborationThreads.lastMessageAt)).limit(limit).offset(offset);
      } else if (sortBy === "createdAt") {
        threadsResult = sortOrder === "asc" ? await this.db.select().from(collaborationThreads).where(whereCondition).orderBy(collaborationThreads.createdAt).limit(limit).offset(offset) : await this.db.select().from(collaborationThreads).where(whereCondition).orderBy(desc28(collaborationThreads.createdAt)).limit(limit).offset(offset);
      } else if (sortBy === "title") {
        threadsResult = sortOrder === "asc" ? await this.db.select().from(collaborationThreads).where(whereCondition).orderBy(collaborationThreads.title).limit(limit).offset(offset) : await this.db.select().from(collaborationThreads).where(whereCondition).orderBy(desc28(collaborationThreads.title)).limit(limit).offset(offset);
      } else {
        threadsResult = sortOrder === "asc" ? await this.db.select().from(collaborationThreads).where(whereCondition).orderBy(collaborationThreads.lastMessageAt).limit(limit).offset(offset) : await this.db.select().from(collaborationThreads).where(whereCondition).orderBy(desc28(collaborationThreads.lastMessageAt)).limit(limit).offset(offset);
      }
      const totalResult = await this.db.select({
        count: sql45`count(*)`
      }).from(collaborationThreads).where(whereCondition);
      const total = Number(totalResult[0]?.count || 0);
      return { threads: threadsResult, total };
    } catch (error) {
      logger81.error(`Error fetching threads for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Update a thread
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @param updates Thread updates
   * @param userId User ID making the update
   * @returns Updated thread
   */
  async updateThread(threadId, companyId, updates, userId) {
    try {
      const updatedThreads = await this.db.update(collaborationThreads).set({
        ...updates,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and50(
        eq62(collaborationThreads.id, threadId),
        eq62(collaborationThreads.companyId, companyId)
      )).returning();
      if (updatedThreads.length === 0) {
        throw new Error(`Thread not found: ${threadId}`);
      }
      return updatedThreads[0];
    } catch (error) {
      logger81.error(`Error updating thread ${threadId} for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Delete a thread
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @returns True if deleted
   */
  async deleteThread(threadId, companyId) {
    try {
      const result = await this.db.delete(collaborationThreads).where(and50(
        eq62(collaborationThreads.id, threadId),
        eq62(collaborationThreads.companyId, companyId)
      )).returning();
      return result.length > 0;
    } catch (error) {
      logger81.error(`Error deleting thread ${threadId} for company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Update thread's last message timestamp
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @returns Updated thread
   */
  async updateLastMessageTimestamp(threadId, companyId) {
    try {
      await this.db.update(collaborationThreads).set({
        lastMessageAt: /* @__PURE__ */ new Date()
      }).where(and50(
        eq62(collaborationThreads.id, threadId),
        eq62(collaborationThreads.companyId, companyId)
      ));
    } catch (error) {
      logger81.error(`Error updating last message timestamp for thread ${threadId} in company ${companyId}: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
};

// server/modules/collab/services/community.service.ts
var logger82 = new Logger("CommunityService");
var CommunityCategory2 = /* @__PURE__ */ ((CommunityCategory3) => {
  CommunityCategory3["ANUNTURI"] = "ANUNTURI";
  CommunityCategory3["INTREBARI"] = "INTREBARI";
  CommunityCategory3["IDEI"] = "IDEI";
  CommunityCategory3["EVENIMENTE"] = "EVENIMENTE";
  CommunityCategory3["RESURSE"] = "RESURSE";
  CommunityCategory3["TUTORIALE"] = "TUTORIALE";
  return CommunityCategory3;
})(CommunityCategory2 || {});
var CommunityService = class {
  /**
   * Create an instance of CommunityService
   * 
   * @param db Database connection
   * @param threadService Thread service (optional)
   */
  constructor(drizzleService5, threadService) {
    this.drizzleService = drizzleService5;
    this.threadService = threadService || new ThreadService(drizzleService5.db);
    logger82.info("Community service initialized");
  }
  /**
   * Get community threads with optional filtering
   * 
   * @param companyId Company ID
   * @param options Filter options
   * @returns Threads that match the filter criteria
   */
  async getCommunityThreads(companyId, options) {
    try {
      logger82.info(`Getting community threads for company ${companyId} with options: ${JSON.stringify(options)}`);
      const limit = options?.limit || 20;
      const offset = options?.offset || 0;
      const category = options?.category;
      const search = options?.search;
      const sort = options?.sort || "newest";
      const conditions = [
        eq63(collaborationThreads.companyId, companyId),
        category ? eq63(collaborationThreads.category, category) : sql46`1=1`,
        search ? like11(collaborationThreads.title, `%${search}%`) : sql46`1=1`
      ];
      const countResult = await this.drizzleService.query(
        (db4) => db4.select({ count: sql46`count(*)`.mapWith(Number) }).from(collaborationThreads).where(and51(...conditions))
      );
      const total = countResult[0]?.count || 0;
      const results = await this.drizzleService.query((db4) => {
        let query = db4.select({
          thread: collaborationThreads,
          replyCount: sql46`count(${collaborationMessages.id})`.mapWith(Number)
        }).from(collaborationThreads).leftJoin(
          collaborationMessages,
          eq63(collaborationThreads.id, collaborationMessages.threadId)
        ).where(and51(...conditions)).groupBy(collaborationThreads.id);
        if (sort === "newest") {
          query = query.orderBy(desc29(collaborationThreads.createdAt));
        } else if (sort === "oldest") {
          query = query.orderBy(asc13(collaborationThreads.createdAt));
        } else if (sort === "popular") {
          query = query.orderBy(desc29(sql46`count(${collaborationMessages.id})`));
        }
        query = query.limit(limit).offset(offset);
        return query;
      });
      const threads = results.map((result) => ({
        ...result.thread,
        replyCount: result.replyCount
      }));
      return {
        threads,
        total,
        limit,
        offset
      };
    } catch (error) {
      logger82.error(`Error getting community threads: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Create a new community thread
   * 
   * @param threadData Thread data
   * @returns Created thread
   */
  async createCommunityThread(threadData) {
    try {
      logger82.info(`Creating community thread for company ${threadData.companyId} in category ${threadData.category}`);
      return this.threadService.createThread(threadData);
    } catch (error) {
      logger82.error(`Error creating community thread: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Get a community thread by ID
   * 
   * @param threadId Thread ID
   * @param companyId Company ID (for security)
   * @returns Thread if found
   */
  async getCommunityThreadById(threadId, companyId) {
    try {
      logger82.info(`Getting community thread ${threadId} for company ${companyId}`);
      const thread = await this.threadService.getThreadById(threadId);
      if (!thread || thread.companyId !== companyId) {
        return null;
      }
      return thread;
    } catch (error) {
      logger82.error(`Error getting community thread: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Update a community thread
   * 
   * @param threadId Thread ID
   * @param threadData Updated thread data
   * @param companyId Company ID (for security)
   * @returns Updated thread if successful
   */
  async updateCommunityThread(threadId, threadData, companyId) {
    try {
      logger82.info(`Updating community thread ${threadId} for company ${companyId}`);
      const thread = await this.getCommunityThreadById(threadId, companyId);
      if (!thread) {
        return null;
      }
      return this.threadService.updateThread(threadId, threadData);
    } catch (error) {
      logger82.error(`Error updating community thread: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Delete a community thread
   * 
   * @param threadId Thread ID
   * @param companyId Company ID (for security)
   * @returns True if deletion was successful
   */
  async deleteCommunityThread(threadId, companyId) {
    try {
      logger82.info(`Deleting community thread ${threadId} for company ${companyId}`);
      const thread = await this.getCommunityThreadById(threadId, companyId);
      if (!thread) {
        return false;
      }
      return this.threadService.deleteThread(threadId);
    } catch (error) {
      logger82.error(`Error deleting community thread: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
};

// server/modules/collab/services/activity.service.ts
init_logger();
init_collaboration_schema();
import { eq as eq64, and as and52, desc as desc30, sql as sql47, count as count3 } from "drizzle-orm";
var ActivityService2 = class {
  /**
   * Constructor
   * 
   * @param drizzleService Drizzle ORM service
   */
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    this._logger = new Logger("ActivityService");
  }
  /**
   * Get recent activity for a company
   * 
   * @param companyId Company ID
   * @param options Query options
   * @returns Activity items
   */
  async getCompanyActivity(companyId, options = {}) {
    try {
      this._logger.debug("Getting company activity", { companyId, options });
      const { limit = 10, offset = 0, userId, includeTypes } = options;
      let whereConditions = and52(
        eq64(collaborationActivities.companyId, companyId)
      );
      if (userId) {
        whereConditions = and52(
          whereConditions,
          eq64(collaborationActivities.userId, userId)
        );
      }
      if (includeTypes && includeTypes.length > 0) {
        whereConditions = and52(
          whereConditions,
          sql47`${collaborationActivities.type} IN (${sql47.join(includeTypes.map((t) => sql47`${t}`), sql47`, `)})`
        );
      }
      this._logger.debug(`Executing activity query with conditions for company: ${companyId}`);
      const activityItems = await this.drizzleService.query(
        (db4) => db4.select().from(collaborationActivities).where(whereConditions).orderBy(desc30(collaborationActivities.createdAt)).limit(limit).offset(offset)
      );
      this._logger.debug(`Activity query results: ${activityItems?.length || 0} items found`);
      const mappedItems = (activityItems || []).map((item) => {
        let itemData = {};
        try {
          if (item.data) {
            itemData = typeof item.data === "string" ? JSON.parse(item.data) : item.data;
          }
        } catch (e) {
          this._logger.error("Error parsing activity data JSON", { error: e, itemId: item.id });
        }
        let activityType;
        switch (item.objectType) {
          case "TASK":
            activityType = "task";
            break;
          case "NOTE":
            activityType = "note";
            break;
          case "THREAD":
            activityType = "thread";
            break;
          case "MESSAGE":
            activityType = "message";
            break;
          default:
            activityType = "task";
        }
        let action;
        switch (item.type) {
          case "TASK_CREATED":
            action = "created";
            break;
          case "TASK_COMPLETED":
            action = "completed";
            break;
          case "TASK_ASSIGNED":
            action = "assigned";
            break;
          case "NOTE_CREATED":
            action = "created";
            break;
          case "NOTE_UPDATED":
            action = "updated";
            break;
          case "THREAD_CREATED":
            action = "started";
            break;
          case "MESSAGE_SENT":
            action = "sent";
            break;
          default:
            action = "updated";
        }
        return {
          id: item.id,
          type: activityType,
          action,
          title: item.title || "Untitled activity",
          description: itemData?.description || "",
          userId: item.userId,
          userName: itemData?.userName || "Unknown User",
          userAvatar: itemData?.userAvatar || void 0,
          targetId: item.objectId,
          createdAt: item.createdAt.toISOString(),
          metadata: itemData
        };
      });
      this._logger.debug(`Activity mapped results: ${mappedItems.length} items mapped`);
      return {
        status: 200,
        items: mappedItems
      };
    } catch (error) {
      this._logger.error("Error getting company activity", { error, companyId });
      return {
        status: 500,
        error: "Error retrieving activity stream",
        message: error instanceof Error ? error.message : "Unknown error",
        items: []
      };
    }
  }
  /**
   * Record task activity
   * 
   * @param task Task data
   * @param type Activity type
   * @param userId User ID
   * @param companyId Company ID
   */
  async recordTaskActivity(task, type, userId, companyId) {
    try {
      await this.drizzleService.query(
        (db4) => db4.insert(collaborationActivities).values({
          type,
          userId,
          companyId,
          objectId: task.id,
          objectType: "TASK",
          title: task.title,
          data: JSON.stringify(task)
        })
      );
      return true;
    } catch (error) {
      this._logger.error("Error recording task activity", { error, type, taskId: task.id });
      return false;
    }
  }
  /**
   * Record note activity
   * 
   * @param note Note data
   * @param type Activity type
   * @param userId User ID
   * @param companyId Company ID
   */
  async recordNoteActivity(note, type, userId, companyId) {
    try {
      await this.drizzleService.query(
        (db4) => db4.insert(collaborationActivities).values({
          type,
          userId,
          companyId,
          objectId: note.id,
          objectType: "NOTE",
          title: note.title || "Untitled Note",
          data: JSON.stringify(note)
        })
      );
      return true;
    } catch (error) {
      this._logger.error("Error recording note activity", { error, type, noteId: note.id });
      return false;
    }
  }
  /**
   * Record thread activity
   * 
   * @param thread Thread data
   * @param type Activity type
   * @param userId User ID
   * @param companyId Company ID
   */
  async recordThreadActivity(thread, type, userId, companyId) {
    try {
      await this.drizzleService.query(
        (db4) => db4.insert(collaborationActivities).values({
          type,
          userId,
          companyId,
          objectId: thread.id,
          objectType: "THREAD",
          title: thread.title || "Untitled Thread",
          data: JSON.stringify(thread)
        })
      );
      return true;
    } catch (error) {
      this._logger.error("Error recording thread activity", { error, type, threadId: thread.id });
      return false;
    }
  }
  /**
   * Record message activity
   * 
   * @param message Message data
   * @param type Activity type
   * @param userId User ID
   * @param companyId Company ID
   */
  async recordMessageActivity(message, type, userId, companyId) {
    try {
      await this.drizzleService.query(
        (db4) => db4.insert(collaborationActivities).values({
          type,
          userId,
          companyId,
          objectId: message.id,
          objectType: "MESSAGE",
          title: message.content?.substring(0, 50) || "New Message",
          data: JSON.stringify(message)
        })
      );
      return true;
    } catch (error) {
      this._logger.error("Error recording message activity", { error, type, messageId: message.id });
      return false;
    }
  }
  /**
   * Count activities for a company
   * 
   * @param companyId Company ID
   * @returns Count of activities
   */
  async countActivities(companyId) {
    try {
      const result = await this.drizzleService.query(
        (db4) => db4.select({ count: count3() }).from(collaborationActivities).where(eq64(collaborationActivities.companyId, companyId))
      );
      return {
        count: result[0]?.count || 0,
        companyId
      };
    } catch (error) {
      this._logger.error("Error counting activities", { error, companyId });
      return {
        error: "Failed to count activities",
        count: 0,
        companyId
      };
    }
  }
};

// server/modules/collab/services/notification.service.ts
init_logger();
init_collaboration_schema();
import { eq as eq65, and as and53, desc as desc31, or as or16, sql as sql48 } from "drizzle-orm";
var NotificationService2 = class {
  /**
   * Constructor
   * 
   * @param drizzleService Drizzle ORM service
   */
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    this._logger = new Logger("NotificationService");
  }
  /**
   * Get notifications for a user
   * 
   * @param userId User ID
   * @param companyId Company ID
   * @param options Query options
   * @returns List of notifications
   */
  async getNotifications(userId, companyId, options = {}) {
    try {
      const { limit = 20, offset = 0, status, onlyUnread = false } = options;
      let whereConditions = and53(
        eq65(collaborationNotifications.userId, userId),
        eq65(collaborationNotifications.companyId, companyId)
      );
      if (status) {
        if (Array.isArray(status)) {
          const statusConditions = status.map((s) => eq65(collaborationNotifications.status, s));
          whereConditions = and53(whereConditions, or16(...statusConditions));
        } else {
          whereConditions = and53(whereConditions, eq65(collaborationNotifications.status, status));
        }
      } else if (onlyUnread) {
        whereConditions = and53(whereConditions, eq65(collaborationNotifications.status, "UNREAD" /* UNREAD */));
      }
      const userNotifications = await this.drizzleService.query(
        (db4) => db4.select().from(collaborationNotifications).where(whereConditions).orderBy(desc31(collaborationNotifications.createdAt)).limit(limit).offset(offset)
      );
      const unreadCount = await this.drizzleService.query(
        (db4) => db4.select({ count: sql48`count(*)` }).from(collaborationNotifications).where(
          and53(
            eq65(collaborationNotifications.userId, userId),
            eq65(collaborationNotifications.companyId, companyId),
            eq65(collaborationNotifications.status, "UNREAD" /* UNREAD */)
          )
        )
      );
      const mappedNotifications = (userNotifications || []).map((notification) => {
        let metadata = {};
        try {
          if (notification.metadata) {
            metadata = typeof notification.metadata === "string" ? JSON.parse(notification.metadata) : notification.metadata;
          }
        } catch (e) {
          this._logger.error("Error parsing notification metadata", {
            error: e,
            notificationId: notification.id
          });
        }
        const isRead = notification.status !== "UNREAD" /* UNREAD */;
        let frontendType = "task_assigned";
        switch (notification.type) {
          case "TASK_ASSIGNED":
            frontendType = "task_assigned";
            break;
          case "TASK_COMPLETED":
            frontendType = "task_completed";
            break;
          case "MENTION":
            frontendType = "mention";
            break;
          case "THREAD_REPLY":
            frontendType = "thread_reply";
            break;
          case "NOTE_CREATED":
            frontendType = "note_created";
            break;
          case "TASK_DUE_SOON":
            frontendType = "task_due_soon";
            break;
          case "TASK_OVERDUE":
            frontendType = "task_overdue";
            break;
          default:
            frontendType = notification.type?.toLowerCase() || "task_assigned";
        }
        let targetType = notification.sourceType?.toLowerCase() || "task";
        const senderId = metadata.senderId || null;
        const senderName = metadata.senderName || "Unknown User";
        const senderAvatar = metadata.senderAvatar || null;
        return {
          id: notification.id,
          userId: notification.userId,
          type: frontendType,
          title: notification.title,
          message: notification.message,
          isRead,
          targetType,
          targetId: notification.sourceId || "",
          metadata: {
            ...metadata,
            // Add sender info if available
            sender: senderId,
            senderName,
            senderAvatar
          },
          createdAt: notification.createdAt.toISOString()
        };
      });
      return {
        status: 200,
        unreadCount: unreadCount[0]?.count || 0,
        items: mappedNotifications
      };
    } catch (error) {
      this._logger.error("Error getting notifications", { error, userId, companyId });
      return {
        status: 500,
        error: "Error retrieving notifications",
        message: error instanceof Error ? error.message : "Unknown error",
        unreadCount: 0,
        items: []
      };
    }
  }
  /**
   * Mark a notification as read
   * 
   * @param id Notification ID
   * @param userId User ID
   * @returns Success status
   */
  async markAsRead(id, userId) {
    try {
      await this.drizzleService.query(
        (db4) => db4.update(collaborationNotifications).set({ status: "READ" /* READ */, updatedAt: /* @__PURE__ */ new Date() }).where(
          and53(
            eq65(collaborationNotifications.id, id),
            eq65(collaborationNotifications.userId, userId)
          )
        )
      );
      return { status: 200, success: true };
    } catch (error) {
      this._logger.error("Error marking notification as read", { error, id, userId });
      return {
        status: 500,
        success: false,
        error: "Failed to update notification",
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Create a new notification
   * 
   * @param data Notification data
   * @returns Created notification
   */
  async createNotification(data) {
    try {
      const result = await this.drizzleService.query(
        (db4) => db4.insert(collaborationNotifications).values({
          ...data,
          status: "UNREAD" /* UNREAD */
        }).returning()
      );
      return { status: 201, notification: result[0] };
    } catch (error) {
      this._logger.error("Error creating notification", { error, data });
      return {
        status: 500,
        error: "Failed to create notification",
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Create a notification for a watched task update
   * 
   * @param watchedTask Watched task data
   * @param updaterUserId User ID who updated the task
   * @returns Success status
   */
  async createWatchedTaskNotification(wt, updaterUserId) {
    try {
      if (wt.userId === updaterUserId) {
        return { status: 200, skipped: true };
      }
      await this.createNotification({
        userId: wt.userId,
        companyId: wt.companyId,
        type: "TASK_UPDATED",
        title: "Task Updated",
        message: `A task you're watching has been updated: ${wt.taskTitle}`,
        sourceType: "TASK",
        sourceId: wt.taskId,
        actionType: "VIEW_TASK",
        actionTarget: wt.taskId
      });
      return { status: 201, success: true };
    } catch (error) {
      this._logger.error("Error creating watched task notification", {
        error,
        taskId: wt.taskId,
        userId: wt.userId
      });
      return {
        status: 500,
        success: false,
        error: "Failed to create notification",
        message: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
};

// server/modules/collab/init.ts
var logger83 = new Logger("CollabServicesInit");
function initCollabServices(db4) {
  logger83.info("Initializing Collaboration Module Services");
  let drizzleService5;
  if (!db4) {
    logger83.debug("Creating new DrizzleService instance");
    drizzleService5 = new DrizzleService();
  } else if (db4 instanceof DrizzleService) {
    logger83.debug("Using provided DrizzleService instance");
    drizzleService5 = db4;
  } else {
    logger83.debug("Creating DrizzleService with provided database connection");
    drizzleService5 = new DrizzleService();
  }
  try {
    logger83.debug("Initializing Task Service");
    const taskService = new TaskService(drizzleService5);
    logger83.debug("Initializing Note Service");
    const noteService = new NoteService(drizzleService5);
    logger83.debug("Initializing Activity Service");
    const activityService = new ActivityService2(drizzleService5);
    logger83.debug("Initializing Notification Service");
    const notificationService2 = new NotificationService2(drizzleService5);
    logger83.debug("Getting thread, message, and watcher services from CollabDrizzleService");
    const collabServices = drizzleService5.collab.getServices();
    const threadService = collabServices.threadService;
    const messageService = collabServices.messageService;
    const watcherService = collabServices.watcherService;
    logger83.debug("Initializing Community Service");
    const communityService = new CommunityService(drizzleService5, threadService);
    logger83.info("All Collaboration Module Services initialized successfully");
    return {
      taskService,
      noteService,
      threadService,
      messageService,
      watcherService,
      communityService,
      activityService,
      notificationService: notificationService2
    };
  } catch (error) {
    logger83.error("Failed to initialize Collaboration Module Services", error);
    throw error;
  }
}

// server/modules/collab/controllers/task.controller.ts
init_logger();
init_collaboration_schema();
function createTaskController(taskService) {
  const controller = new TaskController(taskService);
  return {
    registerRoutes: (router14) => {
      console.warn("Legacy task controller routes registration called, but routes are registered directly");
    }
  };
}
var TaskController = class {
  constructor(taskService) {
    this.taskService = taskService;
    this._logger = new Logger("TaskController");
  }
  /**
   * Get all tasks for a company with filtering and pagination
   * Alias for listTasks to match route name convention
   */
  async getAllTasks(req, res) {
    return this.listTasks(req, res);
  }
  /**
   * Get all tasks for a company with filtering and pagination
   */
  async listTasks(req, res) {
    try {
      let companyId = req.headers["x-company-id"];
      if (!companyId) {
        companyId = req.user?.companyId;
      }
      this._logger.info(`[DEBUG] Task list request - companyId: ${companyId}, from header: ${req.headers["x-company-id"]}, from user: ${req.user?.companyId}`);
      if (!companyId) {
        this._logger.error("[DEBUG] Company ID not found in request");
        res.status(401).json({ error: "Company ID not found" });
        return;
      }
      const {
        page = "1",
        limit = "20",
        status,
        assignedTo,
        priority,
        dueStart,
        dueEnd,
        sortBy,
        sortOrder,
        recent
      } = req.query;
      const options = {
        offset: (parseInt(page, 10) - 1) * parseInt(limit, 10),
        limit: parseInt(limit, 10)
      };
      if (status) {
        options.status = Array.isArray(status) ? status : [status];
      }
      if (assignedTo) {
        options.assignedTo = assignedTo;
      }
      if (priority) {
        options.priority = Array.isArray(priority) ? priority : [priority];
      }
      if (dueStart) {
        options.dueStart = new Date(dueStart);
      }
      if (dueEnd) {
        options.dueEnd = new Date(dueEnd);
      }
      if (sortBy) {
        options.sortBy = sortBy;
      }
      if (sortOrder) {
        options.sortOrder = sortOrder;
      }
      this._logger.info(`[DEBUG] Fetching tasks with options: ${JSON.stringify(options)} for company: ${companyId}`);
      const result = await this.taskService.getTasks(companyId, options);
      this._logger.info(`[DEBUG] Tasks found: ${result.tasks.length}, total: ${result.total}`);
      res.json({
        tasks: result.tasks,
        pagination: {
          total: result.total,
          page: parseInt(page, 10),
          limit: parseInt(limit, 10),
          pages: Math.ceil(result.total / parseInt(limit, 10))
        }
      });
    } catch (error) {
      this._logger.error("Failed to get tasks", { error });
      res.status(500).json({ error: "Failed to get tasks" });
    }
  }
  /**
   * Get a task by ID
   */
  async getTaskById(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        res.status(401).json({ error: "Company ID not found" });
        return;
      }
      const task = await this.taskService.getTaskById(id, companyId);
      if (!task) {
        res.status(404).json({ error: "Task not found" });
        return;
      }
      res.json(task);
    } catch (error) {
      this._logger.error("Failed to get task by ID", { error });
      res.status(500).json({ error: "Failed to get task by ID" });
    }
  }
  /**
   * Create a new task
   */
  async createTask(req, res) {
    try {
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        res.status(401).json({ error: "User ID or company ID not found" });
        return;
      }
      const taskData = req.body;
      taskData.companyId = companyId;
      const task = await this.taskService.createTask(taskData, userId);
      res.status(201).json(task);
    } catch (error) {
      this._logger.error("Failed to create task", { error });
      res.status(500).json({ error: "Failed to create task" });
    }
  }
  /**
   * Update a task
   */
  async updateTask(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        res.status(401).json({ error: "User ID or company ID not found" });
        return;
      }
      const updates = req.body;
      delete updates.id;
      delete updates.companyId;
      delete updates.createdAt;
      delete updates.createdBy;
      const updatedTask = await this.taskService.updateTask(id, companyId, updates, userId);
      res.json(updatedTask);
    } catch (error) {
      this._logger.error("Failed to update task", { error });
      if (error instanceof Error && error.message.includes("not found")) {
        res.status(404).json({ error: error.message });
      } else {
        res.status(500).json({ error: "Failed to update task" });
      }
    }
  }
  /**
   * Delete a task
   */
  async deleteTask(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        res.status(401).json({ error: "Company ID not found" });
        return;
      }
      const success = await this.taskService.deleteTask(id, companyId);
      if (!success) {
        res.status(404).json({ error: "Task not found or already deleted" });
        return;
      }
      res.status(204).end();
    } catch (error) {
      this._logger.error("Failed to delete task", { error });
      res.status(500).json({ error: "Failed to delete task" });
    }
  }
  /**
   * Get task assignment history
   */
  async getTaskAssignmentHistory(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        res.status(401).json({ error: "Company ID not found" });
        return;
      }
      const task = await this.taskService.getTaskById(id, companyId);
      if (!task) {
        res.status(404).json({ error: "Task not found" });
        return;
      }
      const history = await this.taskService.getTaskAssignmentHistory(id, companyId);
      res.json(history);
    } catch (error) {
      this._logger.error("Failed to get task assignment history", { error });
      res.status(500).json({ error: "Failed to get task assignment history" });
    }
  }
  /**
   * Get task status history
   */
  async getTaskStatusHistory(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        res.status(401).json({ error: "Company ID not found" });
        return;
      }
      const task = await this.taskService.getTaskById(id, companyId);
      if (!task) {
        res.status(404).json({ error: "Task not found" });
        return;
      }
      const history = await this.taskService.getTaskStatusHistory(id, companyId);
      res.json(history);
    } catch (error) {
      this._logger.error("Failed to get task status history", { error });
      res.status(500).json({ error: "Failed to get task status history" });
    }
  }
  /**
   * Assign a task to a user
   */
  async assignTask(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      const assignerId = req.user?.id;
      if (!companyId || !assignerId) {
        res.status(401).json({ error: "User ID or company ID not found" });
        return;
      }
      const { userId: assigneeId } = req.body;
      if (!assigneeId) {
        res.status(400).json({ error: "Missing assignee user ID" });
        return;
      }
      const task = await this.taskService.getTaskById(id, companyId);
      if (!task) {
        res.status(404).json({ error: "Task not found" });
        return;
      }
      const updatedTask = await this.taskService.assignTask(id, companyId, assigneeId, assignerId);
      res.json(updatedTask);
    } catch (error) {
      this._logger.error("Failed to assign task", { error });
      res.status(500).json({ error: "Failed to assign task" });
    }
  }
  /**
   * Update task status
   */
  async updateTaskStatus(req, res) {
    try {
      const { id } = req.params;
      const companyId = req.user?.companyId;
      const userId = req.user?.id;
      if (!companyId || !userId) {
        res.status(401).json({ error: "User ID or company ID not found" });
        return;
      }
      const { status } = req.body;
      if (!status || !Object.values(TaskStatus).includes(status)) {
        res.status(400).json({
          error: "Invalid status",
          allowedValues: Object.values(TaskStatus)
        });
        return;
      }
      const task = await this.taskService.getTaskById(id, companyId);
      if (!task) {
        res.status(404).json({ error: "Task not found" });
        return;
      }
      const updatedTask = await this.taskService.updateTaskStatus(
        id,
        companyId,
        status,
        userId
      );
      res.json(updatedTask);
    } catch (error) {
      this._logger.error("Failed to update task status", { error });
      res.status(500).json({ error: "Failed to update task status" });
    }
  }
};

// server/modules/collab/controllers/note.controller.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
init_collaboration_schema();
import { z as z23 } from "zod";
var logger84 = new Logger("CollabNoteController");
var NoteController = class {
  constructor(noteService) {
    this.noteService = noteService;
  }
  /**
   * Register routes for the Note controller
   * 
   * @param router Express router
   */
  registerRoutes(router14) {
    router14.get("/", AuthGuard.protect("required" /* REQUIRED */), this.getAllNotes.bind(this));
    router14.get("/task/:taskId", AuthGuard.protect("required" /* REQUIRED */), this.getNotesByTask.bind(this));
    router14.get("/:id", AuthGuard.protect("required" /* REQUIRED */), this.getNoteById.bind(this));
    router14.post("/", AuthGuard.protect("required" /* REQUIRED */), this.createNote.bind(this));
    router14.patch("/:id", AuthGuard.protect("required" /* REQUIRED */), this.updateNote.bind(this));
    router14.delete("/:id", AuthGuard.protect("required" /* REQUIRED */), this.deleteNote.bind(this));
  }
  /**
   * Get all notes for a company
   */
  async getAllNotes(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const companyId = req.user.companyId;
      const limit = req.query.limit ? parseInt(req.query.limit, 10) : 50;
      const offset = req.query.offset ? parseInt(req.query.offset, 10) : 0;
      const sortOrder = req.query.sortOrder === "asc" ? "asc" : "desc";
      const isPinned = req.query.isPinned ? req.query.isPinned === "true" : void 0;
      const result = await this.noteService.getAllNotesByCompany(companyId, {
        limit,
        offset,
        sortOrder,
        isPinned
      });
      res.status(200).json(result);
    } catch (error) {
      logger84.error(`Error in GET /notes - CompanyId: ${req.user?.companyId}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Get notes for a specific task
   */
  async getNotesByTask(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { taskId } = req.params;
      const companyId = req.user.companyId;
      const notes = await this.noteService.getNotesByTaskId(taskId, companyId);
      res.status(200).json(notes);
    } catch (error) {
      logger84.error(`Error in GET /notes/task/:taskId - TaskId: ${req.params.taskId}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Get a note by ID
   */
  async getNoteById(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id } = req.params;
      const companyId = req.user.companyId;
      const note = await this.noteService.getNoteById(id, companyId);
      if (!note) {
        res.status(404).json({ message: "Note not found" });
        return;
      }
      res.status(200).json(note);
    } catch (error) {
      logger84.error(`Error in GET /notes/:id - NoteId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Create a new note
   */
  async createNote(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const userId = req.user.id;
      const companyId = req.user.companyId;
      const noteSchema = insertCollaborationNoteSchema.extend({
        companyId: z23.string().uuid(),
        createdBy: z23.string().uuid()
      });
      const validatedData = noteSchema.parse({
        ...req.body,
        companyId,
        createdBy: userId
      });
      const note = await this.noteService.createNote(validatedData, userId);
      res.status(201).json(note);
    } catch (error) {
      if (error instanceof z23.ZodError) {
        res.status(400).json({ message: "Invalid note data", errors: error.format() });
        return;
      }
      logger84.error("Error in POST /notes", error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Update a note
   */
  async updateNote(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id } = req.params;
      const userId = req.user.id;
      const companyId = req.user.companyId;
      const updateNoteSchema = insertCollaborationNoteSchema.partial();
      const validatedData = updateNoteSchema.parse(req.body);
      const note = await this.noteService.updateNote(id, companyId, validatedData, userId);
      if (!note) {
        res.status(404).json({ message: "Note not found or you are not authorized to edit it" });
        return;
      }
      res.status(200).json(note);
    } catch (error) {
      if (error instanceof z23.ZodError) {
        res.status(400).json({ message: "Invalid note data", errors: error.format() });
        return;
      }
      logger84.error(`Error in PATCH /notes/:id - NoteId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Delete a note
   */
  async deleteNote(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id } = req.params;
      const userId = req.user.id;
      const companyId = req.user.companyId;
      const success = await this.noteService.deleteNote(id, companyId);
      if (!success) {
        res.status(404).json({ message: "Note not found or you are not authorized to delete it" });
        return;
      }
      res.status(204).send();
    } catch (error) {
      logger84.error(`Error in DELETE /notes/:id - NoteId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
};

// server/modules/collab/controllers/thread.controller.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
init_collaboration_schema();
import { z as z24 } from "zod";
var logger85 = new Logger("CollabThreadController");
var ThreadController = class {
  constructor(threadService) {
    this.threadService = threadService;
  }
  /**
   * Register routes for the Thread controller
   * 
   * @param router Express router
   */
  registerRoutes(router14) {
    router14.get("/", AuthGuard.protect("required" /* REQUIRED */), this.getAllThreads.bind(this));
    router14.get("/task/:taskId", AuthGuard.protect("required" /* REQUIRED */), this.getThreadsByTask.bind(this));
    router14.get("/:id", AuthGuard.protect("required" /* REQUIRED */), this.getThreadById.bind(this));
    router14.post("/", AuthGuard.protect("required" /* REQUIRED */), this.createThread.bind(this));
    router14.patch("/:id", AuthGuard.protect("required" /* REQUIRED */), this.updateThread.bind(this));
    router14.delete("/:id", AuthGuard.protect("required" /* REQUIRED */), this.deleteThread.bind(this));
  }
  /**
   * Get all threads for a company
   */
  async getAllThreads(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const companyId = req.user.companyId;
      const limit = req.query.limit ? parseInt(req.query.limit, 10) : 20;
      const offset = req.query.offset ? parseInt(req.query.offset, 10) : 0;
      const { threads } = await this.threadService.getThreads(companyId, { limit, offset });
      res.status(200).json(threads);
    } catch (error) {
      logger85.error(`Error in GET /threads - CompanyId: ${req.user?.companyId}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Get threads for a specific task
   */
  async getThreadsByTask(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { taskId } = req.params;
      const companyId = req.user.companyId;
      const limit = req.query.limit ? parseInt(req.query.limit, 10) : 20;
      const offset = req.query.offset ? parseInt(req.query.offset, 10) : 0;
      res.status(501).json({
        message: "Getting threads by task ID is not implemented in the current API version"
      });
      return;
    } catch (error) {
      logger85.error(`Error in GET /threads/task/:taskId - TaskId: ${req.params.taskId}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Get a thread by ID
   */
  async getThreadById(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id } = req.params;
      const companyId = req.user.companyId;
      const thread = await this.threadService.getThreadById(id, companyId);
      if (!thread) {
        res.status(404).json({ message: "Thread not found" });
        return;
      }
      res.status(200).json(thread);
    } catch (error) {
      logger85.error(`Error in GET /threads/:id - ThreadId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Create a new thread
   */
  async createThread(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const userId = req.user.id;
      const companyId = req.user.companyId;
      const threadSchema = insertCollaborationThreadSchema.extend({
        companyId: z24.string().uuid(),
        createdBy: z24.string().uuid()
      });
      const validatedData = threadSchema.parse({
        ...req.body,
        companyId,
        createdBy: userId
      });
      const thread = await this.threadService.createThread(validatedData, userId);
      res.status(201).json(thread);
    } catch (error) {
      if (error instanceof z24.ZodError) {
        res.status(400).json({ message: "Invalid thread data", errors: error.format() });
        return;
      }
      logger85.error("Error in POST /threads", error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Update a thread
   */
  async updateThread(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id } = req.params;
      const userId = req.user.id;
      const companyId = req.user.companyId;
      const updateThreadSchema = insertCollaborationThreadSchema.partial();
      const validatedData = updateThreadSchema.parse(req.body);
      const thread = await this.threadService.updateThread(id, companyId, validatedData, userId);
      if (!thread) {
        res.status(404).json({ message: "Thread not found or you are not authorized to edit it" });
        return;
      }
      res.status(200).json(thread);
    } catch (error) {
      if (error instanceof z24.ZodError) {
        res.status(400).json({ message: "Invalid thread data", errors: error.format() });
        return;
      }
      logger85.error(`Error in PATCH /threads/:id - ThreadId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Delete a thread
   */
  async deleteThread(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id } = req.params;
      const userId = req.user.id;
      const companyId = req.user.companyId;
      const success = await this.threadService.deleteThread(id, companyId);
      if (!success) {
        res.status(404).json({ message: "Thread not found or you are not authorized to delete it" });
        return;
      }
      res.status(204).send();
    } catch (error) {
      logger85.error(`Error in DELETE /threads/:id - ThreadId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
};

// server/modules/collab/controllers/message.controller.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
init_collaboration_schema();
import { z as z25 } from "zod";
var logger86 = new Logger("CollabMessageController");
var MessageController = class {
  constructor(messageService) {
    this.messageService = messageService;
  }
  /**
   * Register routes for the Message controller
   * 
   * @param router Express router
   */
  registerRoutes(router14) {
    router14.get("/thread/:threadId", AuthGuard.protect("required" /* REQUIRED */), this.getMessagesByThread.bind(this));
    router14.get("/:id", AuthGuard.protect("required" /* REQUIRED */), this.getMessageById.bind(this));
    router14.post("/", AuthGuard.protect("required" /* REQUIRED */), this.createMessage.bind(this));
    router14.patch("/:id", AuthGuard.protect("required" /* REQUIRED */), this.updateMessage.bind(this));
    router14.delete("/:id", AuthGuard.protect("required" /* REQUIRED */), this.deleteMessage.bind(this));
  }
  /**
   * Get messages for a specific thread
   */
  async getMessagesByThread(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { threadId } = req.params;
      const companyId = req.user.companyId;
      const limit = req.query.limit ? parseInt(req.query.limit, 10) : 20;
      const offset = req.query.offset ? parseInt(req.query.offset, 10) : 0;
      const messages2 = await this.messageService.getMessagesByThreadId(threadId, companyId, { limit, offset });
      res.status(200).json(messages2);
    } catch (error) {
      logger86.error(`Error in GET /messages/thread/:threadId - ThreadId: ${req.params.threadId}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Get a message by ID
   */
  async getMessageById(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id } = req.params;
      const companyId = req.user.companyId;
      const message = await this.messageService.getMessageById(id, companyId);
      if (!message) {
        res.status(404).json({ message: "Message not found" });
        return;
      }
      res.status(200).json(message);
    } catch (error) {
      logger86.error(`Error in GET /messages/:id - MessageId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Create a new message
   */
  async createMessage(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const userId = req.user.id;
      const companyId = req.user.companyId;
      const messageSchema = insertCollaborationMessageSchema.extend({
        companyId: z25.string().uuid(),
        createdBy: z25.string().uuid()
      });
      const validatedData = messageSchema.parse({
        ...req.body,
        companyId,
        createdBy: userId
      });
      const message = await this.messageService.createMessage(validatedData, userId);
      res.status(201).json(message);
    } catch (error) {
      if (error instanceof z25.ZodError) {
        res.status(400).json({ message: "Invalid message data", errors: error.format() });
        return;
      }
      logger86.error("Error in POST /messages", error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Update a message
   */
  async updateMessage(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id } = req.params;
      const userId = req.user.id;
      const companyId = req.user.companyId;
      const updateMessageSchema = insertCollaborationMessageSchema.partial();
      const validatedData = updateMessageSchema.parse(req.body);
      const message = await this.messageService.updateMessage(id, companyId, validatedData, userId);
      if (!message) {
        res.status(404).json({ message: "Message not found or you are not authorized to edit it" });
        return;
      }
      res.status(200).json(message);
    } catch (error) {
      if (error instanceof z25.ZodError) {
        res.status(400).json({ message: "Invalid message data", errors: error.format() });
        return;
      }
      logger86.error(`Error in PATCH /messages/:id - MessageId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Delete a message
   */
  async deleteMessage(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id } = req.params;
      const userId = req.user.id;
      const companyId = req.user.companyId;
      const success = await this.messageService.deleteMessage(id, companyId);
      if (!success) {
        res.status(404).json({ message: "Message not found or you are not authorized to delete it" });
        return;
      }
      res.status(204).send();
    } catch (error) {
      logger86.error(`Error in DELETE /messages/:id - MessageId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
};

// server/modules/collab/controllers/watcher.controller.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
init_collaboration_schema();
import { z as z26 } from "zod";
var logger87 = new Logger("CollabWatcherController");
var WatcherController = class {
  constructor(watcherService) {
    this.watcherService = watcherService;
  }
  /**
   * Register routes for the Watcher controller
   * 
   * @param router Express router
   */
  registerRoutes(router14) {
    router14.get("/task/:taskId", AuthGuard.protect("required" /* REQUIRED */), this.getWatchersByTask.bind(this));
    router14.post("/", AuthGuard.protect("required" /* REQUIRED */), this.addWatcher.bind(this));
    router14.delete("/:id", AuthGuard.protect("required" /* REQUIRED */), this.removeWatcher.bind(this));
  }
  /**
   * Get watchers for a task
   */
  async getWatchersByTask(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { taskId } = req.params;
      const companyId = req.user.companyId;
      const watchers = await this.watcherService.getWatchersByTaskId(taskId, companyId);
      res.status(200).json(watchers);
    } catch (error) {
      logger87.error(`Error in GET /watchers/task/:taskId - TaskId: ${req.params.taskId}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Add a watcher to a task
   */
  async addWatcher(req, res) {
    try {
      if (!req.user || !req.user.id || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const createdBy = req.user.id;
      const companyId = req.user.companyId;
      const watcherSchema = insertTaskWatcherSchema.extend({
        companyId: z26.string().uuid(),
        createdBy: z26.string().uuid()
      });
      const validatedData = watcherSchema.parse({
        ...req.body,
        companyId,
        createdBy
      });
      const watcher = await this.watcherService.addWatcher(
        validatedData.taskId,
        validatedData.companyId,
        validatedData.userId || req.user.id,
        validatedData.notificationPreference || { enabled: true }
      );
      res.status(201).json(watcher);
    } catch (error) {
      if (error instanceof z26.ZodError) {
        res.status(400).json({ message: "Invalid watcher data", errors: error.format() });
        return;
      }
      logger87.error("Error in POST /watchers", error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Remove a watcher from a task
   */
  async removeWatcher(req, res) {
    try {
      if (!req.user || !req.user.companyId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const { id: taskId } = req.params;
      const companyId = req.user.companyId;
      const userId = req.user.id;
      const success = await this.watcherService.removeWatcher(taskId, companyId, userId);
      if (!success) {
        res.status(404).json({ message: "Watcher not found" });
        return;
      }
      res.status(204).send();
    } catch (error) {
      logger87.error(`Error in DELETE /watchers/:id - TaskId: ${req.params.id}`, error);
      res.status(500).json({ message: "Internal server error" });
    }
  }
};

// server/modules/collab/controllers/community.controller.ts
import { z as z27 } from "zod";
init_logger();
init_collaboration_schema();
init_auth_guard();
init_auth_mode_enum();
var logger88 = new Logger("CommunityController");
var getCommunityThreadsQuerySchema = z27.object({
  category: z27.nativeEnum(CommunityCategory2).optional(),
  search: z27.string().optional(),
  limit: z27.coerce.number().min(1).max(100).optional().default(20),
  offset: z27.coerce.number().min(0).optional().default(0),
  sort: z27.enum(["newest", "oldest", "popular"]).optional().default("newest")
});
var createCommunityThreadSchema = insertCollaborationThreadSchema.extend({
  category: z27.nativeEnum(CommunityCategory2).optional()
});
var CommunityController = class {
  /**
   * Create a new community controller
   * 
   * @param communityService Community service instance
   */
  constructor(communityService) {
    this.communityService = communityService;
    logger88.info("Community controller initialized");
  }
  /**
   * Register all community routes on a router
   * 
   * @param router Express router
   */
  registerRoutes(router14) {
    logger88.info("Registering community controller routes");
    router14.get(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getCommunityThreads.bind(this)
    );
    router14.get(
      "/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      this.getCommunityThreadById.bind(this)
    );
    router14.post(
      "/threads",
      AuthGuard.protect("required" /* REQUIRED */),
      this.createCommunityThread.bind(this)
    );
    router14.patch(
      "/threads/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      this.updateCommunityThread.bind(this)
    );
    router14.delete(
      "/threads/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      this.deleteCommunityThread.bind(this)
    );
    logger88.info("Community controller routes registered");
  }
  /**
   * Get community threads with optional filtering
   */
  async getCommunityThreads(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const validationResult = getCommunityThreadsQuerySchema.safeParse(req.query);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid query parameters",
          errors: validationResult.error.errors
        });
      }
      const options = validationResult.data;
      const result = await this.communityService.getCommunityThreads(companyId, options);
      return res.status(200).json({
        threads: result.threads,
        pagination: {
          total: result.total,
          limit: result.limit,
          offset: result.offset
        }
      });
    } catch (error) {
      logger88.error(`Error in getCommunityThreads: ${error instanceof Error ? error.message : String(error)}`);
      return res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Get a specific community thread by ID
   */
  async getCommunityThreadById(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      const threadId = req.params.id;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!threadId) {
        return res.status(400).json({ message: "Thread ID is required" });
      }
      const thread = await this.communityService.getCommunityThreadById(threadId, companyId);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }
      return res.status(200).json({ thread });
    } catch (error) {
      logger88.error(`Error in getCommunityThreadById: ${error instanceof Error ? error.message : String(error)}`);
      return res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Create a new community thread
   */
  async createCommunityThread(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const validationResult = createCommunityThreadSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid thread data",
          errors: validationResult.error.errors
        });
      }
      const threadData = validationResult.data;
      threadData.companyId = companyId;
      threadData.createdBy = userId;
      const thread = await this.communityService.createCommunityThread(threadData);
      return res.status(201).json({ thread });
    } catch (error) {
      logger88.error(`Error in createCommunityThread: ${error instanceof Error ? error.message : String(error)}`);
      return res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Update a community thread
   */
  async updateCommunityThread(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      const threadId = req.params.id;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!threadId) {
        return res.status(400).json({ message: "Thread ID is required" });
      }
      const validationSchema = createCommunityThreadSchema.partial();
      const validationResult = validationSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid thread data",
          errors: validationResult.error.errors
        });
      }
      const threadData = validationResult.data;
      threadData.updatedBy = userId;
      const thread = await this.communityService.updateCommunityThread(threadId, threadData, companyId);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }
      return res.status(200).json({ thread });
    } catch (error) {
      logger88.error(`Error in updateCommunityThread: ${error instanceof Error ? error.message : String(error)}`);
      return res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Delete a community thread
   */
  async deleteCommunityThread(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      const threadId = req.params.id;
      if (!userId || !companyId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!threadId) {
        return res.status(400).json({ message: "Thread ID is required" });
      }
      const success = await this.communityService.deleteCommunityThread(threadId, companyId);
      if (!success) {
        return res.status(404).json({ message: "Thread not found" });
      }
      return res.status(204).send();
    } catch (error) {
      logger88.error(`Error in deleteCommunityThread: ${error instanceof Error ? error.message : String(error)}`);
      return res.status(500).json({ message: "Internal server error" });
    }
  }
};

// server/modules/collab/controllers/activity.controller.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
var ActivityController2 = class {
  /**
   * Constructor
   * 
   * @param activityService Activity service
   */
  constructor(activityService) {
    this.activityService = activityService;
    this._logger = new Logger("ActivityController");
  }
  /**
   * Register routes with the router
   * 
   * @param router Express router
   */
  registerRoutes(router14) {
    this._logger.info("Registering activity controller routes");
    router14.get("/", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        this._logger.info("GET /api/collaboration/activity endpoint hit", {
          user: req.user?.id,
          companyId: req.user?.companyId,
          query: req.query,
          headers: req.headers["x-company-id"]
        });
        const companyId = req.user?.companyId || req.header("X-Company-ID");
        if (!companyId) {
          this._logger.warn("Activity request missing company ID", { user: req.user?.id });
          return res.status(401).json({
            error: "Unauthorized - Company ID missing",
            status: 401,
            items: []
          });
        }
        const limit = req.query.limit ? parseInt(req.query.limit) : 10;
        const userId = req.query.userId ? String(req.query.userId) : void 0;
        const includeTypes = req.query.types ? String(req.query.types).split(",") : void 0;
        this._logger.debug("Fetching activity for company", {
          companyId,
          limit,
          userId,
          includeTypes
        });
        const activity = await this.activityService.getCompanyActivity(companyId, {
          limit,
          userId,
          includeTypes
          // Type assertion to avoid type issues
        });
        const responseData = activity && "items" in activity ? activity.items : [];
        this._logger.debug("Activity response", {
          status: activity?.status || 200,
          itemCount: responseData?.length || 0,
          firstItem: responseData?.[0]?.id || "none"
        });
        return res.status(200).json(responseData);
      } catch (error) {
        this._logger.error("Error fetching activity", { error });
        return res.status(500).json({
          error: "Internal server error",
          message: error instanceof Error ? error.message : "Unknown error",
          status: 500,
          items: []
        });
      }
    });
    router14.get("/debug", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        this._logger.info("Debug endpoint hit for activity controller");
        const companyId = req.user?.companyId || req.header("X-Company-ID");
        if (!companyId) {
          return res.status(401).json({ message: "Unauthorized - Company ID missing" });
        }
        const rawQueryResults = await this.activityService.countActivities(companyId);
        return res.status(200).json({
          message: "Activity debug info",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          rawQueryResults,
          companyId
        });
      } catch (error) {
        this._logger.error("Error in debug endpoint", { error });
        return res.status(500).json({
          error: "Internal server error",
          message: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
  }
};

// server/modules/collab/controllers/notification.controller.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
var NotificationController = class {
  /**
   * Constructor
   * 
   * @param notificationService Notification service
   */
  constructor(notificationService2) {
    this.notificationService = notificationService2;
    this._logger = new Logger("NotificationController");
  }
  /**
   * Register routes with the router
   * 
   * @param router Express router
   */
  registerRoutes(router14) {
    this._logger.info("Registering notification controller routes");
    router14.get("/", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId || req.header("X-Company-ID");
        if (!userId || !companyId) {
          return res.status(401).json({
            error: "Unauthorized - User ID or Company ID missing",
            status: 401,
            items: []
          });
        }
        const limit = req.query.limit ? parseInt(req.query.limit) : 20;
        const onlyUnread = req.query.unread === "true";
        let status = void 0;
        if (req.query.status) {
          if (req.query.status.includes(",")) {
            status = req.query.status.split(",");
          } else {
            status = req.query.status;
          }
        }
        const notifications = await this.notificationService.getNotifications(userId, companyId, {
          limit,
          status,
          onlyUnread
        });
        return res.status(200).json(notifications);
      } catch (error) {
        this._logger.error("Error fetching notifications", { error });
        return res.status(500).json({
          error: "Internal server error",
          message: error instanceof Error ? error.message : "Unknown error",
          status: 500,
          items: []
        });
      }
    });
  }
};

// server/modules/collab/controllers/init.ts
function initCollabControllers(services) {
  const taskController = new TaskController(services.taskService);
  const noteController = new NoteController(services.noteService);
  const threadController = new ThreadController(services.threadService);
  const messageController = new MessageController(services.messageService);
  const watcherController = new WatcherController(services.watcherService);
  const communityController = new CommunityController(services.communityService);
  const activityController = new ActivityController2(services.activityService);
  const notificationController = new NotificationController(services.notificationService);
  const legacyTaskController = createTaskController(services.taskService);
  return {
    taskController,
    noteController,
    threadController,
    messageController,
    watcherController,
    communityController,
    activityController,
    notificationController,
    legacyTaskController
  };
}

// server/modules/collab/routes/task.routes.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
var logger89 = new Logger("TaskRoutes");
function registerTaskRoutes(app2, taskService, existingController) {
  logger89.info("Registering task routes...");
  const controller = existingController || new TaskController(taskService);
  app2.get(
    "/api/collaboration/tasks",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        return await controller.getAllTasks(req, res);
      } catch (error) {
        logger89.error(`Error in GET /api/collaboration/tasks: ${error instanceof Error ? error.message : String(error)}`);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.get(
    "/api/collaboration/tasks/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        return await controller.getTaskById(req, res);
      } catch (error) {
        logger89.error(`Error in GET /api/collaboration/tasks/:id: ${error instanceof Error ? error.message : String(error)}`);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/collaboration/tasks",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const userId = req.user.id;
        const companyId = req.user.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ message: "User ID or company ID not found" });
        }
        return await controller.createTask(req, res);
      } catch (error) {
        logger89.error(`Error in POST /api/collaboration/tasks: ${error instanceof Error ? error.message : String(error)}`);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.put(
    "/api/collaboration/tasks/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        return await controller.updateTask(req, res);
      } catch (error) {
        logger89.error(`Error in PUT /api/collaboration/tasks/:id: ${error instanceof Error ? error.message : String(error)}`);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.delete(
    "/api/collaboration/tasks/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        return await controller.deleteTask(req, res);
      } catch (error) {
        logger89.error(`Error in DELETE /api/collaboration/tasks/:id: ${error instanceof Error ? error.message : String(error)}`);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/collaboration/tasks/:id/assign",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const userId = req.user.id;
        const companyId = req.user.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ message: "User ID or company ID not found" });
        }
        return await controller.assignTask(req, res);
      } catch (error) {
        logger89.error(`Error in POST /api/collaboration/tasks/:id/assign: ${error instanceof Error ? error.message : String(error)}`);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  app2.post(
    "/api/collaboration/tasks/:id/status",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        return await controller.updateTaskStatus(req, res);
      } catch (error) {
        logger89.error(`Error in POST /api/collaboration/tasks/:id/status: ${error instanceof Error ? error.message : String(error)}`);
        return res.status(500).json({ message: "Internal server error" });
      }
    }
  );
  logger89.info("Task routes registered successfully");
}

// server/modules/collab/routes/note.routes.ts
import { Router as Router31 } from "express";
function registerNoteRoutes(noteController) {
  const router14 = Router31();
  noteController.registerRoutes(router14);
  return router14;
}

// server/modules/collab/collab.module.ts
init_auth_guard();
init_auth_mode_enum();
var logger90 = new Logger("CollabModule");
var CollabModule = class _CollabModule {
  constructor() {
    this.initialized = false;
  }
  /**
   * Get singleton instance of Collaboration module
   */
  static getInstance() {
    if (!_CollabModule.instance) {
      _CollabModule.instance = new _CollabModule();
    }
    return _CollabModule.instance;
  }
  /**
   * Initialize the Collaboration module and its services
   */
  initialize(db4) {
    if (this.initialized) {
      logger90.warn("Collaboration module already initialized");
      return;
    }
    logger90.info("Initializing Collaboration module...");
    try {
      const services = initCollabServices(db4);
      this.taskService = services.taskService;
      this.noteService = services.noteService;
      this.threadService = services.threadService;
      this.messageService = services.messageService;
      this.watcherService = services.watcherService;
      this.communityService = services.communityService;
      this.activityService = services.activityService;
      this.notificationService = services.notificationService;
      const controllers = initCollabControllers(services);
      this.taskController = controllers.taskController;
      this.noteController = controllers.noteController;
      this.threadController = controllers.threadController;
      this.messageController = controllers.messageController;
      this.watcherController = controllers.watcherController;
      this.communityController = controllers.communityController;
      this.activityController = controllers.activityController;
      this.notificationController = controllers.notificationController;
      this.initialized = true;
      logger90.info("Collaboration module initialized successfully");
    } catch (error) {
      logger90.error("Failed to initialize Collaboration module", { error });
      throw error;
    }
  }
  /**
   * Register all Collaboration routes with Express app
   */
  registerRoutes(app2) {
    if (!this.initialized) {
      throw new Error("Collaboration module must be initialized before registering routes");
    }
    logger90.info("Registering Collaboration routes...");
    registerTaskRoutes(app2, this.taskService, this.taskController);
    const noteRouter = registerNoteRoutes(this.noteController);
    app2.use("/api/collaboration/notes", noteRouter);
    const threadsRouter = Router32();
    const messagesRouter = Router32();
    const watchersRouter = Router32();
    const communityRouter = Router32();
    const activityRouter = Router32();
    const notificationsRouter = Router32();
    this.threadController.registerRoutes(threadsRouter);
    this.messageController.registerRoutes(messagesRouter);
    this.watcherController.registerRoutes(watchersRouter);
    this.communityController.registerRoutes(communityRouter);
    this.activityController.registerRoutes(activityRouter);
    this.notificationController.registerRoutes(notificationsRouter);
    app2.use("/api/collaboration/threads", threadsRouter);
    app2.use("/api/collaboration/messages", messagesRouter);
    app2.use("/api/collaboration/watchers", watchersRouter);
    app2.use("/api/collaboration/community", communityRouter);
    app2.use("/api/collaboration/activity", activityRouter);
    app2.use("/api/collaboration/notifications", notificationsRouter);
    app2.post("/api/collab/task", AuthGuard.protect("required" /* REQUIRED */), (req, res) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ message: "Unauthorized" });
        }
        logger90.info(`Task placeholder request received - User: ${userId}, Company: ${companyId}`);
        return res.status(200).json({
          message: "Collaboration task creation placeholder",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          requestData: req.body,
          context: {
            userId,
            companyId
          }
        });
      } catch (error) {
        logger90.error(`Error in POST /api/collab/task: ${error instanceof Error ? error.message : String(error)}`);
        res.status(500).json({ message: "Internal server error" });
      }
    });
    logger90.info("Collaboration routes registered successfully");
  }
  /**
   * Start the Collaboration module background processes
   */
  start() {
    if (!this.initialized) {
      throw new Error("Collaboration module must be initialized before starting");
    }
    logger90.info("Starting Collaboration processes...");
    logger90.info("Collaboration processes started successfully");
  }
  /**
   * Stop the Collaboration module background processes
   */
  stop() {
    if (!this.initialized) {
      return;
    }
    logger90.info("Stopping Collaboration processes...");
    logger90.info("Collaboration processes stopped successfully");
  }
};

// server/modules/ai/ai.module.ts
init_logger();

// server/modules/ai/services/openai.service.ts
init_audit_service();

// server/modules/ai/config/openai.config.ts
import dotenv2 from "dotenv";
dotenv2.config();
var defaultOpenAiConfig = {
  apiKey: process.env.OPENAI_API_KEY || "",
  organization: process.env.OPENAI_ORGANIZATION,
  defaultModel: "gpt-4o",
  maxTokens: 1e3,
  temperature: 0.7,
  baseUrl: process.env.OPENAI_API_BASE_URL
};
var useCaseConfigs = {
  salesAssistant: {
    ...defaultOpenAiConfig,
    model: "gpt-4o",
    temperature: 0.5,
    maxTokens: 800,
    systemPrompt: "You are a sales assistant for GeniusERP, analyzing customer data and providing insights to sales representatives."
  },
  inboxAssistant: {
    ...defaultOpenAiConfig,
    model: "gpt-4o",
    temperature: 0.6,
    maxTokens: 1200,
    systemPrompt: "You are an assistant helping to manage email communications. Analyze the content, categorize messages, and suggest responses."
  },
  productQa: {
    ...defaultOpenAiConfig,
    model: "gpt-4o",
    temperature: 0.2,
    maxTokens: 1500,
    systemPrompt: "You are a product specialist answering questions about products in our catalog. Provide accurate information based on product documentation."
  },
  documentAnalysis: {
    ...defaultOpenAiConfig,
    model: "gpt-4o",
    temperature: 0.3,
    maxTokens: 2e3,
    systemPrompt: "You are analyzing business documents. Extract key information, identify important details, and summarize content."
  }
};
function validateOpenAiConfig(config3) {
  if (!config3.apiKey || config3.apiKey.trim() === "") {
    console.error("OpenAI API key is missing. Set OPENAI_API_KEY in environment variables.");
    return false;
  }
  return true;
}
function createMessageTemplate(role, content) {
  return { role, content };
}

// server/modules/ai/services/openai.service.ts
import OpenAI from "openai";
var OpenAiService = class {
  /**
   * Creates an instance of OpenAIService
   */
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    this.openaiClient = null;
    this.config = defaultOpenAiConfig;
    this.isConfigValid = validateOpenAiConfig(this.config);
    if (this.isConfigValid) {
      this.initializeOpenAiClient();
    } else {
      console.warn(
        "OpenAI service initialized with invalid configuration. Please set OPENAI_API_KEY in environment variables."
      );
    }
  }
  /**
   * Initialize the OpenAI client
   */
  initializeOpenAiClient() {
    try {
      this.openaiClient = new OpenAI({
        apiKey: this.config.apiKey,
        organization: this.config.organization,
        baseURL: this.config.baseUrl
      });
      console.log("OpenAI client initialized successfully");
    } catch (error) {
      console.error("Failed to initialize OpenAI client:", error);
      this.openaiClient = null;
    }
  }
  /**
   * Update the service configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    this.isConfigValid = validateOpenAiConfig(this.config);
    if (this.isConfigValid) {
      this.initializeOpenAiClient();
    }
  }
  /**
   * Get a configuration specific to a use case
   */
  getConfigForUseCase(useCase) {
    return useCaseConfigs[useCase];
  }
  /**
   * Create a chat completion request
   */
  async createChatCompletion(params) {
    if (!this.isConfigValid) {
      throw new Error("OpenAI configuration is invalid. Please set OPENAI_API_KEY.");
    }
    try {
      await audit_service_default.log({
        action: "AI_REQUEST",
        entity: "AI_MODEL",
        entityId: params.model || this.config.defaultModel,
        userId: params.userId,
        companyId: params.companyId,
        details: {
          model: params.model || this.config.defaultModel,
          messageCount: params.messages.length,
          useCase: "chat_completion"
        }
      });
      if (!this.openaiClient) {
        console.log("OpenAI client not initialized, using placeholder response");
        return {
          id: `chatcmpl-${Date.now()}`,
          object: "chat.completion",
          created: Math.floor(Date.now() / 1e3),
          model: params.model || this.config.defaultModel,
          choices: [
            {
              index: 0,
              message: {
                role: "assistant",
                content: "This is a placeholder response. OpenAI client failed to initialize properly."
              },
              finish_reason: "placeholder"
            }
          ],
          usage: {
            prompt_tokens: 0,
            completion_tokens: 0,
            total_tokens: 0
          }
        };
      }
      const completion = await this.openaiClient.chat.completions.create({
        model: params.model || this.config.defaultModel,
        messages: params.messages,
        temperature: params.temperature || this.config.temperature,
        max_tokens: params.maxTokens || this.config.maxTokens
      });
      await audit_service_default.log({
        action: "AI_RESPONSE",
        entity: "AI_MODEL",
        entityId: params.model || this.config.defaultModel,
        userId: params.userId,
        companyId: params.companyId,
        details: {
          model: params.model || this.config.defaultModel,
          tokens: completion.usage?.total_tokens || 0,
          promptTokens: completion.usage?.prompt_tokens || 0,
          completionTokens: completion.usage?.completion_tokens || 0
        }
      });
      return completion;
    } catch (error) {
      console.error("Error creating chat completion:", error);
      await audit_service_default.log({
        action: "AI_REQUEST_ERROR",
        entity: "AI_MODEL",
        entityId: params.model || this.config.defaultModel,
        userId: params.userId,
        companyId: params.companyId,
        details: {
          error: error instanceof Error ? error.message : String(error),
          model: params.model || this.config.defaultModel
        }
      });
      throw error;
    }
  }
  /**
   * Helper to build a simple conversation with system, user and optional assistant messages
   */
  buildConversation(systemPrompt, userPrompt, assistantContext) {
    const messages2 = [
      createMessageTemplate("system", systemPrompt),
      createMessageTemplate("user", userPrompt)
    ];
    if (assistantContext) {
      messages2.push(createMessageTemplate("assistant", assistantContext));
    }
    return messages2;
  }
  /**
   * Check if the service is ready to use (has valid config)
   */
  isReady() {
    return this.isConfigValid;
  }
  /**
   * Get API key status (masked for security)
   */
  getApiKeyStatus() {
    if (!this.config.apiKey) return "Missing";
    if (this.config.apiKey.length < 8) return "Invalid";
    const start = this.config.apiKey.substring(0, 3);
    const end = this.config.apiKey.substring(this.config.apiKey.length - 3);
    return `Valid (${start}...${end})`;
  }
};

// server/modules/ai/services/ai.service.ts
init_audit_service();
init_id();
init_analytics_schema();
import { sql as sql49 } from "drizzle-orm";
var AIService = class {
  /**
   * Creates an instance of AIService
   */
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    this.openAiService = new OpenAiService(drizzleService5);
    if (drizzleService5 && !this.drizzleService?.db && drizzleService5?.db) {
      this.drizzleService = {
        ...drizzleService5,
        db: drizzleService5.db,
        _db: drizzleService5._db,
        executeQuery: drizzleService5.executeQuery || ((sql57) => Promise.resolve(sql57))
      };
    }
    const dbAvailable = !!this.drizzleService?.db;
    console.log(`AIService initialized. Database ${dbAvailable ? "is available" : "is NOT available"}`);
  }
  /**
   * Generate a report using AI
   * @param params Report generation parameters
   * @returns The generated report result
   */
  async generateReport(params) {
    const {
      companyId,
      franchiseId,
      type,
      name,
      description,
      parameters,
      userId
    } = params;
    const startTime = Date.now();
    try {
      await audit_service_default.log({
        action: "REPORT_GENERATION_STARTED",
        entity: "ANALYTICS_REPORT",
        entityId: "new",
        userId,
        companyId,
        details: {
          reportType: type,
          franchiseId: franchiseId || null,
          parameters: parameters || {}
        }
      });
      const systemPrompt = this.getSystemPromptForReportType(type);
      const userPrompt = this.buildReportPrompt(type, companyId, franchiseId, parameters);
      const conversation = this.openAiService.buildConversation(
        systemPrompt,
        userPrompt
      );
      const completion = await this.openAiService.createChatCompletion({
        messages: conversation,
        model: "gpt-4o",
        temperature: 0.3,
        maxTokens: 2e3,
        userId,
        companyId
      });
      const reportContent = completion.choices[0]?.message.content || "No content generated";
      const reportId = createId();
      if (!this.drizzleService?.db) {
        console.log("Database not available, returning content only without persistence");
        await audit_service_default.log({
          action: "REPORT_GENERATION_COMPLETED",
          entity: "ANALYTICS_REPORT",
          entityId: reportId,
          userId,
          companyId,
          details: {
            reportType: type,
            executionTime: Date.now() - startTime,
            contentLength: reportContent.length,
            dbStorageSkipped: true
          }
        });
        return {
          id: reportId,
          content: reportContent,
          createdAt: /* @__PURE__ */ new Date(),
          metrics: {
            dbStorageSkipped: true,
            executionTime: Date.now() - startTime
          }
        };
      }
      try {
        await this.drizzleService.db.insert(analyticsReports).values({
          id: reportId,
          companyId,
          name,
          description: description || `AI-generated ${type} report`,
          type,
          // Cast to any since we're assuming the type exists
          parameters: parameters ? JSON.stringify(parameters) : null,
          result: reportContent,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          createdBy: userId,
          updatedBy: userId,
          isPublic: false
        });
        const executionTime = Date.now() - startTime;
        await this.drizzleService.db.insert(reportExecutionHistory).values({
          id: createId(),
          reportId,
          companyId,
          executedBy: userId,
          executedAt: /* @__PURE__ */ new Date(),
          parameters: parameters ? JSON.stringify(parameters) : null,
          result: reportContent,
          executionTime,
          status: "SUCCESS",
          errorMessage: null
        });
        await audit_service_default.log({
          action: "REPORT_GENERATION_COMPLETED",
          entity: "ANALYTICS_REPORT",
          entityId: reportId,
          userId,
          companyId,
          details: {
            reportType: type,
            executionTime,
            contentLength: reportContent.length
          }
        });
      } catch (dbError) {
        console.error("Database operation failed during report generation:", dbError);
        await audit_service_default.log({
          action: "REPORT_DB_ERROR",
          entity: "ANALYTICS_REPORT",
          entityId: reportId,
          userId,
          companyId,
          details: {
            reportType: type,
            error: dbError instanceof Error ? dbError.message : String(dbError)
          }
        });
        return {
          id: reportId,
          content: reportContent,
          createdAt: /* @__PURE__ */ new Date(),
          metrics: {
            dbError: true,
            errorMessage: dbError instanceof Error ? dbError.message : String(dbError)
          }
        };
      }
      return {
        id: reportId,
        content: reportContent,
        createdAt: /* @__PURE__ */ new Date()
      };
    } catch (error) {
      await audit_service_default.log({
        action: "REPORT_GENERATION_FAILED",
        entity: "ANALYTICS_REPORT",
        entityId: "failed",
        userId,
        companyId,
        details: {
          reportType: type,
          error: error instanceof Error ? error.message : String(error)
        }
      });
      if (this.drizzleService?.db) {
        try {
          const executionTime = Date.now() - startTime;
          const reportId = createId();
          await this.drizzleService.db.insert(reportExecutionHistory).values({
            id: createId(),
            reportId,
            companyId,
            executedBy: userId,
            executedAt: /* @__PURE__ */ new Date(),
            parameters: parameters ? JSON.stringify(parameters) : null,
            result: null,
            executionTime,
            status: "FAILED",
            errorMessage: error instanceof Error ? error.message : String(error)
          });
        } catch (dbError) {
          console.error("Failed to log error to database:", dbError);
        }
      }
      throw error;
    }
  }
  /**
   * Get system prompt for a specific report type
   * @param reportType The type of report
   * @returns The system prompt
   */
  getSystemPromptForReportType(reportType) {
    const systemPrompts = {
      "financial_summary": "You are a financial analysis AI assistant. Generate a concise financial summary report with key metrics, trends, and actionable insights. Include sections on revenue, expenses, profitability, and financial health.",
      "sales_performance": "You are a sales analytics AI assistant. Generate a detailed sales performance report with metrics, trends, top performers, regional analysis, and actionable recommendations. Include sections on pipeline analysis, conversion rates, and revenue forecasts.",
      "inventory_analysis": "You are an inventory management AI assistant. Generate a comprehensive inventory analysis report with stock levels, turnover rates, reorder suggestions, and optimization recommendations. Include sections on overstock and understock items.",
      "customer_insights": "You are a customer analytics AI assistant. Generate an insightful customer analysis report with segmentation, behavior patterns, lifetime value analysis, and loyalty metrics. Include sections on acquisition channels and retention strategies.",
      "market_trends": "You are a market research AI assistant. Generate an informative market trends report with industry developments, competitive landscape, emerging opportunities, and potential threats. Include sections on market growth and consumer preferences."
    };
    return systemPrompts[reportType] || "You are an analytics AI assistant. Generate a comprehensive business report with data-driven insights and actionable recommendations.";
  }
  /**
   * Build a report prompt based on parameters
   * @param type Report type
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   * @param parameters Optional additional parameters
   * @returns The constructed prompt
   */
  buildReportPrompt(type, companyId, franchiseId, parameters) {
    let prompt = `Generate a detailed ${type} report `;
    prompt += `for company ID ${companyId} `;
    if (franchiseId) {
      prompt += `and franchise ID ${franchiseId} `;
    }
    if (parameters?.period) {
      prompt += `for the period ${parameters.period} `;
    }
    if (parameters?.focusAreas && Array.isArray(parameters.focusAreas)) {
      prompt += `with focus on ${parameters.focusAreas.join(", ")} `;
    }
    prompt += `

Please structure the report with the following sections:
1. Executive Summary
2. Key Metrics and KPIs
3. Detailed Analysis
4. Trends and Patterns
5. Actionable Recommendations
6. Conclusion
`;
    if (parameters?.metrics && Array.isArray(parameters.metrics)) {
      prompt += `
Include analysis of these specific metrics: ${parameters.metrics.join(", ")}`;
    }
    if (parameters?.compareWith) {
      prompt += `
Compare performance with ${parameters.compareWith}`;
    }
    return prompt;
  }
  /**
   * Get a report by ID
   * @param reportId Report ID
   * @param companyId Company ID
   * @returns The report or null if not found
   */
  async getReportById(reportId, companyId) {
    if (!this.drizzleService?.db) {
      console.log(`Database not available, cannot retrieve report ${reportId}`);
      return null;
    }
    try {
      const report = await this.drizzleService.db.select().from(analyticsReports).where(sql49`${analyticsReports.id} = ${reportId} AND ${analyticsReports.companyId} = ${companyId}`).limit(1);
      return report.length > 0 ? report[0] : null;
    } catch (error) {
      console.error(`Error retrieving report ${reportId}:`, error);
      return null;
    }
  }
  /**
   * List reports for a company
   * @param companyId Company ID
   * @param type Optional report type filter
   * @param limit Optional result limit
   * @returns List of reports
   */
  async listReports(companyId, type, limit = 10) {
    if (!this.drizzleService?.db) {
      console.log(`Database not available, cannot list reports for company ${companyId}`);
      return [];
    }
    try {
      let query = this.drizzleService.db.select().from(analyticsReports).where(sql49`${analyticsReports.companyId} = ${companyId}`);
      if (type) {
        query = query.where(sql49`${analyticsReports.type} = ${type}`);
      }
      const reports = await query.orderBy(sql49`${analyticsReports.createdAt} desc`).limit(limit);
      return reports;
    } catch (error) {
      console.error(`Error listing reports for company ${companyId}:`, error);
      return [];
    }
  }
};

// server/modules/ai/services/sales-ai.service.ts
init_audit_service();
import { randomUUID as randomUUID13 } from "crypto";
var SalesAiService = class {
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    console.log("SalesAI Service initialized");
  }
  /**
   * Score a lead based on CRM data and behavioral signals
   * @param leadId The ID of the lead to score
   * @returns A scoring result with factors and recommendations
   */
  async scoreLead(leadId, userId) {
    await audit_service_default.log({
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      action: "score",
      entity: "lead",
      entityId: leadId,
      details: {
        action: "score_lead",
        leadId
      }
    });
    return {
      leadId,
      score: 85,
      factors: [
        {
          factor: "engagement",
          impact: 30,
          description: "High email open rate and website visits"
        },
        {
          factor: "company_fit",
          impact: 25,
          description: "Matches ideal customer profile"
        },
        {
          factor: "budget",
          impact: 20,
          description: "Budget signals are positive from conversation analysis"
        },
        {
          factor: "timing",
          impact: 10,
          description: "Recent increase in product page visits"
        }
      ],
      recommendation: "High priority lead. Schedule a demo within 48 hours."
    };
  }
  /**
   * Generate intelligent sales recommendations for a specific deal
   * @param dealId The ID of the deal
   * @param customerId The ID of the customer
   * @param userId The ID of the user requesting recommendations
   * @returns A list of intelligent sales recommendations
   */
  async generateDealRecommendations(dealId, customerId, userId) {
    await audit_service_default.log({
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      action: "generate_recommendations",
      entity: "deal",
      entityId: dealId,
      details: {
        action: "generate_deal_recommendations",
        dealId,
        customerId
      }
    });
    return [
      {
        id: randomUUID13(),
        dealId,
        customerId,
        recommendationType: "product",
        recommendation: "Add Premium Support package",
        reasoning: "Customer has previously emphasized need for rapid support resolution",
        priority: "high",
        createdAt: /* @__PURE__ */ new Date()
      },
      {
        id: randomUUID13(),
        dealId,
        customerId,
        recommendationType: "pricing",
        recommendation: "Offer quarterly payment option",
        reasoning: "Analysis of customer cash flow indicates preference for quarterly payments",
        priority: "medium",
        createdAt: /* @__PURE__ */ new Date()
      },
      {
        id: randomUUID13(),
        dealId,
        customerId,
        recommendationType: "approach",
        recommendation: "Focus on ROI metrics in next meeting",
        reasoning: "Decision maker has engaged most with ROI calculator content",
        priority: "high",
        createdAt: /* @__PURE__ */ new Date()
      }
    ];
  }
  /**
   * Predict the close probability and value for a deal
   * @param dealId The ID of the deal
   * @param userId The ID of the user requesting the prediction
   * @returns The predicted probability and value
   */
  async predictDealOutcome(dealId, userId) {
    await audit_service_default.log({
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      action: "predict_outcome",
      entity: "deal",
      entityId: dealId,
      details: {
        action: "predict_deal_outcome",
        dealId
      }
    });
    return {
      probability: 72,
      predictedValue: 15e3,
      factorsIncreasing: [
        "Multiple stakeholders engaged",
        "Technical evaluation complete",
        "Budget confirmed by finance"
      ],
      factorsDecreasing: [
        "Extended decision timeline",
        "Competitor actively engaged"
      ]
    };
  }
  /**
   * Suggest the optimal timing for follow-up based on customer behavior patterns
   * @param customerId The ID of the customer
   * @param userId The ID of the user requesting the suggestion
   * @returns Timing recommendations for follow-up
   */
  async suggestFollowUpTiming(customerId, userId) {
    await audit_service_default.log({
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      action: "suggest_followup",
      entity: "customer",
      entityId: customerId,
      details: {
        action: "suggest_followup_timing",
        customerId
      }
    });
    return {
      optimalDayOfWeek: "Tuesday",
      optimalTimeOfDay: "2:00 PM - 4:00 PM",
      reasoning: "Customer typically responds to emails and accepts meetings on Tuesday afternoons based on past interaction data",
      alternateOptions: [
        { day: "Thursday", time: "10:00 AM - 11:30 AM" },
        { day: "Wednesday", time: "3:30 PM - 5:00 PM" }
      ]
    };
  }
};

// server/modules/ai/services/inbox-ai-assistant.service.ts
init_audit_service();
import { randomUUID as randomUUID14 } from "crypto";
var InboxAiAssistantService = class {
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    console.log("Inbox AI Assistant Service initialized");
  }
  /**
   * Analyze an email message for sentiment, topics, and action items
   * @param messageId The ID of the message to analyze
   * @param messageContent The content of the message
   * @param userId The ID of the user requesting analysis
   * @returns Analysis of the email including sentiment and action items
   */
  async analyzeEmail(messageId, messageContent, userId) {
    await audit_service_default.log({
      entityId: messageId,
      action: "analyze",
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      entity: "message",
      details: {
        action: "analyze_email"
      }
    });
    const analysis = {
      messageId,
      sentiment: "positive",
      sentimentScore: 0.75,
      keyTopics: ["contract renewal", "pricing", "timeline"],
      actionItemsDetected: true,
      actionItems: [
        "Send updated pricing proposal by Friday",
        "Schedule follow-up call next week"
      ],
      priority: "high",
      suggestedCategory: "Sales Opportunity"
    };
    return analysis;
  }
  /**
   * Generate response suggestions for an email message
   * @param messageId The ID of the message to generate suggestions for
   * @param messageContent The content of the message
   * @param emailAnalysis Optional pre-computed email analysis
   * @param userId The ID of the user requesting suggestions
   * @returns A list of suggested responses
   */
  async generateResponseSuggestions(messageId, messageContent, emailAnalysis, userId) {
    await audit_service_default.log({
      entityId: messageId,
      action: "generate_suggestions",
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      entity: "message",
      details: {
        action: "generate_response_suggestions"
      }
    });
    const analysis = emailAnalysis || await this.analyzeEmail(messageId, messageContent, userId);
    return [
      {
        id: randomUUID14(),
        messageId,
        responseText: "Thank you for reaching out about the contract renewal. I'd be happy to send you the updated pricing proposal by Friday as requested. Would you like to schedule a call next week to discuss the details?",
        responseType: "acknowledge",
        confidence: 0.85
      },
      {
        id: randomUUID14(),
        messageId,
        responseText: "I'll prepare the updated pricing proposal based on our new service offerings and send it to you by Friday. Does Tuesday at 2pm work for a follow-up call?",
        responseType: "scheduling",
        confidence: 0.78
      },
      {
        id: randomUUID14(),
        messageId,
        responseText: "I've noted your request for updated pricing. Before I prepare the proposal, could you please confirm which specific services you're interested in for the renewal?",
        responseType: "question",
        confidence: 0.72
      }
    ];
  }
  /**
   * Generate a complete response to an email based on context and previous communications
   * @param messageId The ID of the message to respond to
   * @param messageContent The content of the message
   * @param contextHistory Previous message exchanges with this contact
   * @param userId The ID of the user requesting the response
   * @returns A complete AI-generated response
   */
  async generateCompleteResponse(messageId, messageContent, contextHistory, userId) {
    await audit_service_default.log({
      entityId: messageId,
      action: "generate_complete_response",
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      entity: "message",
      details: {
        action: "generate_complete_response",
        historyLength: contextHistory.length
      }
    });
    return {
      responseText: "Hello Maria,\n\nThank you for reaching out about the contract renewal. I appreciate your continued partnership.\n\nI'll prepare the updated pricing proposal based on our discussion last month and send it to you by Friday. The new proposal will include the additional user licenses and premium support package you mentioned.\n\nWould Tuesday at 2pm work for a follow-up call to discuss any questions you might have? If not, please suggest a few times that work for your schedule.\n\nBest regards,\nAlexandru",
      salutation: "Hello Maria,",
      body: "Thank you for reaching out about the contract renewal. I appreciate your continued partnership.\n\nI'll prepare the updated pricing proposal based on our discussion last month and send it to you by Friday. The new proposal will include the additional user licenses and premium support package you mentioned.\n\nWould Tuesday at 2pm work for a follow-up call to discuss any questions you might have? If not, please suggest a few times that work for your schedule.",
      closing: "Best regards,\nAlexandru",
      confidence: 0.82
    };
  }
  /**
   * Set up automated follow-up reminders based on email content and action items
   * @param messageId The ID of the message
   * @param emailAnalysis The analysis of the email
   * @param userId The ID of the user
   * @returns The created follow-up reminders
   */
  async createSmartFollowUpReminders(messageId, emailAnalysis, userId) {
    await audit_service_default.log({
      entityId: messageId,
      action: "create_followup_reminders",
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      entity: "message",
      details: {
        action: "create_smart_followup_reminders"
      }
    });
    const now = /* @__PURE__ */ new Date();
    const threeDaysLater = new Date(now);
    threeDaysLater.setDate(now.getDate() + 3);
    const oneWeekLater = new Date(now);
    oneWeekLater.setDate(now.getDate() + 7);
    return [
      {
        reminderId: randomUUID14(),
        messageId,
        reminderTime: threeDaysLater,
        description: "Send pricing proposal as promised in email",
        priority: "high"
      },
      {
        reminderId: randomUUID14(),
        messageId,
        reminderTime: oneWeekLater,
        description: "Follow up on scheduling the discussion call if no response",
        priority: "medium"
      }
    ];
  }
};

// server/modules/ai/services/product-qa.service.ts
init_audit_service();
import { randomUUID as randomUUID15 } from "crypto";
var ProductQaService = class {
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    console.log("Product QA Service initialized");
  }
  /**
   * Answer a product-related question using available documentation
   * @param question The question about a product
   * @param productId The optional product ID to scope the question
   * @param userId The ID of the user asking the question
   * @returns A detailed answer with sources and confidence level
   */
  async answerProductQuestion(question, productId, userId) {
    const questionId = randomUUID15();
    await audit_service_default.log({
      entityId: questionId,
      action: "answer",
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      entity: "product_question",
      details: {
        action: "answer_product_question",
        question,
        productId
      }
    });
    return {
      questionId,
      question,
      answer: "The GeniusERP v2 Financial Module supports multi-currency transactions and automatically handles exchange rate differences according to Romanian accounting standards. You can set a default currency for each entity and the system will handle conversions using daily BNR rates. For statutory reporting, all amounts will be converted to RON using the official exchange rates.",
      confidence: 0.92,
      sources: [
        {
          documentId: "doc-financial-001",
          documentName: "Financial Module User Guide",
          relevance: 0.95,
          excerpt: "Chapter 5.3: Multi-Currency Support - The system supports transactions in any currency and automatically handles exchange rate differences."
        },
        {
          documentId: "doc-compliance-003",
          documentName: "Romanian Compliance Guide",
          relevance: 0.88,
          excerpt: "Exchange rate differences must be calculated using daily BNR rates for statutory reporting."
        }
      ],
      relatedQuestions: [
        "How do I set up a new currency in the system?",
        "Where can I view exchange rate differences reports?",
        "Can I use custom exchange rates for specific transactions?"
      ]
    };
  }
  /**
   * Compare multiple products based on their specifications and features
   * @param productIds The IDs of products to compare
   * @param userId The ID of the user requesting the comparison
   * @returns A detailed comparison of the products
   */
  async compareProducts(productIds, userId) {
    const comparisonId = randomUUID15();
    await audit_service_default.log({
      entityId: comparisonId,
      action: "compare",
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      entity: "product_comparison",
      details: {
        action: "compare_products",
        productIds
      }
    });
    return {
      id: comparisonId,
      productIds,
      productNames: ["Standard ERP Package", "Enterprise ERP Suite", "Financial Module Only"],
      comparisonPoints: [
        {
          feature: "Multi-Currency Support",
          values: {
            "Standard ERP Package": "Basic (5 currencies)",
            "Enterprise ERP Suite": "Advanced (unlimited currencies)",
            "Financial Module Only": "Advanced (unlimited currencies)"
          },
          differences: "Enterprise ERP Suite and Financial Module Only both offer unlimited currency support, while Standard Package is limited to 5 currencies."
        },
        {
          feature: "User Licenses",
          values: {
            "Standard ERP Package": 10,
            "Enterprise ERP Suite": "Unlimited",
            "Financial Module Only": 5
          },
          differences: "Enterprise Suite comes with unlimited users, Standard Package includes 10 users, and Financial Module includes only 5 users."
        },
        {
          feature: "Compliance Reports",
          values: {
            "Standard ERP Package": "Basic Romanian reports",
            "Enterprise ERP Suite": "Full compliance pack for Romania and EU",
            "Financial Module Only": "Financial compliance reports only"
          },
          differences: "Enterprise Suite offers the most comprehensive compliance reporting for both Romanian and EU requirements."
        }
      ],
      summary: "The Enterprise ERP Suite offers the most comprehensive feature set with unlimited users and currencies, plus full compliance reporting. The Standard Package provides good core functionality but with some limitations. The Financial Module Only option is best if you only need financial management capabilities with full multi-currency support."
    };
  }
  /**
   * Search for technical documentation across all product manuals
   * @param query The search query
   * @param filters Optional filters to limit search scope
   * @param userId The ID of the user performing the search
   * @returns Relevant documentation matches
   */
  async searchProductDocumentation(query, filters, userId) {
    await audit_service_default.log({
      entityId: "search",
      action: "search",
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      entity: "documentation",
      details: {
        action: "search_documentation",
        query,
        filters
      }
    });
    return {
      query,
      results: [
        {
          documentId: "doc-financial-022",
          documentTitle: "Multi-Currency Management Guide",
          documentType: "user_guide",
          relevance: 0.95,
          excerpt: "Chapter 3: Setting up exchange rates in GeniusERP v2. The system can be configured to automatically fetch daily rates from the Romanian National Bank (BNR) or manual entry is also supported.",
          pageNumber: 24,
          url: "/documentation/financial/multi-currency-guide.pdf"
        },
        {
          documentId: "doc-tutorial-015",
          documentTitle: "Tutorial: Managing Foreign Currency Invoices",
          documentType: "tutorial",
          relevance: 0.88,
          excerpt: "This tutorial demonstrates the complete process of creating, approving, and recording a foreign currency invoice, including handling exchange rate differences.",
          url: "/tutorials/financial/foreign-currency-invoices.html"
        },
        {
          documentId: "doc-technical-008",
          documentTitle: "Technical Reference: Exchange Rate API",
          documentType: "api_doc",
          relevance: 0.82,
          excerpt: "The ExchangeRateService API provides methods for retrieving, storing, and calculating with exchange rates. This document details all available methods and their parameters.",
          pageNumber: 103,
          url: "/api-docs/financial/exchange-rate-service.html"
        }
      ],
      totalResults: 42
    };
  }
  /**
   * Generate usage suggestions and best practices for a specific product or feature
   * @param productId The product ID
   * @param featureId Optional specific feature ID
   * @param userContext Optional user context for personalized suggestions
   * @param userId The ID of the user requesting suggestions
   * @returns Personalized usage suggestions and best practices
   */
  async generateUsageSuggestions(productId, featureId, userContext, userId) {
    await audit_service_default.log({
      entityId: productId,
      action: "generate_suggestions",
      userId,
      companyId: "default",
      // This would come from actual context in a real implementation
      entity: "product",
      details: {
        action: "generate_usage_suggestions",
        featureId,
        userContextRole: userContext?.role
      }
    });
    const userRole = userContext?.role || "accountant";
    const userExperience = userContext?.experience || "intermediate";
    return {
      suggestions: [
        {
          id: randomUUID15(),
          title: "Set up automated exchange rate synchronization",
          description: "Configure the system to automatically download daily exchange rates from BNR to ensure accurate currency conversions.",
          difficulty: "basic",
          estimatedTimeMinutes: 15,
          steps: [
            "Navigate to Settings > Financial > Exchange Rates",
            'Enable "Auto-sync with BNR"',
            "Set the preferred sync schedule (recommended: daily at 10:00 AM)",
            "Click Save to apply the configuration"
          ]
        },
        {
          id: randomUUID15(),
          title: "Create exchange rate difference reports",
          description: "Set up regular reports to track exchange rate differences for accounting reconciliation.",
          difficulty: "intermediate",
          estimatedTimeMinutes: 30,
          steps: [
            "Go to Reports > Financial > New Report",
            'Select "Exchange Rate Differences" from the template list',
            "Configure date range and currencies to include",
            "Set up schedule for automated generation (monthly recommended)",
            "Specify recipients for the report distribution"
          ]
        },
        {
          id: randomUUID15(),
          title: "Implement currency revaluation workflow",
          description: "Set up an end-of-month currency revaluation process to comply with Romanian accounting standards.",
          difficulty: "advanced",
          estimatedTimeMinutes: 60
        }
      ],
      bestPractices: [
        {
          title: "Always verify exchange rates on month-end closing",
          description: "Even with automated synchronization, manually verify the exchange rates used for month-end closing to ensure compliance with accounting standards.",
          importance: "critical"
        },
        {
          title: "Set default currencies for frequent vendors",
          description: "Configure default currencies for vendors you regularly work with to streamline the invoice creation process.",
          importance: "recommended"
        },
        {
          title: "Use reporting currency views for consistency",
          description: "When analyzing financial data across multiple currencies, use the reporting currency view to ensure consistent comparison.",
          importance: "recommended"
        },
        {
          title: "Document exchange rate sources",
          description: "Maintain documentation of exchange rate sources used for each period to support audit requirements.",
          importance: "optional"
        }
      ]
    };
  }
};

// server/modules/ai/controllers/ai.controller.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
import { z as z28 } from "zod";
var generateReportSchema = z28.object({
  type: z28.string().min(1, "Report type is required"),
  name: z28.string().min(1, "Report name is required"),
  description: z28.string().optional(),
  franchiseId: z28.string().optional(),
  parameters: z28.record(z28.any()).optional()
});
var logger91 = new Logger("AIController");
function registerAIControllerRoutes(app2, aiService) {
  const BASE_PATH = "/api/ai";
  app2.get(`${BASE_PATH}/health`, (req, res) => {
    try {
      res.status(200).json({
        status: "ok",
        module: "ai",
        features: [
          "sales-ai",
          "inbox-ai",
          "product-qa",
          "openai",
          "ai-reports"
        ]
      });
    } catch (error) {
      logger91.error("Error in AI health check endpoint", error);
      res.status(500).json({
        status: "error",
        message: "Failed to check AI health"
      });
    }
  });
  app2.get(`${BASE_PATH}/status`, AuthGuard.protect("required" /* REQUIRED */), (req, res) => {
    try {
      res.status(200).json({
        status: "operational",
        module: "ai",
        features: {
          "sales-ai": {
            status: "active",
            capabilities: [
              "lead-scoring",
              "deal-recommendations",
              "outcome-prediction",
              "followup-timing"
            ]
          },
          "inbox-ai": {
            status: "active",
            capabilities: [
              "email-analysis",
              "response-suggestions",
              "complete-response",
              "followup-reminders"
            ]
          },
          "product-qa": {
            status: "active",
            capabilities: [
              "question-answering",
              "product-comparison",
              "documentation-search",
              "usage-suggestions"
            ]
          },
          "openai": {
            status: "active",
            capabilities: [
              "chat-completion",
              "content-analysis",
              "document-processing",
              "smart-workflows"
            ],
            integration: "integrated"
          },
          "ai-reports": {
            status: "active",
            capabilities: [
              "financial-reports",
              "sales-analytics",
              "inventory-analysis",
              "market-trends",
              "customer-insights"
            ],
            integration: "integrated with OpenAI"
          }
        },
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      logger91.error("Error in AI status endpoint", error);
      res.status(500).json({
        status: "error",
        message: "Failed to check AI status"
      });
    }
  });
  app2.post(
    `${BASE_PATH}/report`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(["hq_admin", "ai_access"]),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = generateReportSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { type, name, description = "", franchiseId, parameters } = validationResult.data;
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(400).json({
            success: false,
            error: "User ID and Company ID are required in the authenticated token",
            message: "Authentication error: missing user or company context"
          });
        }
        const result = await aiService.generateReport({
          companyId,
          franchiseId,
          type,
          name,
          description,
          parameters,
          userId
        });
        return res.status(200).json({
          success: true,
          message: "AI report generated successfully",
          data: result
        });
      } catch (error) {
        logger91.error("Error in AI report generation endpoint", error);
        return res.status(500).json({
          success: false,
          message: "An error occurred while generating the AI report",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.get(
    `${BASE_PATH}/reports/:id`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const reportId = req.params.id;
        const companyId = req.user?.companyId;
        if (!companyId) {
          return res.status(400).json({
            success: false,
            message: "Company ID is required in the authenticated token"
          });
        }
        const report = await aiService.getReportById(reportId, companyId);
        if (!report) {
          return res.status(404).json({
            success: false,
            message: "Report not found"
          });
        }
        return res.status(200).json({
          success: true,
          data: report
        });
      } catch (error) {
        logger91.error(`Error retrieving report with ID ${req.params.id}`, error);
        return res.status(500).json({
          success: false,
          message: "Error retrieving report",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.get(
    `${BASE_PATH}/reports`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const companyId = req.user?.companyId;
        const type = req.query.type;
        const limit = req.query.limit ? parseInt(req.query.limit) : 10;
        if (!companyId) {
          return res.status(400).json({
            success: false,
            message: "Company ID is required in the authenticated token"
          });
        }
        const reports = await aiService.listReports(companyId, type, limit);
        return res.status(200).json({
          success: true,
          data: reports
        });
      } catch (error) {
        logger91.error("Error listing reports", error);
        return res.status(500).json({
          success: false,
          message: "Error listing reports",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  logger91.info("AI controller routes registered");
}

// server/modules/ai/controllers/openai.controller.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
init_audit_service();
import { z as z29 } from "zod";
var completionSchema = z29.object({
  messages: z29.array(z29.object({
    role: z29.enum(["system", "user", "assistant"]),
    content: z29.string()
  })).min(1, "At least one message is required"),
  model: z29.string().optional(),
  temperature: z29.number().min(0).max(2).optional(),
  maxTokens: z29.number().positive().optional()
});
var analyzeSchema = z29.object({
  content: z29.string().min(1, "Content is required"),
  type: z29.enum(["email", "document", "conversation", "general"]).optional(),
  options: z29.object({
    model: z29.string().optional(),
    temperature: z29.number().min(0).max(2).optional(),
    maxTokens: z29.number().positive().optional()
  }).optional()
});
var logger92 = new Logger("OpenAIController");
function registerOpenAIControllerRoutes(app2, openAiService) {
  const BASE_PATH = "/api/ai/openai";
  app2.get(`${BASE_PATH}/status`, AuthGuard.protect("required" /* REQUIRED */), (req, res) => {
    try {
      let sdkInstalled = true;
      try {
        if (req.user) {
          audit_service_default.log({
            action: "CHECK_OPENAI_STATUS",
            entity: "AI_MODULE",
            entityId: "openai",
            userId: req.user.id,
            companyId: req.user.companyId,
            details: {
              apiKeyStatus: openAiService.getApiKeyStatus(),
              sdkInstalled
            }
          });
        }
      } catch (error) {
        logger92.error("Error logging OpenAI status check:", error);
      }
      const status = {
        ready: openAiService.isReady(),
        apiKeyStatus: openAiService.getApiKeyStatus(),
        defaultModel: process.env.OPENAI_DEFAULT_MODEL || "gpt-4o",
        models: ["gpt-4o", "gpt-4-turbo", "gpt-3.5-turbo"],
        sdkInstalled,
        useCases: Object.keys(openAiService.getConfigForUseCase("salesAssistant"))
      };
      res.status(200).json({
        success: true,
        data: status
      });
    } catch (error) {
      logger92.error("Error checking OpenAI status", error);
      res.status(500).json({
        success: false,
        message: "Failed to check OpenAI status",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.post(
    `${BASE_PATH}/completion`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = completionSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { messages: messages2, model, temperature, maxTokens } = validationResult.data;
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(400).json({
            success: false,
            error: "User ID and Company ID are required"
          });
        }
        const completion = await openAiService.createChatCompletion({
          messages: messages2,
          model,
          temperature,
          maxTokens,
          userId,
          companyId
        });
        res.status(200).json({
          success: true,
          data: completion
        });
      } catch (error) {
        logger92.error("Error in completion endpoint:", error);
        res.status(500).json({
          success: false,
          error: "Failed to generate completion",
          details: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/analyze`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = analyzeSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { content, type = "general", options } = validationResult.data;
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(400).json({
            success: false,
            error: "User ID and Company ID are required"
          });
        }
        let systemPrompt = "You are an AI assistant analyzing content.";
        switch (type) {
          case "email":
            systemPrompt = "You are an email analysis assistant. Analyze the following email and provide key insights, sentiment, and suggested actions.";
            break;
          case "document":
            systemPrompt = "You are a document analysis assistant. Extract key information, topics, and insights from the following document.";
            break;
          case "conversation":
            systemPrompt = "You are a conversation analysis assistant. Analyze the following conversation transcript and provide key points, sentiment, and next steps.";
            break;
          default:
            systemPrompt = "You are a general content analysis assistant. Analyze the following content and provide insights.";
        }
        const messages2 = openAiService.buildConversation(
          systemPrompt,
          content
        );
        const completion = await openAiService.createChatCompletion({
          messages: messages2,
          model: options?.model,
          temperature: options?.temperature || 0.3,
          // Lower temperature for analysis
          maxTokens: options?.maxTokens,
          userId,
          companyId
        });
        res.status(200).json({
          success: true,
          data: {
            analysis: completion.choices[0]?.message.content,
            model: completion.model,
            type
          }
        });
      } catch (error) {
        logger92.error("Error in analysis endpoint:", error);
        res.status(500).json({
          success: false,
          error: "Failed to analyze content",
          details: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.put(
    `${BASE_PATH}/config`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(["admin"]),
    async (req, res) => {
      try {
        const { apiKey, defaultModel, temperature, maxTokens, organization, baseUrl } = req.body;
        openAiService.updateConfig({
          apiKey,
          defaultModel,
          temperature,
          maxTokens,
          organization,
          baseUrl
        });
        await audit_service_default.log({
          action: "OPENAI_CONFIG_UPDATE",
          entity: "AI_MODULE",
          entityId: "openai_config",
          userId: req.user?.id,
          companyId: req.user?.companyId,
          details: {
            updatedFields: Object.keys(req.body).filter((key) => key !== "apiKey"),
            apiKeyUpdated: !!apiKey
          }
        });
        res.status(200).json({
          success: true,
          message: "OpenAI configuration updated successfully",
          data: {
            ready: openAiService.isReady(),
            apiKeyStatus: openAiService.getApiKeyStatus()
          }
        });
      } catch (error) {
        logger92.error("Error updating OpenAI configuration", error);
        res.status(500).json({
          success: false,
          message: "Failed to update OpenAI configuration",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  logger92.info("OpenAI controller routes registered");
}

// server/modules/ai/controllers/sales-ai.controller.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
import { z as z30 } from "zod";
var leadScoringSchema = z30.object({
  leadId: z30.string().uuid("Invalid lead ID format")
});
var dealRecommendationsSchema = z30.object({
  dealId: z30.string().uuid("Invalid deal ID format"),
  customerId: z30.string().uuid("Invalid customer ID format")
});
var dealOutcomeSchema = z30.object({
  dealId: z30.string().uuid("Invalid deal ID format")
});
var followUpTimingSchema = z30.object({
  customerId: z30.string().uuid("Invalid customer ID format")
});
var logger93 = new Logger("SalesAIController");
function registerSalesAIControllerRoutes(app2, salesAiService) {
  const BASE_PATH = "/api/ai/sales";
  app2.post(
    `${BASE_PATH}/leads/score`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = leadScoringSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { leadId } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const scoringResult = await salesAiService.scoreLead(leadId, userId);
        return res.status(200).json({
          success: true,
          data: scoringResult
        });
      } catch (error) {
        logger93.error("Error in lead scoring endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error scoring lead",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/deals/recommendations`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = dealRecommendationsSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { dealId, customerId } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const recommendations = await salesAiService.generateDealRecommendations(
          dealId,
          customerId,
          userId
        );
        return res.status(200).json({
          success: true,
          data: recommendations
        });
      } catch (error) {
        logger93.error("Error in deal recommendations endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error generating deal recommendations",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/deals/predict`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = dealOutcomeSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { dealId } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const prediction = await salesAiService.predictDealOutcome(dealId, userId);
        return res.status(200).json({
          success: true,
          data: prediction
        });
      } catch (error) {
        logger93.error("Error in deal outcome prediction endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error predicting deal outcome",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/followup/timing`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = followUpTimingSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { customerId } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const timing = await salesAiService.suggestFollowUpTiming(customerId, userId);
        return res.status(200).json({
          success: true,
          data: timing
        });
      } catch (error) {
        logger93.error("Error in follow-up timing endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error suggesting follow-up timing",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  logger93.info("Sales AI controller routes registered");
}

// server/modules/ai/controllers/inbox-ai.controller.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
import { z as z31 } from "zod";
var analyzeEmailSchema = z31.object({
  messageId: z31.string().min(1, "Message ID is required"),
  messageContent: z31.string().min(1, "Message content is required")
});
var responseSuggestionsSchema = z31.object({
  messageId: z31.string().min(1, "Message ID is required"),
  messageContent: z31.string().min(1, "Message content is required"),
  emailAnalysis: z31.object({
    messageId: z31.string(),
    sentiment: z31.enum(["positive", "neutral", "negative", "urgent"]),
    sentimentScore: z31.number(),
    keyTopics: z31.array(z31.string()),
    actionItemsDetected: z31.boolean(),
    actionItems: z31.array(z31.string()).optional(),
    priority: z31.enum(["high", "medium", "low"]),
    suggestedCategory: z31.string().optional()
  }).optional().nullable()
});
var completeResponseSchema = z31.object({
  messageId: z31.string().min(1, "Message ID is required"),
  messageContent: z31.string().min(1, "Message content is required"),
  contextHistory: z31.array(z31.object({
    sender: z31.string(),
    content: z31.string(),
    timestamp: z31.date()
  })).optional().default([])
});
var followUpSchema = z31.object({
  messageId: z31.string().min(1, "Message ID is required"),
  emailAnalysis: z31.object({
    messageId: z31.string(),
    sentiment: z31.enum(["positive", "neutral", "negative", "urgent"]),
    sentimentScore: z31.number(),
    keyTopics: z31.array(z31.string()),
    actionItemsDetected: z31.boolean(),
    actionItems: z31.array(z31.string()).optional(),
    priority: z31.enum(["high", "medium", "low"]),
    suggestedCategory: z31.string().optional()
  })
});
var logger94 = new Logger("InboxAIController");
function registerInboxAIControllerRoutes(app2, inboxAiService) {
  const BASE_PATH = "/api/ai/inbox";
  app2.post(
    `${BASE_PATH}/analyze`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = analyzeEmailSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { messageId, messageContent } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const analysis = await inboxAiService.analyzeEmail(messageId, messageContent, userId);
        return res.status(200).json({
          success: true,
          data: analysis
        });
      } catch (error) {
        logger94.error("Error in email analysis endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error analyzing email",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/suggestions`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = responseSuggestionsSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { messageId, messageContent, emailAnalysis } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const suggestions = await inboxAiService.generateResponseSuggestions(
          messageId,
          messageContent,
          emailAnalysis,
          userId
        );
        return res.status(200).json({
          success: true,
          data: suggestions
        });
      } catch (error) {
        logger94.error("Error in response suggestions endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error generating response suggestions",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/complete-response`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = completeResponseSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { messageId, messageContent, contextHistory } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const response = await inboxAiService.generateCompleteResponse(
          messageId,
          messageContent,
          contextHistory,
          userId
        );
        return res.status(200).json({
          success: true,
          data: response
        });
      } catch (error) {
        logger94.error("Error in complete response endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error generating complete response",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/followup`,
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.companyGuard(),
    async (req, res) => {
      try {
        const validationResult = followUpSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { messageId, emailAnalysis } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const reminders = await inboxAiService.createSmartFollowUpReminders(
          messageId,
          emailAnalysis,
          userId
        );
        return res.status(200).json({
          success: true,
          data: reminders
        });
      } catch (error) {
        logger94.error("Error in follow-up reminders endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error creating follow-up reminders",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  logger94.info("Inbox AI controller routes registered");
}

// server/modules/ai/controllers/product-qa.controller.ts
init_logger();
init_auth_guard();
init_auth_mode_enum();
import { z as z32 } from "zod";
var productQuestionSchema = z32.object({
  question: z32.string().min(1, "Question is required"),
  productId: z32.string().nullable().optional()
});
var productComparisonSchema = z32.object({
  productIds: z32.array(z32.string()).min(2, "At least 2 product IDs are required")
});
var documentationSearchSchema = z32.object({
  query: z32.string().min(1, "Search query is required"),
  filters: z32.object({
    productId: z32.string().optional(),
    documentType: z32.enum(["user_guide", "technical_manual", "tutorial", "api_doc"]).optional(),
    dateRange: z32.object({
      start: z32.date(),
      end: z32.date()
    }).optional()
  }).optional()
});
var usageSuggestionsSchema = z32.object({
  productId: z32.string().min(1, "Product ID is required"),
  featureId: z32.string().nullable().optional(),
  userContext: z32.object({
    role: z32.string(),
    experience: z32.enum(["beginner", "intermediate", "advanced"]),
    usageHistory: z32.array(z32.string()).optional()
  }).nullable().optional()
});
var logger95 = new Logger("ProductQAController");
function registerProductQAControllerRoutes(app2, productQaService) {
  const BASE_PATH = "/api/ai/product-qa";
  app2.post(
    `${BASE_PATH}/answer`,
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const validationResult = productQuestionSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { question, productId } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const answer = await productQaService.answerProductQuestion(
          question,
          productId || null,
          userId
        );
        return res.status(200).json({
          success: true,
          data: answer
        });
      } catch (error) {
        logger95.error("Error in product question answering endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error answering product question",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/compare`,
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const validationResult = productComparisonSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { productIds } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const comparison = await productQaService.compareProducts(productIds, userId);
        return res.status(200).json({
          success: true,
          data: comparison
        });
      } catch (error) {
        logger95.error("Error in product comparison endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error comparing products",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/search`,
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const validationResult = documentationSearchSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { query, filters = {} } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const searchResults = await productQaService.searchProductDocumentation(
          query,
          filters,
          userId
        );
        return res.status(200).json({
          success: true,
          data: searchResults
        });
      } catch (error) {
        logger95.error("Error in documentation search endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error searching documentation",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  app2.post(
    `${BASE_PATH}/suggestions`,
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const validationResult = usageSuggestionsSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: validationResult.error.errors
          });
        }
        const { productId, featureId = null, userContext = null } = validationResult.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(400).json({
            success: false,
            message: "User ID is required"
          });
        }
        const suggestions = await productQaService.generateUsageSuggestions(
          productId,
          featureId,
          userContext,
          userId
        );
        return res.status(200).json({
          success: true,
          data: suggestions
        });
      } catch (error) {
        logger95.error("Error in usage suggestions endpoint", error);
        return res.status(500).json({
          success: false,
          message: "Error generating usage suggestions",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  logger95.info("Product QA controller routes registered");
}

// server/modules/ai/ai.module.ts
var logger96 = new Logger("AIModule");
function initAiModule(app2, drizzleService5) {
  logger96.info("Initializing AI module...");
  const aiService = new AIService(drizzleService5);
  const openAiService = new OpenAiService(drizzleService5);
  const salesAiService = new SalesAiService(drizzleService5);
  const inboxAiAssistantService = new InboxAiAssistantService(drizzleService5);
  const productQaService = new ProductQaService(drizzleService5);
  registerAIControllerRoutes(app2, aiService);
  registerOpenAIControllerRoutes(app2, openAiService);
  registerSalesAIControllerRoutes(app2, salesAiService);
  registerInboxAIControllerRoutes(app2, inboxAiAssistantService);
  registerProductQAControllerRoutes(app2, productQaService);
  app2.use((req, res, next) => {
    req.services = {
      ...req.services,
      aiService,
      openAiService,
      salesAiService,
      inboxAiAssistantService,
      productQaService
    };
    next();
  });
  logger96.info("AI module initialized successfully");
  return {
    aiService,
    openAiService,
    salesAiService,
    inboxAiAssistantService,
    productQaService
  };
}

// server/modules/settings/settings.module.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router33 } from "express";

// server/modules/settings/services/global-settings.service.ts
init_drizzle_service();

// server/modules/settings/schema/settings.schema.ts
import {
  pgTable as pgTable20,
  uuid as uuid19,
  text as text20,
  timestamp as timestamp20,
  boolean as boolean17,
  jsonb as jsonb6,
  varchar as varchar11,
  index as index9
} from "drizzle-orm/pg-core";

// server/modules/company/schema/company.schema.ts
import { relations as relations6 } from "drizzle-orm";
import {
  pgTable as pgTable19,
  uuid as uuid18,
  timestamp as timestamp19,
  text as text19,
  varchar as varchar10,
  pgEnum as pgEnum9,
  decimal as decimal2
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema13 } from "drizzle-zod";
import { z as z33 } from "zod";
var CompanyType = /* @__PURE__ */ ((CompanyType2) => {
  CompanyType2["HEADQUARTERS"] = "headquarters";
  CompanyType2["SUBSIDIARY"] = "subsidiary";
  CompanyType2["FRANCHISE"] = "franchise";
  return CompanyType2;
})(CompanyType || {});
var companyTypeEnum = pgEnum9("company_type", Object.values(CompanyType));
var companies2 = pgTable19("companies", {
  id: uuid18("id").primaryKey().notNull().defaultRandom(),
  name: varchar10("name", { length: 255 }).notNull(),
  type: companyTypeEnum("type").notNull().default("headquarters" /* HEADQUARTERS */),
  parentId: uuid18("parent_id").references(() => companies2.id),
  fiscalCode: varchar10("fiscal_code", { length: 50 }).notNull(),
  // CUI / Cod fiscal
  registrationNumber: varchar10("registration_number", { length: 50 }).notNull(),
  // Număr registrul comerțului
  address: text19("address"),
  city: varchar10("city", { length: 100 }),
  county: varchar10("county", { length: 100 }),
  country: varchar10("country", { length: 100 }).default("Romania"),
  postalCode: varchar10("postal_code", { length: 20 }),
  phone: varchar10("phone", { length: 20 }),
  email: varchar10("email", { length: 255 }),
  website: varchar10("website", { length: 255 }),
  bankName: varchar10("bank_name", { length: 100 }),
  bankAccount: varchar10("bank_account", { length: 50 }),
  socialCapital: decimal2("social_capital", { precision: 15, scale: 2 }),
  logo: text19("logo_url"),
  // Coloana din baza de date este 'logo_url'
  settings: text19("settings"),
  createdAt: timestamp19("created_at", { mode: "string" }).notNull().defaultNow(),
  updatedAt: timestamp19("updated_at", { mode: "string" }).notNull().defaultNow(),
  createdBy: uuid18("created_by"),
  updatedBy: uuid18("updated_by"),
  deletedAt: timestamp19("deleted_at", { mode: "string" })
});
var companiesRelations = relations6(companies2, ({ one, many }) => ({
  parent: one(companies2, {
    fields: [companies2.parentId],
    references: [companies2.id]
  }),
  children: many(companies2)
}));
var insertCompanySchema2 = createInsertSchema13(companies2).omit({ id: true, createdAt: true, updatedAt: true, deletedAt: true }).extend({
  type: z33.nativeEnum(CompanyType).optional()
});

// server/modules/settings/schema/settings.schema.ts
init_schema4();
var globalSettings = pgTable20("settings_global", {
  id: uuid19("id").defaultRandom().primaryKey(),
  companyId: uuid19("company_id").references(() => companies2.id),
  key: varchar11("key", { length: 100 }).notNull(),
  value: jsonb6("value").notNull(),
  category: varchar11("category", { length: 50 }).notNull(),
  module: varchar11("module", { length: 50 }),
  description: text20("description"),
  isSystemWide: boolean17("is_system_wide").default(false),
  createdAt: timestamp20("created_at").defaultNow().notNull(),
  updatedAt: timestamp20("updated_at").defaultNow().notNull(),
  createdBy: uuid19("created_by").references(() => users.id),
  updatedBy: uuid19("updated_by").references(() => users.id)
}, (table) => ({
  keyCompanyIdx: index9("settings_global_key_company_idx").on(table.key, table.companyId),
  moduleCompanyIdx: index9("settings_global_module_company_idx").on(table.module, table.companyId)
}));
var userPreferences = pgTable20("settings_user_preferences", {
  id: uuid19("id").defaultRandom().primaryKey(),
  userId: uuid19("user_id").references(() => users.id).notNull(),
  companyId: uuid19("company_id").references(() => companies2.id),
  key: varchar11("key", { length: 100 }).notNull(),
  value: jsonb6("value").notNull(),
  category: varchar11("category", { length: 50 }).notNull(),
  module: varchar11("module", { length: 50 }),
  createdAt: timestamp20("created_at").defaultNow().notNull(),
  updatedAt: timestamp20("updated_at").defaultNow().notNull()
}, (table) => ({
  userKeyIdx: index9("settings_user_preferences_user_key_idx").on(table.userId, table.key),
  userModuleIdx: index9("settings_user_preferences_user_module_idx").on(table.userId, table.module)
}));
var featureToggles = pgTable20("settings_feature_toggles", {
  id: uuid19("id").defaultRandom().primaryKey(),
  companyId: uuid19("company_id").references(() => companies2.id),
  feature: varchar11("feature", { length: 100 }).notNull(),
  enabled: boolean17("enabled").default(false).notNull(),
  module: varchar11("module", { length: 50 }).notNull(),
  description: text20("description"),
  metadata: jsonb6("metadata"),
  createdAt: timestamp20("created_at").defaultNow().notNull(),
  updatedAt: timestamp20("updated_at").defaultNow().notNull(),
  createdBy: uuid19("created_by").references(() => users.id),
  updatedBy: uuid19("updated_by").references(() => users.id)
}, (table) => ({
  featureCompanyIdx: index9("settings_feature_toggles_feature_company_idx").on(table.feature, table.companyId),
  moduleCompanyIdx: index9("settings_feature_toggles_module_company_idx").on(table.module, table.companyId)
}));
var uiThemes = pgTable20("settings_ui_themes", {
  id: uuid19("id").defaultRandom().primaryKey(),
  companyId: uuid19("company_id").references(() => companies2.id),
  name: varchar11("name", { length: 100 }).notNull(),
  isDefault: boolean17("is_default").default(false),
  colors: jsonb6("colors").notNull(),
  fonts: jsonb6("fonts"),
  logos: jsonb6("logos"),
  customCss: text20("custom_css"),
  createdAt: timestamp20("created_at").defaultNow().notNull(),
  updatedAt: timestamp20("updated_at").defaultNow().notNull(),
  createdBy: uuid19("created_by").references(() => users.id),
  updatedBy: uuid19("updated_by").references(() => users.id)
});
var setupSteps = pgTable20("setup_steps", {
  id: uuid19("id").defaultRandom().primaryKey(),
  companyId: uuid19("company_id").references(() => companies2.id).notNull(),
  franchiseId: uuid19("franchise_id").references(() => companies2.id),
  step: varchar11("step", { length: 100 }).notNull(),
  status: varchar11("status", { length: 20 }).notNull().default("not_started"),
  metadata: jsonb6("metadata"),
  completedAt: timestamp20("completed_at"),
  createdAt: timestamp20("created_at").defaultNow().notNull(),
  updatedAt: timestamp20("updated_at").defaultNow().notNull(),
  createdBy: uuid19("created_by").references(() => users.id),
  updatedBy: uuid19("updated_by").references(() => users.id)
}, (table) => ({
  companyStepIdx: index9("setup_steps_company_step_idx").on(table.companyId, table.step),
  franchiseStepIdx: index9("setup_steps_franchise_step_idx").on(table.franchiseId, table.step)
}));

// server/modules/settings/services/global-settings.service.ts
init_logger();
import { eq as eq66 } from "drizzle-orm";
var GlobalSettingsService = class _GlobalSettingsService {
  constructor(drizzleService5) {
    this.logger = new Logger("GlobalSettingsService");
    this.drizzle = drizzleService5 || new DrizzleService();
  }
  /**
   * Get the singleton instance of the GlobalSettingsService
   */
  static getInstance(drizzleService5) {
    if (!_GlobalSettingsService.instance) {
      _GlobalSettingsService.instance = new _GlobalSettingsService(drizzleService5);
    }
    return _GlobalSettingsService.instance;
  }
  /**
   * Get a global setting by key
   * 
   * @param key The setting key
   * @param companyId Optional company ID for company-specific settings
   * @returns The setting value or null if not found
   */
  async getSetting(key, companyId) {
    try {
      this.logger.debug(`Getting setting by key: ${key}, companyId: ${companyId || "system-wide"}`);
      let query = this.drizzle.select().from(globalSettings).where(eq66(globalSettings.key, key));
      if (companyId) {
        query = query.where(eq66(globalSettings.companyId, companyId));
      } else {
        query = query.where(eq66(globalSettings.isSystemWide, true));
      }
      const result = await query.limit(1);
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      this.logger.error("Error getting global setting:", error);
      throw error;
    }
  }
  /**
   * Get all settings in a category
   * 
   * @param category The settings category
   * @param companyId Optional company ID for company-specific settings
   * @returns An array of settings in the category
   */
  async getSettingsByCategory(category, companyId) {
    try {
      this.logger.debug(`Getting settings by category: ${category}, companyId: ${companyId || "system-wide"}`);
      let query = this.drizzle.select().from(globalSettings).where(eq66(globalSettings.category, category));
      if (companyId) {
        query = query.where(eq66(globalSettings.companyId, companyId));
      } else {
        query = query.where(eq66(globalSettings.isSystemWide, true));
      }
      return await query;
    } catch (error) {
      this.logger.error("Error getting settings by category:", error);
      throw error;
    }
  }
  /**
   * Get all settings for a module
   * 
   * @param module The module name
   * @param companyId Optional company ID for company-specific settings
   * @returns An array of settings for the module
   */
  async getSettingsByModule(module, companyId) {
    try {
      this.logger.debug(`Getting settings by module: ${module}, companyId: ${companyId || "system-wide"}`);
      let query = this.drizzle.select().from(globalSettings).where(eq66(globalSettings.module, module));
      if (companyId) {
        query = query.where(eq66(globalSettings.companyId, companyId));
      } else {
        query = query.where(eq66(globalSettings.isSystemWide, true));
      }
      return await query;
    } catch (error) {
      this.logger.error("Error getting settings by module:", error);
      throw error;
    }
  }
  /**
   * Create a new global setting
   * 
   * @param data The setting data
   * @returns The created setting
   */
  async createSetting(data) {
    try {
      this.logger.debug(`Creating setting: ${data.key}`);
      const result = await this.drizzle.insert(globalSettings).values(data).returning();
      return result[0];
    } catch (error) {
      this.logger.error("Error creating global setting:", error);
      throw error;
    }
  }
  /**
   * Update an existing global setting
   * 
   * @param id The setting ID
   * @param data The updated setting data
   * @returns The updated setting
   */
  async updateSetting(id, data) {
    try {
      this.logger.debug(`Updating setting with ID: ${id}`);
      const updateData = {
        ...data,
        updatedAt: /* @__PURE__ */ new Date()
      };
      const result = await this.drizzle.update(globalSettings).set(updateData).where(eq66(globalSettings.id, id)).returning();
      return result[0];
    } catch (error) {
      this.logger.error("Error updating global setting:", error);
      throw error;
    }
  }
  /**
   * Delete a global setting
   * 
   * @param id The setting ID
   * @returns The deleted setting
   */
  async deleteSetting(id) {
    try {
      this.logger.debug(`Deleting setting with ID: ${id}`);
      const result = await this.drizzle.delete(globalSettings).where(eq66(globalSettings.id, id)).returning();
      return result[0];
    } catch (error) {
      this.logger.error("Error deleting global setting:", error);
      throw error;
    }
  }
};

// server/modules/settings/controllers/global-settings.controller.ts
init_logger();
var GlobalSettingsController = class {
  constructor(globalSettingsService) {
    this.logger = new Logger("GlobalSettingsController");
    this.service = globalSettingsService || GlobalSettingsService.getInstance();
  }
  /**
   * Get a setting by key
   */
  async getSetting(req, res) {
    try {
      const { key } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to get setting: ${key}, companyId: ${companyId || "system-wide"}`);
      const setting = await this.service.getSetting(
        key,
        companyId
      );
      if (!setting) {
        this.logger.debug(`Setting not found: ${key}`);
        res.status(404).json({ error: "Setting not found" });
        return;
      }
      res.status(200).json(setting);
    } catch (error) {
      this.logger.error("Error in getSetting:", error);
      res.status(500).json({ error: "Failed to retrieve setting" });
    }
  }
  /**
   * Get settings by category
   */
  async getSettingsByCategory(req, res) {
    try {
      const { category } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to get settings by category: ${category}, companyId: ${companyId || "system-wide"}`);
      const settings = await this.service.getSettingsByCategory(
        category,
        companyId
      );
      res.status(200).json(settings);
    } catch (error) {
      this.logger.error("Error in getSettingsByCategory:", error);
      res.status(500).json({ error: "Failed to retrieve settings by category" });
    }
  }
  /**
   * Create a new setting
   */
  async createSetting(req, res) {
    try {
      const settingData = req.body;
      if (!settingData.key || !settingData.value || !settingData.category) {
        this.logger.warn("Missing required fields in createSetting request");
        res.status(400).json({ error: "Missing required fields (key, value, category)" });
        return;
      }
      this.logger.debug(`Request to create setting: ${settingData.key}`);
      const result = await this.service.createSetting(settingData);
      res.status(201).json(result);
    } catch (error) {
      this.logger.error("Error in createSetting:", error);
      res.status(500).json({ error: "Failed to create setting" });
    }
  }
  /**
   * Update an existing setting
   */
  async updateSetting(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;
      this.logger.debug(`Request to update setting with ID: ${id}`);
      const result = await this.service.updateSetting(id, updateData);
      if (!result) {
        this.logger.warn(`Setting not found for update: ${id}`);
        res.status(404).json({ error: "Setting not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in updateSetting:", error);
      res.status(500).json({ error: "Failed to update setting" });
    }
  }
  /**
   * Delete a setting
   */
  async deleteSetting(req, res) {
    try {
      const { id } = req.params;
      this.logger.debug(`Request to delete setting with ID: ${id}`);
      const result = await this.service.deleteSetting(id);
      if (!result) {
        this.logger.warn(`Setting not found for deletion: ${id}`);
        res.status(404).json({ error: "Setting not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in deleteSetting:", error);
      res.status(500).json({ error: "Failed to delete setting" });
    }
  }
};

// server/modules/settings/services/feature-toggle.service.ts
init_drizzle_service();
init_logger();
import { eq as eq67 } from "drizzle-orm";
var FeatureToggleService = class _FeatureToggleService {
  // 1 minute in milliseconds
  constructor(drizzleService5) {
    // In-memory cache for commonly accessed toggles
    this.cache = /* @__PURE__ */ new Map();
    this.CACHE_TTL = 60 * 1e3;
    this.logger = new Logger("FeatureToggleService");
    this.drizzle = drizzleService5 || new DrizzleService();
  }
  /**
   * Get the singleton instance of the FeatureToggleService
   */
  static getInstance(drizzleService5) {
    if (!_FeatureToggleService.instance) {
      _FeatureToggleService.instance = new _FeatureToggleService(drizzleService5);
    }
    return _FeatureToggleService.instance;
  }
  /**
   * Generate a cache key for a feature toggle
   * 
   * @param feature The feature name
   * @param companyId Optional company ID
   * @returns The cache key
   */
  getCacheKey(feature, companyId) {
    return `${feature}:${companyId || "global"}`;
  }
  /**
   * Store a feature toggle in the cache
   * 
   * @param feature The feature name
   * @param value The toggle value (enabled/disabled)
   * @param companyId Optional company ID
   */
  cacheToggle(feature, value, companyId) {
    const key = this.getCacheKey(feature, companyId);
    this.cache.set(key, {
      value,
      expiry: Date.now() + this.CACHE_TTL
    });
    this.logger.debug(`Cached feature toggle: ${key} = ${value}`);
  }
  /**
   * Get a cached feature toggle value if available
   * 
   * @param feature The feature name
   * @param companyId Optional company ID
   * @returns The cached value or undefined if not in cache or expired
   */
  getCachedToggle(feature, companyId) {
    const key = this.getCacheKey(feature, companyId);
    const cached = this.cache.get(key);
    if (cached && cached.expiry > Date.now()) {
      this.logger.debug(`Cache hit for feature toggle: ${key} = ${cached.value}`);
      return cached.value;
    }
    if (cached) {
      this.logger.debug(`Removing expired cache entry for feature toggle: ${key}`);
      this.cache.delete(key);
    }
    return void 0;
  }
  /**
   * Check if a feature is enabled
   * 
   * @param feature The feature name
   * @param companyId Optional company ID for company-specific toggles
   * @returns True if the feature is enabled, false otherwise
   */
  async isFeatureEnabled(feature, companyId) {
    const cachedValue = this.getCachedToggle(feature, companyId);
    if (cachedValue !== void 0) {
      return cachedValue;
    }
    try {
      this.logger.debug(`Checking if feature is enabled: ${feature}, companyId: ${companyId || "global"}`);
      let query = this.drizzle.select().from(featureToggles).where(eq67(featureToggles.feature, feature));
      if (companyId) {
        query = query.where(eq67(featureToggles.companyId, companyId));
      } else {
        query = query.where(eq67(featureToggles.companyId, null));
      }
      const result = await query.limit(1);
      const isEnabled = result.length > 0 ? result[0].enabled : false;
      this.cacheToggle(feature, isEnabled, companyId);
      return isEnabled;
    } catch (error) {
      this.logger.error("Error checking feature toggle:", error);
      return false;
    }
  }
  /**
   * Get all feature toggles for a module
   * 
   * @param module The module name
   * @param companyId Optional company ID for company-specific toggles
   * @returns An array of feature toggles for the module
   */
  async getFeaturesByModule(module, companyId) {
    try {
      this.logger.debug(`Getting features for module: ${module}, companyId: ${companyId || "global"}`);
      let query = this.drizzle.select().from(featureToggles).where(eq67(featureToggles.module, module));
      if (companyId) {
        query = query.where(eq67(featureToggles.companyId, companyId));
      } else {
        query = query.where(eq67(featureToggles.companyId, null));
      }
      return await query;
    } catch (error) {
      this.logger.error("Error getting features by module:", error);
      throw error;
    }
  }
  /**
   * Get all feature toggles for a company
   * 
   * @param companyId The company ID
   * @returns An array of feature toggles for the company
   */
  async getCompanyFeatures(companyId) {
    try {
      this.logger.debug(`Getting features for company: ${companyId}`);
      const result = await this.drizzle.select().from(featureToggles).where(eq67(featureToggles.companyId, companyId));
      return result;
    } catch (error) {
      this.logger.error("Error getting company features:", error);
      throw error;
    }
  }
  /**
   * Create a new feature toggle
   * 
   * @param data The feature toggle data
   * @returns The created feature toggle
   */
  async createFeatureToggle(data) {
    try {
      this.logger.debug(`Creating feature toggle: ${data.feature}`);
      const result = await this.drizzle.insert(featureToggles).values(data).returning();
      if (result[0]) {
        const key = this.getCacheKey(result[0].feature, result[0].companyId || void 0);
        this.cache.delete(key);
      }
      return result[0];
    } catch (error) {
      this.logger.error("Error creating feature toggle:", error);
      throw error;
    }
  }
  /**
   * Update an existing feature toggle
   * 
   * @param id The feature toggle ID
   * @param data The updated feature toggle data
   * @returns The updated feature toggle
   */
  async updateFeatureToggle(id, data) {
    try {
      this.logger.debug(`Updating feature toggle with ID: ${id}`);
      const currentToggle = await this.drizzle.select().from(featureToggles).where(eq67(featureToggles.id, id)).limit(1);
      const updateData = {
        ...data,
        updatedAt: /* @__PURE__ */ new Date()
      };
      const result = await this.drizzle.update(featureToggles).set(updateData).where(eq67(featureToggles.id, id)).returning();
      if (currentToggle.length > 0) {
        const feature = currentToggle[0];
        const key = this.getCacheKey(feature.feature, feature.companyId || void 0);
        this.cache.delete(key);
        this.logger.debug(`Cleared cache for feature toggle: ${key}`);
      }
      return result[0];
    } catch (error) {
      this.logger.error("Error updating feature toggle:", error);
      throw error;
    }
  }
  /**
   * Enable a feature toggle
   * 
   * @param id The feature toggle ID
   * @param userId The user ID who enabled the feature
   * @returns The updated feature toggle
   */
  async enableFeature(id, userId) {
    this.logger.debug(`Enabling feature toggle ${id} by user ${userId}`);
    return this.updateFeatureToggle(id, { enabled: true, updatedBy: userId });
  }
  /**
   * Disable a feature toggle
   * 
   * @param id The feature toggle ID
   * @param userId The user ID who disabled the feature
   * @returns The updated feature toggle
   */
  async disableFeature(id, userId) {
    this.logger.debug(`Disabling feature toggle ${id} by user ${userId}`);
    return this.updateFeatureToggle(id, { enabled: false, updatedBy: userId });
  }
  /**
   * Delete a feature toggle
   * 
   * @param id The feature toggle ID
   * @returns The deleted feature toggle
   */
  async deleteFeatureToggle(id) {
    try {
      this.logger.debug(`Deleting feature toggle with ID: ${id}`);
      const currentToggle = await this.drizzle.select().from(featureToggles).where(eq67(featureToggles.id, id)).limit(1);
      const result = await this.drizzle.delete(featureToggles).where(eq67(featureToggles.id, id)).returning();
      if (currentToggle.length > 0) {
        const feature = currentToggle[0];
        const key = this.getCacheKey(feature.feature, feature.companyId || void 0);
        this.cache.delete(key);
        this.logger.debug(`Cleared cache for deleted feature toggle: ${key}`);
      }
      return result[0];
    } catch (error) {
      this.logger.error("Error deleting feature toggle:", error);
      throw error;
    }
  }
};

// server/modules/settings/controllers/feature-toggle.controller.ts
init_logger();
var FeatureToggleController = class {
  constructor(featureToggleService) {
    this.logger = new Logger("FeatureToggleController");
    this.service = featureToggleService || FeatureToggleService.getInstance();
  }
  /**
   * Check if a feature is enabled
   */
  async isFeatureEnabled(req, res) {
    try {
      const { feature } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to check feature: ${feature}, companyId: ${companyId || "global"}`);
      const isEnabled = await this.service.isFeatureEnabled(
        feature,
        companyId
      );
      res.status(200).json({ feature, enabled: isEnabled });
    } catch (error) {
      this.logger.error("Error in isFeatureEnabled:", error);
      res.status(500).json({ error: "Failed to check feature status" });
    }
  }
  /**
   * Get all feature toggles for a module
   */
  async getFeaturesByModule(req, res) {
    try {
      const { module } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to get features for module: ${module}, companyId: ${companyId || "global"}`);
      const features = await this.service.getFeaturesByModule(
        module,
        companyId
      );
      res.status(200).json(features);
    } catch (error) {
      this.logger.error("Error in getFeaturesByModule:", error);
      res.status(500).json({ error: "Failed to retrieve features by module" });
    }
  }
  /**
   * Get all feature toggles for a company
   */
  async getCompanyFeatures(req, res) {
    try {
      const { companyId } = req.params;
      this.logger.debug(`Request to get features for company: ${companyId}`);
      const features = await this.service.getCompanyFeatures(companyId);
      res.status(200).json(features);
    } catch (error) {
      this.logger.error("Error in getCompanyFeatures:", error);
      res.status(500).json({ error: "Failed to retrieve company features" });
    }
  }
  /**
   * Create a new feature toggle
   */
  async createFeatureToggle(req, res) {
    try {
      const toggleData = req.body;
      if (!toggleData.feature || toggleData.enabled === void 0 || !toggleData.module) {
        this.logger.warn("Missing required fields in createFeatureToggle request");
        res.status(400).json({ error: "Missing required fields (feature, enabled, module)" });
        return;
      }
      this.logger.debug(`Request to create feature toggle: ${toggleData.feature}`);
      const result = await this.service.createFeatureToggle(toggleData);
      res.status(201).json(result);
    } catch (error) {
      this.logger.error("Error in createFeatureToggle:", error);
      res.status(500).json({ error: "Failed to create feature toggle" });
    }
  }
  /**
   * Update an existing feature toggle
   */
  async updateFeatureToggle(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;
      this.logger.debug(`Request to update feature toggle with ID: ${id}`);
      const result = await this.service.updateFeatureToggle(id, updateData);
      if (!result) {
        this.logger.warn(`Feature toggle not found for update: ${id}`);
        res.status(404).json({ error: "Feature toggle not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in updateFeatureToggle:", error);
      res.status(500).json({ error: "Failed to update feature toggle" });
    }
  }
  /**
   * Enable a feature toggle
   */
  async enableFeature(req, res) {
    try {
      const { id } = req.params;
      const { userId } = req.body;
      if (!userId) {
        this.logger.warn("Missing userId in enableFeature request");
        res.status(400).json({ error: "User ID is required" });
        return;
      }
      this.logger.debug(`Request to enable feature toggle: ${id} by user: ${userId}`);
      const result = await this.service.enableFeature(id, userId);
      if (!result) {
        this.logger.warn(`Feature toggle not found for enabling: ${id}`);
        res.status(404).json({ error: "Feature toggle not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in enableFeature:", error);
      res.status(500).json({ error: "Failed to enable feature" });
    }
  }
  /**
   * Disable a feature toggle
   */
  async disableFeature(req, res) {
    try {
      const { id } = req.params;
      const { userId } = req.body;
      if (!userId) {
        this.logger.warn("Missing userId in disableFeature request");
        res.status(400).json({ error: "User ID is required" });
        return;
      }
      this.logger.debug(`Request to disable feature toggle: ${id} by user: ${userId}`);
      const result = await this.service.disableFeature(id, userId);
      if (!result) {
        this.logger.warn(`Feature toggle not found for disabling: ${id}`);
        res.status(404).json({ error: "Feature toggle not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in disableFeature:", error);
      res.status(500).json({ error: "Failed to disable feature" });
    }
  }
  /**
   * Delete a feature toggle
   */
  async deleteFeatureToggle(req, res) {
    try {
      const { id } = req.params;
      this.logger.debug(`Request to delete feature toggle with ID: ${id}`);
      const result = await this.service.deleteFeatureToggle(id);
      if (!result) {
        this.logger.warn(`Feature toggle not found for deletion: ${id}`);
        res.status(404).json({ error: "Feature toggle not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in deleteFeatureToggle:", error);
      res.status(500).json({ error: "Failed to delete feature toggle" });
    }
  }
};

// server/modules/settings/services/module-settings.service.ts
init_drizzle_service();
import { eq as eq68, and as and56 } from "drizzle-orm";
init_logger();
var ModuleSettingsService = class _ModuleSettingsService {
  constructor(drizzleService5) {
    this.logger = new Logger("ModuleSettingsService");
    this.drizzle = drizzleService5 || new DrizzleService();
    this.globalSettingsService = GlobalSettingsService.getInstance(this.drizzle);
  }
  /**
   * Get the singleton instance of the ModuleSettingsService
   */
  static getInstance(drizzleService5) {
    if (!_ModuleSettingsService.instance) {
      _ModuleSettingsService.instance = new _ModuleSettingsService(drizzleService5);
    }
    return _ModuleSettingsService.instance;
  }
  /**
   * Get all settings for a specific module
   * 
   * @param moduleName The module name
   * @param companyId Optional company ID for company-specific settings
   * @returns An array of settings for the module
   */
  async getAllModuleSettings(moduleName, companyId) {
    try {
      this.logger.debug(`Getting all settings for module: ${moduleName}, companyId: ${companyId || "N/A"}`);
      let query = this.drizzle.select().from(globalSettings).where(eq68(globalSettings.module, moduleName));
      if (companyId) {
        query = query.where(eq68(globalSettings.companyId, companyId));
      }
      return await query;
    } catch (error) {
      this.logger.error(`Error getting settings for module ${moduleName}:`, error);
      throw error;
    }
  }
  /**
   * Get a specific setting for a module
   * 
   * @param moduleName The module name
   * @param key The setting key
   * @param companyId Optional company ID for company-specific settings
   * @returns The setting value or null if not found
   */
  async getModuleSetting(moduleName, key, companyId) {
    try {
      this.logger.debug(`Getting setting [${key}] for module: ${moduleName}, companyId: ${companyId || "N/A"}`);
      const params = [
        eq68(globalSettings.module, moduleName),
        eq68(globalSettings.key, key)
      ];
      if (companyId) {
        params.push(eq68(globalSettings.companyId, companyId));
      }
      const result = await this.drizzle.select().from(globalSettings).where(and56(...params)).limit(1);
      return result.length > 0 ? result[0] : null;
    } catch (error) {
      this.logger.error(`Error getting setting for module ${moduleName}:`, error);
      throw error;
    }
  }
  /**
   * Create a module setting
   * 
   * @param data The setting data including module field
   * @returns The created setting
   */
  async createModuleSetting(data) {
    if (!data.module) {
      this.logger.error("Module name is required for module settings");
      throw new Error("Module name is required for module settings");
    }
    this.logger.debug(`Creating module setting: ${data.key} for module: ${data.module}`);
    return this.globalSettingsService.createSetting(data);
  }
  /**
   * Update a module setting
   * 
   * @param id The setting ID
   * @param data The updated setting data
   * @returns The updated setting
   */
  async updateModuleSetting(id, data) {
    this.logger.debug(`Updating module setting with ID: ${id}`);
    return this.globalSettingsService.updateSetting(id, data);
  }
  /**
   * Delete a module setting
   * 
   * @param id The setting ID
   * @returns The deleted setting
   */
  async deleteModuleSetting(id) {
    this.logger.debug(`Deleting module setting with ID: ${id}`);
    return this.globalSettingsService.deleteSetting(id);
  }
  /**
   * Register default settings for a module
   * 
   * @param moduleName The module name
   * @param settings Array of default settings for the module
   * @param companyId Optional company ID for company-specific settings
   * @param createdBy Optional user ID who created the settings
   * @returns Array of created settings
   */
  async registerDefaultSettings(moduleName, settings, companyId, createdBy) {
    this.logger.debug(`Registering default settings for module: ${moduleName}, companyId: ${companyId || "N/A"}`);
    const results = [];
    for (const setting of settings) {
      const existingSetting = await this.getModuleSetting(moduleName, setting.key, companyId);
      if (!existingSetting) {
        this.logger.debug(`Creating new default setting: ${setting.key} for module: ${moduleName}`);
        const newSetting = await this.createModuleSetting({
          key: setting.key,
          value: setting.value,
          category: setting.category,
          module: moduleName,
          description: setting.description,
          isSystemWide: setting.isSystemWide || false,
          companyId,
          createdBy,
          updatedBy: createdBy
        });
        results.push(newSetting);
      } else {
        this.logger.debug(`Setting ${setting.key} already exists for module: ${moduleName}`);
      }
    }
    return results;
  }
  /**
   * Get settings for multiple modules
   * 
   * @param moduleNames Array of module names
   * @param companyId Optional company ID for company-specific settings
   * @returns Object with module names as keys and arrays of settings as values
   */
  async getMultiModuleSettings(moduleNames, companyId) {
    try {
      this.logger.debug(`Getting settings for multiple modules: ${moduleNames.join(", ")}, companyId: ${companyId || "N/A"}`);
      const results = {};
      for (const moduleName of moduleNames) {
        results[moduleName] = await this.getAllModuleSettings(moduleName, companyId);
      }
      return results;
    } catch (error) {
      this.logger.error("Error getting multi-module settings:", error);
      throw error;
    }
  }
};

// server/modules/settings/controllers/module-settings.controller.ts
init_logger();
var ModuleSettingsController = class {
  constructor(moduleSettingsService) {
    this.logger = new Logger("ModuleSettingsController");
    this.service = moduleSettingsService || ModuleSettingsService.getInstance();
  }
  /**
   * Get all settings for a specific module
   */
  async getAllModuleSettings(req, res) {
    try {
      const { moduleName } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to get all settings for module: ${moduleName}, companyId: ${companyId || "N/A"}`);
      const settings = await this.service.getAllModuleSettings(
        moduleName,
        companyId
      );
      res.status(200).json(settings);
    } catch (error) {
      this.logger.error("Error in getAllModuleSettings:", error);
      res.status(500).json({ error: "Failed to retrieve module settings" });
    }
  }
  /**
   * Get a specific setting for a module
   */
  async getModuleSetting(req, res) {
    try {
      const { moduleName, key } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to get setting [${key}] for module: ${moduleName}, companyId: ${companyId || "N/A"}`);
      const setting = await this.service.getModuleSetting(
        moduleName,
        key,
        companyId
      );
      if (!setting) {
        this.logger.warn(`Module setting not found: ${moduleName}/${key}`);
        res.status(404).json({ error: "Module setting not found" });
        return;
      }
      res.status(200).json(setting);
    } catch (error) {
      this.logger.error("Error in getModuleSetting:", error);
      res.status(500).json({ error: "Failed to retrieve module setting" });
    }
  }
  /**
   * Create a module setting
   */
  async createModuleSetting(req, res) {
    try {
      const { moduleName } = req.params;
      const settingData = req.body;
      if (!settingData.key || !settingData.value || !settingData.category) {
        this.logger.warn("Missing required fields in createModuleSetting request");
        res.status(400).json({ error: "Missing required fields (key, value, category)" });
        return;
      }
      settingData.module = moduleName;
      this.logger.debug(`Request to create module setting: ${settingData.key} for module: ${moduleName}`);
      const result = await this.service.createModuleSetting(settingData);
      res.status(201).json(result);
    } catch (error) {
      this.logger.error("Error in createModuleSetting:", error);
      res.status(500).json({ error: "Failed to create module setting" });
    }
  }
  /**
   * Update a module setting
   */
  async updateModuleSetting(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;
      this.logger.debug(`Request to update module setting with ID: ${id}`);
      const result = await this.service.updateModuleSetting(id, updateData);
      if (!result) {
        this.logger.warn(`Module setting not found for update: ${id}`);
        res.status(404).json({ error: "Module setting not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in updateModuleSetting:", error);
      res.status(500).json({ error: "Failed to update module setting" });
    }
  }
  /**
   * Delete a module setting
   */
  async deleteModuleSetting(req, res) {
    try {
      const { id } = req.params;
      this.logger.debug(`Request to delete module setting with ID: ${id}`);
      const result = await this.service.deleteModuleSetting(id);
      if (!result) {
        this.logger.warn(`Module setting not found for deletion: ${id}`);
        res.status(404).json({ error: "Module setting not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in deleteModuleSetting:", error);
      res.status(500).json({ error: "Failed to delete module setting" });
    }
  }
  /**
   * Register default settings for a module
   */
  async registerDefaultSettings(req, res) {
    try {
      const { moduleName } = req.params;
      const { companyId, createdBy, settings } = req.body;
      if (!settings || !Array.isArray(settings) || settings.length === 0) {
        this.logger.warn("Missing or invalid settings array in registerDefaultSettings request");
        res.status(400).json({ error: "Valid settings array is required" });
        return;
      }
      this.logger.debug(`Request to register default settings for module: ${moduleName}, count: ${settings.length}`);
      const results = await this.service.registerDefaultSettings(
        moduleName,
        settings,
        companyId,
        createdBy
      );
      res.status(200).json({
        registered: results.length,
        settings: results
      });
    } catch (error) {
      this.logger.error("Error in registerDefaultSettings:", error);
      res.status(500).json({ error: "Failed to register default settings" });
    }
  }
  /**
   * Get settings for multiple modules
   */
  async getMultiModuleSettings(req, res) {
    try {
      const { moduleNames } = req.body;
      const { companyId } = req.query;
      if (!moduleNames || !Array.isArray(moduleNames) || moduleNames.length === 0) {
        this.logger.warn("Missing or invalid moduleNames array in getMultiModuleSettings request");
        res.status(400).json({ error: "Valid moduleNames array is required" });
        return;
      }
      this.logger.debug(`Request to get settings for multiple modules: ${moduleNames.join(", ")}, companyId: ${companyId || "N/A"}`);
      const results = await this.service.getMultiModuleSettings(
        moduleNames,
        companyId
      );
      res.status(200).json(results);
    } catch (error) {
      this.logger.error("Error in getMultiModuleSettings:", error);
      res.status(500).json({ error: "Failed to retrieve multi-module settings" });
    }
  }
};

// server/modules/settings/services/setup.service.ts
init_drizzle_service();
init_id();
init_logger();
import { eq as eq69, and as and57 } from "drizzle-orm";
var SetupService2 = class _SetupService {
  constructor(drizzleService5) {
    this.logger = new Logger("SetupService");
    this.drizzle = drizzleService5 || new DrizzleService();
  }
  /**
   * Get the singleton instance of the SetupService
   */
  static getInstance(drizzleService5) {
    if (!_SetupService.instance) {
      _SetupService.instance = new _SetupService(drizzleService5);
    }
    return _SetupService.instance;
  }
  /**
   * Update or create a setup step for a company/franchise
   * 
   * @param companyId Company ID
   * @param franchiseId Franchise ID (optional)
   * @param step Step identifier
   * @param status Status of the step
   * @returns The result of the database operation
   */
  async updateSetupStep(companyId, step, status, franchiseId) {
    try {
      this.logger.debug(`Updating setup step [${step}] for company: ${companyId}, franchiseId: ${franchiseId || "N/A"}, status: ${status}`);
      const existing = await this.drizzle.select().from(setupSteps).where(
        and57(
          eq69(setupSteps.companyId, companyId),
          eq69(setupSteps.step, step),
          franchiseId ? eq69(setupSteps.franchiseId, franchiseId) : void 0
        )
      ).limit(1);
      if (existing && existing.length > 0) {
        this.logger.debug(`Updating existing setup step: ${existing[0].id}`);
        return await this.drizzle.update(setupSteps).set({
          status,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq69(setupSteps.id, existing[0].id)).returning();
      } else {
        this.logger.debug(`Creating new setup step for: ${step}`);
        return await this.drizzle.insert(setupSteps).values({
          id: createId(),
          companyId,
          franchiseId: franchiseId || null,
          step,
          status,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
      }
    } catch (error) {
      this.logger.error("Error updating setup step:", error);
      throw error;
    }
  }
  /**
   * Check if a specific step is completed
   * 
   * @param companyId Company ID
   * @param step Step identifier
   * @param franchiseId Franchise ID (optional)
   * @returns Boolean indicating if the step is completed
   */
  async isStepComplete(companyId, step, franchiseId) {
    try {
      this.logger.debug(`Checking if step [${step}] is completed for company: ${companyId}, franchiseId: ${franchiseId || "N/A"}`);
      const steps = await this.drizzle.select().from(setupSteps).where(
        and57(
          eq69(setupSteps.companyId, companyId),
          eq69(setupSteps.step, step),
          eq69(setupSteps.status, "completed"),
          franchiseId ? eq69(setupSteps.franchiseId, franchiseId) : void 0
        )
      );
      return steps.length > 0;
    } catch (error) {
      this.logger.error("Error checking step completion:", error);
      return false;
    }
  }
  /**
   * Get all setup steps for a company
   * 
   * @param companyId Company ID
   * @param franchiseId Franchise ID (optional)
   * @returns Array of setup steps
   */
  async getCompanySetupSteps(companyId, franchiseId) {
    try {
      this.logger.debug(`Getting all setup steps for company: ${companyId}, franchiseId: ${franchiseId || "N/A"}`);
      return await this.drizzle.select().from(setupSteps).where(
        and57(
          eq69(setupSteps.companyId, companyId),
          franchiseId ? eq69(setupSteps.franchiseId, franchiseId) : void 0
        )
      ).orderBy(setupSteps.createdAt);
    } catch (error) {
      this.logger.error("Error fetching setup steps:", error);
      throw error;
    }
  }
  /**
   * Get setup progress percentage
   * 
   * @param companyId Company ID
   * @param franchiseId Franchise ID (optional)
   * @returns Percentage of completed steps (0-100)
   */
  async getSetupProgress(companyId, franchiseId) {
    try {
      this.logger.debug(`Calculating setup progress for company: ${companyId}, franchiseId: ${franchiseId || "N/A"}`);
      const totalSteps = await this.drizzle.select().from(setupSteps).where(
        and57(
          eq69(setupSteps.companyId, companyId),
          franchiseId ? eq69(setupSteps.franchiseId, franchiseId) : void 0
        )
      );
      const completedSteps = totalSteps.filter(
        (step) => step.status === "completed" || step.status === "skipped"
      );
      if (totalSteps.length === 0) return 0;
      const progress = Math.round(completedSteps.length / totalSteps.length * 100);
      this.logger.debug(`Setup progress: ${progress}% (${completedSteps.length}/${totalSteps.length} steps completed)`);
      return progress;
    } catch (error) {
      this.logger.error("Error calculating setup progress:", error);
      return 0;
    }
  }
};

// server/modules/settings/controllers/setup.controller.ts
init_logger();
var SetupController = class {
  constructor(setupService) {
    this.logger = new Logger("SetupController");
    this.service = setupService || SetupService2.getInstance();
  }
  /**
   * Update a setup step
   */
  async updateSetupStep(req, res) {
    try {
      const { companyId, step } = req.params;
      const { franchiseId, status } = req.body;
      const validStatuses = ["completed", "in_progress", "not_started", "skipped", "pending"];
      if (!status || !validStatuses.includes(status)) {
        this.logger.warn(`Invalid status value: ${status} for step: ${step}`);
        res.status(400).json({
          error: "Invalid status value",
          validValues: validStatuses
        });
        return;
      }
      this.logger.debug(`Request to update setup step: ${step} for company: ${companyId}, franchiseId: ${franchiseId || "N/A"}, status: ${status}`);
      const result = await this.service.updateSetupStep(
        companyId,
        step,
        status,
        franchiseId
      );
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in updateSetupStep:", error);
      res.status(500).json({ error: "Failed to update setup step" });
    }
  }
  /**
   * Check if a step is completed
   */
  async isStepComplete(req, res) {
    try {
      const { companyId, step } = req.params;
      const { franchiseId } = req.query;
      this.logger.debug(`Request to check if step is completed: ${step} for company: ${companyId}, franchiseId: ${franchiseId || "N/A"}`);
      const isCompleted = await this.service.isStepComplete(
        companyId,
        step,
        franchiseId
      );
      res.status(200).json({ step, completed: isCompleted });
    } catch (error) {
      this.logger.error("Error in isStepComplete:", error);
      res.status(500).json({ error: "Failed to check step completion status" });
    }
  }
  /**
   * Get all setup steps for a company
   */
  async getCompanySetupSteps(req, res) {
    try {
      const { companyId } = req.params;
      const { franchiseId } = req.query;
      this.logger.debug(`Request to get all setup steps for company: ${companyId}, franchiseId: ${franchiseId || "N/A"}`);
      const steps = await this.service.getCompanySetupSteps(
        companyId,
        franchiseId
      );
      res.status(200).json(steps);
    } catch (error) {
      this.logger.error("Error in getCompanySetupSteps:", error);
      res.status(500).json({ error: "Failed to retrieve company setup steps" });
    }
  }
  /**
   * Get setup progress percentage
   */
  async getSetupProgress(req, res) {
    try {
      const { companyId } = req.params;
      const { franchiseId } = req.query;
      this.logger.debug(`Request to get setup progress for company: ${companyId}, franchiseId: ${franchiseId || "N/A"}`);
      const progress = await this.service.getSetupProgress(
        companyId,
        franchiseId
      );
      res.status(200).json({ companyId, franchiseId: franchiseId || null, progress });
    } catch (error) {
      this.logger.error("Error in getSetupProgress:", error);
      res.status(500).json({ error: "Failed to calculate setup progress" });
    }
  }
};

// server/modules/settings/services/user-preferences.service.ts
init_drizzle_service();
init_logger();
import { eq as eq70, and as and58 } from "drizzle-orm";
var UserPreferencesService = class _UserPreferencesService {
  constructor(drizzleService5) {
    this.logger = new Logger("UserPreferencesService");
    this.drizzle = drizzleService5 || new DrizzleService();
  }
  /**
   * Get the singleton instance of the UserPreferencesService
   */
  static getInstance(drizzleService5) {
    if (!_UserPreferencesService.instance) {
      _UserPreferencesService.instance = new _UserPreferencesService(drizzleService5);
    }
    return _UserPreferencesService.instance;
  }
  /**
   * Get a user preference by key
   * 
   * @param userId The user ID
   * @param key The preference key
   * @param companyId Optional company ID for company-specific preferences
   * @returns The preference value or null if not found
   */
  async getPreference(userId, key, companyId) {
    try {
      this.logger.debug(`Getting user preference: ${key} for user: ${userId}, companyId: ${companyId || "N/A"}`);
      let query = this.drizzle.select().from(userPreferences).where(and58(
        eq70(userPreferences.userId, userId),
        eq70(userPreferences.key, key)
      ));
      if (companyId) {
        query = query.where(eq70(userPreferences.companyId, companyId));
      }
      const result = await query.limit(1);
      const preference = result.length > 0 ? result[0] : null;
      this.logger.debug(`User preference ${preference ? "found" : "not found"}: ${key} for user: ${userId}`);
      return preference;
    } catch (error) {
      this.logger.error("Error getting user preference:", error);
      throw error;
    }
  }
  /**
   * Get all preferences for a user
   * 
   * @param userId The user ID
   * @param companyId Optional company ID for company-specific preferences
   * @returns An array of user preferences
   */
  async getUserPreferences(userId, companyId) {
    try {
      this.logger.debug(`Getting all preferences for user: ${userId}, companyId: ${companyId || "N/A"}`);
      let query = this.drizzle.select().from(userPreferences).where(eq70(userPreferences.userId, userId));
      if (companyId) {
        query = query.where(eq70(userPreferences.companyId, companyId));
      }
      const results = await query;
      this.logger.debug(`Found ${results.length} preferences for user: ${userId}`);
      return results;
    } catch (error) {
      this.logger.error("Error getting user preferences:", error);
      throw error;
    }
  }
  /**
   * Get user preferences by category
   * 
   * @param userId The user ID
   * @param category The preference category
   * @param companyId Optional company ID for company-specific preferences
   * @returns An array of user preferences in the category
   */
  async getPreferencesByCategory(userId, category, companyId) {
    try {
      this.logger.debug(`Getting preferences by category: ${category} for user: ${userId}, companyId: ${companyId || "N/A"}`);
      let query = this.drizzle.select().from(userPreferences).where(and58(
        eq70(userPreferences.userId, userId),
        eq70(userPreferences.category, category)
      ));
      if (companyId) {
        query = query.where(eq70(userPreferences.companyId, companyId));
      }
      const results = await query;
      this.logger.debug(`Found ${results.length} preferences in category: ${category} for user: ${userId}`);
      return results;
    } catch (error) {
      this.logger.error("Error getting user preferences by category:", error);
      throw error;
    }
  }
  /**
   * Get user preferences for a module
   * 
   * @param userId The user ID
   * @param module The module name
   * @param companyId Optional company ID for company-specific preferences
   * @returns An array of user preferences for the module
   */
  async getPreferencesByModule(userId, module, companyId) {
    try {
      this.logger.debug(`Getting preferences by module: ${module} for user: ${userId}, companyId: ${companyId || "N/A"}`);
      let query = this.drizzle.select().from(userPreferences).where(and58(
        eq70(userPreferences.userId, userId),
        eq70(userPreferences.module, module)
      ));
      if (companyId) {
        query = query.where(eq70(userPreferences.companyId, companyId));
      }
      const results = await query;
      this.logger.debug(`Found ${results.length} preferences for module: ${module} for user: ${userId}`);
      return results;
    } catch (error) {
      this.logger.error("Error getting user preferences by module:", error);
      throw error;
    }
  }
  /**
   * Create a new user preference
   * 
   * @param data The preference data
   * @returns The created preference
   */
  async createPreference(data) {
    try {
      this.logger.debug(`Creating new user preference: ${data.key} for user: ${data.userId}`);
      const result = await this.drizzle.insert(userPreferences).values(data).returning();
      this.logger.debug(`Created new user preference with ID: ${result[0].id}`);
      return result[0];
    } catch (error) {
      this.logger.error("Error creating user preference:", error);
      throw error;
    }
  }
  /**
   * Update an existing user preference
   * 
   * @param id The preference ID
   * @param data The updated preference data
   * @returns The updated preference
   */
  async updatePreference(id, data) {
    try {
      this.logger.debug(`Updating user preference with ID: ${id}`);
      const updateData = {
        ...data,
        updatedAt: /* @__PURE__ */ new Date()
      };
      const result = await this.drizzle.update(userPreferences).set(updateData).where(eq70(userPreferences.id, id)).returning();
      this.logger.debug(`Updated user preference with ID: ${id}`);
      return result[0];
    } catch (error) {
      this.logger.error("Error updating user preference:", error);
      throw error;
    }
  }
  /**
   * Delete a user preference
   * 
   * @param id The preference ID
   * @returns The deleted preference
   */
  async deletePreference(id) {
    try {
      this.logger.debug(`Deleting user preference with ID: ${id}`);
      const result = await this.drizzle.delete(userPreferences).where(eq70(userPreferences.id, id)).returning();
      this.logger.debug(`Deleted user preference with ID: ${id}`);
      return result[0];
    } catch (error) {
      this.logger.error("Error deleting user preference:", error);
      throw error;
    }
  }
};

// server/modules/settings/controllers/user-preferences.controller.ts
init_logger();
var UserPreferencesController = class {
  constructor(userPreferencesService) {
    this.logger = new Logger("UserPreferencesController");
    this.service = userPreferencesService || UserPreferencesService.getInstance();
  }
  /**
   * Get a user preference by key
   */
  async getPreference(req, res) {
    try {
      const { userId, key } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to get preference ${key} for user: ${userId}, companyId: ${companyId || "N/A"}`);
      const preference = await this.service.getPreference(
        userId,
        key,
        companyId
      );
      if (!preference) {
        this.logger.debug(`Preference not found: ${key} for user: ${userId}`);
        res.status(404).json({ error: "User preference not found" });
        return;
      }
      res.status(200).json(preference);
    } catch (error) {
      this.logger.error("Error in getPreference:", error);
      res.status(500).json({ error: "Failed to retrieve user preference" });
    }
  }
  /**
   * Get all preferences for a user
   */
  async getUserPreferences(req, res) {
    try {
      const { userId } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to get all preferences for user: ${userId}, companyId: ${companyId || "N/A"}`);
      const preferences = await this.service.getUserPreferences(
        userId,
        companyId
      );
      res.status(200).json(preferences);
    } catch (error) {
      this.logger.error("Error in getUserPreferences:", error);
      res.status(500).json({ error: "Failed to retrieve user preferences" });
    }
  }
  /**
   * Get user preferences by category
   */
  async getPreferencesByCategory(req, res) {
    try {
      const { userId, category } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to get preferences by category: ${category} for user: ${userId}, companyId: ${companyId || "N/A"}`);
      const preferences = await this.service.getPreferencesByCategory(
        userId,
        category,
        companyId
      );
      res.status(200).json(preferences);
    } catch (error) {
      this.logger.error("Error in getPreferencesByCategory:", error);
      res.status(500).json({ error: "Failed to retrieve user preferences by category" });
    }
  }
  /**
   * Get user preferences for a module
   */
  async getPreferencesByModule(req, res) {
    try {
      const { userId, module } = req.params;
      const { companyId } = req.query;
      this.logger.debug(`Request to get preferences by module: ${module} for user: ${userId}, companyId: ${companyId || "N/A"}`);
      const preferences = await this.service.getPreferencesByModule(
        userId,
        module,
        companyId
      );
      res.status(200).json(preferences);
    } catch (error) {
      this.logger.error("Error in getPreferencesByModule:", error);
      res.status(500).json({ error: "Failed to retrieve user preferences by module" });
    }
  }
  /**
   * Create a new user preference
   */
  async createPreference(req, res) {
    try {
      const preferenceData = req.body;
      if (!preferenceData.userId || !preferenceData.key || !preferenceData.value || !preferenceData.category) {
        this.logger.warn("Missing required fields in createPreference request");
        res.status(400).json({ error: "Missing required fields (userId, key, value, category)" });
        return;
      }
      this.logger.debug(`Request to create preference: ${preferenceData.key} for user: ${preferenceData.userId}`);
      const result = await this.service.createPreference(preferenceData);
      res.status(201).json(result);
    } catch (error) {
      this.logger.error("Error in createPreference:", error);
      res.status(500).json({ error: "Failed to create user preference" });
    }
  }
  /**
   * Update an existing user preference
   */
  async updatePreference(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;
      this.logger.debug(`Request to update preference with ID: ${id}`);
      const result = await this.service.updatePreference(id, updateData);
      if (!result) {
        this.logger.warn(`Preference not found for update: ${id}`);
        res.status(404).json({ error: "User preference not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in updatePreference:", error);
      res.status(500).json({ error: "Failed to update user preference" });
    }
  }
  /**
   * Delete a user preference
   */
  async deletePreference(req, res) {
    try {
      const { id } = req.params;
      this.logger.debug(`Request to delete preference with ID: ${id}`);
      const result = await this.service.deletePreference(id);
      if (!result) {
        this.logger.warn(`Preference not found for deletion: ${id}`);
        res.status(404).json({ error: "User preference not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in deletePreference:", error);
      res.status(500).json({ error: "Failed to delete user preference" });
    }
  }
};

// server/modules/settings/services/ui-theme.service.ts
init_drizzle_service();
init_logger();
import { eq as eq71, and as and59, not as not5 } from "drizzle-orm";
var UiThemeService = class _UiThemeService {
  constructor(drizzleService5) {
    this.logger = new Logger("UiThemeService");
    this.drizzle = drizzleService5 || new DrizzleService();
  }
  /**
   * Get the singleton instance of the UiThemeService
   */
  static getInstance(drizzleService5) {
    if (!_UiThemeService.instance) {
      _UiThemeService.instance = new _UiThemeService(drizzleService5);
    }
    return _UiThemeService.instance;
  }
  /**
   * Get all themes for a company
   * 
   * @param companyId The company ID
   * @returns An array of UI themes for the company
   */
  async getCompanyThemes(companyId) {
    try {
      this.logger.debug(`Getting UI themes for company: ${companyId}`);
      const result = await this.drizzle.select().from(uiThemes).where(eq71(uiThemes.companyId, companyId));
      this.logger.debug(`Found ${result.length} UI themes for company: ${companyId}`);
      return result;
    } catch (error) {
      this.logger.error("Error getting company themes:", error);
      throw error;
    }
  }
  /**
   * Get the default theme for a company
   * 
   * @param companyId The company ID
   * @returns The default UI theme or null if not found
   */
  async getDefaultTheme(companyId) {
    try {
      this.logger.debug(`Getting default UI theme for company: ${companyId}`);
      const result = await this.drizzle.select().from(uiThemes).where(and59(
        eq71(uiThemes.companyId, companyId),
        eq71(uiThemes.isDefault, true)
      )).limit(1);
      const theme = result.length > 0 ? result[0] : null;
      this.logger.debug(`Default theme ${theme ? "found" : "not found"} for company: ${companyId}`);
      return theme;
    } catch (error) {
      this.logger.error("Error getting default theme:", error);
      throw error;
    }
  }
  /**
   * Get a theme by ID
   * 
   * @param id The theme ID
   * @returns The UI theme or null if not found
   */
  async getThemeById(id) {
    try {
      this.logger.debug(`Getting UI theme by ID: ${id}`);
      const result = await this.drizzle.select().from(uiThemes).where(eq71(uiThemes.id, id)).limit(1);
      const theme = result.length > 0 ? result[0] : null;
      this.logger.debug(`Theme ${theme ? "found" : "not found"} with ID: ${id}`);
      return theme;
    } catch (error) {
      this.logger.error("Error getting theme by ID:", error);
      throw error;
    }
  }
  /**
   * Create a new UI theme
   * 
   * @param data The theme data
   * @returns The created UI theme
   */
  async createTheme(data) {
    try {
      this.logger.debug(`Creating new UI theme for company: ${data.companyId}`);
      if (data.isDefault && data.companyId) {
        this.logger.debug("Clearing other default themes before creating new default theme");
        await this.clearDefaultTheme(data.companyId);
      }
      const result = await this.drizzle.insert(uiThemes).values(data).returning();
      this.logger.debug(`Created new UI theme with ID: ${result[0].id}`);
      return result[0];
    } catch (error) {
      this.logger.error("Error creating UI theme:", error);
      throw error;
    }
  }
  /**
   * Update an existing UI theme
   * 
   * @param id The theme ID
   * @param data The updated theme data
   * @returns The updated UI theme
   */
  async updateTheme(id, data) {
    try {
      this.logger.debug(`Updating UI theme with ID: ${id}`);
      if (data.isDefault) {
        const currentTheme = await this.getThemeById(id);
        if (currentTheme) {
          this.logger.debug(`Clearing other default themes for company: ${currentTheme.companyId}`);
          await this.clearDefaultTheme(currentTheme.companyId, id);
        }
      }
      const updateData = {
        ...data,
        updatedAt: /* @__PURE__ */ new Date()
      };
      const result = await this.drizzle.update(uiThemes).set(updateData).where(eq71(uiThemes.id, id)).returning();
      this.logger.debug(`Updated UI theme with ID: ${id}`);
      return result[0];
    } catch (error) {
      this.logger.error("Error updating UI theme:", error);
      throw error;
    }
  }
  /**
   * Delete a UI theme
   * 
   * @param id The theme ID
   * @returns The deleted UI theme
   */
  async deleteTheme(id) {
    try {
      this.logger.debug(`Deleting UI theme with ID: ${id}`);
      const result = await this.drizzle.delete(uiThemes).where(eq71(uiThemes.id, id)).returning();
      this.logger.debug(`Deleted UI theme with ID: ${id}`);
      return result[0];
    } catch (error) {
      this.logger.error("Error deleting UI theme:", error);
      throw error;
    }
  }
  /**
   * Set a theme as the default for a company
   * 
   * @param id The theme ID
   * @returns The updated UI theme
   */
  async setAsDefault(id) {
    try {
      this.logger.debug(`Setting UI theme with ID: ${id} as default`);
      const theme = await this.getThemeById(id);
      if (!theme) {
        this.logger.error(`Theme not found with ID: ${id}`);
        throw new Error("Theme not found");
      }
      this.logger.debug(`Clearing other default themes for company: ${theme.companyId}`);
      await this.clearDefaultTheme(theme.companyId, id);
      const result = await this.drizzle.update(uiThemes).set({ isDefault: true, updatedAt: /* @__PURE__ */ new Date() }).where(eq71(uiThemes.id, id)).returning();
      this.logger.debug(`Set UI theme with ID: ${id} as default`);
      return result[0];
    } catch (error) {
      this.logger.error("Error setting theme as default:", error);
      throw error;
    }
  }
  /**
   * Clear the default flag from all themes for a company except the specified theme
   * 
   * @param companyId The company ID
   * @param exceptThemeId Optional theme ID to exclude from the update
   */
  async clearDefaultTheme(companyId, exceptThemeId) {
    try {
      this.logger.debug(`Clearing default themes for company: ${companyId}${exceptThemeId ? ", except ID: " + exceptThemeId : ""}`);
      let query = this.drizzle.update(uiThemes).set({ isDefault: false, updatedAt: /* @__PURE__ */ new Date() }).where(and59(
        eq71(uiThemes.companyId, companyId),
        eq71(uiThemes.isDefault, true)
      ));
      if (exceptThemeId) {
        query = query.where(not5(eq71(uiThemes.id, exceptThemeId)));
      }
      await query;
      this.logger.debug("Default themes cleared successfully");
    } catch (error) {
      this.logger.error("Error clearing default theme:", error);
      throw error;
    }
  }
};

// server/modules/settings/controllers/ui-theme.controller.ts
init_logger();
var UiThemeController = class {
  constructor(uiThemeService) {
    this.logger = new Logger("UiThemeController");
    this.service = uiThemeService || UiThemeService.getInstance();
  }
  /**
   * Get all themes for a company
   */
  async getCompanyThemes(req, res) {
    try {
      const { companyId } = req.params;
      this.logger.debug(`Request to get UI themes for company: ${companyId}`);
      const themes = await this.service.getCompanyThemes(companyId);
      res.status(200).json(themes);
    } catch (error) {
      this.logger.error("Error in getCompanyThemes:", error);
      res.status(500).json({ error: "Failed to retrieve company themes" });
    }
  }
  /**
   * Get the default theme for a company
   */
  async getDefaultTheme(req, res) {
    try {
      const { companyId } = req.params;
      this.logger.debug(`Request to get default UI theme for company: ${companyId}`);
      const theme = await this.service.getDefaultTheme(companyId);
      if (!theme) {
        this.logger.debug(`Default theme not found for company: ${companyId}`);
        res.status(404).json({ error: "Default theme not found" });
        return;
      }
      res.status(200).json(theme);
    } catch (error) {
      this.logger.error("Error in getDefaultTheme:", error);
      res.status(500).json({ error: "Failed to retrieve default theme" });
    }
  }
  /**
   * Get a theme by ID
   */
  async getThemeById(req, res) {
    try {
      const { id } = req.params;
      this.logger.debug(`Request to get UI theme by ID: ${id}`);
      const theme = await this.service.getThemeById(id);
      if (!theme) {
        this.logger.debug(`Theme not found with ID: ${id}`);
        res.status(404).json({ error: "UI theme not found" });
        return;
      }
      res.status(200).json(theme);
    } catch (error) {
      this.logger.error("Error in getThemeById:", error);
      res.status(500).json({ error: "Failed to retrieve UI theme" });
    }
  }
  /**
   * Create a new UI theme
   */
  async createTheme(req, res) {
    try {
      const themeData = req.body;
      if (!themeData.companyId || !themeData.name || !themeData.theme) {
        this.logger.warn("Missing required fields in createTheme request");
        res.status(400).json({ error: "Missing required fields (companyId, name, theme)" });
        return;
      }
      this.logger.debug(`Request to create UI theme: ${themeData.name} for company: ${themeData.companyId}`);
      const result = await this.service.createTheme(themeData);
      res.status(201).json(result);
    } catch (error) {
      this.logger.error("Error in createTheme:", error);
      res.status(500).json({ error: "Failed to create UI theme" });
    }
  }
  /**
   * Update an existing UI theme
   */
  async updateTheme(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;
      this.logger.debug(`Request to update UI theme with ID: ${id}`);
      const result = await this.service.updateTheme(id, updateData);
      if (!result) {
        this.logger.warn(`Theme not found for update: ${id}`);
        res.status(404).json({ error: "UI theme not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in updateTheme:", error);
      res.status(500).json({ error: "Failed to update UI theme" });
    }
  }
  /**
   * Delete a UI theme
   */
  async deleteTheme(req, res) {
    try {
      const { id } = req.params;
      this.logger.debug(`Request to delete UI theme with ID: ${id}`);
      const result = await this.service.deleteTheme(id);
      if (!result) {
        this.logger.warn(`Theme not found for deletion: ${id}`);
        res.status(404).json({ error: "UI theme not found" });
        return;
      }
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in deleteTheme:", error);
      res.status(500).json({ error: "Failed to delete UI theme" });
    }
  }
  /**
   * Set a theme as the default for a company
   */
  async setAsDefault(req, res) {
    try {
      const { id } = req.params;
      this.logger.debug(`Request to set UI theme with ID: ${id} as default`);
      const result = await this.service.setAsDefault(id);
      res.status(200).json(result);
    } catch (error) {
      this.logger.error("Error in setAsDefault:", error);
      if (error instanceof Error && error.message === "Theme not found") {
        res.status(404).json({ error: "UI theme not found" });
        return;
      }
      res.status(500).json({ error: "Failed to set UI theme as default" });
    }
  }
};

// server/modules/settings/settings.module.ts
var SettingsModule = class _SettingsModule {
  constructor() {
    this.moduleInfo = {
      name: "Settings Module",
      version: "1.0.0",
      description: "Centralized settings management for all application modules",
      capabilities: [
        {
          name: "global-settings",
          description: "System-wide and company-level configurations"
        },
        {
          name: "user-preferences",
          description: "User-specific preferences and settings"
        },
        {
          name: "feature-toggles",
          description: "Feature flags for enabling/disabling functionality"
        },
        {
          name: "ui-customization",
          description: "UI theming and appearance settings"
        },
        {
          name: "module-settings",
          description: "Module-specific configurations"
        },
        {
          name: "setup-tracking",
          description: "System setup and onboarding progress tracking"
        }
      ]
    };
  }
  /**
   * Register settings module routes with the Express app
   * 
   * @param app Express application instance
   */
  static registerRoutes(app2) {
    console.log("Registering settings module routes...");
    const baseRouter = Router33();
    baseRouter.use(AuthGuard.protect("required" /* REQUIRED */));
    const globalSettingsController = new GlobalSettingsController();
    const featureToggleController = new FeatureToggleController();
    const moduleSettingsController = new ModuleSettingsController();
    const setupController = new SetupController();
    const userPreferencesController = new UserPreferencesController();
    const uiThemeController = new UiThemeController();
    const globalRouter = Router33();
    globalRouter.get("/", (req, res) => {
      if (req.query.category) {
        return globalSettingsController.getSettingsByCategory(req, res);
      } else if (req.query.module) {
        return globalSettingsController.getSettingsByCategory(req, res);
      } else {
        return res.status(400).json({ error: "Must provide category or module parameter" });
      }
    });
    globalRouter.get("/:key", (req, res) => globalSettingsController.getSetting(req, res));
    globalRouter.post("/", (req, res) => globalSettingsController.createSetting(req, res));
    globalRouter.put("/:id", (req, res) => globalSettingsController.updateSetting(req, res));
    globalRouter.delete("/:id", (req, res) => globalSettingsController.deleteSetting(req, res));
    baseRouter.use("/global", globalRouter);
    const featuresRouter = Router33();
    featuresRouter.get("/", (req, res) => {
      if (req.query.module) {
        return featureToggleController.getFeaturesByModule(req, res);
      } else if (req.query.companyId) {
        return featureToggleController.getCompanyFeatures(req, res);
      } else {
        return res.status(400).json({ error: "Must provide module or companyId parameter" });
      }
    });
    featuresRouter.get("/:feature/status", (req, res) => featureToggleController.isFeatureEnabled(req, res));
    featuresRouter.post("/", (req, res) => featureToggleController.createFeatureToggle(req, res));
    featuresRouter.put("/:id/enable", (req, res) => featureToggleController.enableFeature(req, res));
    featuresRouter.put("/:id/disable", (req, res) => featureToggleController.disableFeature(req, res));
    featuresRouter.delete("/:id", (req, res) => featureToggleController.deleteFeatureToggle(req, res));
    baseRouter.use("/features", featuresRouter);
    const modulesRouter = Router33();
    modulesRouter.get("/:moduleName/settings", (req, res) => moduleSettingsController.getAllModuleSettings(req, res));
    modulesRouter.get("/:moduleName/settings/:key", (req, res) => moduleSettingsController.getModuleSetting(req, res));
    modulesRouter.post("/:moduleName/settings", (req, res) => moduleSettingsController.createModuleSetting(req, res));
    modulesRouter.post("/:moduleName/defaults", (req, res) => moduleSettingsController.registerDefaultSettings(req, res));
    baseRouter.use("/modules", modulesRouter);
    baseRouter.get("/multi-modules", (req, res) => {
      const { modules } = req.query;
      if (!modules) {
        return res.status(400).json({ error: "Missing modules parameter" });
      }
      req.body.moduleNames = modules.split(",");
      return moduleSettingsController.getMultiModuleSettings(req, res);
    });
    const setupRouter = Router33();
    setupRouter.get("/", (req, res) => setupController.getCompanySetupSteps(req, res));
    setupRouter.get("/progress/:companyId", (req, res) => setupController.getSetupProgress(req, res));
    setupRouter.get("/:companyId/step/:step/status", (req, res) => setupController.isStepComplete(req, res));
    setupRouter.post("/:companyId/step/:step", (req, res) => setupController.updateSetupStep(req, res));
    baseRouter.use("/setup", setupRouter);
    const preferencesRouter = Router33();
    preferencesRouter.get("/:userId", (req, res) => userPreferencesController.getUserPreferences(req, res));
    preferencesRouter.get("/:userId/category/:category", (req, res) => userPreferencesController.getPreferencesByCategory(req, res));
    preferencesRouter.get("/:userId/module/:module", (req, res) => userPreferencesController.getPreferencesByModule(req, res));
    preferencesRouter.get("/:userId/key/:key", (req, res) => userPreferencesController.getPreference(req, res));
    preferencesRouter.post("/", (req, res) => userPreferencesController.createPreference(req, res));
    preferencesRouter.put("/:id", (req, res) => userPreferencesController.updatePreference(req, res));
    preferencesRouter.delete("/:id", (req, res) => userPreferencesController.deletePreference(req, res));
    baseRouter.use("/user-preferences", preferencesRouter);
    const themesRouter = Router33();
    themesRouter.get("/:companyId", (req, res) => uiThemeController.getCompanyThemes(req, res));
    themesRouter.get("/:companyId/default", (req, res) => uiThemeController.getDefaultTheme(req, res));
    themesRouter.get("/theme/:id", (req, res) => uiThemeController.getThemeById(req, res));
    themesRouter.post("/", (req, res) => uiThemeController.createTheme(req, res));
    themesRouter.put("/:id", (req, res) => uiThemeController.updateTheme(req, res));
    themesRouter.put("/:id/set-default", (req, res) => uiThemeController.setAsDefault(req, res));
    themesRouter.delete("/:id", (req, res) => uiThemeController.deleteTheme(req, res));
    baseRouter.use("/themes", themesRouter);
    app2.use("/api/settings", baseRouter);
    console.log("Settings module routes registered at /api/settings");
    if (!_SettingsModule.instance) {
      _SettingsModule.instance = new _SettingsModule();
    }
    return {
      name: "Settings Module",
      version: "1.0.0",
      description: "Centralized settings management for all application modules",
      capabilities: [
        "global-settings",
        "user-preferences",
        "feature-toggles",
        "ui-customization",
        "module-settings",
        "setup-tracking"
      ]
    };
  }
  /**
   * Initialize the module
   */
  static initialize(app2) {
    return _SettingsModule.registerRoutes(app2);
  }
  /**
   * Get the module information
   */
  getModuleInfo() {
    return this.moduleInfo;
  }
};

// server/modules/marketing/marketing.module.ts
init_logger();
import { Router as Router37 } from "express";

// server/modules/marketing/init.ts
init_logger();
var logger97 = new Logger("MarketingInit");
async function initialize() {
  try {
    logger97.info("Initializing Marketing module...");
    logger97.info("Marketing module initialized successfully");
  } catch (error) {
    logger97.error("Failed to initialize Marketing module", error instanceof Error ? error.message : String(error));
    throw error;
  }
}

// server/modules/marketing/marketing.module.ts
init_auth_guard();
init_auth_mode_enum();

// server/modules/marketing/services/campaign.service.ts
init_logger();
init_drizzle_service();
import { eq as eq72, and as and60, desc as desc32, sql as sql51, like as like12 } from "drizzle-orm";
import { v4 as uuidv434 } from "uuid";

// shared/schema/marketing.schema.ts
import {
  pgTable as pgTable22,
  uuid as uuid21,
  text as text22,
  timestamp as timestamp22,
  pgEnum as pgEnum11,
  json as json10,
  index as index11,
  unique as unique8,
  boolean as boolean19,
  integer as integer13
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema15 } from "drizzle-zod";
import { z as z35 } from "zod";

// shared/schema/communications.schema.ts
import {
  pgTable as pgTable21,
  uuid as uuid20,
  text as text21,
  timestamp as timestamp21,
  pgEnum as pgEnum10,
  json as json9,
  index as index10,
  unique as unique7,
  boolean as boolean18,
  real
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema14 } from "drizzle-zod";
import { z as z34 } from "zod";
var CommunicationChannel = /* @__PURE__ */ ((CommunicationChannel5) => {
  CommunicationChannel5["EMAIL"] = "email";
  CommunicationChannel5["WHATSAPP"] = "whatsapp";
  CommunicationChannel5["MESSENGER"] = "messenger";
  CommunicationChannel5["COMMENT"] = "comment";
  CommunicationChannel5["CALL"] = "call";
  CommunicationChannel5["SHOPIFY_INBOX"] = "shopify-inbox";
  CommunicationChannel5["SMS"] = "sms";
  CommunicationChannel5["CONTACT_FORM"] = "contact-form";
  CommunicationChannel5["CHAT"] = "chat";
  CommunicationChannel5["OTHER"] = "other";
  return CommunicationChannel5;
})(CommunicationChannel || {});
var MessageDirection = /* @__PURE__ */ ((MessageDirection3) => {
  MessageDirection3["INBOUND"] = "inbound";
  MessageDirection3["OUTBOUND"] = "outbound";
  MessageDirection3["INTERNAL"] = "internal";
  return MessageDirection3;
})(MessageDirection || {});
var MessageStatus = /* @__PURE__ */ ((MessageStatus2) => {
  MessageStatus2["NEW"] = "new";
  MessageStatus2["READ"] = "read";
  MessageStatus2["RESPONDED"] = "responded";
  MessageStatus2["ARCHIVED"] = "archived";
  MessageStatus2["SPAM"] = "spam";
  MessageStatus2["DELETED"] = "deleted";
  MessageStatus2["PENDING"] = "pending";
  MessageStatus2["SCHEDULED"] = "scheduled";
  MessageStatus2["DRAFT"] = "draft";
  return MessageStatus2;
})(MessageStatus || {});
var SentimentType = /* @__PURE__ */ ((SentimentType3) => {
  SentimentType3["POSITIVE"] = "positive";
  SentimentType3["NEGATIVE"] = "negative";
  SentimentType3["NEUTRAL"] = "neutral";
  SentimentType3["MIXED"] = "mixed";
  return SentimentType3;
})(SentimentType || {});
var channelEnum = pgEnum10("communication_channel", ["email", "whatsapp", "messenger", "comment", "call", "shopify-inbox", "sms", "contact-form", "chat", "other"]);
var directionEnum = pgEnum10("message_direction", ["inbound", "outbound", "internal"]);
var statusEnum = pgEnum10("message_status", ["new", "read", "responded", "archived", "spam", "deleted", "pending", "scheduled", "draft"]);
var sentimentEnum = pgEnum10("sentiment_type", ["positive", "negative", "neutral", "mixed"]);
var messageThreads = pgTable21("communications_threads", {
  id: uuid20("id").primaryKey().defaultRandom(),
  companyId: uuid20("company_id").notNull(),
  subject: text21("subject"),
  channel: channelEnum("channel").notNull(),
  externalThreadId: text21("external_thread_id"),
  status: statusEnum("status").default("new" /* NEW */),
  lastMessageAt: timestamp21("last_message_at").defaultNow().notNull(),
  assignedTo: uuid20("assigned_to"),
  customerId: uuid20("customer_id"),
  contactId: uuid20("contact_id"),
  metadata: json9("metadata").default({}),
  createdAt: timestamp21("created_at").defaultNow().notNull(),
  updatedAt: timestamp21("updated_at").defaultNow().notNull(),
  createdBy: uuid20("created_by"),
  updatedBy: uuid20("updated_by")
}, (table) => {
  return {
    companyIdIdx: index10("communications_threads_company_id_idx").on(table.companyId),
    channelIdx: index10("communications_threads_channel_idx").on(table.channel),
    customerIdIdx: index10("communications_threads_customer_id_idx").on(table.customerId),
    contactIdIdx: index10("communications_threads_contact_id_idx").on(table.contactId),
    lastMessageAtIdx: index10("communications_threads_last_message_at_idx").on(table.lastMessageAt)
  };
});
var messages = pgTable21("communications_messages", {
  id: uuid20("id").primaryKey().defaultRandom(),
  threadId: uuid20("thread_id").notNull().references(() => messageThreads.id, { onDelete: "cascade" }),
  companyId: uuid20("company_id").notNull(),
  channel: channelEnum("channel").notNull(),
  direction: directionEnum("direction").notNull(),
  status: statusEnum("status").default("new" /* NEW */),
  fromEmail: text21("from_email"),
  fromName: text21("from_name"),
  fromPhone: text21("from_phone"),
  toEmail: text21("to_email"),
  toName: text21("to_name"),
  toPhone: text21("to_phone"),
  subject: text21("subject"),
  body: text21("body").notNull(),
  bodyHtml: text21("body_html"),
  sentiment: sentimentEnum("sentiment"),
  sentimentScore: real("sentiment_score"),
  externalMessageId: text21("external_message_id"),
  externalConversationId: text21("external_conversation_id"),
  isFlagged: boolean18("is_flagged").default(false),
  readAt: timestamp21("read_at"),
  deliveredAt: timestamp21("delivered_at"),
  metadata: json9("metadata").default({}),
  createdAt: timestamp21("created_at").defaultNow().notNull(),
  updatedAt: timestamp21("updated_at").defaultNow().notNull(),
  createdBy: uuid20("created_by"),
  updatedBy: uuid20("updated_by")
}, (table) => {
  return {
    threadIdIdx: index10("communications_messages_thread_id_idx").on(table.threadId),
    companyIdIdx: index10("communications_messages_company_id_idx").on(table.companyId),
    channelIdx: index10("communications_messages_channel_idx").on(table.channel),
    directionIdx: index10("communications_messages_direction_idx").on(table.direction),
    sentimentIdx: index10("communications_messages_sentiment_idx").on(table.sentiment),
    createdAtIdx: index10("communications_messages_created_at_idx").on(table.createdAt)
  };
});
var contacts2 = pgTable21("communications_contacts", {
  id: uuid20("id").primaryKey().defaultRandom(),
  companyId: uuid20("company_id").notNull(),
  customerId: uuid20("customer_id"),
  email: text21("email"),
  phone: text21("phone"),
  firstName: text21("first_name"),
  lastName: text21("last_name"),
  displayName: text21("display_name"),
  company: text21("company"),
  jobTitle: text21("job_title"),
  avatarUrl: text21("avatar_url"),
  socialProfiles: json9("social_profiles").default({}),
  communicationPreferences: json9("communication_preferences").default({}),
  optOut: json9("opt_out").default({}),
  metadata: json9("metadata").default({}),
  externalId: text21("external_id"),
  externalSource: text21("external_source"),
  createdAt: timestamp21("created_at").defaultNow().notNull(),
  updatedAt: timestamp21("updated_at").defaultNow().notNull(),
  createdBy: uuid20("created_by"),
  updatedBy: uuid20("updated_by")
}, (table) => {
  return {
    companyIdIdx: index10("communications_contacts_company_id_idx").on(table.companyId),
    emailIdx: index10("communications_contacts_email_idx").on(table.email),
    phoneIdx: index10("communications_contacts_phone_idx").on(table.phone),
    customerIdIdx: index10("communications_contacts_customer_id_idx").on(table.customerId),
    externalIdIdx: index10("communications_contacts_external_id_idx").on(table.externalId)
  };
});
var channelConfigurations = pgTable21("communications_channel_configs", {
  id: uuid20("id").primaryKey().defaultRandom(),
  name: text21("name").notNull(),
  companyId: uuid20("company_id").notNull(),
  channel: channelEnum("channel").notNull(),
  isActive: boolean18("is_active").default(true),
  credentials: text21("credentials").notNull(),
  // Stored encrypted in production
  settings: json9("settings").default({}),
  webhookUrl: text21("webhook_url"),
  createdAt: timestamp21("created_at").defaultNow().notNull(),
  updatedAt: timestamp21("updated_at").defaultNow().notNull(),
  createdBy: uuid20("created_by"),
  updatedBy: uuid20("updated_by")
}, (table) => {
  return {
    companyIdIdx: index10("communications_channel_configs_company_id_idx").on(table.companyId),
    channelIdx: index10("communications_channel_configs_channel_idx").on(table.channel),
    companyChannelIdx: index10("communications_channel_configs_company_channel_idx").on(table.companyId, table.channel)
  };
});
var messageAccess = pgTable21("communications_message_access", {
  id: uuid20("id").primaryKey().defaultRandom(),
  messageId: uuid20("message_id").notNull().references(() => messages.id, { onDelete: "cascade" }),
  userId: uuid20("user_id").notNull(),
  companyId: uuid20("company_id").notNull(),
  canView: boolean18("can_view").default(true),
  canReply: boolean18("can_reply").default(false),
  canDelete: boolean18("can_delete").default(false),
  createdAt: timestamp21("created_at").defaultNow().notNull(),
  updatedAt: timestamp21("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    messageIdIdx: index10("communications_message_access_message_id_idx").on(table.messageId),
    userIdIdx: index10("communications_message_access_user_id_idx").on(table.userId),
    companyIdIdx: index10("communications_message_access_company_id_idx").on(table.companyId),
    uniqueAccess: unique7("communications_message_access_unique").on(table.messageId, table.userId)
  };
});
var threadAccess = pgTable21("communications_thread_access", {
  id: uuid20("id").primaryKey().defaultRandom(),
  threadId: uuid20("thread_id").notNull().references(() => messageThreads.id, { onDelete: "cascade" }),
  userId: uuid20("user_id").notNull(),
  companyId: uuid20("company_id").notNull(),
  canView: boolean18("can_view").default(true),
  canReply: boolean18("can_reply").default(false),
  canAssign: boolean18("can_assign").default(false),
  canDelete: boolean18("can_delete").default(false),
  createdAt: timestamp21("created_at").defaultNow().notNull(),
  updatedAt: timestamp21("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    threadIdIdx: index10("communications_thread_access_thread_id_idx").on(table.threadId),
    userIdIdx: index10("communications_thread_access_user_id_idx").on(table.userId),
    companyIdIdx: index10("communications_thread_access_company_id_idx").on(table.companyId),
    uniqueAccess: unique7("communications_thread_access_unique").on(table.threadId, table.userId)
  };
});
var insertMessageThreadSchema = createInsertSchema14(messageThreads, {
  id: z34.string().uuid().optional(),
  channel: z34.nativeEnum(CommunicationChannel),
  status: z34.nativeEnum(MessageStatus).optional(),
  createdAt: z34.date().optional(),
  updatedAt: z34.date().optional()
}).omit({ id: true, createdAt: true, updatedAt: true });
var insertMessageSchema = createInsertSchema14(messages, {
  id: z34.string().uuid().optional(),
  channel: z34.nativeEnum(CommunicationChannel),
  direction: z34.nativeEnum(MessageDirection),
  status: z34.nativeEnum(MessageStatus).optional(),
  sentiment: z34.nativeEnum(SentimentType).optional(),
  createdAt: z34.date().optional(),
  updatedAt: z34.date().optional()
}).omit({ id: true, createdAt: true, updatedAt: true });
var insertContactSchema2 = createInsertSchema14(contacts2, {
  id: z34.string().uuid().optional(),
  createdAt: z34.date().optional(),
  updatedAt: z34.date().optional()
}).omit({ id: true, createdAt: true, updatedAt: true });
var insertChannelConfigSchema = createInsertSchema14(channelConfigurations, {
  id: z34.string().uuid().optional(),
  channel: z34.nativeEnum(CommunicationChannel),
  createdAt: z34.date().optional(),
  updatedAt: z34.date().optional()
}).omit({ id: true, createdAt: true, updatedAt: true });

// shared/schema/marketing.schema.ts
var CampaignStatus = /* @__PURE__ */ ((CampaignStatus2) => {
  CampaignStatus2["DRAFT"] = "draft";
  CampaignStatus2["SCHEDULED"] = "scheduled";
  CampaignStatus2["ACTIVE"] = "active";
  CampaignStatus2["PAUSED"] = "paused";
  CampaignStatus2["COMPLETED"] = "completed";
  CampaignStatus2["CANCELLED"] = "cancelled";
  return CampaignStatus2;
})(CampaignStatus || {});
var CampaignType = /* @__PURE__ */ ((CampaignType4) => {
  CampaignType4["EMAIL"] = "email";
  CampaignType4["SMS"] = "sms";
  CampaignType4["SOCIAL"] = "social";
  CampaignType4["PUSH"] = "push";
  CampaignType4["WHATSAPP"] = "whatsapp";
  CampaignType4["MULTI_CHANNEL"] = "multi_channel";
  return CampaignType4;
})(CampaignType || {});
var AudienceType = /* @__PURE__ */ ((AudienceType4) => {
  AudienceType4["SEGMENT"] = "segment";
  AudienceType4["LIST"] = "list";
  AudienceType4["CUSTOM"] = "custom";
  AudienceType4["ALL_CUSTOMERS"] = "all_customers";
  AudienceType4["FILTERED"] = "filtered";
  return AudienceType4;
})(AudienceType || {});
var campaignStatusEnum = pgEnum11("campaign_status", [
  "draft",
  "scheduled",
  "active",
  "paused",
  "completed",
  "cancelled"
]);
var campaignTypeEnum = pgEnum11("campaign_type", [
  "email",
  "sms",
  "social",
  "push",
  "whatsapp",
  "multi_channel"
]);
var audienceTypeEnum = pgEnum11("audience_type", [
  "segment",
  "list",
  "custom",
  "all_customers",
  "filtered"
]);
var campaigns = pgTable22("marketing_campaigns", {
  id: uuid21("id").primaryKey().defaultRandom(),
  companyId: uuid21("company_id").notNull(),
  name: text22("name").notNull(),
  description: text22("description"),
  type: campaignTypeEnum("type").notNull(),
  status: campaignStatusEnum("status").default("draft" /* DRAFT */).notNull(),
  // Content fields
  subject: text22("subject"),
  content: text22("content"),
  contentHtml: text22("content_html"),
  templateId: uuid21("template_id"),
  // Channel configuration
  channels: json10("channels").default([]).notNull(),
  // Array of channel IDs
  primaryChannel: channelEnum("primary_channel"),
  // From communications_schema
  // Schedule fields
  scheduledAt: timestamp22("scheduled_at"),
  startedAt: timestamp22("started_at"),
  completedAt: timestamp22("completed_at"),
  // Audience targeting
  audienceType: audienceTypeEnum("audience_type").notNull(),
  audienceId: uuid21("audience_id"),
  // ID of the segment or list
  audienceFilter: json10("audience_filter").default({}),
  // For filtered audiences
  estimatedReach: integer13("estimated_reach"),
  // Campaign statistics
  sentCount: integer13("sent_count").default(0),
  deliveredCount: integer13("delivered_count").default(0),
  openCount: integer13("open_count").default(0),
  clickCount: integer13("click_count").default(0),
  bounceCount: integer13("bounce_count").default(0),
  responseCount: integer13("response_count").default(0),
  // A/B Testing
  isAbTest: boolean19("is_ab_test").default(false),
  abTestVariants: json10("ab_test_variants").default([]),
  abTestWinnerVariant: text22("ab_test_winner_variant"),
  // Additional settings
  settings: json10("settings").default({}),
  metadata: json10("metadata").default({}),
  // Tracking fields
  createdAt: timestamp22("created_at").defaultNow().notNull(),
  updatedAt: timestamp22("updated_at").defaultNow().notNull(),
  createdBy: uuid21("created_by"),
  updatedBy: uuid21("updated_by")
}, (table) => {
  return {
    companyIdIdx: index11("marketing_campaigns_company_id_idx").on(table.companyId),
    typeIdx: index11("marketing_campaigns_type_idx").on(table.type),
    statusIdx: index11("marketing_campaigns_status_idx").on(table.status),
    audienceTypeIdx: index11("marketing_campaigns_audience_type_idx").on(table.audienceType),
    scheduledAtIdx: index11("marketing_campaigns_scheduled_at_idx").on(table.scheduledAt)
  };
});
var campaignMessages = pgTable22("marketing_campaign_messages", {
  id: uuid21("id").primaryKey().defaultRandom(),
  campaignId: uuid21("campaign_id").notNull().references(() => campaigns.id, { onDelete: "cascade" }),
  messageId: uuid21("message_id").notNull(),
  // References communications_messages.id
  companyId: uuid21("company_id").notNull(),
  recipientId: uuid21("recipient_id").notNull(),
  // References communications_contacts.id
  status: text22("status").notNull(),
  // Message delivery status
  sentAt: timestamp22("sent_at"),
  deliveredAt: timestamp22("delivered_at"),
  openedAt: timestamp22("opened_at"),
  clickedAt: timestamp22("clicked_at"),
  bouncedAt: timestamp22("bounced_at"),
  bounceReason: text22("bounce_reason"),
  metadata: json10("metadata").default({}),
  variantId: text22("variant_id"),
  // For A/B testing
  createdAt: timestamp22("created_at").defaultNow().notNull(),
  updatedAt: timestamp22("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    campaignIdIdx: index11("marketing_campaign_messages_campaign_id_idx").on(table.campaignId),
    messageIdIdx: index11("marketing_campaign_messages_message_id_idx").on(table.messageId),
    recipientIdIdx: index11("marketing_campaign_messages_recipient_id_idx").on(table.recipientId),
    statusIdx: index11("marketing_campaign_messages_status_idx").on(table.status),
    uniqueMessageCampaign: unique8("marketing_campaign_messages_unique").on(table.campaignId, table.messageId)
  };
});
var campaignSegments = pgTable22("marketing_campaign_segments", {
  id: uuid21("id").primaryKey().defaultRandom(),
  companyId: uuid21("company_id").notNull(),
  name: text22("name").notNull(),
  description: text22("description"),
  filterCriteria: json10("filter_criteria").default({}),
  estimatedReach: integer13("estimated_reach"),
  isActive: boolean19("is_active").default(true),
  lastRefreshedAt: timestamp22("last_refreshed_at"),
  metadata: json10("metadata").default({}),
  createdAt: timestamp22("created_at").defaultNow().notNull(),
  updatedAt: timestamp22("updated_at").defaultNow().notNull(),
  createdBy: uuid21("created_by"),
  updatedBy: uuid21("updated_by")
}, (table) => {
  return {
    companyIdIdx: index11("marketing_campaign_segments_company_id_idx").on(table.companyId),
    uniqueNamePerCompany: unique8("marketing_campaign_segments_name_company_idx").on(table.name, table.companyId)
  };
});
var campaignTemplates = pgTable22("marketing_campaign_templates", {
  id: uuid21("id").primaryKey().defaultRandom(),
  companyId: uuid21("company_id").notNull(),
  name: text22("name").notNull(),
  description: text22("description"),
  type: campaignTypeEnum("type").notNull(),
  subject: text22("subject"),
  content: text22("content"),
  contentHtml: text22("content_html"),
  previewImage: text22("preview_image"),
  category: text22("category"),
  isActive: boolean19("is_active").default(true),
  metadata: json10("metadata").default({}),
  createdAt: timestamp22("created_at").defaultNow().notNull(),
  updatedAt: timestamp22("updated_at").defaultNow().notNull(),
  createdBy: uuid21("created_by"),
  updatedBy: uuid21("updated_by")
}, (table) => {
  return {
    companyIdIdx: index11("marketing_campaign_templates_company_id_idx").on(table.companyId),
    typeIdx: index11("marketing_campaign_templates_type_idx").on(table.type),
    categoryIdx: index11("marketing_campaign_templates_category_idx").on(table.category)
  };
});
var insertCampaignSchema = createInsertSchema15(campaigns, {
  id: z35.string().uuid().optional(),
  type: z35.nativeEnum(CampaignType),
  status: z35.nativeEnum(CampaignStatus).optional(),
  audienceType: z35.nativeEnum(AudienceType),
  channels: z35.array(z35.string()).optional(),
  createdAt: z35.date().optional(),
  updatedAt: z35.date().optional()
}).omit({ id: true, createdAt: true, updatedAt: true });
var insertCampaignMessageSchema = createInsertSchema15(campaignMessages, {
  id: z35.string().uuid().optional(),
  createdAt: z35.date().optional(),
  updatedAt: z35.date().optional()
}).omit({ id: true, createdAt: true, updatedAt: true });
var insertCampaignSegmentSchema = createInsertSchema15(campaignSegments, {
  id: z35.string().uuid().optional(),
  createdAt: z35.date().optional(),
  updatedAt: z35.date().optional()
}).omit({ id: true, createdAt: true, updatedAt: true });
var insertCampaignTemplateSchema = createInsertSchema15(campaignTemplates, {
  id: z35.string().uuid().optional(),
  type: z35.nativeEnum(CampaignType),
  createdAt: z35.date().optional(),
  updatedAt: z35.date().optional()
}).omit({ id: true, createdAt: true, updatedAt: true });

// server/modules/marketing/services/campaign.service.ts
var CampaignService = class {
  constructor() {
    this._logger = new Logger("CampaignService");
    this.drizzle = new DrizzleService();
  }
  /**
   * Create a new marketing campaign
   * @param campaignData Campaign data to insert
   * @param userId ID of the user creating the campaign
   * @returns The created campaign
   */
  async createCampaign(campaignData, userId) {
    this._logger.info(`Creating new campaign: ${campaignData.name}`);
    try {
      const id = uuidv434();
      const nowTimestamp = /* @__PURE__ */ new Date();
      const result = await this.drizzle.insert(campaigns).values({
        ...campaignData,
        id,
        createdAt: nowTimestamp,
        updatedAt: nowTimestamp,
        createdBy: userId,
        updatedBy: userId
      }).returning();
      if (!result || result.length === 0) {
        throw new Error("Failed to create campaign");
      }
      return result[0];
    } catch (error) {
      this._logger.error("Error creating campaign", error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Get a campaign by ID
   * @param id Campaign ID
   * @param companyId Company ID
   * @returns The campaign or null if not found
   */
  async getCampaignById(id, companyId) {
    this._logger.info(`Getting campaign by ID: ${id}`);
    try {
      const result = await this.drizzle.select().from(campaigns).where(and60(
        eq72(campaigns.id, id),
        eq72(campaigns.companyId, companyId)
      ));
      if (!result || result.length === 0) {
        return null;
      }
      return result[0];
    } catch (error) {
      this._logger.error(`Error getting campaign with ID ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Update an existing campaign
   * @param id Campaign ID
   * @param companyId Company ID
   * @param updateData The campaign data to update
   * @param userId The ID of the user making the update
   * @returns The updated campaign
   */
  async updateCampaign(id, companyId, updateData, userId) {
    this._logger.info(`Updating campaign: ${id}`);
    try {
      const existing = await this.getCampaignById(id, companyId);
      if (!existing) {
        this._logger.warn(`Campaign with ID ${id} not found`);
        return null;
      }
      const result = await this.drizzle.update(campaigns).set({
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and60(
        eq72(campaigns.id, id),
        eq72(campaigns.companyId, companyId)
      )).returning();
      if (!result || result.length === 0) {
        throw new Error("Failed to update campaign");
      }
      return result[0];
    } catch (error) {
      this._logger.error(`Error updating campaign with ID ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Delete a campaign
   * @param id Campaign ID
   * @param companyId Company ID
   * @returns True if successfully deleted, false otherwise
   */
  async deleteCampaign(id, companyId) {
    this._logger.info(`Deleting campaign: ${id}`);
    try {
      const existing = await this.getCampaignById(id, companyId);
      if (!existing) {
        this._logger.warn(`Campaign with ID ${id} not found`);
        return false;
      }
      const result = await this.drizzle.delete(campaigns).where(and60(
        eq72(campaigns.id, id),
        eq72(campaigns.companyId, companyId)
      )).returning({ id: campaigns.id });
      return result.length > 0;
    } catch (error) {
      this._logger.error(`Error deleting campaign with ID ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * List campaigns with filtering and pagination
   * @param companyId Company ID
   * @param filters Optional filters for the campaigns
   * @param page Page number for pagination (1-based)
   * @param pageSize Number of items per page
   * @returns List of campaigns and total count
   */
  async listCampaigns(companyId, filters = {}, page = 1, pageSize = 20) {
    this._logger.info(`Listing campaigns for company: ${companyId}`);
    try {
      const offset = (page - 1) * pageSize;
      let whereClause = eq72(campaigns.companyId, companyId);
      if (filters.status) {
        whereClause = and60(whereClause, eq72(campaigns.status, filters.status));
      }
      if (filters.type) {
        whereClause = and60(whereClause, eq72(campaigns.type, filters.type));
      }
      if (filters.search) {
        whereClause = and60(whereClause, like12(campaigns.name, `%${filters.search}%`));
      }
      const countResult = await this.drizzle.select({ count: sql51`count(*)` }).from(campaigns).where(whereClause);
      const total = countResult[0]?.count || 0;
      const result = await this.drizzle.select().from(campaigns).where(whereClause).orderBy(desc32(campaigns.createdAt)).limit(pageSize).offset(offset);
      return { campaigns: result, total };
    } catch (error) {
      this._logger.error("Error listing campaigns", error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Schedule a campaign for execution
   * @param id Campaign ID
   * @param companyId Company ID
   * @param scheduledAt When to schedule the campaign
   * @param userId ID of the user scheduling the campaign
   * @returns The updated campaign
   */
  async scheduleCampaign(id, companyId, scheduledAt, userId) {
    this._logger.info(`Scheduling campaign ${id} for execution at ${scheduledAt.toISOString()}`);
    try {
      const updatedCampaign = await this.updateCampaign(
        id,
        companyId,
        {
          status: "scheduled" /* SCHEDULED */,
          scheduledAt
        },
        userId
      );
      return updatedCampaign;
    } catch (error) {
      this._logger.error(`Error scheduling campaign ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Start a campaign immediately
   * @param id Campaign ID
   * @param companyId Company ID
   * @param userId ID of the user starting the campaign
   * @returns The updated campaign
   */
  async startCampaign(id, companyId, userId) {
    this._logger.info(`Starting campaign ${id} immediately`);
    try {
      const updatedCampaign = await this.updateCampaign(
        id,
        companyId,
        {
          status: "active" /* ACTIVE */,
          startedAt: /* @__PURE__ */ new Date()
        },
        userId
      );
      return updatedCampaign;
    } catch (error) {
      this._logger.error(`Error starting campaign ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Pause an active campaign
   * @param id Campaign ID
   * @param companyId Company ID
   * @param userId ID of the user pausing the campaign
   * @returns The updated campaign
   */
  async pauseCampaign(id, companyId, userId) {
    this._logger.info(`Pausing campaign ${id}`);
    try {
      const updatedCampaign = await this.updateCampaign(
        id,
        companyId,
        {
          status: "paused" /* PAUSED */
        },
        userId
      );
      return updatedCampaign;
    } catch (error) {
      this._logger.error(`Error pausing campaign ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Resume a paused campaign
   * @param id Campaign ID
   * @param companyId Company ID
   * @param userId ID of the user resuming the campaign
   * @returns The updated campaign
   */
  async resumeCampaign(id, companyId, userId) {
    this._logger.info(`Resuming campaign ${id}`);
    try {
      const updatedCampaign = await this.updateCampaign(
        id,
        companyId,
        {
          status: "active" /* ACTIVE */
        },
        userId
      );
      return updatedCampaign;
    } catch (error) {
      this._logger.error(`Error resuming campaign ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Mark a campaign as completed
   * @param id Campaign ID
   * @param companyId Company ID
   * @param userId ID of the user completing the campaign
   * @returns The updated campaign
   */
  async completeCampaign(id, companyId, userId) {
    this._logger.info(`Completing campaign ${id}`);
    try {
      const updatedCampaign = await this.updateCampaign(
        id,
        companyId,
        {
          status: "completed" /* COMPLETED */,
          completedAt: /* @__PURE__ */ new Date()
        },
        userId
      );
      return updatedCampaign;
    } catch (error) {
      this._logger.error(`Error completing campaign ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Get campaign performance metrics
   * @param id Campaign ID
   * @param companyId Company ID
   * @returns Performance metrics for the campaign
   */
  async getCampaignPerformance(id, companyId) {
    this._logger.info(`Getting performance metrics for campaign ${id}`);
    try {
      const campaign = await this.getCampaignById(id, companyId);
      if (!campaign) {
        throw new Error(`Campaign with ID ${id} not found`);
      }
      const messagesSent = campaign.sentCount || 0;
      const messagesDelivered = campaign.deliveredCount || 0;
      const openCount = campaign.openCount || 0;
      const clickCount = campaign.clickCount || 0;
      const bounceCount = campaign.bounceCount || 0;
      const responseCount = campaign.responseCount || 0;
      const openRate = messagesSent > 0 ? openCount / messagesSent : 0;
      const clickRate = messagesSent > 0 ? clickCount / messagesSent : 0;
      const bounceRate = messagesSent > 0 ? bounceCount / messagesSent : 0;
      const responseRate = messagesSent > 0 ? responseCount / messagesSent : 0;
      return {
        messagesSent,
        messagesDelivered,
        openRate,
        clickRate,
        bounceRate,
        responseRate
      };
    } catch (error) {
      this._logger.error(`Error getting performance metrics for campaign ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Link a message to a campaign
   * @param campaignId Campaign ID
   * @param messageId Message ID from the Communications module
   * @param recipientId Recipient ID (contact)
   * @param companyId Company ID
   * @param status Message status
   * @returns The created campaign message link
   */
  async linkMessageToCampaign(campaignId, messageId, recipientId, companyId, status = "sent", variantId) {
    this._logger.info(`Linking message ${messageId} to campaign ${campaignId}`);
    try {
      const result = await this.drizzle.insert(campaignMessages).values({
        id: uuidv434(),
        campaignId,
        messageId,
        recipientId,
        companyId,
        status,
        sentAt: /* @__PURE__ */ new Date(),
        variantId,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      await this.drizzle.update(campaigns).set({
        sentCount: sql51`${campaigns.sentCount} + 1`,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(and60(
        eq72(campaigns.id, campaignId),
        eq72(campaigns.companyId, companyId)
      ));
      return result[0];
    } catch (error) {
      this._logger.error(`Error linking message ${messageId} to campaign ${campaignId}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Update campaign message status
   * @param messageId Message ID
   * @param campaignId Campaign ID
   * @param status New status
   * @param details Additional details (like bounce reason)
   * @returns True if successfully updated
   */
  async updateCampaignMessageStatus(messageId, campaignId, status, details = {}) {
    this._logger.info(`Updating status for message ${messageId} in campaign ${campaignId} to ${status}`);
    try {
      const updateData = {
        status,
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (status === "delivered") {
        updateData.deliveredAt = /* @__PURE__ */ new Date();
      } else if (status === "opened") {
        updateData.openedAt = /* @__PURE__ */ new Date();
      } else if (status === "clicked") {
        updateData.clickedAt = /* @__PURE__ */ new Date();
      } else if (status === "bounced") {
        updateData.bouncedAt = /* @__PURE__ */ new Date();
        if (details.bounceReason) {
          updateData.bounceReason = details.bounceReason;
        }
      }
      const result = await this.drizzle.update(campaignMessages).set(updateData).where(and60(
        eq72(campaignMessages.messageId, messageId),
        eq72(campaignMessages.campaignId, campaignId)
      )).returning({ id: campaignMessages.id });
      if (status === "delivered") {
        await this.incrementCampaignField(campaignId, "deliveredCount");
      } else if (status === "opened") {
        await this.incrementCampaignField(campaignId, "openCount");
      } else if (status === "clicked") {
        await this.incrementCampaignField(campaignId, "clickCount");
      } else if (status === "bounced") {
        await this.incrementCampaignField(campaignId, "bounceCount");
      } else if (status === "responded") {
        await this.incrementCampaignField(campaignId, "responseCount");
      }
      return result.length > 0;
    } catch (error) {
      this._logger.error(`Error updating status for message ${messageId}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Increment a numeric field in the campaign table
   * @param campaignId Campaign ID
   * @param field The field to increment
   * @returns True if successfully updated
   */
  async incrementCampaignField(campaignId, field) {
    try {
      const result = await this.drizzle.update(campaigns).set({
        [field]: sql51`${campaigns[field]} + 1`,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq72(campaigns.id, campaignId)).returning({ id: campaigns.id });
      return result.length > 0;
    } catch (error) {
      this._logger.error(`Error incrementing ${field} for campaign ${campaignId}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
};

// server/modules/marketing/services/segment.service.ts
init_logger();
init_drizzle();
import { eq as eq73, and as and61, desc as desc33, sql as sql52, like as like13 } from "drizzle-orm";
import { v4 as uuidv435 } from "uuid";
var SegmentService = class {
  constructor() {
    this._logger = new Logger("SegmentService");
    this.drizzle = new DrizzleService();
  }
  /**
   * Create a new customer segment
   * @param segmentData Segment data to insert
   * @param userId ID of the user creating the segment
   * @returns The created segment
   */
  async createSegment(segmentData, userId) {
    this._logger.info(`Creating new segment: ${segmentData.name}`);
    try {
      const id = uuidv435();
      const nowTimestamp = /* @__PURE__ */ new Date();
      const result = await this.drizzle.insert(campaignSegments).values({
        ...segmentData,
        id,
        createdAt: nowTimestamp,
        updatedAt: nowTimestamp,
        createdBy: userId,
        updatedBy: userId
      }).returning();
      if (!result || result.length === 0) {
        throw new Error("Failed to create segment");
      }
      return result[0];
    } catch (error) {
      this._logger.error("Error creating segment", error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Get a segment by ID
   * @param id Segment ID
   * @param companyId Company ID
   * @returns The segment or null if not found
   */
  async getSegmentById(id, companyId) {
    this._logger.info(`Getting segment by ID: ${id}`);
    try {
      const result = await this.drizzle.select().from(campaignSegments).where(and61(
        eq73(campaignSegments.id, id),
        eq73(campaignSegments.companyId, companyId)
      ));
      if (!result || result.length === 0) {
        return null;
      }
      return result[0];
    } catch (error) {
      this._logger.error(`Error getting segment with ID ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Update an existing segment
   * @param id Segment ID
   * @param companyId Company ID
   * @param updateData The segment data to update
   * @param userId The ID of the user making the update
   * @returns The updated segment
   */
  async updateSegment(id, companyId, updateData, userId) {
    this._logger.info(`Updating segment: ${id}`);
    try {
      const existing = await this.getSegmentById(id, companyId);
      if (!existing) {
        this._logger.warn(`Segment with ID ${id} not found`);
        return null;
      }
      const result = await this.drizzle.update(campaignSegments).set({
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and61(
        eq73(campaignSegments.id, id),
        eq73(campaignSegments.companyId, companyId)
      )).returning();
      if (!result || result.length === 0) {
        throw new Error("Failed to update segment");
      }
      return result[0];
    } catch (error) {
      this._logger.error(`Error updating segment with ID ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Delete a segment
   * @param id Segment ID
   * @param companyId Company ID
   * @returns True if successfully deleted, false otherwise
   */
  async deleteSegment(id, companyId) {
    this._logger.info(`Deleting segment: ${id}`);
    try {
      const existing = await this.getSegmentById(id, companyId);
      if (!existing) {
        this._logger.warn(`Segment with ID ${id} not found`);
        return false;
      }
      const result = await this.drizzle.delete(campaignSegments).where(and61(
        eq73(campaignSegments.id, id),
        eq73(campaignSegments.companyId, companyId)
      )).returning({ id: campaignSegments.id });
      return result.length > 0;
    } catch (error) {
      this._logger.error(`Error deleting segment with ID ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * List segments with filtering and pagination
   * @param companyId Company ID
   * @param filters Optional filters for the segments
   * @param page Page number for pagination (1-based)
   * @param pageSize Number of items per page
   * @returns List of segments and total count
   */
  async listSegments(companyId, filters = {}, page = 1, pageSize = 20) {
    this._logger.info(`Listing segments for company: ${companyId}`);
    try {
      const offset = (page - 1) * pageSize;
      let whereClause = eq73(campaignSegments.companyId, companyId);
      if (filters.isActive !== void 0) {
        whereClause = and61(whereClause, eq73(campaignSegments.isActive, filters.isActive));
      }
      if (filters.search) {
        whereClause = and61(whereClause, like13(campaignSegments.name, `%${filters.search}%`));
      }
      const countResult = await this.drizzle.select({ count: sql52`count(*)` }).from(campaignSegments).where(whereClause);
      const total = countResult[0]?.count || 0;
      const result = await this.drizzle.select().from(campaignSegments).where(whereClause).orderBy(desc33(campaignSegments.createdAt)).limit(pageSize).offset(offset);
      return { segments: result, total };
    } catch (error) {
      this._logger.error("Error listing segments", error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Refresh estimated reach for a segment
   * This would typically query customer data based on the segment criteria
   * @param id Segment ID
   * @param companyId Company ID
   * @param userId ID of the user refreshing the segment
   * @returns The updated segment with refreshed reach count
   */
  async refreshSegmentReach(id, companyId, userId) {
    this._logger.info(`Refreshing reach for segment ${id}`);
    try {
      const segment = await this.getSegmentById(id, companyId);
      if (!segment) {
        this._logger.warn(`Segment with ID ${id} not found`);
        return null;
      }
      const estimatedReach = 0;
      const result = await this.drizzle.update(campaignSegments).set({
        estimatedReach,
        lastRefreshedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and61(
        eq73(campaignSegments.id, id),
        eq73(campaignSegments.companyId, companyId)
      )).returning();
      if (!result || result.length === 0) {
        throw new Error("Failed to update segment reach");
      }
      return result[0];
    } catch (error) {
      this._logger.error(`Error refreshing reach for segment ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Clone an existing segment
   * @param id ID of the segment to clone
   * @param companyId Company ID
   * @param newName Name for the cloned segment
   * @param userId ID of the user cloning the segment
   * @returns The newly created segment
   */
  async cloneSegment(id, companyId, newName, userId) {
    this._logger.info(`Cloning segment ${id} with name ${newName}`);
    try {
      const original = await this.getSegmentById(id, companyId);
      if (!original) {
        this._logger.warn(`Segment with ID ${id} not found`);
        return null;
      }
      const clonedSegment = await this.createSegment({
        companyId,
        name: newName,
        description: original.description ? `Clone of: ${original.description}` : `Clone of segment: ${original.name}`,
        filterCriteria: original.filterCriteria,
        isActive: true,
        metadata: original.metadata
      }, userId);
      return clonedSegment;
    } catch (error) {
      this._logger.error(`Error cloning segment ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Toggle a segment's active status
   * @param id Segment ID
   * @param companyId Company ID
   * @param isActive New active status
   * @param userId ID of the user updating the segment
   * @returns The updated segment
   */
  async toggleSegmentStatus(id, companyId, isActive, userId) {
    this._logger.info(`Setting segment ${id} active status to ${isActive}`);
    try {
      return await this.updateSegment(
        id,
        companyId,
        { isActive },
        userId
      );
    } catch (error) {
      this._logger.error(`Error toggling status for segment ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
};

// server/modules/marketing/services/template.service.ts
init_logger();
init_drizzle_service();
import { eq as eq74, and as and62, desc as desc34, sql as sql53, like as like14, not as not8, isNull as isNull14 } from "drizzle-orm";
import { v4 as uuidv436 } from "uuid";
var TemplateService = class {
  constructor() {
    this._logger = new Logger("TemplateService");
    this.drizzle = new DrizzleService();
  }
  /**
   * Create a new campaign template
   * @param templateData Template data to insert
   * @param userId ID of the user creating the template
   * @returns The created template
   */
  async createTemplate(templateData, userId) {
    this._logger.info(`Creating new template: ${templateData.name}`);
    try {
      const id = uuidv436();
      const nowTimestamp = /* @__PURE__ */ new Date();
      const result = await this.drizzle.insert(campaignTemplates).values({
        ...templateData,
        id,
        createdAt: nowTimestamp,
        updatedAt: nowTimestamp,
        createdBy: userId,
        updatedBy: userId
      }).returning();
      if (!result || result.length === 0) {
        throw new Error("Failed to create template");
      }
      return result[0];
    } catch (error) {
      this._logger.error("Error creating template", error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Get a template by ID
   * @param id Template ID
   * @param companyId Company ID
   * @returns The template or null if not found
   */
  async getTemplateById(id, companyId) {
    this._logger.info(`Getting template by ID: ${id}`);
    try {
      const result = await this.drizzle.select().from(campaignTemplates).where(and62(
        eq74(campaignTemplates.id, id),
        eq74(campaignTemplates.companyId, companyId)
      ));
      if (!result || result.length === 0) {
        return null;
      }
      return result[0];
    } catch (error) {
      this._logger.error(`Error getting template with ID ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Update an existing template
   * @param id Template ID
   * @param companyId Company ID
   * @param updateData The template data to update
   * @param userId The ID of the user making the update
   * @returns The updated template
   */
  async updateTemplate(id, companyId, updateData, userId) {
    this._logger.info(`Updating template: ${id}`);
    try {
      const existing = await this.getTemplateById(id, companyId);
      if (!existing) {
        this._logger.warn(`Template with ID ${id} not found`);
        return null;
      }
      const result = await this.drizzle.update(campaignTemplates).set({
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      }).where(and62(
        eq74(campaignTemplates.id, id),
        eq74(campaignTemplates.companyId, companyId)
      )).returning();
      if (!result || result.length === 0) {
        throw new Error("Failed to update template");
      }
      return result[0];
    } catch (error) {
      this._logger.error(`Error updating template with ID ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Delete a template
   * @param id Template ID
   * @param companyId Company ID
   * @returns True if successfully deleted, false otherwise
   */
  async deleteTemplate(id, companyId) {
    this._logger.info(`Deleting template: ${id}`);
    try {
      const existing = await this.getTemplateById(id, companyId);
      if (!existing) {
        this._logger.warn(`Template with ID ${id} not found`);
        return false;
      }
      const result = await this.drizzle.delete(campaignTemplates).where(and62(
        eq74(campaignTemplates.id, id),
        eq74(campaignTemplates.companyId, companyId)
      )).returning({ id: campaignTemplates.id });
      return result.length > 0;
    } catch (error) {
      this._logger.error(`Error deleting template with ID ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * List templates with filtering and pagination
   * @param companyId Company ID
   * @param filters Optional filters for the templates
   * @param page Page number for pagination (1-based)
   * @param pageSize Number of items per page
   * @returns List of templates and total count
   */
  async listTemplates(companyId, filters = {}, page = 1, pageSize = 20) {
    this._logger.info(`Listing templates for company: ${companyId}`);
    try {
      const offset = (page - 1) * pageSize;
      let whereClause = eq74(campaignTemplates.companyId, companyId);
      if (filters.type) {
        whereClause = and62(whereClause, eq74(campaignTemplates.type, filters.type));
      }
      if (filters.category) {
        whereClause = and62(whereClause, eq74(campaignTemplates.category, filters.category));
      }
      if (filters.isActive !== void 0) {
        whereClause = and62(whereClause, eq74(campaignTemplates.isActive, filters.isActive));
      }
      if (filters.search) {
        whereClause = and62(whereClause, like14(campaignTemplates.name, `%${filters.search}%`));
      }
      const countResult = await this.drizzle.select({ count: sql53`count(*)` }).from(campaignTemplates).where(whereClause);
      const total = countResult[0]?.count || 0;
      const result = await this.drizzle.select().from(campaignTemplates).where(whereClause).orderBy(desc34(campaignTemplates.createdAt)).limit(pageSize).offset(offset);
      return { templates: result, total };
    } catch (error) {
      this._logger.error("Error listing templates", error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Get all template categories
   * @param companyId Company ID
   * @returns List of unique template categories
   */
  async getTemplateCategories(companyId) {
    this._logger.info(`Getting template categories for company: ${companyId}`);
    try {
      const result = await this.drizzle.select({
        category: campaignTemplates.category
      }).from(campaignTemplates).where(and62(
        eq74(campaignTemplates.companyId, companyId),
        not8(isNull14(campaignTemplates.category))
      )).groupBy(campaignTemplates.category);
      return result.map((row) => row.category).filter(Boolean);
    } catch (error) {
      this._logger.error("Error getting template categories", error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Clone an existing template
   * @param id ID of the template to clone
   * @param companyId Company ID
   * @param newName Name for the cloned template
   * @param userId ID of the user cloning the template
   * @returns The newly created template
   */
  async cloneTemplate(id, companyId, newName, userId) {
    this._logger.info(`Cloning template ${id} with name ${newName}`);
    try {
      const original = await this.getTemplateById(id, companyId);
      if (!original) {
        this._logger.warn(`Template with ID ${id} not found`);
        return null;
      }
      const clonedTemplate = await this.createTemplate({
        companyId,
        name: newName,
        description: original.description ? `Clone of: ${original.description}` : `Clone of template: ${original.name}`,
        type: original.type,
        subject: original.subject,
        content: original.content,
        contentHtml: original.contentHtml,
        previewImage: original.previewImage,
        category: original.category,
        isActive: true,
        metadata: original.metadata
      }, userId);
      return clonedTemplate;
    } catch (error) {
      this._logger.error(`Error cloning template ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Toggle a template's active status
   * @param id Template ID
   * @param companyId Company ID
   * @param isActive New active status
   * @param userId ID of the user updating the template
   * @returns The updated template
   */
  async toggleTemplateStatus(id, companyId, isActive, userId) {
    this._logger.info(`Setting template ${id} active status to ${isActive}`);
    try {
      return await this.updateTemplate(
        id,
        companyId,
        { isActive },
        userId
      );
    } catch (error) {
      this._logger.error(`Error toggling status for template ${id}`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
};

// server/modules/marketing/routes/campaign.routes.ts
import { Router as Router34 } from "express";
import { z as z36 } from "zod";
init_logger();
init_auth_guard();
init_auth_mode_enum();
var campaignRoutes = Router34();
var campaignService = new CampaignService();
var logger98 = new Logger("CampaignRoutes");
var campaignQuerySchema = z36.object({
  page: z36.coerce.number().int().positive().optional().default(1),
  pageSize: z36.coerce.number().int().positive().max(100).optional().default(20),
  status: z36.nativeEnum(CampaignStatus).optional(),
  type: z36.nativeEnum(CampaignType).optional(),
  search: z36.string().optional()
});
var campaignIdParamSchema = z36.object({
  id: z36.string().uuid()
});
campaignRoutes.post(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = insertCampaignSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid campaign data",
          details: validation.error.format()
        });
      }
      const campaign = await campaignService.createCampaign({
        ...validation.data,
        companyId
      }, userId);
      return res.status(201).json({
        success: true,
        data: campaign
      });
    } catch (error) {
      logger98.error("Error creating campaign", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to create campaign"
      });
    }
  }
);
campaignRoutes.get(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = campaignQuerySchema.safeParse(req.query);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid query parameters",
          details: validation.error.format()
        });
      }
      const { page, pageSize, status, type, search } = validation.data;
      const { campaigns: campaigns2, total } = await campaignService.listCampaigns(
        companyId,
        { status, type, search },
        page,
        pageSize
      );
      return res.status(200).json({
        success: true,
        data: {
          campaigns: campaigns2,
          pagination: {
            page,
            pageSize,
            total,
            totalPages: Math.ceil(total / pageSize)
          }
        }
      });
    } catch (error) {
      logger98.error("Error listing campaigns", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to list campaigns"
      });
    }
  }
);
campaignRoutes.get(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = campaignIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid campaign ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const campaign = await campaignService.getCampaignById(id, companyId);
      if (!campaign) {
        return res.status(404).json({
          success: false,
          error: "Campaign not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: campaign
      });
    } catch (error) {
      logger98.error("Error getting campaign", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to get campaign"
      });
    }
  }
);
var handleUpdateCampaign = async (req, res) => {
  try {
    const userId = req.user?.id;
    const companyId = req.user?.companyId;
    if (!userId || !companyId) {
      return res.status(401).json({
        success: false,
        error: "Unauthorized"
      });
    }
    const idValidation = campaignIdParamSchema.safeParse(req.params);
    if (!idValidation.success) {
      return res.status(400).json({
        success: false,
        error: "Invalid campaign ID",
        details: idValidation.error.format()
      });
    }
    const { id } = idValidation.data;
    const validation = insertCampaignSchema.partial().safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({
        success: false,
        error: "Invalid campaign data",
        details: validation.error.format()
      });
    }
    const updatedCampaign = await campaignService.updateCampaign(
      id,
      companyId,
      validation.data,
      userId
    );
    if (!updatedCampaign) {
      return res.status(404).json({
        success: false,
        error: "Campaign not found"
      });
    }
    return res.status(200).json({
      success: true,
      data: updatedCampaign
    });
  } catch (error) {
    logger98.error("Error updating campaign", error instanceof Error ? error.message : String(error));
    return res.status(500).json({
      success: false,
      error: "Failed to update campaign"
    });
  }
};
campaignRoutes.put("/:id", AuthGuard.protect("required" /* REQUIRED */), handleUpdateCampaign);
campaignRoutes.patch("/:id", AuthGuard.protect("required" /* REQUIRED */), handleUpdateCampaign);
campaignRoutes.delete(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = campaignIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid campaign ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const deleted = await campaignService.deleteCampaign(id, companyId);
      if (!deleted) {
        return res.status(404).json({
          success: false,
          error: "Campaign not found"
        });
      }
      return res.status(200).json({
        success: true,
        message: "Campaign deleted successfully"
      });
    } catch (error) {
      logger98.error("Error deleting campaign", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to delete campaign"
      });
    }
  }
);
campaignRoutes.get(
  "/:id/performance",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = campaignIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid campaign ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const campaign = await campaignService.getCampaignById(id, companyId);
      if (!campaign) {
        return res.status(404).json({
          success: false,
          error: "Campaign not found"
        });
      }
      const performance = await campaignService.getCampaignPerformance(id, companyId);
      return res.status(200).json({
        success: true,
        data: performance
      });
    } catch (error) {
      logger98.error("Error getting campaign performance", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to get campaign performance"
      });
    }
  }
);
campaignRoutes.post(
  "/:id/schedule",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const idValidation = campaignIdParamSchema.safeParse(req.params);
      if (!idValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid campaign ID",
          details: idValidation.error.format()
        });
      }
      const { id } = idValidation.data;
      const bodySchema = z36.object({
        scheduledAt: z36.coerce.date()
      });
      const bodyValidation = bodySchema.safeParse(req.body);
      if (!bodyValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid schedule data",
          details: bodyValidation.error.format()
        });
      }
      const { scheduledAt } = bodyValidation.data;
      const updatedCampaign = await campaignService.scheduleCampaign(
        id,
        companyId,
        scheduledAt,
        userId
      );
      if (!updatedCampaign) {
        return res.status(404).json({
          success: false,
          error: "Campaign not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: updatedCampaign
      });
    } catch (error) {
      logger98.error("Error scheduling campaign", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to schedule campaign"
      });
    }
  }
);
campaignRoutes.post(
  "/:id/start",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = campaignIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid campaign ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const updatedCampaign = await campaignService.startCampaign(
        id,
        companyId,
        userId
      );
      if (!updatedCampaign) {
        return res.status(404).json({
          success: false,
          error: "Campaign not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: updatedCampaign
      });
    } catch (error) {
      logger98.error("Error starting campaign", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to start campaign"
      });
    }
  }
);
campaignRoutes.post(
  "/:id/pause",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = campaignIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid campaign ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const updatedCampaign = await campaignService.pauseCampaign(
        id,
        companyId,
        userId
      );
      if (!updatedCampaign) {
        return res.status(404).json({
          success: false,
          error: "Campaign not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: updatedCampaign
      });
    } catch (error) {
      logger98.error("Error pausing campaign", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to pause campaign"
      });
    }
  }
);
campaignRoutes.post(
  "/:id/resume",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = campaignIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid campaign ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const updatedCampaign = await campaignService.resumeCampaign(
        id,
        companyId,
        userId
      );
      if (!updatedCampaign) {
        return res.status(404).json({
          success: false,
          error: "Campaign not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: updatedCampaign
      });
    } catch (error) {
      logger98.error("Error resuming campaign", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to resume campaign"
      });
    }
  }
);
campaignRoutes.post(
  "/campaign-placeholder",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      return res.status(200).json({
        success: true,
        message: "Marketing campaign creation placeholder",
        data: req.body,
        context: {
          userId,
          companyId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    } catch (error) {
      logger98.error("Error in campaign placeholder endpoint", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to process campaign placeholder request"
      });
    }
  }
);

// server/modules/marketing/routes/segment.routes.ts
import { Router as Router35 } from "express";
import { z as z37 } from "zod";
init_logger();
init_auth_guard();
init_auth_mode_enum();
var segmentRoutes = Router35();
var segmentService = new SegmentService();
var logger99 = new Logger("SegmentRoutes");
var segmentQuerySchema = z37.object({
  page: z37.coerce.number().int().positive().optional().default(1),
  pageSize: z37.coerce.number().int().positive().max(100).optional().default(20),
  isActive: z37.preprocess(
    (val) => val === "true" ? true : val === "false" ? false : void 0,
    z37.boolean().optional()
  ),
  search: z37.string().optional()
});
var segmentIdParamSchema = z37.object({
  id: z37.string().uuid()
});
segmentRoutes.post(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = insertCampaignSegmentSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid segment data",
          details: validation.error.format()
        });
      }
      const segment = await segmentService.createSegment({
        ...validation.data,
        companyId
      }, userId);
      return res.status(201).json({
        success: true,
        data: segment
      });
    } catch (error) {
      logger99.error("Error creating segment", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to create segment"
      });
    }
  }
);
segmentRoutes.get(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = segmentQuerySchema.safeParse(req.query);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid query parameters",
          details: validation.error.format()
        });
      }
      const { page, pageSize, isActive, search } = validation.data;
      const { segments: segments2, total } = await segmentService.listSegments(
        companyId,
        { isActive, search },
        page,
        pageSize
      );
      return res.status(200).json({
        success: true,
        data: {
          segments: segments2,
          pagination: {
            page,
            pageSize,
            total,
            totalPages: Math.ceil(total / pageSize)
          }
        }
      });
    } catch (error) {
      logger99.error("Error listing segments", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to list segments"
      });
    }
  }
);
segmentRoutes.get(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = segmentIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid segment ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const segment = await segmentService.getSegmentById(id, companyId);
      if (!segment) {
        return res.status(404).json({
          success: false,
          error: "Segment not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: segment
      });
    } catch (error) {
      logger99.error("Error getting segment", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to get segment"
      });
    }
  }
);
segmentRoutes.put(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const idValidation = segmentIdParamSchema.safeParse(req.params);
      if (!idValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid segment ID",
          details: idValidation.error.format()
        });
      }
      const { id } = idValidation.data;
      const validation = insertCampaignSegmentSchema.partial().safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid segment data",
          details: validation.error.format()
        });
      }
      const updatedSegment = await segmentService.updateSegment(
        id,
        companyId,
        validation.data,
        userId
      );
      if (!updatedSegment) {
        return res.status(404).json({
          success: false,
          error: "Segment not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: updatedSegment
      });
    } catch (error) {
      logger99.error("Error updating segment", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to update segment"
      });
    }
  }
);
segmentRoutes.delete(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = segmentIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid segment ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const deleted = await segmentService.deleteSegment(id, companyId);
      if (!deleted) {
        return res.status(404).json({
          success: false,
          error: "Segment not found"
        });
      }
      return res.status(200).json({
        success: true,
        message: "Segment deleted successfully"
      });
    } catch (error) {
      logger99.error("Error deleting segment", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to delete segment"
      });
    }
  }
);
segmentRoutes.post(
  "/:id/refresh",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = segmentIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid segment ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const updatedSegment = await segmentService.refreshSegmentReach(
        id,
        companyId,
        userId
      );
      if (!updatedSegment) {
        return res.status(404).json({
          success: false,
          error: "Segment not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: updatedSegment
      });
    } catch (error) {
      logger99.error("Error refreshing segment reach", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to refresh segment reach"
      });
    }
  }
);
segmentRoutes.post(
  "/:id/clone",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const idValidation = segmentIdParamSchema.safeParse(req.params);
      if (!idValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid segment ID",
          details: idValidation.error.format()
        });
      }
      const { id } = idValidation.data;
      const bodySchema = z37.object({
        name: z37.string().min(1).max(255)
      });
      const bodyValidation = bodySchema.safeParse(req.body);
      if (!bodyValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid segment name",
          details: bodyValidation.error.format()
        });
      }
      const { name } = bodyValidation.data;
      const clonedSegment = await segmentService.cloneSegment(
        id,
        companyId,
        name,
        userId
      );
      if (!clonedSegment) {
        return res.status(404).json({
          success: false,
          error: "Segment not found"
        });
      }
      return res.status(201).json({
        success: true,
        data: clonedSegment
      });
    } catch (error) {
      logger99.error("Error cloning segment", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to clone segment"
      });
    }
  }
);
segmentRoutes.post(
  "/:id/toggle-status",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const idValidation = segmentIdParamSchema.safeParse(req.params);
      if (!idValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid segment ID",
          details: idValidation.error.format()
        });
      }
      const { id } = idValidation.data;
      const bodySchema = z37.object({
        isActive: z37.boolean()
      });
      const bodyValidation = bodySchema.safeParse(req.body);
      if (!bodyValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid status data",
          details: bodyValidation.error.format()
        });
      }
      const { isActive } = bodyValidation.data;
      const updatedSegment = await segmentService.toggleSegmentStatus(
        id,
        companyId,
        isActive,
        userId
      );
      if (!updatedSegment) {
        return res.status(404).json({
          success: false,
          error: "Segment not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: updatedSegment
      });
    } catch (error) {
      logger99.error("Error toggling segment status", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to toggle segment status"
      });
    }
  }
);

// server/modules/marketing/routes/template.routes.ts
import { Router as Router36 } from "express";
import { z as z38 } from "zod";
init_logger();
init_auth_guard();
init_auth_mode_enum();
var templateRoutes = Router36();
var templateService = new TemplateService();
var logger100 = new Logger("TemplateRoutes");
var templateQuerySchema = z38.object({
  page: z38.coerce.number().int().positive().optional().default(1),
  pageSize: z38.coerce.number().int().positive().max(100).optional().default(20),
  type: z38.nativeEnum(CampaignType).optional(),
  category: z38.string().optional(),
  isActive: z38.preprocess(
    (val) => val === "true" ? true : val === "false" ? false : void 0,
    z38.boolean().optional()
  ),
  search: z38.string().optional()
});
var templateIdParamSchema = z38.object({
  id: z38.string().uuid()
});
templateRoutes.post(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = insertCampaignTemplateSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid template data",
          details: validation.error.format()
        });
      }
      const template = await templateService.createTemplate({
        ...validation.data,
        companyId
      }, userId);
      return res.status(201).json({
        success: true,
        data: template
      });
    } catch (error) {
      logger100.error("Error creating template", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to create template"
      });
    }
  }
);
templateRoutes.get(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = templateQuerySchema.safeParse(req.query);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid query parameters",
          details: validation.error.format()
        });
      }
      const { page, pageSize, type, category, isActive, search } = validation.data;
      const { templates, total } = await templateService.listTemplates(
        companyId,
        { type, category, isActive, search },
        page,
        pageSize
      );
      return res.status(200).json({
        success: true,
        data: {
          templates,
          pagination: {
            page,
            pageSize,
            total,
            totalPages: Math.ceil(total / pageSize)
          }
        }
      });
    } catch (error) {
      logger100.error("Error listing templates", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to list templates"
      });
    }
  }
);
templateRoutes.get(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = templateIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid template ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const template = await templateService.getTemplateById(id, companyId);
      if (!template) {
        return res.status(404).json({
          success: false,
          error: "Template not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: template
      });
    } catch (error) {
      logger100.error("Error getting template", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to get template"
      });
    }
  }
);
templateRoutes.put(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const idValidation = templateIdParamSchema.safeParse(req.params);
      if (!idValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid template ID",
          details: idValidation.error.format()
        });
      }
      const { id } = idValidation.data;
      const validation = insertCampaignTemplateSchema.partial().safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid template data",
          details: validation.error.format()
        });
      }
      const updatedTemplate = await templateService.updateTemplate(
        id,
        companyId,
        validation.data,
        userId
      );
      if (!updatedTemplate) {
        return res.status(404).json({
          success: false,
          error: "Template not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: updatedTemplate
      });
    } catch (error) {
      logger100.error("Error updating template", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to update template"
      });
    }
  }
);
templateRoutes.delete(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const validation = templateIdParamSchema.safeParse(req.params);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid template ID",
          details: validation.error.format()
        });
      }
      const { id } = validation.data;
      const deleted = await templateService.deleteTemplate(id, companyId);
      if (!deleted) {
        return res.status(404).json({
          success: false,
          error: "Template not found"
        });
      }
      return res.status(200).json({
        success: true,
        message: "Template deleted successfully"
      });
    } catch (error) {
      logger100.error("Error deleting template", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to delete template"
      });
    }
  }
);
templateRoutes.get(
  "/categories/list",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const categories = await templateService.getTemplateCategories(companyId);
      return res.status(200).json({
        success: true,
        data: categories
      });
    } catch (error) {
      logger100.error("Error getting template categories", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to get template categories"
      });
    }
  }
);
templateRoutes.post(
  "/:id/clone",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const idValidation = templateIdParamSchema.safeParse(req.params);
      if (!idValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid template ID",
          details: idValidation.error.format()
        });
      }
      const { id } = idValidation.data;
      const bodySchema = z38.object({
        name: z38.string().min(1).max(255)
      });
      const bodyValidation = bodySchema.safeParse(req.body);
      if (!bodyValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid template name",
          details: bodyValidation.error.format()
        });
      }
      const { name } = bodyValidation.data;
      const clonedTemplate = await templateService.cloneTemplate(
        id,
        companyId,
        name,
        userId
      );
      if (!clonedTemplate) {
        return res.status(404).json({
          success: false,
          error: "Template not found"
        });
      }
      return res.status(201).json({
        success: true,
        data: clonedTemplate
      });
    } catch (error) {
      logger100.error("Error cloning template", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to clone template"
      });
    }
  }
);
templateRoutes.post(
  "/:id/toggle-status",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!userId || !companyId) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized"
        });
      }
      const idValidation = templateIdParamSchema.safeParse(req.params);
      if (!idValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid template ID",
          details: idValidation.error.format()
        });
      }
      const { id } = idValidation.data;
      const bodySchema = z38.object({
        isActive: z38.boolean()
      });
      const bodyValidation = bodySchema.safeParse(req.body);
      if (!bodyValidation.success) {
        return res.status(400).json({
          success: false,
          error: "Invalid status data",
          details: bodyValidation.error.format()
        });
      }
      const { isActive } = bodyValidation.data;
      const updatedTemplate = await templateService.toggleTemplateStatus(
        id,
        companyId,
        isActive,
        userId
      );
      if (!updatedTemplate) {
        return res.status(404).json({
          success: false,
          error: "Template not found"
        });
      }
      return res.status(200).json({
        success: true,
        data: updatedTemplate
      });
    } catch (error) {
      logger100.error("Error toggling template status", error instanceof Error ? error.message : String(error));
      return res.status(500).json({
        success: false,
        error: "Failed to toggle template status"
      });
    }
  }
);

// server/modules/marketing/marketing.module.ts
var MarketingModule = class _MarketingModule {
  /**
   * Private constructor to enforce singleton pattern
   */
  constructor() {
    this._initialized = false;
    this._logger = new Logger("MarketingModule");
    this._router = Router37();
  }
  /**
   * Get the singleton instance of MarketingModule
   */
  static getInstance() {
    if (!_MarketingModule._instance) {
      _MarketingModule._instance = new _MarketingModule();
    }
    return _MarketingModule._instance;
  }
  /**
   * Initialize the Marketing module
   * This should be called once at application startup
   */
  async initialize() {
    if (this._initialized) {
      this._logger.warn("Marketing module already initialized");
      return;
    }
    try {
      this._logger.info("Initializing Marketing module...");
      await initialize();
      this._campaignService = new CampaignService();
      this._segmentService = new SegmentService();
      this._templateService = new TemplateService();
      this._router.use("/campaigns", campaignRoutes);
      this._router.use("/segments", segmentRoutes);
      this._router.use("/templates", templateRoutes);
      this._initialized = true;
      this._logger.info("Marketing module initialized successfully");
    } catch (error) {
      this._logger.error("Failed to initialize Marketing module", error instanceof Error ? error.message : String(error));
      throw error;
    }
  }
  /**
   * Get the Express router for this module
   */
  getRouter() {
    if (!this._initialized) {
      this._logger.warn("Attempted to get router before initialization");
    }
    return this._router;
  }
  /**
   * Get the campaign service instance
   */
  getCampaignService() {
    return this._campaignService;
  }
  /**
   * Get the segment service instance
   */
  getSegmentService() {
    return this._segmentService;
  }
  /**
   * Get the template service instance
   */
  getTemplateService() {
    return this._templateService;
  }
  /**
   * Register the Marketing module with the application
   * @param app The Express application instance
   * @param basePath The base path for the module routes
   */
  static async register(app2, basePath = "/api/marketing") {
    const instance = _MarketingModule.getInstance();
    await instance.initialize();
    app2.use(basePath, instance.getRouter());
    const logger121 = new Logger("MarketingModule");
    app2.post("/api/marketing/campaign-placeholder", AuthGuard.protect("required" /* REQUIRED */), (req, res) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({
            success: false,
            error: "Unauthorized"
          });
        }
        logger121.info("Direct campaign placeholder endpoint accessed", { userId, companyId });
        return res.status(200).json({
          success: true,
          message: "Marketing campaign creation placeholder",
          data: req.body,
          context: {
            userId,
            companyId,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        });
      } catch (error) {
        logger121.error("Error in direct campaign placeholder endpoint", error instanceof Error ? error.message : String(error));
        return res.status(500).json({
          success: false,
          error: "Failed to process campaign placeholder request"
        });
      }
    });
    logger121.info("Extra marketing routes registered successfully");
  }
};

// server/modules/examples/examples.module.ts
import { Router as Router41 } from "express";

// server/modules/examples/routes/examples.routes.ts
init_auth_guard();
import { Router as Router40 } from "express";

// server/modules/examples/controllers/examples.controller.ts
import jwt6 from "jsonwebtoken";
var ExamplesController = class {
  static publicTest(req, res) {
    return res.status(200).json({
      message: "Public endpoint - no authentication required"
    });
  }
  static protectedTest(req, res) {
    return res.status(200).json({
      message: "Protected endpoint - authentication required",
      user: {
        id: req.user?.id,
        username: req.user?.username,
        role: req.user?.role
      }
    });
  }
  static optionalAuthTest(req, res) {
    return res.status(200).json({
      success: true,
      message: req.user ? "User authenticated" : "No user auth",
      user: req.user || null
    });
  }
  static adminTest(req, res) {
    return res.status(200).json({
      success: true,
      message: "Admin only route",
      user: req.user
    });
  }
  static companyTest(req, res) {
    return res.status(200).json({
      success: true,
      message: "Company specific route",
      user: req.user,
      companyId: req.params.companyId
    });
  }
  static managerTest(req, res) {
    return res.status(200).json({
      success: true,
      message: "Manager route - Admin or Company Admin only",
      user: req.user
    });
  }
  static tokenInfo(req, res) {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(200).json({
        success: false,
        message: "No token provided"
      });
    }
    const parts = authHeader.split(" ");
    const token = parts.length > 1 ? parts[1] : parts[0];
    try {
      const decoded = jwt6.decode(token);
      return res.status(200).json({
        success: true,
        message: "Token info",
        token,
        decoded
      });
    } catch (error) {
      return res.status(400).json({
        success: false,
        message: "Failed to decode token",
        error: error.message
      });
    }
  }
};

// server/modules/examples/routes/notification-example.routes.ts
init_auth_guard();
init_auth_mode_enum();
init_registry();
init_notification_service();
import { Router as Router38 } from "express";
var router9 = Router38();
router9.post("/user", AuthGuard.protect("required" /* REQUIRED */), async (req, res) => {
  try {
    const { title, message, userId, priority, actionUrl } = req.body;
    const result = await Services.notification.notifyUser(userId, {
      title,
      message,
      type: "info" /* INFO */,
      priority: priority || "medium" /* MEDIUM */,
      actionUrl
    });
    await Services.audit.log({
      companyId: req.user?.companyId || "",
      userId: req.user?.id,
      action: "NOTIFICATION_SENT",
      entity: "USER",
      entityId: userId,
      details: { title, message }
    });
    return res.status(200).json({
      success: true,
      message: "Notification sent successfully",
      result
    });
  } catch (error) {
    console.error("Failed to send user notification:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to send notification",
      error: error.message
    });
  }
});
router9.post("/system", AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
  try {
    const { title, message, priority, metadata } = req.body;
    const result = await Services.notification.notifySystem({
      title,
      message,
      type: "warning" /* WARNING */,
      priority: priority || "high" /* HIGH */,
      metadata
    });
    await Services.audit.log({
      companyId: req.user?.companyId || "",
      userId: req.user?.id,
      action: "SYSTEM_NOTIFICATION_SENT",
      entity: "SYSTEM",
      entityId: "system",
      details: { title, message, metadata }
    });
    return res.status(200).json({
      success: true,
      message: "System notification sent successfully",
      result
    });
  } catch (error) {
    console.error("Failed to send system notification:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to send system notification",
      error: error.message
    });
  }
});
router9.post("/company", AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin", "company_admin"]), async (req, res) => {
  try {
    const { title, message, companyId, priority, actionUrl } = req.body;
    const targetCompanyId = companyId || req.user?.companyId;
    if (!targetCompanyId) {
      return res.status(400).json({
        success: false,
        message: "Company ID is required"
      });
    }
    const result = await Services.notification.notifyCompany(targetCompanyId, {
      title,
      message,
      type: "info" /* INFO */,
      priority: priority || "medium" /* MEDIUM */,
      actionUrl
    });
    await Services.audit.log({
      companyId: req.user?.companyId || "",
      userId: req.user?.id,
      action: "COMPANY_NOTIFICATION_SENT",
      entity: "COMPANY",
      entityId: targetCompanyId,
      details: { title, message }
    });
    return res.status(200).json({
      success: true,
      message: "Company notification sent successfully",
      result
    });
  } catch (error) {
    console.error("Failed to send company notification:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to send company notification",
      error: error.message
    });
  }
});
router9.post("/role", AuthGuard.protect("required" /* REQUIRED */), AuthGuard.roleGuard(["admin"]), async (req, res) => {
  try {
    const { title, message, role, priority, actionUrl } = req.body;
    if (!role) {
      return res.status(400).json({
        success: false,
        message: "Role is required"
      });
    }
    const result = await Services.notification.notifyRole(role, {
      title,
      message,
      type: "info" /* INFO */,
      priority: priority || "medium" /* MEDIUM */,
      actionUrl
    });
    await Services.audit.log({
      companyId: req.user?.companyId || "",
      userId: req.user?.id,
      action: "ROLE_NOTIFICATION_SENT",
      entity: "ROLE",
      entityId: role,
      details: { title, message }
    });
    return res.status(200).json({
      success: true,
      message: `Notification sent to all users with role: ${role}`,
      result
    });
  } catch (error) {
    console.error("Failed to send role notification:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to send role notification",
      error: error.message
    });
  }
});
var notification_example_routes_default = router9;

// server/modules/examples/routes/notification-public.routes.ts
init_registry();
init_notification_service();
import { Router as Router39 } from "express";
var router10 = Router39();
router10.get("/test", async (req, res) => {
  try {
    const result = await Services.notification.notifySystem({
      title: "Public Test Notification",
      message: "This is a test notification from the public API endpoint",
      type: "info" /* INFO */,
      priority: "low" /* LOW */,
      metadata: {
        source: "public-test-endpoint",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
    return res.status(200).json({
      success: true,
      message: "Test notification sent successfully",
      result
    });
  } catch (error) {
    console.error("Failed to send test notification:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to send test notification",
      error: error.message
    });
  }
});
var notification_public_routes_default = router10;

// server/modules/examples/routes/examples.routes.ts
var router11 = Router40();
router11.use("/notifications", notification_example_routes_default);
router11.use("/public-notifications", notification_public_routes_default);
router11.get("/public", ExamplesController.publicTest);
router11.get(
  "/protected",
  AuthGuard.protect("required" /* REQUIRED */),
  ExamplesController.protectedTest
);
router11.get(
  "/optional-auth",
  AuthGuard.protect("optional" /* OPTIONAL */),
  ExamplesController.optionalAuthTest
);
router11.get(
  "/admin-only",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["admin" /* ADMIN */]),
  ExamplesController.adminTest
);
router11.get(
  "/company/:companyId",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.companyGuard("companyId"),
  ExamplesController.companyTest
);
router11.get(
  "/manager-route",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */]),
  ExamplesController.managerTest
);
router11.get("/token-info", ExamplesController.tokenInfo);
var examples_routes_default = router11;

// server/modules/examples/examples.module.ts
var ExamplesModule = class {
  /**
   * Register the module components with the application
   * @param app Express application
   * @returns Registered components
   */
  static register(app2) {
    log("\u{1F510} Registering example routes for testing", "examples-module");
    const router14 = Router41();
    router14.use(examples_routes_default);
    router14.use("/notifications", notification_example_routes_default);
    router14.use("/public-notifications", notification_public_routes_default);
    app2.use("/api/examples", router14);
    log("\u{1F510} AuthGuard example routes registered at /api/examples", "examples-module");
    log("\u{1F514} Notification example routes registered at /api/examples/notifications", "examples-module");
    log("\u{1F514} Public notification routes registered at /api/examples/public-notifications", "examples-module");
    log("Try: /api/examples/protected with Authorization header", "examples-module");
    return {
      routes: [examples_routes_default, notification_example_routes_default, notification_public_routes_default]
    };
  }
};

// server/modules/examples/index.ts
function initExampleModule(app2) {
  const { routes } = ExamplesModule.register(app2);
  return { routes };
}

// server/modules/sales/customer.service.ts
init_drizzle_service();
init_crm_schema();
init_logger();
import { eq as eq75 } from "drizzle-orm";
var CustomerService2 = class {
  constructor(drizzleService5) {
    this.logger = new Logger("CustomerService");
    this.drizzle = drizzleService5 || new DrizzleService();
  }
  /**
   * Create a new customer record
   * 
   * @param companyId ID of the company that owns this customer
   * @param franchiseId ID of the franchise if applicable (can be null)
   * @param name Customer name
   * @param email Customer email (optional)
   * @returns The newly created customer record
   */
  async createCustomer(companyId, franchiseId, name, email) {
    this.logger.debug(`Creating customer: ${name} for company ${companyId}`);
    const inserted = await this.drizzle.insert(customers).values({
      companyId,
      name,
      email,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).returning();
    return inserted[0];
  }
  /**
   * Get a customer by ID
   * 
   * @param customerId ID of the customer to fetch
   * @param companyId Company ID for security validation
   * @returns The customer record if found
   */
  async getCustomerById(customerId, companyId) {
    this.logger.debug(`Getting customer by ID: ${customerId} for company ${companyId}`);
    const result = await this.drizzle.select().from(customers).where(
      eq75(customers.id, customerId)
    ).limit(1);
    return result[0] || null;
  }
  /**
   * Get all customers for a company
   * 
   * @param companyId Company ID
   * @param limit Maximum number of results to return
   * @param offset Number of records to skip for pagination
   * @returns Array of customer records
   */
  async getCustomersByCompany(companyId, limit = 50, offset = 0) {
    this.logger.debug(`Getting customers for company ${companyId}, limit: ${limit}, offset: ${offset}`);
    const result = await this.drizzle.select().from(customers).where(
      eq75(customers.companyId, companyId)
    ).limit(limit).offset(offset);
    return result;
  }
};

// server/modules/sales/sales.module.ts
init_logger();
init_drizzle_service();

// server/modules/sales/sales.controller.ts
import { Router as Router42 } from "express";
init_auth_guard();
init_auth_mode_enum();
init_logger();
init_drizzle_service();
var logger101 = new Logger("SalesController");
var router12 = Router42();
var drizzleService2 = new DrizzleService();
var customerService = new CustomerService2(drizzleService2);
router12.use(AuthGuard.protect("required" /* REQUIRED */));
router12.post(
  "/customer",
  AuthGuard.roleGuard(["sales_team", "SALES_TEAM", "sales_manager", "SALES_MANAGER"]),
  async (req, res) => {
    try {
      logger101.info(`Creating new customer for company ${req.user?.companyId}`);
      const { name, email, franchiseId } = req.body;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      if (!name) {
        return res.status(400).json({
          success: false,
          message: "Customer name is required"
        });
      }
      const customer = await customerService.createCustomer(
        companyId,
        franchiseId,
        name,
        email
      );
      logger101.info(`Customer created successfully - ID: ${customer.id}, Company: ${customer.companyId}`);
      return res.status(201).json({
        success: true,
        data: customer
      });
    } catch (error) {
      logger101.error("Error creating customer", error);
      return res.status(500).json({
        success: false,
        message: "An error occurred while creating the customer"
      });
    }
  }
);
router12.get(
  "/customer/:id",
  AuthGuard.roleGuard(["sales_team", "SALES_TEAM", "sales_manager", "SALES_MANAGER"]),
  async (req, res) => {
    try {
      const customerId = req.params.id;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const customer = await customerService.getCustomerById(customerId, companyId);
      if (!customer) {
        return res.status(404).json({
          success: false,
          message: "Customer not found"
        });
      }
      return res.json({
        success: true,
        data: customer
      });
    } catch (error) {
      logger101.error("Error retrieving customer", error);
      return res.status(500).json({
        success: false,
        message: "An error occurred while retrieving the customer"
      });
    }
  }
);
router12.get(
  "/customers",
  AuthGuard.roleGuard(["sales_team", "SALES_TEAM", "sales_manager", "SALES_MANAGER"]),
  async (req, res) => {
    try {
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
      }
      const limit = req.query.limit ? parseInt(req.query.limit, 10) : 50;
      const offset = req.query.offset ? parseInt(req.query.offset, 10) : 0;
      const customers2 = await customerService.getCustomersByCompany(companyId, limit, offset);
      return res.json({
        success: true,
        data: customers2
      });
    } catch (error) {
      logger101.error("Error listing customers", error);
      return res.status(500).json({
        success: false,
        message: "An error occurred while listing customers"
      });
    }
  }
);
var sales_controller_default = router12;

// server/modules/sales/sales.module.ts
var logger102 = new Logger("SalesModule");
var SalesModule = class _SalesModule {
  /**
   * Register the Sales module with the Express application
   */
  static register(app2) {
    logger102.info("Registering Sales Module");
    const module = new _SalesModule();
    module.initialize(app2);
  }
  constructor() {
    this.drizzleService = new DrizzleService();
    this.customerService = new CustomerService2(this.drizzleService);
    this.jwtService = new JwtService();
  }
  /**
   * Initialize the Sales module
   */
  initialize(app2) {
    logger102.info("Initializing Sales Module");
    this.registerRoutes(app2);
  }
  /**
   * Register all routes for the Sales module
   */
  registerRoutes(app2) {
    app2.use("/api/sales", sales_controller_default);
    logger102.info("Sales routes registered at /api/sales");
  }
};
function initSalesModule(app2) {
  logger102.info("Initializing Sales Module");
  SalesModule.register(app2);
}

// server/modules/accounting/routes/accounting.routes.ts
import { Router as Router49 } from "express";

// server/modules/accounting/services/accounting.service.ts
var AccountingService = class {
  constructor(storage3) {
    this.storage = storage3;
  }
  // Account Classes
  async getAccountClasses() {
    return this.storage.getAccountClasses();
  }
  async getAccountClass(id) {
    return this.storage.getAccountClass(id);
  }
  async getAccountClassByCode(code) {
    return this.storage.getAccountClassByCode(code);
  }
  // Account Groups
  async getAccountGroups() {
    return this.storage.getAccountGroups();
  }
  async getAccountGroupsByClass(classId) {
    return this.storage.getAccountGroupsByClass(classId);
  }
  async getAccountGroup(id) {
    return this.storage.getAccountGroup(id);
  }
  // Synthetic Accounts
  async getSyntheticAccounts() {
    return this.storage.getSyntheticAccounts();
  }
  async getSyntheticAccountsByGroup(groupId) {
    return this.storage.getSyntheticAccountsByGroup(groupId);
  }
  async getSyntheticAccountsByGrade(grade) {
    return this.storage.getSyntheticAccountsByGrade(grade);
  }
  async getSyntheticAccount(id) {
    return this.storage.getSyntheticAccount(id);
  }
  // Analytic Accounts
  async getAnalyticAccounts() {
    return this.storage.getAnalyticAccounts();
  }
  async getAnalyticAccountsBySynthetic(syntheticId) {
    return this.storage.getAnalyticAccountsBySynthetic(syntheticId);
  }
  async getAnalyticAccount(id) {
    return this.storage.getAnalyticAccount(id);
  }
  async createAnalyticAccount(accountData) {
    return this.storage.createAnalyticAccount(accountData);
  }
  // Journal Entries
  async getJournalEntries() {
    return this.storage.getJournalEntries();
  }
  async getJournalEntry(id) {
    return this.storage.getJournalEntry(id);
  }
  async createJournalEntry(entry, lines) {
    this.validateJournalEntry(lines);
    return this.storage.createJournalEntry(entry, lines);
  }
  validateJournalEntry(lines) {
    let totalDebit = 0;
    let totalCredit = 0;
    for (const line of lines) {
      totalDebit += Number(line.debit || 0);
      totalCredit += Number(line.credit || 0);
    }
    if (totalDebit !== totalCredit) {
      throw new Error(`Journal entry is not balanced. Total debit: ${totalDebit}, Total credit: ${totalCredit}`);
    }
    if (lines.length < 2) {
      throw new Error("Journal entry must have at least two lines");
    }
  }
};

// server/modules/accounting/routes/accounting.routes.ts
init_storage();
init_auth_guard();
init_auth_mode_enum();

// server/modules/accounting/routes/sales-journal.routes.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router43 } from "express";

// server/modules/accounting/controllers/base.controller.ts
var BaseController = class {
  /**
   * Handle API request with standardized error handling
   */
  async handleRequest(req, res, handler) {
    try {
      const result = await handler();
      res.status(200).json(result);
    } catch (error) {
      console.error("Controller error:", error);
      const statusCode = error.statusCode || 500;
      const message = error.message || "Internal server error";
      res.status(statusCode).json({
        error: true,
        message,
        details: error.details || null
      });
    }
  }
  /**
   * Extract company ID from request
   */
  getCompanyId(req) {
    if (!req.user || !req.user.companyId) {
      throw {
        statusCode: 401,
        message: "User is not associated with a company"
      };
    }
    return req.user.companyId;
  }
  /**
   * Extract user ID from request
   */
  getUserId(req) {
    if (!req.user || !req.user.id) {
      throw {
        statusCode: 401,
        message: "User ID not found in request"
      };
    }
    return req.user.id;
  }
  /**
   * Extract franchise ID from request (if available)
   */
  getFranchiseId(req) {
    if (!req.user) {
      throw {
        statusCode: 401,
        message: "User not authenticated"
      };
    }
    return req.user.franchiseId || null;
  }
  /**
   * Get pagination parameters with defaults
   */
  getPaginationParams(req) {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    return {
      page: Math.max(1, page),
      // Ensure page is at least 1
      limit: Math.min(Math.max(1, limit), 100)
      // Limit between 1 and 100
    };
  }
  /**
   * Parse date parameter safely
   */
  parseDate(dateStr) {
    if (!dateStr) return void 0;
    try {
      const date5 = new Date(dateStr);
      if (isNaN(date5.getTime())) {
        return void 0;
      }
      return date5;
    } catch (error) {
      return void 0;
    }
  }
};

// server/modules/accounting/controllers/sales-journal.controller.ts
var SalesJournalController = class extends BaseController {
  /**
   * Constructor
   */
  constructor(salesJournalService2) {
    super();
    this.salesJournalService = salesJournalService2;
  }
  /**
   * Get all customer invoices with pagination and filtering
   */
  async getCustomerInvoices(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const { page, limit } = this.getPaginationParams(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate);
      const customerId = req.query.customerId;
      const status = req.query.status;
      return await this.salesJournalService.getCustomerInvoices(
        companyId,
        page,
        limit,
        startDate,
        endDate,
        customerId,
        status
      );
    });
  }
  /**
   * Get invoice by ID
   */
  async getCustomerInvoice(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const invoiceId = req.params.id;
      const invoice = await this.salesJournalService.getCustomerInvoice(invoiceId, companyId);
      if (!invoice) {
        throw { statusCode: 404, message: "Customer invoice not found" };
      }
      return invoice;
    });
  }
  /**
   * Create customer invoice
   */
  async createCustomerInvoice(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const {
        invoiceData,
        customer,
        items,
        taxRates,
        paymentTerms,
        notes
      } = req.body;
      invoiceData.companyId = companyId;
      invoiceData.userId = userId;
      const invoiceId = await this.salesJournalService.createCustomerInvoice(
        invoiceData,
        customer,
        items,
        taxRates,
        paymentTerms,
        notes
      );
      return await this.salesJournalService.getCustomerInvoice(invoiceId, companyId);
    });
  }
  /**
   * Update customer invoice
   */
  async updateCustomerInvoice(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const invoiceId = req.params.id;
      const existingInvoice = await this.salesJournalService.getCustomerInvoice(invoiceId, companyId);
      if (!existingInvoice) {
        throw { statusCode: 404, message: "Customer invoice not found" };
      }
      const {
        invoiceData,
        customer,
        items,
        taxRates,
        paymentTerms,
        notes
      } = req.body;
      invoiceData.companyId = companyId;
      invoiceData.id = invoiceId;
      await this.salesJournalService.updateCustomerInvoice(
        invoiceData,
        customer,
        items,
        taxRates,
        paymentTerms,
        notes
      );
      return await this.salesJournalService.getCustomerInvoice(invoiceId, companyId);
    });
  }
  /**
   * Delete customer invoice
   */
  async deleteCustomerInvoice(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const invoiceId = req.params.id;
      const existingInvoice = await this.salesJournalService.getCustomerInvoice(invoiceId, companyId);
      if (!existingInvoice) {
        throw { statusCode: 404, message: "Customer invoice not found" };
      }
      await this.salesJournalService.deleteCustomerInvoice(invoiceId, companyId);
      return { success: true, message: "Customer invoice deleted successfully" };
    });
  }
  /**
   * Record payment for invoice
   */
  async recordInvoicePayment(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const invoiceId = req.params.id;
      const existingInvoice = await this.salesJournalService.getCustomerInvoice(invoiceId, companyId);
      if (!existingInvoice) {
        throw { statusCode: 404, message: "Customer invoice not found" };
      }
      const { paymentData } = req.body;
      paymentData.companyId = companyId;
      paymentData.userId = userId;
      paymentData.invoiceId = invoiceId;
      const paymentId = await this.salesJournalService.recordInvoicePayment(paymentData);
      const payment = await this.salesJournalService.getInvoicePayment(paymentId, companyId);
      if (!payment) {
        throw {
          statusCode: 500,
          message: "Payment was recorded but could not be retrieved"
        };
      }
      return payment;
    });
  }
  /**
   * Get payments for an invoice
   */
  async getInvoicePayments(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const invoiceId = req.params.id;
      const existingInvoice = await this.salesJournalService.getCustomerInvoice(invoiceId, companyId);
      if (!existingInvoice) {
        throw { statusCode: 404, message: "Customer invoice not found" };
      }
      return await this.salesJournalService.getInvoicePayments(invoiceId, companyId);
    });
  }
  /**
   * Delete payment
   */
  async deleteInvoicePayment(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const paymentId = req.params.id;
      const existingPayment = await this.salesJournalService.getInvoicePayment(paymentId, companyId);
      if (!existingPayment) {
        throw { statusCode: 404, message: "Payment not found" };
      }
      await this.salesJournalService.deleteInvoicePayment(paymentId, companyId);
      return { success: true, message: "Payment deleted successfully" };
    });
  }
  /**
   * Create sales receipt (cash sale)
   */
  async createSalesReceipt(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const receiptData = { ...req.body, companyId, userId };
      const receiptId = await this.salesJournalService.createSalesReceipt(receiptData);
      const receipt = await this.salesJournalService.getSalesReceipt(receiptId, companyId);
      if (!receipt) {
        throw {
          statusCode: 500,
          message: "Sales receipt was created but could not be retrieved"
        };
      }
      return receipt;
    });
  }
  /**
   * Get all sales receipts
   */
  async getSalesReceipts(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const { page, limit } = this.getPaginationParams(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate);
      const customerId = req.query.customerId;
      return await this.salesJournalService.getSalesReceipts(
        companyId,
        page,
        limit,
        startDate,
        endDate,
        customerId
      );
    });
  }
  /**
   * Get sales receipt by ID
   */
  async getSalesReceipt(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const receiptId = req.params.id;
      const receipt = await this.salesJournalService.getSalesReceipt(receiptId, companyId);
      if (!receipt) {
        throw { statusCode: 404, message: "Sales receipt not found" };
      }
      return receipt;
    });
  }
  /**
   * Create sales ledger entry
   */
  async createSalesLedgerEntry(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const ledgerEntryData = { ...req.body, companyId, userId };
      const entryId = await this.salesJournalService.createSalesLedgerEntry(ledgerEntryData);
      const entry = await this.salesJournalService.getSalesLedgerEntry(entryId, companyId);
      if (!entry) {
        throw {
          statusCode: 500,
          message: "Ledger entry was created but could not be retrieved"
        };
      }
      return entry;
    });
  }
  /**
   * Get sales ledger entries
   */
  async getSalesLedgerEntries(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const { page, limit } = this.getPaginationParams(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate);
      return await this.salesJournalService.getSalesLedgerEntries(
        companyId,
        page,
        limit,
        startDate,
        endDate
      );
    });
  }
  /**
   * Get sales ledger entry by ID
   */
  async getSalesLedgerEntry(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const entryId = req.params.id;
      const entry = await this.salesJournalService.getSalesLedgerEntry(entryId, companyId);
      if (!entry) {
        throw { statusCode: 404, message: "Sales ledger entry not found" };
      }
      return entry;
    });
  }
  /**
   * Generate customer account statement
   */
  async getCustomerAccountStatement(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const customerId = req.params.id;
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate) || /* @__PURE__ */ new Date();
      return await this.salesJournalService.generateCustomerAccountStatement(
        companyId,
        customerId,
        startDate,
        endDate
      );
    });
  }
  /**
   * Get customer balance
   */
  async getCustomerBalance(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const customerId = req.params.id;
      const asOfDate = this.parseDate(req.query.asOfDate) || /* @__PURE__ */ new Date();
      return await this.salesJournalService.getCustomerBalanceAsOf(
        companyId,
        customerId,
        asOfDate
      );
    });
  }
  /**
   * Generate sales report by period
   */
  async getSalesByPeriodReport(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate) || /* @__PURE__ */ new Date();
      const groupBy = req.query.groupBy || "month";
      return await this.salesJournalService.generateSalesByPeriodReport(
        companyId,
        startDate,
        endDate,
        groupBy
      );
    });
  }
  /**
   * Generate sales report by product
   */
  async getSalesByProductReport(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate) || /* @__PURE__ */ new Date();
      return await this.salesJournalService.generateSalesByProductReport(
        companyId,
        startDate,
        endDate
      );
    });
  }
  /**
   * Generate sales report by customer
   */
  async getSalesByCustomerReport(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate) || /* @__PURE__ */ new Date();
      return await this.salesJournalService.generateSalesByCustomerReport(
        companyId,
        startDate,
        endDate
      );
    });
  }
};

// server/modules/accounting/routes/sales-journal.routes.ts
function setupSalesJournalRoutes() {
  const router14 = Router43();
  const salesJournalController2 = new SalesJournalController(salesJournalService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/invoices", (req, res) => {
    salesJournalController2.getCustomerInvoices(req, res);
  });
  router14.get("/invoices/:id", (req, res) => {
    salesJournalController2.getCustomerInvoice(req, res);
  });
  router14.post(
    "/invoices",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      salesJournalController2.createCustomerInvoice(req, res);
    }
  );
  router14.put(
    "/invoices/:id",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      salesJournalController2.updateCustomerInvoice(req, res);
    }
  );
  router14.delete(
    "/invoices/:id",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      salesJournalController2.deleteCustomerInvoice(req, res);
    }
  );
  router14.post(
    "/invoices/:id/payments",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      salesJournalController2.recordInvoicePayment(req, res);
    }
  );
  router14.get("/invoices/:id/payments", (req, res) => {
    salesJournalController2.getInvoicePayments(req, res);
  });
  router14.delete(
    "/payments/:id",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      salesJournalController2.deleteInvoicePayment(req, res);
    }
  );
  router14.post(
    "/receipts",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      salesJournalController2.createSalesReceipt(req, res);
    }
  );
  router14.get("/receipts", (req, res) => {
    salesJournalController2.getSalesReceipts(req, res);
  });
  router14.get("/receipts/:id", (req, res) => {
    salesJournalController2.getSalesReceipt(req, res);
  });
  router14.post(
    "/ledger-entries",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      salesJournalController2.createSalesLedgerEntry(req, res);
    }
  );
  router14.get("/ledger-entries", (req, res) => {
    salesJournalController2.getSalesLedgerEntries(req, res);
  });
  router14.get("/ledger-entries/:id", (req, res) => {
    salesJournalController2.getSalesLedgerEntry(req, res);
  });
  router14.get("/customers/:id/statement", (req, res) => {
    salesJournalController2.getCustomerAccountStatement(req, res);
  });
  router14.get("/customers/:id/balance", (req, res) => {
    salesJournalController2.getCustomerBalance(req, res);
  });
  router14.get("/reports/sales-by-period", (req, res) => {
    salesJournalController2.getSalesByPeriodReport(req, res);
  });
  router14.get("/reports/sales-by-product", (req, res) => {
    salesJournalController2.getSalesByProductReport(req, res);
  });
  router14.get("/reports/sales-by-customer", (req, res) => {
    salesJournalController2.getSalesByCustomerReport(req, res);
  });
  return router14;
}

// server/modules/accounting/routes/purchase-journal.routes.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router44 } from "express";

// server/modules/accounting/controllers/purchase-journal.controller.ts
var PurchaseJournalController = class extends BaseController {
  /**
   * Constructor
   */
  constructor(purchaseJournalService2) {
    super();
    this.purchaseJournalService = purchaseJournalService2;
  }
  /**
   * Get all supplier invoices with pagination and filtering
   */
  async getSupplierInvoices(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const { page, limit } = this.getPaginationParams(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate);
      const supplierId = req.query.supplierId;
      const status = req.query.status;
      return await this.purchaseJournalService.getSupplierInvoices(
        companyId,
        page,
        limit,
        startDate,
        endDate,
        supplierId,
        status
      );
    });
  }
  /**
   * Get supplier invoice by ID
   */
  async getSupplierInvoice(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const invoiceId = req.params.id;
      const invoice = await this.purchaseJournalService.getSupplierInvoice(invoiceId, companyId);
      if (!invoice) {
        throw { statusCode: 404, message: "Supplier invoice not found" };
      }
      return invoice;
    });
  }
  /**
   * Record supplier invoice
   */
  async recordSupplierInvoice(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const {
        invoiceData,
        supplier,
        items,
        taxRates,
        paymentTerms,
        notes
      } = req.body;
      invoiceData.companyId = companyId;
      invoiceData.userId = userId;
      const invoiceId = await this.purchaseJournalService.recordSupplierInvoice(
        invoiceData,
        supplier,
        items,
        taxRates,
        paymentTerms,
        notes
      );
      return await this.purchaseJournalService.getSupplierInvoice(invoiceId, companyId);
    });
  }
  /**
   * Update supplier invoice
   */
  async updateSupplierInvoice(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const invoiceId = req.params.id;
      const existingInvoice = await this.purchaseJournalService.getSupplierInvoice(invoiceId, companyId);
      if (!existingInvoice) {
        throw { statusCode: 404, message: "Supplier invoice not found" };
      }
      const {
        invoiceData,
        supplier,
        items,
        taxRates,
        paymentTerms,
        notes
      } = req.body;
      invoiceData.companyId = companyId;
      invoiceData.id = invoiceId;
      await this.purchaseJournalService.updateSupplierInvoice(
        invoiceData,
        supplier,
        items,
        taxRates,
        paymentTerms,
        notes
      );
      return await this.purchaseJournalService.getSupplierInvoice(invoiceId, companyId);
    });
  }
  /**
   * Delete supplier invoice
   */
  async deleteSupplierInvoice(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const invoiceId = req.params.id;
      const existingInvoice = await this.purchaseJournalService.getSupplierInvoice(invoiceId, companyId);
      if (!existingInvoice) {
        throw { statusCode: 404, message: "Supplier invoice not found" };
      }
      await this.purchaseJournalService.deleteSupplierInvoice(invoiceId, companyId);
      return { success: true, message: "Supplier invoice deleted successfully" };
    });
  }
  /**
   * Record payment for invoice
   */
  async recordInvoicePayment(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const invoiceId = req.params.id;
      const existingInvoice = await this.purchaseJournalService.getSupplierInvoice(invoiceId, companyId);
      if (!existingInvoice) {
        throw { statusCode: 404, message: "Supplier invoice not found" };
      }
      const { paymentData } = req.body;
      paymentData.companyId = companyId;
      paymentData.userId = userId;
      paymentData.invoiceId = invoiceId;
      const paymentId = await this.purchaseJournalService.recordInvoicePayment(paymentData);
      const payment = await this.purchaseJournalService.getInvoicePayment(paymentId, companyId);
      if (!payment) {
        throw {
          statusCode: 500,
          message: "Payment was recorded but could not be retrieved"
        };
      }
      return payment;
    });
  }
  /**
   * Get payments for an invoice
   */
  async getInvoicePayments(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const invoiceId = req.params.id;
      const existingInvoice = await this.purchaseJournalService.getSupplierInvoice(invoiceId, companyId);
      if (!existingInvoice) {
        throw { statusCode: 404, message: "Supplier invoice not found" };
      }
      return await this.purchaseJournalService.getInvoicePayments(invoiceId, companyId);
    });
  }
  /**
   * Delete payment
   */
  async deleteInvoicePayment(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const paymentId = req.params.id;
      const existingPayment = await this.purchaseJournalService.getInvoicePayment(paymentId, companyId);
      if (!existingPayment) {
        throw { statusCode: 404, message: "Payment not found" };
      }
      await this.purchaseJournalService.deleteInvoicePayment(paymentId, companyId);
      return { success: true, message: "Payment deleted successfully" };
    });
  }
  /**
   * Create purchase ledger entry
   */
  async createPurchaseLedgerEntry(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const ledgerEntryData = { ...req.body, companyId, userId };
      const entryId = await this.purchaseJournalService.createPurchaseLedgerEntry(ledgerEntryData);
      const entry = await this.purchaseJournalService.getPurchaseLedgerEntry(entryId, companyId);
      if (!entry) {
        throw {
          statusCode: 500,
          message: "Ledger entry was created but could not be retrieved"
        };
      }
      return entry;
    });
  }
  /**
   * Get purchase ledger entries
   */
  async getPurchaseLedgerEntries(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const { page, limit } = this.getPaginationParams(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate);
      return await this.purchaseJournalService.getPurchaseLedgerEntries(
        companyId,
        page,
        limit,
        startDate,
        endDate
      );
    });
  }
  /**
   * Get purchase ledger entry by ID
   */
  async getPurchaseLedgerEntry(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const entryId = req.params.id;
      const entry = await this.purchaseJournalService.getPurchaseLedgerEntry(entryId, companyId);
      if (!entry) {
        throw { statusCode: 404, message: "Purchase ledger entry not found" };
      }
      return entry;
    });
  }
  /**
   * Generate supplier account statement
   */
  async getSupplierAccountStatement(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const supplierId = req.params.id;
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate) || /* @__PURE__ */ new Date();
      return await this.purchaseJournalService.generateSupplierAccountStatement(
        companyId,
        supplierId,
        startDate,
        endDate
      );
    });
  }
  /**
   * Get supplier balance
   */
  async getSupplierBalance(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const supplierId = req.params.id;
      const asOfDate = this.parseDate(req.query.asOfDate) || /* @__PURE__ */ new Date();
      return await this.purchaseJournalService.getSupplierBalanceAsOf(
        companyId,
        supplierId,
        asOfDate
      );
    });
  }
};

// server/modules/accounting/routes/purchase-journal.routes.ts
function setupPurchaseJournalRoutes() {
  const router14 = Router44();
  const purchaseJournalController2 = new PurchaseJournalController(purchaseJournalService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/invoices", (req, res) => {
    purchaseJournalController2.getSupplierInvoices(req, res);
  });
  router14.get("/invoices/:id", (req, res) => {
    purchaseJournalController2.getSupplierInvoice(req, res);
  });
  router14.post(
    "/invoices",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      purchaseJournalController2.recordSupplierInvoice(req, res);
    }
  );
  router14.put(
    "/invoices/:id",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      purchaseJournalController2.updateSupplierInvoice(req, res);
    }
  );
  router14.delete(
    "/invoices/:id",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      purchaseJournalController2.deleteSupplierInvoice(req, res);
    }
  );
  router14.post(
    "/invoices/:id/payments",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      purchaseJournalController2.recordInvoicePayment(req, res);
    }
  );
  router14.get("/invoices/:id/payments", (req, res) => {
    purchaseJournalController2.getInvoicePayments(req, res);
  });
  router14.delete(
    "/payments/:id",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      purchaseJournalController2.deleteInvoicePayment(req, res);
    }
  );
  router14.post(
    "/ledger-entries",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      purchaseJournalController2.createPurchaseLedgerEntry(req, res);
    }
  );
  router14.get("/ledger-entries", (req, res) => {
    purchaseJournalController2.getPurchaseLedgerEntries(req, res);
  });
  router14.get("/ledger-entries/:id", (req, res) => {
    purchaseJournalController2.getPurchaseLedgerEntry(req, res);
  });
  router14.get("/suppliers/:id/statement", (req, res) => {
    purchaseJournalController2.getSupplierAccountStatement(req, res);
  });
  router14.get("/suppliers/:id/balance", (req, res) => {
    purchaseJournalController2.getSupplierBalance(req, res);
  });
  return router14;
}

// server/modules/accounting/routes/bank-journal.routes.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router45 } from "express";

// server/modules/accounting/controllers/bank-journal.controller.ts
var BankJournalController = class extends BaseController {
  /**
   * Constructor
   */
  constructor(bankJournalService2) {
    super();
    this.bankJournalService = bankJournalService2;
  }
  /**
   * Get all bank accounts
   */
  async getBankAccounts(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      return await this.bankJournalService.getBankAccounts(companyId);
    });
  }
  /**
   * Get bank account by ID
   */
  async getBankAccount(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const accountId = req.params.id;
      const account = await this.bankJournalService.getBankAccount(accountId, companyId);
      if (!account) {
        throw { statusCode: 404, message: "Bank account not found" };
      }
      return account;
    });
  }
  /**
   * Create bank account
   */
  async createBankAccount(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const accountData = { ...req.body, companyId, userId };
      const accountId = await this.bankJournalService.createBankAccount(accountData);
      const account = await this.bankJournalService.getBankAccount(accountId, companyId);
      if (!account) {
        throw {
          statusCode: 500,
          message: "Account was created but could not be retrieved"
        };
      }
      return account;
    });
  }
  /**
   * Update bank account
   */
  async updateBankAccount(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const accountId = req.params.id;
      const existingAccount = await this.bankJournalService.getBankAccount(accountId, companyId);
      if (!existingAccount) {
        throw { statusCode: 404, message: "Bank account not found" };
      }
      const accountData = {
        ...req.body,
        id: accountId,
        companyId
      };
      await this.bankJournalService.updateBankAccount(accountData);
      const updatedAccount = await this.bankJournalService.getBankAccount(accountId, companyId);
      return updatedAccount;
    });
  }
  /**
   * Get bank transactions with pagination and filtering
   */
  async getBankTransactions(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const { page, limit } = this.getPaginationParams(req);
      const accountId = req.query.accountId;
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate);
      const type = req.query.type;
      return await this.bankJournalService.getBankTransactions(
        companyId,
        page,
        limit,
        accountId,
        startDate,
        endDate,
        type
      );
    });
  }
  /**
   * Get bank transaction by ID
   */
  async getBankTransaction(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const transactionId = req.params.id;
      const transaction = await this.bankJournalService.getBankTransaction(transactionId, companyId);
      if (!transaction) {
        throw { statusCode: 404, message: "Bank transaction not found" };
      }
      return transaction;
    });
  }
  /**
   * Create bank deposit
   */
  async createDeposit(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const accountId = req.params.id;
      const existingAccount = await this.bankJournalService.getBankAccount(accountId, companyId);
      if (!existingAccount) {
        throw { statusCode: 404, message: "Bank account not found" };
      }
      const depositData = {
        ...req.body,
        companyId,
        userId,
        accountId
      };
      const transactionId = await this.bankJournalService.createDeposit(depositData);
      const transaction = await this.bankJournalService.getBankTransaction(transactionId, companyId);
      if (!transaction) {
        throw {
          statusCode: 500,
          message: "Deposit was recorded but could not be retrieved"
        };
      }
      return transaction;
    });
  }
  /**
   * Create bank payment
   */
  async createPayment(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const accountId = req.params.id;
      const existingAccount = await this.bankJournalService.getBankAccount(accountId, companyId);
      if (!existingAccount) {
        throw { statusCode: 404, message: "Bank account not found" };
      }
      const paymentData = {
        ...req.body,
        companyId,
        userId,
        accountId
      };
      const transactionId = await this.bankJournalService.createPayment(paymentData);
      const transaction = await this.bankJournalService.getBankTransaction(transactionId, companyId);
      if (!transaction) {
        throw {
          statusCode: 500,
          message: "Payment was recorded but could not be retrieved"
        };
      }
      return transaction;
    });
  }
  /**
   * Create bank transfer between accounts
   */
  async createBankTransfer(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const fromAccountId = req.params.id;
      const { toAccountId } = req.body;
      const fromAccount = await this.bankJournalService.getBankAccount(fromAccountId, companyId);
      const toAccount = await this.bankJournalService.getBankAccount(toAccountId, companyId);
      if (!fromAccount) {
        throw { statusCode: 404, message: "Source bank account not found" };
      }
      if (!toAccount) {
        throw { statusCode: 404, message: "Destination bank account not found" };
      }
      const transferData = {
        ...req.body,
        companyId,
        userId,
        fromAccountId,
        toAccountId
      };
      const { sourceTransactionId, destinationTransactionId } = await this.bankJournalService.createBankTransfer(transferData);
      const sourceTransaction = await this.bankJournalService.getBankTransaction(sourceTransactionId, companyId);
      const destinationTransaction = await this.bankJournalService.getBankTransaction(destinationTransactionId, companyId);
      if (!sourceTransaction || !destinationTransaction) {
        throw {
          statusCode: 500,
          message: "Transfer was recorded but transactions could not be retrieved"
        };
      }
      return {
        sourceTransaction,
        destinationTransaction
      };
    });
  }
  /**
   * Import bank statement
   */
  async importBankStatement(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const accountId = req.params.id;
      const existingAccount = await this.bankJournalService.getBankAccount(accountId, companyId);
      if (!existingAccount) {
        throw { statusCode: 404, message: "Bank account not found" };
      }
      if (!req.file) {
        throw { statusCode: 400, message: "No file uploaded" };
      }
      const { path: path6 } = req.file;
      const { format, dateFormat } = req.body;
      const importResult = await this.bankJournalService.importBankStatement(
        accountId,
        companyId,
        path6,
        format,
        dateFormat
      );
      return importResult;
    });
  }
  /**
   * Create bank reconciliation
   */
  async createReconciliation(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const accountId = req.params.id;
      const existingAccount = await this.bankJournalService.getBankAccount(accountId, companyId);
      if (!existingAccount) {
        throw { statusCode: 404, message: "Bank account not found" };
      }
      const reconciliationData = {
        ...req.body,
        companyId,
        userId,
        accountId
      };
      const result = await this.bankJournalService.createReconciliation(reconciliationData);
      return result;
    });
  }
  /**
   * Get bank account balance as of a specific date
   */
  async getBankAccountBalance(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const accountId = req.params.id;
      const asOfDate = this.parseDate(req.query.asOfDate) || /* @__PURE__ */ new Date();
      return await this.bankJournalService.getBankAccountBalanceAsOf(
        accountId,
        companyId,
        asOfDate
      );
    });
  }
  /**
   * Generate bank statement for a date range
   */
  async generateBankStatement(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const accountId = req.params.id;
      const existingAccount = await this.bankJournalService.getBankAccount(accountId, companyId);
      if (!existingAccount) {
        throw { statusCode: 404, message: "Bank account not found" };
      }
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate) || /* @__PURE__ */ new Date();
      return await this.bankJournalService.generateBankStatement(
        accountId,
        companyId,
        startDate,
        endDate
      );
    });
  }
  /**
   * Get all bank accounts with balances
   */
  async getBankAccountsWithBalances(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const asOfDate = this.parseDate(req.query.asOfDate) || /* @__PURE__ */ new Date();
      return await this.bankJournalService.getBankAccountsWithBalances(
        companyId,
        asOfDate
      );
    });
  }
};

// server/modules/accounting/routes/bank-journal.routes.ts
function setupBankJournalRoutes() {
  const router14 = Router45();
  const bankJournalController2 = new BankJournalController(bankJournalService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/accounts", (req, res) => {
    bankJournalController2.getBankAccounts(req, res);
  });
  router14.get("/accounts/:id", (req, res) => {
    bankJournalController2.getBankAccount(req, res);
  });
  router14.post(
    "/accounts",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      bankJournalController2.createBankAccount(req, res);
    }
  );
  router14.put(
    "/accounts/:id",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      bankJournalController2.updateBankAccount(req, res);
    }
  );
  router14.get("/transactions", (req, res) => {
    bankJournalController2.getBankTransactions(req, res);
  });
  router14.get("/transactions/:id", (req, res) => {
    bankJournalController2.getBankTransaction(req, res);
  });
  router14.post(
    "/transactions/deposits",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      bankJournalController2.createDeposit(req, res);
    }
  );
  router14.post(
    "/transactions/payments",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      bankJournalController2.createPayment(req, res);
    }
  );
  router14.post(
    "/transactions/transfers",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      bankJournalController2.createBankTransfer(req, res);
    }
  );
  router14.post(
    "/statements/import/:bankAccountId",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      bankJournalController2.importBankStatement(req, res);
    }
  );
  router14.post(
    "/reconciliations/:bankAccountId",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      bankJournalController2.createReconciliation(req, res);
    }
  );
  router14.get("/accounts/:id/balance", (req, res) => {
    bankJournalController2.getBankAccountBalance(req, res);
  });
  router14.get("/accounts/:id/statement", (req, res) => {
    bankJournalController2.generateBankStatement(req, res);
  });
  router14.post(
    "/transactions/entry",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      bankJournalController2.createBankTransactionEntry(req, res);
    }
  );
  return router14;
}

// server/modules/accounting/routes/cash-register.routes.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router46 } from "express";

// server/modules/accounting/controllers/cash-register.controller.ts
var CashRegisterController = class extends BaseController {
  constructor(cashRegisterService2) {
    super();
    this.cashRegisterService = cashRegisterService2;
  }
  /**
   * Get all cash registers for a company
   * GET /api/accounting/cash-register/registers
   */
  async getCashRegisters(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      return await this.cashRegisterService.getCashRegisters(companyId);
    });
  }
  /**
   * Get cash register by ID
   * GET /api/accounting/cash-register/registers/:id
   */
  async getCashRegister(req, res) {
    await this.handleRequest(req, res, async () => {
      const registerId = req.params.id;
      const companyId = this.getCompanyId(req);
      const register = await this.cashRegisterService.getCashRegister(registerId, companyId);
      if (!register) {
        throw {
          statusCode: 404,
          message: "Cash register not found"
        };
      }
      return register;
    });
  }
  /**
   * Create new cash register
   * POST /api/accounting/cash-register/registers
   */
  async createCashRegister(req, res) {
    await this.handleRequest(req, res, async () => {
      const registerData = req.body;
      registerData.companyId = this.getCompanyId(req);
      try {
        const registerId = await this.cashRegisterService.createCashRegister(registerData);
        const register = await this.cashRegisterService.getCashRegister(registerId, registerData.companyId);
        return {
          ...register,
          message: "Cash register created successfully"
        };
      } catch (error) {
        if (error.message && error.message.includes("validation")) {
          throw {
            statusCode: 400,
            message: error.message
          };
        }
        throw error;
      }
    });
  }
  /**
   * Update cash register
   * PUT /api/accounting/cash-register/registers/:id
   */
  async updateCashRegister(req, res) {
    await this.handleRequest(req, res, async () => {
      const registerId = req.params.id;
      const companyId = this.getCompanyId(req);
      const registerData = req.body;
      try {
        const existingRegister = await this.cashRegisterService.getCashRegister(registerId, companyId);
        if (!existingRegister) {
          throw {
            statusCode: 404,
            message: "Cash register not found"
          };
        }
        await this.cashRegisterService.updateCashRegister(registerId, registerData, companyId);
        const updatedRegister = await this.cashRegisterService.getCashRegister(registerId, companyId);
        return {
          ...updatedRegister,
          message: "Cash register updated successfully"
        };
      } catch (error) {
        if (error.message && error.message.includes("validation")) {
          throw {
            statusCode: 400,
            message: error.message
          };
        }
        throw error;
      }
    });
  }
  /**
   * Get cash transactions with pagination and filtering
   * GET /api/accounting/cash-register/transactions
   */
  async getCashTransactions(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const registerId = req.query.registerId;
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const startDate = req.query.startDate ? new Date(req.query.startDate) : void 0;
      const endDate = req.query.endDate ? new Date(req.query.endDate) : void 0;
      return await this.cashRegisterService.getCashTransactions(
        companyId,
        registerId,
        page,
        limit,
        startDate,
        endDate
      );
    });
  }
  /**
   * Get cash transaction by ID
   * GET /api/accounting/cash-register/transactions/:id
   */
  async getCashTransaction(req, res) {
    await this.handleRequest(req, res, async () => {
      const transactionId = req.params.id;
      const companyId = this.getCompanyId(req);
      const transaction = await this.cashRegisterService.getCashTransaction(
        transactionId,
        companyId
      );
      if (!transaction) {
        throw {
          statusCode: 404,
          message: "Cash transaction not found"
        };
      }
      return transaction;
    });
  }
  /**
   * Record cash receipt
   * POST /api/accounting/cash-register/transactions/receipts
   */
  async recordCashReceipt(req, res) {
    await this.handleRequest(req, res, async () => {
      const {
        receiptData,
        payerInfo,
        referenceDocuments,
        notes
      } = req.body;
      try {
        receiptData.companyId = this.getCompanyId(req);
        receiptData.userId = this.getUserId(req);
        const transactionId = await this.cashRegisterService.recordCashReceipt(
          receiptData,
          payerInfo,
          referenceDocuments,
          notes
        );
        const transaction = await this.cashRegisterService.getCashTransaction(
          transactionId,
          receiptData.companyId
        );
        return {
          ...transaction,
          message: "Cash receipt recorded successfully"
        };
      } catch (error) {
        if (error.message && error.message.includes("validation")) {
          throw {
            statusCode: 400,
            message: error.message
          };
        }
        throw error;
      }
    });
  }
  /**
   * Record cash payment
   * POST /api/accounting/cash-register/transactions/payments
   */
  async recordCashPayment(req, res) {
    await this.handleRequest(req, res, async () => {
      const {
        paymentData,
        payeeInfo,
        referenceDocuments,
        notes
      } = req.body;
      try {
        paymentData.companyId = this.getCompanyId(req);
        paymentData.userId = this.getUserId(req);
        const transactionId = await this.cashRegisterService.recordCashPayment(
          paymentData,
          payeeInfo,
          referenceDocuments,
          notes
        );
        const transaction = await this.cashRegisterService.getCashTransaction(
          transactionId,
          paymentData.companyId
        );
        return {
          ...transaction,
          message: "Cash payment recorded successfully"
        };
      } catch (error) {
        if (error.message && error.message.includes("validation")) {
          throw {
            statusCode: 400,
            message: error.message
          };
        }
        throw error;
      }
    });
  }
  /**
   * Transfer money between cash registers
   * POST /api/accounting/cash-register/transactions/transfers
   */
  async transferCash(req, res) {
    await this.handleRequest(req, res, async () => {
      const {
        sourceRegisterId,
        targetRegisterId,
        date: date5,
        amount,
        description,
        notes
      } = req.body;
      try {
        const companyId = this.getCompanyId(req);
        const userId = this.getUserId(req);
        const transactionId = await this.cashRegisterService.transferCash(
          companyId,
          sourceRegisterId,
          targetRegisterId,
          date5,
          amount,
          description,
          userId,
          notes
        );
        const transaction = await this.cashRegisterService.getCashTransaction(
          transactionId,
          companyId
        );
        return {
          ...transaction,
          message: "Cash transfer recorded successfully"
        };
      } catch (error) {
        if (error.message && (error.message.includes("validation") || error.message.includes("not found"))) {
          throw {
            statusCode: 400,
            message: error.message
          };
        }
        throw error;
      }
    });
  }
  /**
   * Record cash deposit from cash register to bank
   * POST /api/accounting/cash-register/transactions/bank-deposits
   */
  async recordCashDepositToBank(req, res) {
    await this.handleRequest(req, res, async () => {
      const {
        registerId,
        bankAccountId,
        date: date5,
        amount,
        description,
        referenceNumber,
        notes
      } = req.body;
      try {
        const companyId = this.getCompanyId(req);
        const userId = this.getUserId(req);
        const depositId = await this.cashRegisterService.recordCashDepositToBank(
          companyId,
          registerId,
          bankAccountId,
          date5,
          amount,
          description,
          referenceNumber,
          userId,
          notes
        );
        const deposit = await this.cashRegisterService.getCashTransaction(
          depositId,
          companyId
        );
        return {
          ...deposit,
          message: "Cash deposit to bank recorded successfully"
        };
      } catch (error) {
        if (error.message && (error.message.includes("validation") || error.message.includes("not found"))) {
          throw {
            statusCode: 400,
            message: error.message
          };
        }
        throw error;
      }
    });
  }
  /**
   * Record cash withdrawal from bank to cash register
   * POST /api/accounting/cash-register/transactions/bank-withdrawals
   */
  async recordCashWithdrawalFromBank(req, res) {
    await this.handleRequest(req, res, async () => {
      const {
        registerId,
        bankAccountId,
        date: date5,
        amount,
        description,
        referenceNumber,
        notes
      } = req.body;
      try {
        const companyId = this.getCompanyId(req);
        const userId = this.getUserId(req);
        const withdrawalId = await this.cashRegisterService.recordCashWithdrawalFromBank(
          companyId,
          registerId,
          bankAccountId,
          date5,
          amount,
          description,
          referenceNumber,
          userId,
          notes
        );
        const withdrawal = await this.cashRegisterService.getCashTransaction(
          withdrawalId,
          companyId
        );
        return {
          ...withdrawal,
          message: "Cash withdrawal from bank recorded successfully"
        };
      } catch (error) {
        if (error.message && (error.message.includes("validation") || error.message.includes("not found"))) {
          throw {
            statusCode: 400,
            message: error.message
          };
        }
        throw error;
      }
    });
  }
  /**
   * Cash register reconciliation
   * POST /api/accounting/cash-register/reconciliations/:registerId
   */
  async createReconciliation(req, res) {
    await this.handleRequest(req, res, async () => {
      const registerId = req.params.registerId;
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const {
        reconciliationDate,
        physicalCount,
        transactionIds,
        notes
      } = req.body;
      try {
        const result = await this.cashRegisterService.createReconciliation(
          registerId,
          companyId,
          new Date(reconciliationDate),
          physicalCount,
          transactionIds,
          userId,
          notes
        );
        return {
          ...result,
          message: "Cash register reconciliation completed successfully"
        };
      } catch (error) {
        if (error.message && (error.message.includes("validation") || error.message.includes("not found"))) {
          throw {
            statusCode: 400,
            message: error.message
          };
        }
        throw error;
      }
    });
  }
  /**
   * Get cash register balance as of specific date
   * GET /api/accounting/cash-register/registers/:id/balance
   */
  async getCashRegisterBalance(req, res) {
    await this.handleRequest(req, res, async () => {
      const registerId = req.params.id;
      const companyId = this.getCompanyId(req);
      const asOfDate = req.query.asOfDate ? new Date(req.query.asOfDate) : /* @__PURE__ */ new Date();
      const balance = await this.cashRegisterService.getCashRegisterBalanceAsOf(
        registerId,
        companyId,
        asOfDate
      );
      return { balance };
    });
  }
  /**
   * Generate cash register report for a period
   * GET /api/accounting/cash-register/registers/:id/report
   */
  async generateCashRegisterReport(req, res) {
    await this.handleRequest(req, res, async () => {
      const registerId = req.params.id;
      const companyId = this.getCompanyId(req);
      try {
        const startDate = new Date(req.query.startDate);
        const endDate = new Date(req.query.endDate);
        const report = await this.cashRegisterService.generateCashRegisterReport(
          registerId,
          companyId,
          startDate,
          endDate
        );
        return report;
      } catch (error) {
        if (error.message && error.message.includes("date")) {
          throw {
            statusCode: 400,
            message: error.message
          };
        }
        throw error;
      }
    });
  }
  /**
   * Get daily closing report for a cash register
   * GET /api/accounting/cash-register/registers/:id/daily-closing
   */
  async getDailyClosingReport(req, res) {
    await this.handleRequest(req, res, async () => {
      const registerId = req.params.id;
      const companyId = this.getCompanyId(req);
      const date5 = req.query.date ? new Date(req.query.date) : /* @__PURE__ */ new Date();
      const report = await this.cashRegisterService.getDailyClosingReport(
        registerId,
        companyId,
        date5
      );
      return report;
    });
  }
};

// server/modules/accounting/routes/cash-register.routes.ts
function setupCashRegisterRoutes() {
  const router14 = Router46();
  const cashRegisterController2 = new CashRegisterController(cashRegisterService);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.get("/registers", (req, res) => {
    cashRegisterController2.getCashRegisters(req, res);
  });
  router14.get("/registers/:id", (req, res) => {
    cashRegisterController2.getCashRegister(req, res);
  });
  router14.post(
    "/registers",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      cashRegisterController2.createCashRegister(req, res);
    }
  );
  router14.put(
    "/registers/:id",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      cashRegisterController2.updateCashRegister(req, res);
    }
  );
  router14.post(
    "/receipts",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      cashRegisterController2.recordCashReceipt(req, res);
    }
  );
  router14.post(
    "/payments",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      cashRegisterController2.recordCashPayment(req, res);
    }
  );
  router14.post(
    "/transfers",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      cashRegisterController2.transferCash(req, res);
    }
  );
  router14.get("/registers/:id/transactions", (req, res) => {
    cashRegisterController2.getCashTransactions(req, res);
  });
  router14.get("/registers/:id/balance", (req, res) => {
    cashRegisterController2.getCashRegisterBalance(req, res);
  });
  router14.post(
    "/registers/:id/bank-deposits",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      cashRegisterController2.recordCashDepositToBank(req, res);
    }
  );
  router14.post(
    "/registers/:id/bank-withdrawals",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      cashRegisterController2.recordCashWithdrawalFromBank(req, res);
    }
  );
  router14.post(
    "/reconciliations/:registerId",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      cashRegisterController2.createReconciliation(req, res);
    }
  );
  router14.get("/reports/:registerId", (req, res) => {
    cashRegisterController2.generateCashRegisterReport(req, res);
  });
  router14.get("/registers/:id/daily-closing", (req, res) => {
    cashRegisterController2.getDailyClosingReport(req, res);
  });
  return router14;
}

// server/modules/accounting/routes/ledger.routes.ts
import { Router as Router47 } from "express";
init_auth_guard();
init_auth_mode_enum();

// server/modules/accounting/services/journal-service-v2.ts
init_drizzle();
init_audit_service();
import { v4 as uuidv437 } from "uuid";
var LedgerEntryType2 = /* @__PURE__ */ ((LedgerEntryType4) => {
  LedgerEntryType4["SALES"] = "SALES";
  LedgerEntryType4["PURCHASE"] = "PURCHASE";
  LedgerEntryType4["BANK"] = "BANK";
  LedgerEntryType4["CASH"] = "CASH";
  LedgerEntryType4["GENERAL"] = "GENERAL";
  LedgerEntryType4["ADJUSTMENT"] = "ADJUSTMENT";
  LedgerEntryType4["REVERSAL"] = "REVERSAL";
  return LedgerEntryType4;
})(LedgerEntryType2 || {});
var JournalServiceV2 = class {
  /**
   * Create a ledger entry with lines
   * @param options Ledger entry options
   * @returns Created entry data
   */
  async createLedgerEntry(options) {
    const {
      companyId,
      franchiseId,
      type,
      referenceNumber,
      amount,
      description,
      userId,
      lines
    } = options;
    console.log("[DEBUG] createLedgerEntry called with params:", JSON.stringify({
      companyId,
      franchiseId,
      type,
      referenceNumber,
      amount,
      description,
      userId,
      lines
    }, null, 2));
    if (!companyId) {
      throw new Error("Company ID is required");
    }
    if (!type) {
      throw new Error("Ledger entry type is required");
    }
    if (amount === void 0 || amount === null) {
      throw new Error("Amount is required");
    }
    if (!description) {
      throw new Error("Description is required");
    }
    if (!lines || !Array.isArray(lines) || lines.length === 0) {
      throw new Error("At least one ledger line is required");
    }
    this.validateBalancedLines(lines);
    const db4 = getDrizzle();
    try {
      const entryId = uuidv437();
      const now = /* @__PURE__ */ new Date();
      console.log("[DEBUG] Using direct SQL for database operations");
      const sqlClient = getClient();
      await sqlClient`
        INSERT INTO ledger_entries (
          id, company_id, franchise_id, type, reference_number, 
          amount, description, created_at, updated_at, created_by
        ) VALUES (
          ${entryId}, ${companyId}, ${franchiseId || null}, ${type}, ${referenceNumber || null},
          ${amount}, ${description}, ${now.toISOString()}, ${now.toISOString()}, ${userId || null}
        ) RETURNING id
      `;
      console.log("[DEBUG] Entry inserted with ID:", entryId);
      const lineIds = [];
      for (const line of lines) {
        const lineId = uuidv437();
        lineIds.push(lineId);
        const accountId = line.accountId || line.accountNumber;
        if (!accountId) {
          throw new Error("Account ID is required for ledger line");
        }
        const sql58 = getClient();
        await sql58`
          INSERT INTO ledger_lines (
            id, ledger_entry_id, account_id, debit_amount, credit_amount, 
            description, created_at, updated_at
          ) VALUES (
            ${lineId}, ${entryId}, ${accountId}, ${line.debitAmount || 0}, ${line.creditAmount || 0},
            ${line.description || description}, ${now.toISOString()}, ${now.toISOString()}
          )
        `;
      }
      console.log("[DEBUG] Inserted", lineIds.length, "ledger lines");
      const sql57 = getClient();
      const entryResult = await sql57`
        SELECT 
          id, company_id as "companyId", franchise_id as "franchiseId", 
          type, reference_number as "referenceNumber", amount, 
          description, created_at as "createdAt"
        FROM ledger_entries 
        WHERE id = ${entryId}
      `;
      const linesResult = await sql57`
        SELECT 
          id, ledger_entry_id as "ledgerEntryId", account_id as "accountId", 
          debit_amount as "debitAmount", credit_amount as "creditAmount", 
          description
        FROM ledger_lines 
        WHERE ledger_entry_id = ${entryId}
      `;
      await this.updateAccountBalances(lines);
      if (userId) {
        await AuditService.log({
          userId,
          companyId,
          franchiseId,
          action: "CREATE" /* CREATE */,
          entity: "ledger_entry",
          entityId: entryId,
          details: {
            type,
            amount,
            referenceNumber
          }
        });
      }
      const entryRow = entryResult && Array.isArray(entryResult) && entryResult.length > 0 ? entryResult[0] : null;
      const lineRows = linesResult && Array.isArray(linesResult) ? linesResult : [];
      if (!entryRow) {
        console.error("[ERROR] Failed to retrieve entry after creation");
        return {
          id: entryId,
          companyId,
          type,
          referenceNumber: referenceNumber || "",
          amount: Number(amount),
          description,
          createdAt: now.toISOString(),
          lines: lineIds.map((lineId, index12) => ({
            id: lineId,
            ledgerEntryId: entryId,
            accountId: lines[index12].accountId || lines[index12].accountNumber || "",
            debitAmount: Number(lines[index12].debitAmount || 0),
            creditAmount: Number(lines[index12].creditAmount || 0),
            description: lines[index12].description || description
          }))
        };
      }
      return {
        id: entryRow.id,
        companyId: entryRow.companyId,
        type: entryRow.type,
        referenceNumber: entryRow.referenceNumber || "",
        amount: Number(entryRow.amount),
        description: entryRow.description,
        createdAt: entryRow.createdAt,
        lines: lineRows.map((line) => ({
          id: line.id,
          ledgerEntryId: line.ledgerEntryId,
          accountId: line.accountId,
          debitAmount: Number(line.debitAmount || 0),
          creditAmount: Number(line.creditAmount || 0),
          description: line.description || ""
        }))
      };
    } catch (error) {
      console.error("[JournalService] Error creating ledger entry:", error instanceof Error ? error.message : String(error));
      throw new Error(`Failed to create ledger entry: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Reverse a ledger entry
   * @param ledgerEntryId ID of the ledger entry to reverse
   * @param reason Reason for the reversal
   * @returns Reversal ledger entry ID
   */
  async reverseLedgerEntry(ledgerEntryId, reason) {
    if (!ledgerEntryId) {
      throw new Error("Ledger entry ID is required");
    }
    if (!reason) {
      throw new Error("Reversal reason is required");
    }
    const db4 = getDrizzle();
    const sql57 = getClient();
    const entryResult = await sql57`
      SELECT 
        id, company_id as "companyId", franchise_id as "franchiseId", 
        type, reference_number as "referenceNumber", amount, 
        description, created_at as "createdAt", created_by as "createdBy"
      FROM ledger_entries 
      WHERE id = ${ledgerEntryId}
    `;
    const originalEntry = entryResult && Array.isArray(entryResult) && entryResult.length > 0 ? entryResult[0] : null;
    if (!originalEntry) {
      throw new Error(`Ledger entry with ID ${ledgerEntryId} not found`);
    }
    const linesResult = await sql57`
      SELECT 
        id, ledger_entry_id as "ledgerEntryId", account_id as "accountId", 
        debit_amount as "debitAmount", credit_amount as "creditAmount", 
        description
      FROM ledger_lines 
      WHERE ledger_entry_id = ${ledgerEntryId}
    `;
    const originalLines = linesResult && Array.isArray(linesResult) ? linesResult : [];
    if (originalLines.length === 0) {
      throw new Error("Ledger entry is missing its associated lines");
    }
    const reversalLines = originalLines.map((line) => ({
      accountId: line.accountId,
      debitAmount: Number(line.creditAmount),
      creditAmount: Number(line.debitAmount),
      description: `Reversal: ${line.description}`
    }));
    const reversalEntry = await this.createLedgerEntry({
      companyId: originalEntry.companyId,
      franchiseId: originalEntry.franchiseId,
      type: "REVERSAL" /* REVERSAL */,
      referenceNumber: `REV-${originalEntry.referenceNumber || originalEntry.id}`,
      amount: Number(originalEntry.amount),
      description: `Reversal of entry ${originalEntry.id}: ${reason}`,
      userId: originalEntry.createdBy,
      lines: reversalLines
    });
    return reversalEntry.id;
  }
  /**
   * Validate that ledger lines are balanced (debits = credits)
   * @param lines Ledger lines to validate
   * @throws Error if lines are not balanced
   */
  validateBalancedLines(lines) {
    let totalDebits = 0;
    let totalCredits = 0;
    for (const line of lines) {
      totalDebits += Number(line.debitAmount || 0);
      totalCredits += Number(line.creditAmount || 0);
    }
    if (Math.abs(totalDebits - totalCredits) > 0.01) {
      throw new Error(`Ledger lines must be balanced (debits = credits). Current totals: debits = ${totalDebits}, credits = ${totalCredits}`);
    }
  }
  /**
   * Retrieve a ledger entry by ID including all its lines
   * @param entryId The ledger entry ID to retrieve
   * @returns The ledger entry data with lines
   */
  async getLedgerEntryById(entryId) {
    try {
      console.log(`[DEBUG] Getting ledger entry by ID: ${entryId}`);
      const sql57 = getClient();
      const entryResult = await sql57`
        SELECT * FROM ledger_entries 
        WHERE id = ${entryId}
      `;
      if (!entryResult || entryResult.length === 0) {
        console.log(`[DEBUG] No ledger entry found with ID: ${entryId}`);
        return null;
      }
      const entry = entryResult[0];
      const linesResult = await sql57`
        SELECT * FROM ledger_lines
        WHERE ledger_entry_id = ${entryId}
        ORDER BY id
      `;
      const lines = linesResult && Array.isArray(linesResult) ? linesResult : [];
      const result = {
        id: entry.id,
        companyId: entry.company_id,
        type: entry.type,
        referenceNumber: entry.reference_number,
        amount: parseFloat(entry.amount),
        description: entry.description,
        createdAt: entry.created_at,
        lines: lines.map((line) => ({
          id: line.id,
          ledgerEntryId: line.ledger_entry_id,
          accountId: line.account_id,
          debitAmount: parseFloat(line.debit_amount || 0),
          creditAmount: parseFloat(line.credit_amount || 0),
          description: line.description
        }))
      };
      console.log(`[DEBUG] Successfully retrieved ledger entry with ${result.lines.length} lines`);
      return result;
    } catch (error) {
      console.error("[ERROR] Error getting ledger entry by ID:", error);
      throw error;
    }
  }
  /**
   * Calculate account class and group from Romanian account number
   * @param accountId Account ID or number
   * @returns Account class and group
   */
  parseAccountNumber(accountId) {
    const accountNumber = accountId.toString().split("-")[0];
    const accountClass = parseInt(accountNumber.charAt(0));
    const accountGroup = accountNumber.length > 1 ? parseInt(accountNumber.substring(0, 2)) : accountClass * 10;
    return {
      class: accountClass,
      group: accountGroup
    };
  }
  /**
   * Update account balances after ledger entry creation
   * @param lines Ledger lines
   */
  async updateAccountBalances(lines) {
    try {
      const accountUpdates = {};
      for (const line of lines) {
        if (!accountUpdates[line.accountId]) {
          accountUpdates[line.accountId] = { debit: 0, credit: 0 };
        }
        accountUpdates[line.accountId].debit += Number(line.debitAmount || 0);
        accountUpdates[line.accountId].credit += Number(line.creditAmount || 0);
      }
    } catch (error) {
      console.error("[JournalService] Error updating account balances:", error);
    }
  }
  /**
   * Record a simple double-entry transaction (simplified ledger recording)
   * This provides a more direct way to create a ledger entry with just debit and credit accounts
   * 
   * @param options Transaction recording options
   * @returns The created ledger entry ID
   */
  async recordTransaction({
    companyId,
    franchiseId,
    debitAccount,
    creditAccount,
    amount,
    description,
    documentId,
    documentType,
    userId
  }) {
    if (!companyId) {
      throw new Error("Company ID is required");
    }
    if (!debitAccount) {
      throw new Error("Debit account is required");
    }
    if (!creditAccount) {
      throw new Error("Credit account is required");
    }
    if (amount === void 0 || amount === null || amount <= 0) {
      throw new Error("Amount must be a positive number");
    }
    if (!description) {
      throw new Error("Description is required");
    }
    const lines = [
      {
        accountId: debitAccount,
        debitAmount: amount,
        creditAmount: 0,
        description: `${description} (DR)`
      },
      {
        accountId: creditAccount,
        debitAmount: 0,
        creditAmount: amount,
        description: `${description} (CR)`
      }
    ];
    let entryType = "GENERAL" /* GENERAL */;
    if (documentType) {
      try {
        entryType = LedgerEntryType2[documentType] || "GENERAL" /* GENERAL */;
      } catch (e) {
        console.warn(`Invalid document type: ${documentType}, using GENERAL instead`);
      }
    }
    const ledgerEntry = await this.createLedgerEntry({
      companyId,
      franchiseId,
      type: entryType,
      referenceNumber: documentId,
      amount,
      description,
      userId,
      lines
    });
    return ledgerEntry.id;
  }
};

// server/modules/accounting/controllers/journal.controller.ts
var JournalController = class extends BaseController {
  constructor(journalService2) {
    super();
    this.journalService = journalService2;
    this.journalServiceV2 = new JournalServiceV2();
  }
  /**
   * Record a new transaction
   * POST /api/accounting/ledger/transactions
   */
  async recordTransaction(req, res) {
    await this.handleRequest(req, res, async () => {
      const {
        debitAccount,
        creditAccount,
        amount,
        description,
        documentId,
        documentType,
        franchiseId
      } = req.body;
      if (!debitAccount || !creditAccount || !amount || !description) {
        throw {
          statusCode: 400,
          message: "Missing required fields: debitAccount, creditAccount, amount, and description are required"
        };
      }
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      console.log("[DEBUG] Using JournalServiceV2 for transaction recording");
      const entryId = await this.journalServiceV2.recordTransaction({
        companyId,
        franchiseId,
        debitAccount,
        creditAccount,
        amount: Number(amount),
        description,
        documentId,
        documentType,
        userId
      });
      return {
        success: true,
        data: {
          entryId,
          message: "Transaction recorded successfully"
        }
      };
    });
  }
  /**
   * Get transaction details
   * GET /api/accounting/ledger/transactions/:id
   */
  async getTransaction(req, res) {
    await this.handleRequest(req, res, async () => {
      const entryId = req.params.id;
      const companyId = this.getCompanyId(req);
      console.log(`[DEBUG] Fetching transaction details for entry ID: ${entryId} using JournalServiceV2`);
      try {
        const transaction = await this.journalServiceV2.getLedgerEntryById(entryId);
        if (!transaction) {
          throw {
            statusCode: 404,
            message: `Transaction with ID ${entryId} not found`
          };
        }
        if (transaction.companyId !== companyId) {
          throw {
            statusCode: 403,
            message: "You don't have permission to access this transaction"
          };
        }
        return {
          success: true,
          data: transaction
        };
      } catch (error) {
        console.error(`[ERROR] Failed to fetch transaction details: ${error.message || error}`);
        throw {
          statusCode: error.statusCode || 500,
          message: error.message || "Failed to fetch transaction details"
        };
      }
    });
  }
  /**
   * Create a ledger entry
   * POST /api/accounting/ledger/entries or /api/accounting/ledger/entry
   */
  async createLedgerEntry(req, res) {
    await this.handleRequest(req, res, async () => {
      const {
        type,
        referenceNumber,
        documentType,
        documentNumber,
        amount,
        description,
        transactionDate,
        lines
      } = req.body;
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const franchiseId = this.getFranchiseId(req);
      const mappedLines = lines.map((line) => {
        if (line.accountId) {
          return line;
        }
        return {
          ...line,
          accountId: line.accountNumber
        };
      });
      console.log("[DEBUG] Creating ledger entry with mapped lines:", JSON.stringify(mappedLines, null, 2));
      console.log("[DEBUG] Using JournalServiceV2 for direct SQL operations");
      const entry = await this.journalServiceV2.createLedgerEntry({
        companyId,
        franchiseId,
        // Use the type from the request, or map from documentType if not provided
        type: type || documentType,
        // Use referenceNumber if provided, otherwise use documentNumber
        referenceNumber: referenceNumber || documentNumber,
        amount: Number(amount),
        description,
        userId,
        lines: mappedLines
      });
      return {
        success: true,
        data: entry,
        message: "Ledger entry created successfully"
      };
    });
  }
  /**
   * Reverse a ledger entry
   * POST /api/accounting/ledger/entries/:id/reverse
   */
  async reverseLedgerEntry(req, res) {
    await this.handleRequest(req, res, async () => {
      const entryId = req.params.id;
      const { reason } = req.body;
      if (!reason) {
        throw {
          statusCode: 400,
          message: "Reason for reversal is required"
        };
      }
      console.log("[DEBUG] Using JournalServiceV2 for reversal operation");
      const reversalId = await this.journalServiceV2.reverseLedgerEntry(entryId, reason);
      return {
        success: true,
        data: {
          originalEntryId: entryId,
          reversalEntryId: reversalId,
          message: "Ledger entry reversed successfully"
        }
      };
    });
  }
};

// server/modules/accounting/routes/ledger.routes.ts
function setupLedgerRoutes() {
  const router14 = Router47();
  const journalService2 = new JournalService();
  const journalController2 = new JournalController(journalService2);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.post("/transactions", (req, res) => {
    journalController2.recordTransaction(req, res);
  });
  router14.get("/transactions/:id", (req, res) => {
    journalController2.getTransaction(req, res);
  });
  router14.get("/entries", (req, res) => {
    res.json([]);
  });
  router14.post("/entry", (req, res) => {
    journalController2.createLedgerEntry(req, res);
  });
  router14.post("/entries", (req, res) => {
    journalController2.createLedgerEntry(req, res);
  });
  router14.post("/entries/:id/reverse", (req, res) => {
    journalController2.reverseLedgerEntry(req, res);
  });
  return router14;
}

// server/modules/accounting/routes/note-contabil.routes.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router48 } from "express";

// server/modules/accounting/controllers/note-contabil.controller.ts
var NoteContabilController = class extends BaseController {
  constructor(noteContabilService2) {
    super();
    this.noteContabilService = noteContabilService2;
  }
  /**
   * Create a new accounting note
   * POST /api/accounting/note-contabil
   */
  async createNote(req, res) {
    await this.handleRequest(req, res, async () => {
      const { note, lines } = req.body;
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      note.companyId = companyId;
      note.createdBy = userId;
      const result = await this.noteContabilService.createNote(note, lines);
      return {
        success: true,
        data: result
      };
    });
  }
  /**
   * Get accounting notes for a company
   * GET /api/accounting/note-contabil
   */
  async getNotes(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const result = await this.noteContabilService.getNotesByCompany(companyId);
      return {
        success: true,
        data: result
      };
    });
  }
  /**
   * Get accounting note by ID
   * GET /api/accounting/note-contabil/:id
   */
  async getNoteById(req, res) {
    await this.handleRequest(req, res, async () => {
      const { id } = req.params;
      const companyId = this.getCompanyId(req);
      const note = await this.noteContabilService.getNoteById(id, companyId);
      if (!note) {
        throw {
          statusCode: 404,
          message: "Accounting note not found"
        };
      }
      return {
        success: true,
        data: note
      };
    });
  }
  /**
   * Generate accounting note from a validated document
   * POST /api/accounting/note-contabil/generate
   */
  async generateNote(req, res) {
    await this.handleRequest(req, res, async () => {
      const { documentId, documentType } = req.body;
      if (!documentId || !documentType) {
        throw {
          statusCode: 400,
          message: "Document ID and document type are required"
        };
      }
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const note = await this.noteContabilService.generateNoteFromDocument(
        documentId,
        documentType,
        companyId,
        userId
      );
      return {
        success: true,
        data: note
      };
    });
  }
  /**
   * Approve an accounting note
   * POST /api/accounting/note-contabil/:id/approve
   */
  async approveNote(req, res) {
    await this.handleRequest(req, res, async () => {
      const { id } = req.params;
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const note = await this.noteContabilService.approveNote(id, companyId, userId);
      return {
        success: true,
        data: note
      };
    });
  }
};

// server/modules/accounting/services/note-contabil.service.ts
init_audit_service();
init_types();
import { v4 as uuidv438 } from "uuid";
var _NoteContabilService_decorators, _init3;
_NoteContabilService_decorators = [Service()];
var NoteContabilService = class {
  constructor(drizzleService5, auditService4) {
    this.drizzleService = drizzleService5;
    this.auditService = auditService4;
  }
  /**
   * Create a new accounting note (Notă Contabilă)
   * 
   * @param noteData Data for the accounting note
   * @returns The created note
   */
  async createNote(noteData) {
    try {
      const validation = this.validateNote(noteData);
      if (!validation.valid) {
        throw new Error(`Invalid accounting note: ${validation.message}
${validation.errors.join("\n")}`);
      }
      const noteId = noteData.id || uuidv438();
      const noteNumber = noteData.number || await this.generateNoteNumber(noteData.companyId);
      const note = {
        id: noteId,
        number: noteNumber,
        date: new Date(noteData.date),
        description: noteData.description,
        companyId: noteData.companyId,
        documentId: noteData.documentId || null,
        documentType: noteData.documentType || null,
        currencyCode: noteData.currencyCode || "RON",
        exchangeRate: noteData.exchangeRate || 1,
        validated: noteData.validated || false,
        createdAt: /* @__PURE__ */ new Date(),
        createdBy: noteData.userId
      };
      await AuditService.log({
        userId: noteData.userId,
        companyId: noteData.companyId,
        action: "create",
        entity: "accounting_note",
        entityId: noteId,
        details: {
          entityType: "ACCOUNTING_DOCUMENT",
          noteNumber,
          description: noteData.description,
          date: noteData.date,
          entriesCount: noteData.entries.length
        }
      });
      return {
        ...note,
        entries: noteData.entries
      };
    } catch (error) {
      console.error("Error creating accounting note:", error);
      throw error;
    }
  }
  /**
   * Validate an accounting note according to Romanian accounting rules
   * 
   * @param noteData Note data to validate
   * @returns Validation result
   */
  validateNote(noteData) {
    const errors = [];
    if (!noteData.date) {
      errors.push("Date is required");
    }
    if (!noteData.description || noteData.description.trim() === "") {
      errors.push("Description is required");
    }
    if (!noteData.entries || noteData.entries.length === 0) {
      errors.push("At least one accounting entry is required");
    }
    if (!noteData.companyId) {
      errors.push("Company ID is required");
    }
    if (!noteData.userId) {
      errors.push("User ID is required");
    }
    if (noteData.entries && noteData.entries.length > 0) {
      noteData.entries.forEach((entry, index12) => {
        if (!entry.accountCode) {
          errors.push(`Entry ${index12 + 1}: Account code is required`);
        }
        if (typeof entry.debit !== "number" && typeof entry.credit !== "number") {
          errors.push(`Entry ${index12 + 1}: Either debit or credit must be specified`);
        }
        if (typeof entry.debit === "number" && typeof entry.credit === "number" && entry.debit > 0 && entry.credit > 0) {
          errors.push(`Entry ${index12 + 1}: An entry cannot have both debit and credit values`);
        }
      });
      const totalDebit = noteData.entries.reduce((sum2, entry) => sum2 + (entry.debit || 0), 0);
      const totalCredit = noteData.entries.reduce((sum2, entry) => sum2 + (entry.credit || 0), 0);
      if (Math.abs(totalDebit - totalCredit) > 1e-3) {
        errors.push(`Accounting equation does not balance: total debit (${totalDebit}) \u2260 total credit (${totalCredit})`);
      }
    }
    return {
      valid: errors.length === 0,
      message: errors.length > 0 ? "Validation failed" : "Note is valid",
      errors
    };
  }
  /**
   * Generate a sequential note number
   * 
   * @param companyId Company ID
   * @returns Generated note number
   */
  async generateNoteNumber(companyId) {
    const currentDate = /* @__PURE__ */ new Date();
    const year = currentDate.getFullYear();
    const month = (currentDate.getMonth() + 1).toString().padStart(2, "0");
    const sequentialNumber = Math.floor(Math.random() * 9e3) + 1e3;
    return `NC-${year}${month}-${sequentialNumber}`;
  }
  /**
   * Get an accounting note by ID
   * 
   * @param noteId Note ID
   * @param companyId Company ID
   * @param userId User ID requesting the note
   * @returns The accounting note
   */
  async getNoteById(noteId, companyId, userId) {
    try {
      await AuditService.log({
        userId,
        companyId,
        action: "view",
        entity: "accounting_note",
        entityId: noteId,
        details: {
          entityType: "ACCOUNTING_DOCUMENT",
          action: "view",
          noteId
        }
      });
      return {
        id: noteId,
        number: "NC-202504-1234",
        date: /* @__PURE__ */ new Date(),
        description: "Sample accounting note",
        companyId,
        documentId: null,
        documentType: null,
        currencyCode: "RON",
        exchangeRate: 1,
        validated: false,
        createdAt: /* @__PURE__ */ new Date(),
        createdBy: userId,
        entries: [
          {
            accountCode: "411",
            debit: 1e3,
            credit: 0,
            description: "Client invoice"
          },
          {
            accountCode: "4111",
            debit: 0,
            credit: 1e3,
            description: "Client invoice"
          }
        ]
      };
    } catch (error) {
      console.error("Error getting accounting note:", error);
      throw error;
    }
  }
  /**
   * Validate and mark an accounting note (mark it as validated)
   * 
   * @param noteId Note ID
   * @param companyId Company ID
   * @param userId User ID performing the validation
   * @returns The validated note
   */
  async validateAndMarkNote(noteId, companyId, userId) {
    try {
      await AuditService.log({
        userId,
        companyId,
        action: "validate",
        entity: "accounting_note",
        entityId: noteId,
        details: {
          entityType: "ACCOUNTING_DOCUMENT",
          action: "validate",
          noteId,
          validatedAt: /* @__PURE__ */ new Date()
        }
      });
      return {
        id: noteId,
        number: "NC-202504-1234",
        date: /* @__PURE__ */ new Date(),
        description: "Sample accounting note",
        companyId,
        documentId: null,
        documentType: null,
        currencyCode: "RON",
        exchangeRate: 1,
        validated: true,
        validatedAt: /* @__PURE__ */ new Date(),
        validatedBy: userId,
        createdAt: /* @__PURE__ */ new Date(),
        createdBy: userId,
        entries: [
          {
            accountCode: "411",
            debit: 1e3,
            credit: 0,
            description: "Client invoice"
          },
          {
            accountCode: "4111",
            debit: 0,
            credit: 1e3,
            description: "Client invoice"
          }
        ]
      };
    } catch (error) {
      console.error("Error validating accounting note:", error);
      throw error;
    }
  }
};
_init3 = __decoratorStart(null);
NoteContabilService = __decorateElement(_init3, 0, "NoteContabilService", _NoteContabilService_decorators, NoteContabilService);
__runInitializers(_init3, 1, NoteContabilService);

// server/modules/accounting/routes/note-contabil.routes.ts
function setupNoteContabilRoutes() {
  const router14 = Router48();
  const noteContabilService2 = new NoteContabilService();
  const noteContabilController2 = new NoteContabilController(noteContabilService2);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.post("/", (req, res) => {
    noteContabilController2.createNote(req, res);
  });
  router14.get("/", (req, res) => {
    noteContabilController2.getNotes(req, res);
  });
  router14.get("/:id", (req, res) => {
    noteContabilController2.getNoteById(req, res);
  });
  router14.post("/generate", (req, res) => {
    noteContabilController2.generateNote(req, res);
  });
  router14.post("/:id/approve", (req, res) => {
    noteContabilController2.approveNote(req, res);
  });
  return router14;
}

// server/modules/accounting/controllers/accounting.controller.ts
var AccountingController = class extends BaseController {
  /**
   * Constructor
   */
  constructor(accountingService2) {
    super();
    this.accountingService = accountingService2;
  }
  /**
   * Get all account classes
   */
  async getAccountClasses(req, res) {
    await this.handleRequest(req, res, async () => {
      return await this.accountingService.getAccountClasses();
    });
  }
  /**
   * Get all account groups
   */
  async getAccountGroups(req, res) {
    await this.handleRequest(req, res, async () => {
      return await this.accountingService.getAccountGroups();
    });
  }
  /**
   * Get account groups by class ID
   */
  async getAccountGroupsByClass(req, res) {
    await this.handleRequest(req, res, async () => {
      const classId = req.params.classId;
      const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(classId);
      if (isUuid) {
        return await this.accountingService.getAccountGroupsByClass(classId);
      } else {
        const classes = await this.accountingService.getAccountClasses();
        const foundClass = classes.find((c) => c.code === classId);
        if (!foundClass) {
          throw { statusCode: 404, message: "Account class not found" };
        }
        return await this.accountingService.getAccountGroupsByClass(foundClass.id);
      }
    });
  }
  /**
   * Get all synthetic accounts
   */
  async getSyntheticAccounts(req, res) {
    await this.handleRequest(req, res, async () => {
      return await this.accountingService.getSyntheticAccounts();
    });
  }
  /**
   * Get synthetic accounts by group ID
   */
  async getSyntheticAccountsByGroup(req, res) {
    await this.handleRequest(req, res, async () => {
      const groupId = req.params.groupId;
      const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(groupId);
      if (isUuid) {
        return await this.accountingService.getSyntheticAccountsByGroup(groupId);
      } else {
        const groups = await this.accountingService.getAccountGroups();
        const foundGroup = groups.find((g) => g.code === groupId);
        if (!foundGroup) {
          throw { statusCode: 404, message: "Account group not found" };
        }
        return await this.accountingService.getSyntheticAccountsByGroup(foundGroup.id);
      }
    });
  }
  /**
   * Get synthetic accounts by grade
   */
  async getSyntheticAccountsByGrade(req, res) {
    await this.handleRequest(req, res, async () => {
      const grade = parseInt(req.params.grade);
      return await this.accountingService.getSyntheticAccountsByGrade(grade);
    });
  }
  /**
   * Get all analytic accounts
   */
  async getAnalyticAccounts(req, res) {
    await this.handleRequest(req, res, async () => {
      return await this.accountingService.getAnalyticAccounts();
    });
  }
  /**
   * Get analytic accounts by synthetic ID
   */
  async getAnalyticAccountsBySynthetic(req, res) {
    await this.handleRequest(req, res, async () => {
      const syntheticId = req.params.syntheticId;
      const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(syntheticId);
      if (isUuid) {
        return await this.accountingService.getAnalyticAccountsBySynthetic(syntheticId);
      } else {
        const syntheticAccounts2 = await this.accountingService.getSyntheticAccounts();
        const foundAccount = syntheticAccounts2.find((sa) => sa.code === syntheticId);
        if (!foundAccount) {
          throw { statusCode: 404, message: "Synthetic account not found" };
        }
        return await this.accountingService.getAnalyticAccountsBySynthetic(foundAccount.id);
      }
    });
  }
  /**
   * Get all journal entries
   */
  async getJournalEntries(req, res) {
    await this.handleRequest(req, res, async () => {
      return await this.accountingService.getJournalEntries();
    });
  }
  /**
   * Get journal entry by ID
   */
  async getJournalEntry(req, res) {
    await this.handleRequest(req, res, async () => {
      const id = req.params.id;
      return await this.accountingService.getJournalEntry(id);
    });
  }
  /**
   * Create a new journal entry
   */
  async createJournalEntry(req, res) {
    await this.handleRequest(req, res, async () => {
      const { entry, lines } = req.body;
      return await this.accountingService.createJournalEntry(entry, lines);
    });
  }
  /**
   * Get account chart (plan de conturi)
   */
  async getAccountChart(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const includeInactive = req.query.includeInactive === "true";
      const type = req.query.type;
      return await this.accountingService.getAccountChart(companyId, includeInactive, type);
    });
  }
  /**
   * Get account by ID
   */
  async getAccount(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const accountId = req.params.id;
      const account = await this.accountingService.getAccount(accountId, companyId);
      if (!account) {
        throw { statusCode: 404, message: "Account not found" };
      }
      return account;
    });
  }
  /**
   * Create a new account
   */
  async createAccount(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const accountData = { ...req.body, companyId, createdBy: userId };
      const accountId = await this.accountingService.createAccount(accountData);
      const account = await this.accountingService.getAccount(accountId, companyId);
      if (!account) {
        throw {
          statusCode: 500,
          message: "Account was created but could not be retrieved"
        };
      }
      return account;
    });
  }
  /**
   * Update an account
   */
  async updateAccount(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const accountId = req.params.id;
      const existingAccount = await this.accountingService.getAccount(accountId, companyId);
      if (!existingAccount) {
        throw { statusCode: 404, message: "Account not found" };
      }
      const accountData = {
        ...req.body,
        id: accountId,
        companyId
      };
      await this.accountingService.updateAccount(accountData);
      const updatedAccount = await this.accountingService.getAccount(accountId, companyId);
      return updatedAccount;
    });
  }
  /**
   * Delete an account
   */
  async deleteAccount(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const accountId = req.params.id;
      const existingAccount = await this.accountingService.getAccount(accountId, companyId);
      if (!existingAccount) {
        throw { statusCode: 404, message: "Account not found" };
      }
      const canDelete = await this.accountingService.canDeleteAccount(accountId, companyId);
      if (!canDelete.canDelete) {
        throw {
          statusCode: 400,
          message: `Cannot delete account. ${canDelete.reason}`
        };
      }
      await this.accountingService.deleteAccount(accountId, companyId);
      return { success: true, message: "Account deleted successfully" };
    });
  }
  /**
   * Get general ledger
   */
  async getGeneralLedger(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const { page, limit } = this.getPaginationParams(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate);
      const accountId = req.query.accountId;
      return await this.accountingService.getGeneralLedger(
        companyId,
        page,
        limit,
        startDate,
        endDate,
        accountId
      );
    });
  }
  /**
   * Get ledger entry by ID
   */
  async getLedgerEntry(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const entryId = req.params.id;
      const entry = await this.accountingService.getLedgerEntry(entryId, companyId);
      if (!entry) {
        throw { statusCode: 404, message: "Ledger entry not found" };
      }
      return entry;
    });
  }
  /**
   * Generate financial statements (trial balance)
   */
  async getTrialBalance(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const asOfDate = this.parseDate(req.query.asOfDate) || /* @__PURE__ */ new Date();
      return await this.accountingService.generateTrialBalance(
        companyId,
        asOfDate
      );
    });
  }
  /**
   * Generate balance sheet
   */
  async getBalanceSheet(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const asOfDate = this.parseDate(req.query.asOfDate) || /* @__PURE__ */ new Date();
      const compareToDate = this.parseDate(req.query.compareToDate);
      return await this.accountingService.generateBalanceSheet(
        companyId,
        asOfDate,
        compareToDate
      );
    });
  }
  /**
   * Generate income statement
   */
  async getIncomeStatement(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const startDate = this.parseDate(req.query.startDate);
      const endDate = this.parseDate(req.query.endDate) || /* @__PURE__ */ new Date();
      const compareStartDate = this.parseDate(req.query.compareStartDate);
      const compareEndDate = this.parseDate(req.query.compareEndDate);
      return await this.accountingService.generateIncomeStatement(
        companyId,
        startDate,
        endDate,
        compareStartDate,
        compareEndDate
      );
    });
  }
  /**
   * Get company fiscal settings
   */
  async getFiscalSettings(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      return await this.accountingService.getFiscalSettings(companyId);
    });
  }
  /**
   * Update company fiscal settings
   */
  async updateFiscalSettings(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const settingsData = { ...req.body, companyId };
      await this.accountingService.updateFiscalSettings(settingsData);
      return await this.accountingService.getFiscalSettings(companyId);
    });
  }
  /**
   * Create an analytic account
   */
  async createAnalyticAccount(req, res) {
    await this.handleRequest(req, res, async () => {
      const companyId = this.getCompanyId(req);
      const userId = this.getUserId(req);
      const { parentId, ...restData } = req.body;
      const accountData = {
        ...restData,
        syntheticId: parentId,
        // Remapăm parentId la syntheticId
        companyId,
        createdBy: userId
      };
      const analyticAccount = await this.accountingService.createAnalyticAccount(accountData);
      return analyticAccount;
    });
  }
};

// server/modules/accounting/routes/accounting.routes.ts
function setupAccountingRoutes() {
  const router14 = Router49();
  const accountingService2 = new AccountingService(storage);
  const accountingController2 = new AccountingController(accountingService2);
  router14.use(AuthGuard.protect("required" /* REQUIRED */));
  router14.use("/sales-journal", setupSalesJournalRoutes());
  router14.use("/purchase-journal", setupPurchaseJournalRoutes());
  router14.use("/bank-journal", setupBankJournalRoutes());
  router14.use("/cash-register", setupCashRegisterRoutes());
  router14.use("/ledger", setupLedgerRoutes());
  router14.use("/note-contabil", setupNoteContabilRoutes());
  router14.get("/account-classes", (req, res) => {
    accountingController2.getAccountClasses(req, res);
  });
  router14.get("/account-groups", (req, res) => {
    accountingController2.getAccountGroups(req, res);
  });
  router14.get("/account-groups/by-class/:classId", (req, res) => {
    accountingController2.getAccountGroupsByClass(req, res);
  });
  router14.get("/synthetic-accounts", (req, res) => {
    accountingController2.getSyntheticAccounts(req, res);
  });
  router14.get("/synthetic-accounts/by-group/:groupId", (req, res) => {
    accountingController2.getSyntheticAccountsByGroup(req, res);
  });
  router14.get("/synthetic-accounts/by-grade/:grade", (req, res) => {
    accountingController2.getSyntheticAccountsByGrade(req, res);
  });
  router14.get("/analytic-accounts", (req, res) => {
    accountingController2.getAnalyticAccounts(req, res);
  });
  router14.get("/analytic-accounts/by-synthetic/:syntheticId", (req, res) => {
    accountingController2.getAnalyticAccountsBySynthetic(req, res);
  });
  router14.post("/analytic-accounts", (req, res) => {
    accountingController2.createAnalyticAccount(req, res);
  });
  router14.get("/journal-entries", (req, res) => {
    accountingController2.getJournalEntries(req, res);
  });
  router14.get("/journal-entries/:id", (req, res) => {
    accountingController2.getJournalEntry(req, res);
  });
  router14.post(
    "/journal-entries",
    AuthGuard.roleGuard(["accountant", "admin"]),
    (req, res) => {
      accountingController2.createJournalEntry(req, res);
    }
  );
  router14.get(
    "/trial-balance",
    AuthGuard.roleGuard(["accountant", "admin", "manager"]),
    AuthGuard.companyGuard("companyId"),
    (req, res) => {
      accountingController2.getTrialBalance(req, res);
    }
  );
  router14.get(
    "/balance-sheet",
    AuthGuard.roleGuard(["accountant", "admin", "manager"]),
    (req, res) => {
      accountingController2.getBalanceSheet(req, res);
    }
  );
  router14.get(
    "/income-statement",
    AuthGuard.roleGuard(["accountant", "admin", "manager"]),
    (req, res) => {
      accountingController2.getIncomeStatement(req, res);
    }
  );
  return router14;
}

// server/modules/accounting/index.ts
init_storage();
init_services();

// server/modules/accounting/services/purchase-journal.service.ts
var PURCHASE_ACCOUNTS = {
  // Class 4 - Third Party Accounts
  SUPPLIER: "401",
  // Suppliers
  VAT_DEDUCTIBLE: "4426",
  // VAT deductible
  // Class 3 - Inventory Accounts
  MERCHANDISE: "371",
  // Merchandise inventory
  RAW_MATERIALS: "301",
  // Raw materials
  CONSUMABLES: "302",
  // Consumable materials
  // Class 6 - Expense Accounts
  UTILITIES: "605",
  // Utilities expenses
  SERVICES: "628",
  // Services performed by third parties
  MAINTENANCE: "611",
  // Maintenance and repairs
  // Class 2 - Fixed Asset Accounts
  EQUIPMENT: "213",
  // Equipment and machinery
  // Currency accounts
  EXCHANGE_DIFF_INCOME: "765",
  // Foreign exchange gains
  EXCHANGE_DIFF_EXPENSE: "665"
  // Foreign exchange losses
};
var PurchaseJournalService = class {
  /**
   * Constructor
   */
  constructor() {
    this.journalService = new JournalService();
  }
  /**
   * Create a purchase invoice entry
   * @param data Purchase invoice data
   * @returns Created ledger entry
   */
  async createPurchaseInvoiceEntry(data) {
    const {
      companyId,
      franchiseId,
      invoiceNumber,
      invoiceId,
      supplierId,
      supplierName,
      amount,
      netAmount,
      vatAmount,
      vatRate,
      currency,
      exchangeRate,
      issueDate,
      dueDate,
      description,
      userId,
      expenseType,
      deductibleVat
    } = data;
    const expenseAccount = this.getExpenseAccount(expenseType);
    const ledgerLines2 = [];
    ledgerLines2.push({
      accountId: PURCHASE_ACCOUNTS.SUPPLIER,
      debitAmount: 0,
      creditAmount: amount,
      description: `Supplier: ${supplierName}, Invoice: ${invoiceNumber}`
    });
    if (vatAmount > 0 && deductibleVat) {
      ledgerLines2.push({
        accountId: PURCHASE_ACCOUNTS.VAT_DEDUCTIBLE,
        debitAmount: vatAmount,
        creditAmount: 0,
        description: `VAT ${vatRate}%: ${invoiceNumber}`
      });
    }
    ledgerLines2.push({
      accountId: expenseAccount,
      debitAmount: netAmount,
      creditAmount: 0,
      description: `Purchase: ${invoiceNumber} from ${supplierName}`
    });
    if (currency !== "RON" && exchangeRate !== 1) {
    }
    const entry = await this.journalService.createLedgerEntry({
      companyId,
      franchiseId,
      type: "PURCHASE" /* PURCHASE */,
      referenceNumber: invoiceNumber,
      amount,
      description: description || `Purchase invoice ${invoiceNumber} from ${supplierName}`,
      userId,
      lines: ledgerLines2
    });
    return entry;
  }
  /**
   * Get the appropriate account for the expense type
   * @param expenseType Type of expense
   * @returns Account ID
   */
  getExpenseAccount(expenseType) {
    switch (expenseType) {
      case "merchandise" /* MERCHANDISE */:
        return PURCHASE_ACCOUNTS.MERCHANDISE;
      case "raw_materials" /* RAW_MATERIALS */:
        return PURCHASE_ACCOUNTS.RAW_MATERIALS;
      case "consumables" /* CONSUMABLES */:
        return PURCHASE_ACCOUNTS.CONSUMABLES;
      case "utilities" /* UTILITIES */:
        return PURCHASE_ACCOUNTS.UTILITIES;
      case "services" /* SERVICES */:
        return PURCHASE_ACCOUNTS.SERVICES;
      case "maintenance" /* MAINTENANCE */:
        return PURCHASE_ACCOUNTS.MAINTENANCE;
      case "equipment" /* EQUIPMENT */:
        return PURCHASE_ACCOUNTS.EQUIPMENT;
      default:
        return PURCHASE_ACCOUNTS.SERVICES;
    }
  }
  /**
   * Validate a purchase invoice
   * @param invoiceData Purchase invoice data
   * @returns Validation result
   */
  validatePurchaseInvoice(invoiceData) {
    const errors = [];
    if (!invoiceData.invoiceNumber) {
      errors.push("Invoice number is required");
    }
    if (!invoiceData.supplierId) {
      errors.push("Supplier ID is required");
    }
    if (!invoiceData.issueDate) {
      errors.push("Issue date is required");
    }
    const currentDate = /* @__PURE__ */ new Date();
    const invoiceDate = new Date(invoiceData.issueDate);
    const maxBackdatedDays = 15;
    const daysDifference = Math.floor((currentDate.getTime() - invoiceDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (daysDifference > maxBackdatedDays) {
      errors.push(`Invoice date is too old. Maximum allowed backdating is ${maxBackdatedDays} days according to Romanian fiscal law`);
    }
    if (invoiceDate > currentDate) {
      errors.push("Invoice date cannot be in the future");
    }
    if (!invoiceData.supplier) {
      errors.push("Supplier information is required");
    } else {
      if (!invoiceData.supplier.vatNumber && !invoiceData.supplier.fiscalCode) {
        errors.push("Supplier must have either a VAT number (CUI) or fiscal code (CIF)");
      }
      if (!invoiceData.supplier.registrationNumber) {
        errors.push("Supplier registration number (J number) is required");
      }
      if (!invoiceData.supplier.address) {
        errors.push("Supplier address is required");
      }
    }
    const validVatRates = [0, 5, 9, 19];
    if (invoiceData.vatRate !== void 0 && !validVatRates.includes(Number(invoiceData.vatRate))) {
      errors.push(`Invalid VAT rate. Valid rates in Romania are: ${validVatRates.join(", ")}%`);
    }
    if (!invoiceData.items || !Array.isArray(invoiceData.items) || invoiceData.items.length === 0) {
      errors.push("Invoice must have at least one item");
    } else {
      for (const [index12, item] of invoiceData.items.entries()) {
        if (!item.description && !item.productName) {
          errors.push(`Item #${index12 + 1}: Description or product name is required`);
        }
        if (!item.quantity || Number(item.quantity) <= 0) {
          errors.push(`Item #${index12 + 1}: Quantity must be positive`);
        }
        if (!item.unitPrice || Number(item.unitPrice) < 0) {
          errors.push(`Item #${index12 + 1}: Unit price must be non-negative`);
        }
        const calculatedNet = Number(item.quantity) * Number(item.unitPrice);
        if (Math.abs(calculatedNet - Number(item.netAmount)) > 0.01) {
          errors.push(`Item #${index12 + 1}: Net amount doesn't match quantity \xD7 unit price`);
        }
        const calculatedVat = Number(item.netAmount) * (Number(item.vatRate) / 100);
        if (Math.abs(calculatedVat - Number(item.vatAmount)) > 0.01) {
          errors.push(`Item #${index12 + 1}: VAT amount doesn't match net amount \xD7 VAT rate`);
        }
        const calculatedGross = Number(item.netAmount) + Number(item.vatAmount);
        if (Math.abs(calculatedGross - Number(item.grossAmount)) > 0.01) {
          errors.push(`Item #${index12 + 1}: Gross amount doesn't match net amount + VAT amount`);
        }
      }
      const totalNet = invoiceData.items.reduce((sum2, item) => {
        return sum2 + Number(item.netAmount);
      }, 0);
      if (invoiceData.netTotal && Math.abs(Number(invoiceData.netTotal) - totalNet) > 0.01) {
        errors.push("Invoice net total does not match sum of line net amounts");
      }
      const totalVat = invoiceData.items.reduce((sum2, item) => {
        return sum2 + Number(item.vatAmount);
      }, 0);
      if (invoiceData.vatTotal && Math.abs(Number(invoiceData.vatTotal) - totalVat) > 0.01) {
        errors.push("Invoice VAT total does not match sum of line VAT amounts");
      }
      const totalGross = invoiceData.items.reduce((sum2, item) => {
        return sum2 + Number(item.grossAmount);
      }, 0);
      if (invoiceData.grossTotal && Math.abs(Number(invoiceData.grossTotal) - totalGross) > 0.01) {
        errors.push("Invoice gross total does not match sum of line gross amounts");
      }
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
};
var purchase_journal_service_default = PurchaseJournalService;

// server/modules/accounting/services/bank-journal.service.ts
var BankTransactionType = /* @__PURE__ */ ((BankTransactionType2) => {
  BankTransactionType2["INCOMING_PAYMENT"] = "incoming_payment";
  BankTransactionType2["OUTGOING_PAYMENT"] = "outgoing_payment";
  BankTransactionType2["BANK_FEE"] = "bank_fee";
  BankTransactionType2["BANK_INTEREST"] = "bank_interest";
  BankTransactionType2["TRANSFER_BETWEEN_ACCOUNTS"] = "transfer_between_accounts";
  BankTransactionType2["LOAN_DISBURSEMENT"] = "loan_disbursement";
  BankTransactionType2["LOAN_REPAYMENT"] = "loan_repayment";
  BankTransactionType2["FOREIGN_EXCHANGE"] = "foreign_exchange";
  BankTransactionType2["OTHER"] = "other";
  return BankTransactionType2;
})(BankTransactionType || {});
var BANK_ACCOUNTS = {
  // Class 5 - Cash and Bank Accounts
  BANK_PRIMARY: "5121",
  // Bank accounts in RON
  BANK_CURRENCY: "5124",
  // Bank accounts in foreign currency
  BANK_INTEREST_RECEIVED: "5187",
  // Interest receivable
  // Class 4 - Third Party Accounts
  CUSTOMERS: "4111",
  // Customer accounts
  SUPPLIERS: "401",
  // Supplier accounts
  VAT_COLLECTED: "4427",
  // VAT collected
  VAT_DEDUCTIBLE: "4426",
  // VAT deductible
  EMPLOYEE_ADVANCES: "425",
  // Advances to employees
  // Class 6 - Expense Accounts
  BANK_FEES: "627",
  // Bank fees and similar expenses
  INTEREST_EXPENSE: "666",
  // Interest expenses
  // Class 7 - Income Accounts
  INTEREST_INCOME: "766",
  // Interest income
  // Exchange Rate Accounts
  EXCHANGE_DIFF_INCOME: "765",
  // Foreign exchange gains
  EXCHANGE_DIFF_EXPENSE: "665",
  // Foreign exchange losses,
  // Short-term Loans
  SHORT_TERM_LOANS: "519",
  // Short-term bank loans
  // Long-term Loans
  LONG_TERM_LOANS: "162"
  // Long-term bank loans
};
var BankJournalService = class {
  /**
   * Constructor
   */
  constructor() {
    this.journalService = new JournalService();
  }
  /**
   * Create a bank transaction entry
   * @param data Bank transaction data
   * @returns Created ledger entry
   */
  async createBankTransactionEntry(data) {
    const {
      companyId,
      franchiseId,
      bankAccountId,
      bankAccountNumber,
      transactionId,
      referenceNumber,
      transactionType,
      paymentMethod,
      amount,
      currency,
      exchangeRate,
      transactionDate,
      valueDate,
      description,
      payerId,
      payerName,
      payeeId,
      payeeName,
      invoiceId,
      invoiceNumber,
      userId,
      documentNumber,
      fees
    } = data;
    const ledgerLines2 = [];
    let entryDescription = description || "Bank transaction";
    switch (transactionType) {
      case "incoming_payment" /* INCOMING_PAYMENT */:
        ledgerLines2.push({
          accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
          debitAmount: amount,
          creditAmount: 0,
          description: `Payment received: ${referenceNumber}`
        });
        ledgerLines2.push({
          accountId: BANK_ACCOUNTS.CUSTOMERS,
          debitAmount: 0,
          creditAmount: amount,
          description: `Payment from ${payerName || "customer"} for ${invoiceNumber || "invoice"}`
        });
        entryDescription = `Payment received from ${payerName || "customer"} ref: ${referenceNumber}`;
        break;
      case "outgoing_payment" /* OUTGOING_PAYMENT */:
        ledgerLines2.push({
          accountId: BANK_ACCOUNTS.SUPPLIERS,
          debitAmount: amount,
          creditAmount: 0,
          description: `Payment to ${payeeName || "supplier"} for ${invoiceNumber || "invoice"}`
        });
        ledgerLines2.push({
          accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
          debitAmount: 0,
          creditAmount: amount,
          description: `Payment sent: ${referenceNumber}`
        });
        entryDescription = `Payment to ${payeeName || "supplier"} ref: ${referenceNumber}`;
        break;
      case "bank_fee" /* BANK_FEE */:
        ledgerLines2.push({
          accountId: BANK_ACCOUNTS.BANK_FEES,
          debitAmount: amount,
          creditAmount: 0,
          description: `Bank fee: ${description || referenceNumber}`
        });
        ledgerLines2.push({
          accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
          debitAmount: 0,
          creditAmount: amount,
          description: `Bank fee deduction: ${referenceNumber}`
        });
        entryDescription = `Bank fee: ${description || referenceNumber}`;
        break;
      case "bank_interest" /* BANK_INTEREST */:
        if (amount > 0) {
          ledgerLines2.push({
            accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
            debitAmount: amount,
            creditAmount: 0,
            description: `Interest received: ${referenceNumber}`
          });
          ledgerLines2.push({
            accountId: BANK_ACCOUNTS.INTEREST_INCOME,
            debitAmount: 0,
            creditAmount: amount,
            description: `Interest income: ${description || referenceNumber}`
          });
          entryDescription = `Interest received: ${description || referenceNumber}`;
        } else {
          ledgerLines2.push({
            accountId: BANK_ACCOUNTS.INTEREST_EXPENSE,
            debitAmount: Math.abs(amount),
            creditAmount: 0,
            description: `Interest paid: ${description || referenceNumber}`
          });
          ledgerLines2.push({
            accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
            debitAmount: 0,
            creditAmount: Math.abs(amount),
            description: `Interest payment: ${referenceNumber}`
          });
          entryDescription = `Interest paid: ${description || referenceNumber}`;
        }
        break;
      case "transfer_between_accounts" /* TRANSFER_BETWEEN_ACCOUNTS */:
        if (amount > 0) {
          ledgerLines2.push({
            accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
            debitAmount: amount,
            creditAmount: 0,
            description: `Transfer in: ${referenceNumber}`
          });
          ledgerLines2.push({
            accountId: "581",
            // Internal transfers
            debitAmount: 0,
            creditAmount: amount,
            description: `Transfer from other account: ${referenceNumber}`
          });
          entryDescription = `Fund transfer in: ${description || referenceNumber}`;
        } else {
          ledgerLines2.push({
            accountId: "581",
            // Internal transfers
            debitAmount: Math.abs(amount),
            creditAmount: 0,
            description: `Transfer to other account: ${referenceNumber}`
          });
          ledgerLines2.push({
            accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
            debitAmount: 0,
            creditAmount: Math.abs(amount),
            description: `Transfer out: ${referenceNumber}`
          });
          entryDescription = `Fund transfer out: ${description || referenceNumber}`;
        }
        break;
      case "loan_disbursement" /* LOAN_DISBURSEMENT */:
        ledgerLines2.push({
          accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
          debitAmount: amount,
          creditAmount: 0,
          description: `Loan disbursement: ${referenceNumber}`
        });
        const loanAccountId = BANK_ACCOUNTS.SHORT_TERM_LOANS;
        ledgerLines2.push({
          accountId: loanAccountId,
          debitAmount: 0,
          creditAmount: amount,
          description: `Loan received: ${description || referenceNumber}`
        });
        entryDescription = `Loan disbursement: ${description || referenceNumber}`;
        break;
      case "loan_repayment" /* LOAN_REPAYMENT */:
        const principalAmount = amount - (fees || 0);
        const repaymentLoanAccountId = BANK_ACCOUNTS.SHORT_TERM_LOANS;
        ledgerLines2.push({
          accountId: repaymentLoanAccountId,
          debitAmount: principalAmount,
          creditAmount: 0,
          description: `Loan principal repayment: ${referenceNumber}`
        });
        if (fees && fees > 0) {
          ledgerLines2.push({
            accountId: BANK_ACCOUNTS.INTEREST_EXPENSE,
            debitAmount: fees,
            creditAmount: 0,
            description: `Loan interest payment: ${referenceNumber}`
          });
        }
        ledgerLines2.push({
          accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
          debitAmount: 0,
          creditAmount: amount,
          description: `Loan repayment: ${referenceNumber}`
        });
        entryDescription = `Loan repayment: ${description || referenceNumber}`;
        break;
      case "foreign_exchange" /* FOREIGN_EXCHANGE */:
        if (amount > 0) {
          ledgerLines2.push({
            accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
            debitAmount: amount,
            creditAmount: 0,
            description: `FX transaction: ${referenceNumber}`
          });
          ledgerLines2.push({
            accountId: BANK_ACCOUNTS.EXCHANGE_DIFF_INCOME,
            debitAmount: 0,
            creditAmount: amount,
            description: `FX gain: ${description || referenceNumber}`
          });
          entryDescription = `Foreign exchange gain: ${description || referenceNumber}`;
        } else {
          ledgerLines2.push({
            accountId: BANK_ACCOUNTS.EXCHANGE_DIFF_EXPENSE,
            debitAmount: Math.abs(amount),
            creditAmount: 0,
            description: `FX loss: ${description || referenceNumber}`
          });
          ledgerLines2.push({
            accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
            debitAmount: 0,
            creditAmount: Math.abs(amount),
            description: `FX transaction: ${referenceNumber}`
          });
          entryDescription = `Foreign exchange loss: ${description || referenceNumber}`;
        }
        break;
      case "other" /* OTHER */:
      default:
        if (amount > 0) {
          ledgerLines2.push({
            accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
            debitAmount: amount,
            creditAmount: 0,
            description: `Bank transaction in: ${referenceNumber}`
          });
          ledgerLines2.push({
            accountId: "473",
            // Settlements from operations in progress
            debitAmount: 0,
            creditAmount: amount,
            description: `Unclassified transaction: ${description || referenceNumber}`
          });
          entryDescription = `Unclassified bank transaction in: ${description || referenceNumber}`;
        } else {
          ledgerLines2.push({
            accountId: "473",
            // Settlements from operations in progress
            debitAmount: Math.abs(amount),
            creditAmount: 0,
            description: `Unclassified transaction: ${description || referenceNumber}`
          });
          ledgerLines2.push({
            accountId: currency === "RON" ? BANK_ACCOUNTS.BANK_PRIMARY : BANK_ACCOUNTS.BANK_CURRENCY,
            debitAmount: 0,
            creditAmount: Math.abs(amount),
            description: `Bank transaction out: ${referenceNumber}`
          });
          entryDescription = `Unclassified bank transaction out: ${description || referenceNumber}`;
        }
        break;
    }
    if (fees && fees > 0 && transactionType !== "bank_fee" /* BANK_FEE */ && transactionType !== "loan_repayment" /* LOAN_REPAYMENT */) {
      ledgerLines2.push({
        accountId: BANK_ACCOUNTS.BANK_FEES,
        debitAmount: fees,
        creditAmount: 0,
        description: `Transaction fee: ${referenceNumber}`
      });
      const bankLine = ledgerLines2.find(
        (line) => line.accountId === BANK_ACCOUNTS.BANK_PRIMARY || line.accountId === BANK_ACCOUNTS.BANK_CURRENCY
      );
      if (bankLine) {
        if (bankLine.debitAmount > 0) {
          bankLine.debitAmount -= fees;
        } else if (bankLine.creditAmount > 0) {
          bankLine.creditAmount += fees;
        }
      }
    }
    if (currency !== "RON" && exchangeRate !== 1) {
    }
    const entry = await this.journalService.createLedgerEntry({
      companyId,
      franchiseId,
      type: "BANK" /* BANK */,
      referenceNumber: documentNumber || referenceNumber,
      amount: Math.abs(amount),
      description: entryDescription,
      userId,
      lines: ledgerLines2
    });
    return entry;
  }
  /**
   * Validate a bank transaction
   * @param transactionData Bank transaction data
   * @returns Validation result
   */
  validateBankTransaction(transactionData) {
    const errors = [];
    if (!transactionData.transactionId) {
      errors.push("Transaction ID is required");
    }
    if (!transactionData.bankAccountId) {
      errors.push("Bank account ID is required");
    }
    if (!transactionData.transactionDate) {
      errors.push("Transaction date is required");
    }
    if (!transactionData.valueDate) {
      errors.push("Value date is required");
    }
    if (transactionData.amount === void 0 || transactionData.amount === null) {
      errors.push("Transaction amount is required");
    }
    if (!transactionData.transactionType) {
      errors.push("Transaction type is required");
    } else {
      const validTypes = Object.values(BankTransactionType);
      if (!validTypes.includes(transactionData.transactionType)) {
        errors.push(`Invalid transaction type. Valid types are: ${validTypes.join(", ")}`);
      }
    }
    const currentDate = /* @__PURE__ */ new Date();
    const transactionDate = new Date(transactionData.transactionDate);
    const maxDaysDifference = 3;
    const daysDifference = Math.floor((currentDate.getTime() - transactionDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (daysDifference > maxDaysDifference) {
      errors.push(`Transaction date is too old. Bank transactions should be recorded within ${maxDaysDifference} business days according to Romanian fiscal procedures`);
    }
    if (transactionDate > currentDate) {
      errors.push("Transaction date cannot be in the future");
    }
    if (!transactionData.currency) {
      errors.push("Currency is required");
    } else if (transactionData.currency !== "RON" && !transactionData.exchangeRate) {
      errors.push("Exchange rate is required for non-RON transactions");
    }
    switch (transactionData.transactionType) {
      case "incoming_payment" /* INCOMING_PAYMENT */:
        if (!transactionData.payerId && !transactionData.payerName) {
          errors.push("Payer information is required for incoming payments");
        }
        break;
      case "outgoing_payment" /* OUTGOING_PAYMENT */:
        if (!transactionData.payeeId && !transactionData.payeeName) {
          errors.push("Payee information is required for outgoing payments");
        }
        break;
      case "loan_disbursement" /* LOAN_DISBURSEMENT */:
      case "loan_repayment" /* LOAN_REPAYMENT */:
        if (!transactionData.description) {
          errors.push("Description is required for loan transactions");
        }
        break;
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
  /**
   * Get bank transaction entry by transaction ID
   * @param companyId Company ID
   * @param transactionId Transaction ID
   * @returns Ledger entry or null if not found
   */
  async getBankTransactionEntryByTransactionId(companyId, transactionId) {
    return null;
  }
};
var bank_journal_service_default = BankJournalService;

// server/modules/accounting/services/cash-register.service.ts
var CashTransactionType = /* @__PURE__ */ ((CashTransactionType2) => {
  CashTransactionType2["CASH_RECEIPT"] = "cash_receipt";
  CashTransactionType2["CASH_PAYMENT"] = "cash_payment";
  CashTransactionType2["PETTY_CASH_ADVANCE"] = "petty_cash_advance";
  CashTransactionType2["PETTY_CASH_SETTLEMENT"] = "petty_cash_settlement";
  CashTransactionType2["CASH_COUNT_ADJUSTMENT"] = "cash_count_adjustment";
  CashTransactionType2["CASH_TRANSFER"] = "cash_transfer";
  return CashTransactionType2;
})(CashTransactionType || {});
var CashTransactionPurpose = /* @__PURE__ */ ((CashTransactionPurpose2) => {
  CashTransactionPurpose2["CUSTOMER_PAYMENT"] = "customer_payment";
  CashTransactionPurpose2["SUPPLIER_PAYMENT"] = "supplier_payment";
  CashTransactionPurpose2["SALARY_PAYMENT"] = "salary_payment";
  CashTransactionPurpose2["EXPENSE_PAYMENT"] = "expense_payment";
  CashTransactionPurpose2["ADVANCE_TO_EMPLOYEE"] = "advance_to_employee";
  CashTransactionPurpose2["ADVANCE_SETTLEMENT"] = "advance_settlement";
  CashTransactionPurpose2["BANK_DEPOSIT"] = "bank_deposit";
  CashTransactionPurpose2["CASH_WITHDRAWAL"] = "cash_withdrawal";
  CashTransactionPurpose2["OTHER"] = "other";
  return CashTransactionPurpose2;
})(CashTransactionPurpose || {});
var CASH_ACCOUNTS = {
  // Class 5 - Cash and Bank Accounts
  CASH_RON: "5311",
  // Cash in RON
  CASH_CURRENCY: "5314",
  // Cash in foreign currency
  PETTY_CASH: "5321",
  // Petty cash
  // Class 4 - Third Party Accounts
  CUSTOMERS: "4111",
  // Customer accounts
  SUPPLIERS: "401",
  // Supplier accounts
  EMPLOYEE_ADVANCES: "425",
  // Advances to employees
  EMPLOYEE_PAYROLL: "421",
  // Personnel - salaries payable
  VAT_COLLECTED: "4427",
  // VAT collected
  VAT_DEDUCTIBLE: "4426",
  // VAT deductible
  // Class 6 - Expense Accounts
  UTILITIES: "605",
  // Utilities expenses
  SUPPLIES: "6022",
  // Consumable supplies
  TRANSPORT: "624",
  // Transport of goods and personnel
  OTHER_SERVICES: "628",
  // Services performed by third parties
  // Class 7 - Income Accounts
  MERCHANDISE_SALES: "707",
  // Sale of merchandise
  SERVICE_REVENUE: "704",
  // Service provision
  // Cash transfers
  INTERNAL_TRANSFERS: "581",
  // Internal transfers
  // Cash shortages/overages accounts
  CASH_SHORTAGES: "6581",
  // Cash shortages
  CASH_OVERAGES: "7588",
  // Cash overages
  // Exchange Rate Accounts
  EXCHANGE_DIFF_INCOME: "765",
  // Foreign exchange gains
  EXCHANGE_DIFF_EXPENSE: "665"
  // Foreign exchange losses
};
var CashRegisterService = class {
  /**
   * Constructor
   */
  constructor() {
    this.journalService = new JournalService();
  }
  /**
   * Create a cash transaction entry
   * @param data Cash transaction data
   * @returns Created ledger entry
   */
  async createCashTransactionEntry(data) {
    const {
      companyId,
      franchiseId,
      cashRegisterId,
      transactionId,
      receiptNumber,
      transactionType,
      transactionPurpose,
      amount,
      vatAmount,
      vatRate,
      currency,
      exchangeRate,
      transactionDate,
      description,
      personId,
      personName,
      personIdNumber,
      invoiceId,
      invoiceNumber,
      userId,
      fiscalReceiptNumber,
      isFiscalReceipt,
      items
    } = data;
    const ledgerLines2 = [];
    let entryDescription = description || "Cash transaction";
    const getCashAccount = () => currency === "RON" ? CASH_ACCOUNTS.CASH_RON : CASH_ACCOUNTS.CASH_CURRENCY;
    switch (transactionType) {
      case "cash_receipt" /* CASH_RECEIPT */:
        switch (transactionPurpose) {
          case "customer_payment" /* CUSTOMER_PAYMENT */:
            ledgerLines2.push({
              accountId: getCashAccount(),
              debitAmount: amount,
              creditAmount: 0,
              description: `Cash receipt: ${receiptNumber}`
            });
            ledgerLines2.push({
              accountId: CASH_ACCOUNTS.CUSTOMERS,
              debitAmount: 0,
              creditAmount: amount,
              description: `Payment from ${personName} for ${invoiceNumber || "invoice"}`
            });
            entryDescription = `Cash receipt from ${personName} ref: ${receiptNumber}`;
            break;
          case "cash_withdrawal" /* CASH_WITHDRAWAL */:
            ledgerLines2.push({
              accountId: getCashAccount(),
              debitAmount: amount,
              creditAmount: 0,
              description: `Cash withdrawal: ${receiptNumber}`
            });
            ledgerLines2.push({
              accountId: CASH_ACCOUNTS.INTERNAL_TRANSFERS,
              debitAmount: 0,
              creditAmount: amount,
              description: `Bank withdrawal: ${description || "Cash withdrawal"}`
            });
            entryDescription = `Cash withdrawal from bank ref: ${receiptNumber}`;
            break;
          case "advance_settlement" /* ADVANCE_SETTLEMENT */:
            ledgerLines2.push({
              accountId: getCashAccount(),
              debitAmount: amount,
              creditAmount: 0,
              description: `Advance return: ${receiptNumber}`
            });
            ledgerLines2.push({
              accountId: CASH_ACCOUNTS.EMPLOYEE_ADVANCES,
              debitAmount: 0,
              creditAmount: amount,
              description: `Unused advance returned by ${personName}`
            });
            entryDescription = `Advance settlement from ${personName} ref: ${receiptNumber}`;
            break;
          default:
            if (isFiscalReceipt) {
              const netTotal = items && items.length > 0 ? items.reduce((sum2, item) => sum2 + item.netAmount, 0) : amount - (vatAmount || 0);
              const vatTotal = vatAmount || (items && items.length > 0 ? items.reduce((sum2, item) => sum2 + item.vatAmount, 0) : 0);
              ledgerLines2.push({
                accountId: getCashAccount(),
                debitAmount: amount,
                creditAmount: 0,
                description: `Cash sale: ${fiscalReceiptNumber || receiptNumber}`
              });
              ledgerLines2.push({
                accountId: CASH_ACCOUNTS.MERCHANDISE_SALES,
                // or SERVICE_REVENUE based on what was sold
                debitAmount: 0,
                creditAmount: netTotal,
                description: `Sales revenue: ${fiscalReceiptNumber || receiptNumber}`
              });
              if (vatTotal > 0) {
                ledgerLines2.push({
                  accountId: CASH_ACCOUNTS.VAT_COLLECTED,
                  debitAmount: 0,
                  creditAmount: vatTotal,
                  description: `VAT collected: ${fiscalReceiptNumber || receiptNumber}`
                });
              }
              entryDescription = `Cash sale: ${fiscalReceiptNumber || receiptNumber}`;
            } else {
              ledgerLines2.push({
                accountId: getCashAccount(),
                debitAmount: amount,
                creditAmount: 0,
                description: `Cash receipt: ${receiptNumber}`
              });
              ledgerLines2.push({
                accountId: "473",
                // Settlements from operations in progress
                debitAmount: 0,
                creditAmount: amount,
                description: `Unclassified cash receipt: ${description || receiptNumber}`
              });
              entryDescription = `Unclassified cash receipt ref: ${receiptNumber}`;
            }
            break;
        }
        break;
      case "cash_payment" /* CASH_PAYMENT */:
        switch (transactionPurpose) {
          case "supplier_payment" /* SUPPLIER_PAYMENT */:
            ledgerLines2.push({
              accountId: CASH_ACCOUNTS.SUPPLIERS,
              debitAmount: amount,
              creditAmount: 0,
              description: `Payment to ${personName} for ${invoiceNumber || "invoice"}`
            });
            ledgerLines2.push({
              accountId: getCashAccount(),
              debitAmount: 0,
              creditAmount: amount,
              description: `Cash payment: ${receiptNumber}`
            });
            entryDescription = `Cash payment to ${personName} ref: ${receiptNumber}`;
            break;
          case "salary_payment" /* SALARY_PAYMENT */:
            ledgerLines2.push({
              accountId: CASH_ACCOUNTS.EMPLOYEE_PAYROLL,
              debitAmount: amount,
              creditAmount: 0,
              description: `Salary payment to ${personName}`
            });
            ledgerLines2.push({
              accountId: getCashAccount(),
              debitAmount: 0,
              creditAmount: amount,
              description: `Cash payment: ${receiptNumber}`
            });
            entryDescription = `Salary payment to ${personName} ref: ${receiptNumber}`;
            break;
          case "expense_payment" /* EXPENSE_PAYMENT */:
            let expenseAccount = CASH_ACCOUNTS.OTHER_SERVICES;
            const expenseType = data.additionalData?.expenseType;
            if (expenseType) {
              switch (expenseType) {
                case "utilities":
                  expenseAccount = CASH_ACCOUNTS.UTILITIES;
                  break;
                case "supplies":
                  expenseAccount = CASH_ACCOUNTS.SUPPLIES;
                  break;
                case "transport":
                  expenseAccount = CASH_ACCOUNTS.TRANSPORT;
                  break;
              }
            }
            const netAmount = vatAmount ? amount - vatAmount : amount;
            ledgerLines2.push({
              accountId: expenseAccount,
              debitAmount: netAmount,
              creditAmount: 0,
              description: `Expense: ${description || "Cash expense"}`
            });
            if (vatAmount && vatAmount > 0) {
              ledgerLines2.push({
                accountId: CASH_ACCOUNTS.VAT_DEDUCTIBLE,
                debitAmount: vatAmount,
                creditAmount: 0,
                description: `VAT ${vatRate}%: ${receiptNumber}`
              });
            }
            ledgerLines2.push({
              accountId: getCashAccount(),
              debitAmount: 0,
              creditAmount: amount,
              description: `Cash payment: ${receiptNumber}`
            });
            entryDescription = `Cash expense payment ref: ${receiptNumber}`;
            break;
          case "advance_to_employee" /* ADVANCE_TO_EMPLOYEE */:
            ledgerLines2.push({
              accountId: CASH_ACCOUNTS.EMPLOYEE_ADVANCES,
              debitAmount: amount,
              creditAmount: 0,
              description: `Advance to ${personName}`
            });
            ledgerLines2.push({
              accountId: getCashAccount(),
              debitAmount: 0,
              creditAmount: amount,
              description: `Cash payment: ${receiptNumber}`
            });
            entryDescription = `Cash advance to ${personName} ref: ${receiptNumber}`;
            break;
          case "bank_deposit" /* BANK_DEPOSIT */:
            ledgerLines2.push({
              accountId: CASH_ACCOUNTS.INTERNAL_TRANSFERS,
              debitAmount: amount,
              creditAmount: 0,
              description: `Bank deposit: ${description || "Cash deposit"}`
            });
            ledgerLines2.push({
              accountId: getCashAccount(),
              debitAmount: 0,
              creditAmount: amount,
              description: `Cash deposit: ${receiptNumber}`
            });
            entryDescription = `Cash deposit to bank ref: ${receiptNumber}`;
            break;
          default:
            ledgerLines2.push({
              accountId: "473",
              // Settlements from operations in progress
              debitAmount: amount,
              creditAmount: 0,
              description: `Unclassified cash payment: ${description || receiptNumber}`
            });
            ledgerLines2.push({
              accountId: getCashAccount(),
              debitAmount: 0,
              creditAmount: amount,
              description: `Cash payment: ${receiptNumber}`
            });
            entryDescription = `Unclassified cash payment ref: ${receiptNumber}`;
            break;
        }
        break;
      case "petty_cash_advance" /* PETTY_CASH_ADVANCE */:
        ledgerLines2.push({
          accountId: CASH_ACCOUNTS.PETTY_CASH,
          debitAmount: amount,
          creditAmount: 0,
          description: `Petty cash advance: ${receiptNumber}`
        });
        ledgerLines2.push({
          accountId: getCashAccount(),
          debitAmount: 0,
          creditAmount: amount,
          description: `Petty cash funding: ${receiptNumber}`
        });
        entryDescription = `Petty cash advance ref: ${receiptNumber}`;
        break;
      case "petty_cash_settlement" /* PETTY_CASH_SETTLEMENT */:
        ledgerLines2.push({
          accountId: getCashAccount(),
          debitAmount: amount,
          creditAmount: 0,
          description: `Petty cash return: ${receiptNumber}`
        });
        ledgerLines2.push({
          accountId: CASH_ACCOUNTS.PETTY_CASH,
          debitAmount: 0,
          creditAmount: amount,
          description: `Petty cash settlement: ${receiptNumber}`
        });
        entryDescription = `Petty cash settlement ref: ${receiptNumber}`;
        break;
      case "cash_count_adjustment" /* CASH_COUNT_ADJUSTMENT */:
        if (amount > 0) {
          ledgerLines2.push({
            accountId: getCashAccount(),
            debitAmount: amount,
            creditAmount: 0,
            description: `Cash count adjustment: ${receiptNumber}`
          });
          ledgerLines2.push({
            accountId: CASH_ACCOUNTS.CASH_OVERAGES,
            debitAmount: 0,
            creditAmount: amount,
            description: `Cash overage: ${description || "Cash count adjustment"}`
          });
          entryDescription = `Cash count overage ref: ${receiptNumber}`;
        } else {
          ledgerLines2.push({
            accountId: CASH_ACCOUNTS.CASH_SHORTAGES,
            debitAmount: Math.abs(amount),
            creditAmount: 0,
            description: `Cash shortage: ${description || "Cash count adjustment"}`
          });
          ledgerLines2.push({
            accountId: getCashAccount(),
            debitAmount: 0,
            creditAmount: Math.abs(amount),
            description: `Cash count adjustment: ${receiptNumber}`
          });
          entryDescription = `Cash count shortage ref: ${receiptNumber}`;
        }
        break;
      case "cash_transfer" /* CASH_TRANSFER */:
        if (amount > 0) {
          ledgerLines2.push({
            accountId: getCashAccount(),
            debitAmount: amount,
            creditAmount: 0,
            description: `Cash transfer in: ${receiptNumber}`
          });
          ledgerLines2.push({
            accountId: CASH_ACCOUNTS.INTERNAL_TRANSFERS,
            debitAmount: 0,
            creditAmount: amount,
            description: `Transfer from other cash register: ${description || "Cash transfer"}`
          });
          entryDescription = `Cash transfer in ref: ${receiptNumber}`;
        } else {
          ledgerLines2.push({
            accountId: CASH_ACCOUNTS.INTERNAL_TRANSFERS,
            debitAmount: Math.abs(amount),
            creditAmount: 0,
            description: `Transfer to other cash register: ${description || "Cash transfer"}`
          });
          ledgerLines2.push({
            accountId: getCashAccount(),
            debitAmount: 0,
            creditAmount: Math.abs(amount),
            description: `Cash transfer out: ${receiptNumber}`
          });
          entryDescription = `Cash transfer out ref: ${receiptNumber}`;
        }
        break;
    }
    if (currency !== "RON" && exchangeRate !== 1) {
    }
    const entry = await this.journalService.createLedgerEntry({
      companyId,
      franchiseId,
      type: "CASH" /* CASH */,
      referenceNumber: receiptNumber,
      amount: Math.abs(amount),
      description: entryDescription,
      userId,
      lines: ledgerLines2
    });
    return entry;
  }
  /**
   * Validate a cash transaction
   * @param transactionData Cash transaction data
   * @returns Validation result
   */
  validateCashTransaction(transactionData) {
    const errors = [];
    if (!transactionData.transactionId) {
      errors.push("Transaction ID is required");
    }
    if (!transactionData.cashRegisterId) {
      errors.push("Cash register ID is required");
    }
    if (!transactionData.receiptNumber) {
      errors.push("Receipt number is required");
    }
    if (!transactionData.transactionDate) {
      errors.push("Transaction date is required");
    }
    if (transactionData.amount === void 0 || transactionData.amount === null) {
      errors.push("Transaction amount is required");
    }
    if (!transactionData.transactionType) {
      errors.push("Transaction type is required");
    } else {
      const validTypes = Object.values(CashTransactionType);
      if (!validTypes.includes(transactionData.transactionType)) {
        errors.push(`Invalid transaction type. Valid types are: ${validTypes.join(", ")}`);
      }
    }
    if (!transactionData.transactionPurpose) {
      errors.push("Transaction purpose is required");
    } else {
      const validPurposes = Object.values(CashTransactionPurpose);
      if (!validPurposes.includes(transactionData.transactionPurpose)) {
        errors.push(`Invalid transaction purpose. Valid purposes are: ${validPurposes.join(", ")}`);
      }
    }
    const currentDate = /* @__PURE__ */ new Date();
    const transactionDate = new Date(transactionData.transactionDate);
    const sameDayRequired = true;
    if (sameDayRequired) {
      const todayDate = /* @__PURE__ */ new Date();
      todayDate.setHours(0, 0, 0, 0);
      const txnDate = new Date(transactionDate);
      txnDate.setHours(0, 0, 0, 0);
      if (txnDate.getTime() !== todayDate.getTime()) {
        errors.push("Transaction date must be today according to Romanian fiscal regulations for cash operations");
      }
    }
    if (transactionDate > currentDate) {
      errors.push("Transaction date cannot be in the future");
    }
    switch (transactionData.transactionType) {
      case "cash_receipt" /* CASH_RECEIPT */:
      case "cash_payment" /* CASH_PAYMENT */:
        if (!transactionData.personName) {
          errors.push("Person name is required for cash receipts and payments");
        }
        if (transactionData.transactionPurpose === "supplier_payment" /* SUPPLIER_PAYMENT */ && transactionData.amount > 5e3 || transactionData.transactionPurpose === "salary_payment" /* SALARY_PAYMENT */) {
          if (!transactionData.personIdNumber) {
            errors.push("Person ID number (CNP/ID card) is required for this transaction type according to Romanian regulations");
          }
        }
        break;
    }
    if (transactionData.isFiscalReceipt) {
      if (!transactionData.fiscalReceiptNumber) {
        errors.push("Fiscal receipt number is required for fiscal receipts");
      }
      if (!transactionData.items || !Array.isArray(transactionData.items) || transactionData.items.length === 0) {
        errors.push("Fiscal receipts must have at least one item");
      } else {
        for (const [index12, item] of transactionData.items.entries()) {
          if (!item.description) {
            errors.push(`Item #${index12 + 1}: Description is required`);
          }
          if (!item.quantity || Number(item.quantity) <= 0) {
            errors.push(`Item #${index12 + 1}: Quantity must be positive`);
          }
          if (!item.unitPrice || Number(item.unitPrice) < 0) {
            errors.push(`Item #${index12 + 1}: Unit price must be non-negative`);
          }
          const calculatedNet = Number(item.quantity) * Number(item.unitPrice);
          if (Math.abs(calculatedNet - Number(item.netAmount)) > 0.01) {
            errors.push(`Item #${index12 + 1}: Net amount doesn't match quantity \xD7 unit price`);
          }
          const calculatedVat = Number(item.netAmount) * (Number(item.vatRate) / 100);
          if (Math.abs(calculatedVat - Number(item.vatAmount)) > 0.01) {
            errors.push(`Item #${index12 + 1}: VAT amount doesn't match net amount \xD7 VAT rate`);
          }
          const calculatedGross = Number(item.netAmount) + Number(item.vatAmount);
          if (Math.abs(calculatedGross - Number(item.grossAmount)) > 0.01) {
            errors.push(`Item #${index12 + 1}: Gross amount doesn't match net amount + VAT amount`);
          }
        }
        const totalNet = transactionData.items.reduce((sum2, item) => sum2 + Number(item.netAmount), 0);
        const totalVat = transactionData.items.reduce((sum2, item) => sum2 + Number(item.vatAmount), 0);
        const totalGross = transactionData.items.reduce((sum2, item) => sum2 + Number(item.grossAmount), 0);
        if (Math.abs(totalGross - Number(transactionData.amount)) > 0.01) {
          errors.push("Transaction amount does not match the sum of item gross amounts");
        }
        if (transactionData.vatAmount !== void 0 && Math.abs(totalVat - Number(transactionData.vatAmount)) > 0.01) {
          errors.push("Transaction VAT amount does not match the sum of item VAT amounts");
        }
      }
      const validVatRates = [0, 5, 9, 19];
      if (transactionData.vatRate !== void 0 && !validVatRates.includes(Number(transactionData.vatRate))) {
        errors.push(`Invalid VAT rate. Valid rates in Romania are: ${validVatRates.join(", ")}%`);
      }
    }
    if (!transactionData.currency) {
      errors.push("Currency is required");
    } else if (transactionData.currency !== "RON" && !transactionData.exchangeRate) {
      errors.push("Exchange rate is required for non-RON transactions");
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
  /**
   * Get cash transaction entry by transaction ID
   * @param companyId Company ID
   * @param transactionId Transaction ID
   * @returns Ledger entry or null if not found
   */
  async getCashTransactionEntryByTransactionId(companyId, transactionId) {
    return null;
  }
  /**
   * Generate a cash receipt number
   * This follows Romanian requirements for sequential numbering
   * @param companyId Company ID
   * @param cashRegisterId Cash register ID
   * @param isPayment Whether this is a payment (default: false, meaning it's a receipt)
   * @returns Generated receipt number
   */
  async generateReceiptNumber(companyId, cashRegisterId, isPayment = false) {
    const prefix = isPayment ? "DP" : "DI";
    const currentDate = /* @__PURE__ */ new Date();
    const year = currentDate.getFullYear();
    const month = (currentDate.getMonth() + 1).toString().padStart(2, "0");
    const day = currentDate.getDate().toString().padStart(2, "0");
    const lastNumber = Math.floor(Math.random() * 1e3);
    const nextNumber = (lastNumber + 1).toString().padStart(6, "0");
    return `${prefix}/${year}${month}${day}/${nextNumber}`;
  }
};
var cash_register_service_default = CashRegisterService;

// server/modules/accounting/services/validate-document.ts
init_audit_service();
init_drizzle();
var ValidateDocumentService = class {
  /**
   * Constructor
   */
  constructor() {
    this.journalService = new JournalService();
    this.salesJournalService = new SalesJournalService();
  }
  /**
   * Validate a document and generate accounting note (Note Contabil)
   * @param documentType Type of document to validate
   * @param documentId Document ID
   * @param userId User ID performing the validation
   * @returns Validation result
   */
  async validateDocument(documentType, documentId, userId) {
    if (!documentType) {
      return {
        success: false,
        message: "Document type is required"
      };
    }
    if (!documentId) {
      return {
        success: false,
        message: "Document ID is required"
      };
    }
    if (!userId) {
      return {
        success: false,
        message: "User ID is required"
      };
    }
    const documentData = await this.getDocumentData(documentType, documentId);
    if (!documentData) {
      return {
        success: false,
        message: `Document with ID ${documentId} not found`
      };
    }
    if (documentData.isValidated) {
      return {
        success: false,
        message: `Document is already validated`
      };
    }
    switch (documentType) {
      case "invoice" /* INVOICE */:
        return await this.validateSalesInvoice(documentData, userId);
      case "purchase_invoice" /* PURCHASE_INVOICE */:
        return {
          success: false,
          message: "Purchase invoice validation not implemented yet"
        };
      case "bank_statement" /* BANK_STATEMENT */:
        return {
          success: false,
          message: "Bank statement validation not implemented yet"
        };
      case "cash_receipt" /* CASH_RECEIPT */:
        return {
          success: false,
          message: "Cash receipt validation not implemented yet"
        };
      case "credit_note" /* CREDIT_NOTE */:
        return {
          success: false,
          message: "Credit note validation not implemented yet"
        };
      default:
        return {
          success: false,
          message: `Validation for document type ${documentType} not implemented`
        };
    }
  }
  /**
   * Get document data from the database
   * @param documentType Document type
   * @param documentId Document ID
   * @returns Document data or null if not found
   */
  async getDocumentData(documentType, documentId) {
    const drizzleService5 = new DrizzleService();
    try {
      switch (documentType) {
        case "invoice" /* INVOICE */:
          const invoiceData = await drizzleService5.executeQuery(async (db4) => {
            const invoice = await db4.query.invoices.findFirst({
              where: (fields, { eq: eq89 }) => eq89(fields.id, documentId),
              with: {
                items: true,
                customer: true,
                company: true
              }
            });
            return invoice;
          });
          return invoiceData;
        case "purchase_invoice" /* PURCHASE_INVOICE */:
          return null;
        // Add more cases for other document types
        default:
          return null;
      }
    } catch (error) {
      console.error(`[ValidateDocumentService] Error getting document data:`, error instanceof Error ? error.message : String(error));
      return null;
    }
  }
  /**
   * Validate a sales invoice
   * @param invoiceData Invoice data
   * @param userId User ID performing the validation
   * @returns Validation result
   */
  async validateSalesInvoice(invoiceData, userId) {
    const validation = this.salesJournalService.validateSalesInvoice(invoiceData);
    if (!validation.valid) {
      return {
        success: false,
        message: "Invoice validation failed",
        errors: validation.errors
      };
    }
    try {
      const totalNet = invoiceData.items.reduce((sum2, item) => sum2 + Number(item.netAmount), 0);
      const totalVat = invoiceData.items.reduce((sum2, item) => sum2 + Number(item.vatAmount), 0);
      const totalGross = invoiceData.items.reduce((sum2, item) => sum2 + Number(item.grossAmount), 0);
      const ledgerEntryData = await this.salesJournalService.createSalesInvoiceEntry({
        companyId: invoiceData.companyId,
        franchiseId: invoiceData.franchiseId,
        invoiceNumber: invoiceData.invoiceNumber,
        invoiceId: invoiceData.id,
        customerId: invoiceData.customerId,
        customerName: invoiceData.customer?.name || "Unknown Customer",
        amount: Number(totalGross),
        netAmount: Number(totalNet),
        vatAmount: Number(totalVat),
        vatRate: Number(invoiceData.vatRate),
        currency: invoiceData.currency,
        exchangeRate: Number(invoiceData.exchangeRate) || 1,
        issueDate: new Date(invoiceData.issueDate),
        dueDate: new Date(invoiceData.dueDate),
        description: `Sales invoice ${invoiceData.invoiceNumber} to ${invoiceData.customer?.name || "customer"}`,
        userId
      });
      const now = /* @__PURE__ */ new Date();
      const drizzleService5 = new DrizzleService();
      await drizzleService5.executeQuery(async (db4) => {
        await db4.update(invoiceData.constructor.table).set({
          isValidated: true,
          validatedAt: now.toISOString(),
          validatedBy: userId,
          ledgerEntryId: ledgerEntryData.id,
          updatedAt: now.toISOString()
        }).where((fields, { eq: eq89 }) => eq89(fields.id, invoiceData.id));
      });
      await AuditService.log({
        userId,
        companyId: invoiceData.companyId,
        franchiseId: invoiceData.franchiseId,
        action: "VALIDATE" /* VALIDATE */,
        entity: "invoice",
        entityId: invoiceData.id,
        details: {
          invoiceNumber: invoiceData.invoiceNumber,
          ledgerEntryId: ledgerEntryData.id,
          amount: totalGross,
          currency: invoiceData.currency
        }
      });
      return {
        success: true,
        message: "Invoice validated successfully",
        ledgerEntryId: ledgerEntryData.id
      };
    } catch (error) {
      console.error("[ValidateDocumentService] Error validating sales invoice:", error instanceof Error ? error.message : String(error));
      return {
        success: false,
        message: `Error validating invoice: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Devalidate a document
   * @param documentType Document type
   * @param documentId Document ID
   * @param userId User ID performing the devalidation
   * @param reason Reason for devalidation
   * @returns Devalidation result
   */
  async devalidateDocument(documentType, documentId, userId, reason) {
    if (!documentType) {
      return {
        success: false,
        message: "Document type is required"
      };
    }
    if (!documentId) {
      return {
        success: false,
        message: "Document ID is required"
      };
    }
    if (!userId) {
      return {
        success: false,
        message: "User ID is required"
      };
    }
    if (!reason || reason.trim() === "") {
      return {
        success: false,
        message: "Devalidation reason is required"
      };
    }
    const documentData = await this.getDocumentData(documentType, documentId);
    if (!documentData) {
      return {
        success: false,
        message: `Document with ID ${documentId} not found`
      };
    }
    if (!documentData.isValidated) {
      return {
        success: false,
        message: `Document is not validated`
      };
    }
    if (!documentData.ledgerEntryId) {
      return {
        success: false,
        message: `Document does not have a linked ledger entry`
      };
    }
    try {
      await this.journalService.reverseLedgerEntry(
        documentData.ledgerEntryId,
        `Reversed due to document devalidation: ${reason}`
      );
      const now = /* @__PURE__ */ new Date();
      const drizzleService5 = new DrizzleService();
      await drizzleService5.executeQuery(async (db4) => {
        await db4.update(documentData.constructor.table).set({
          isValidated: false,
          validatedAt: null,
          validatedBy: null,
          ledgerEntryId: null,
          updatedAt: now.toISOString()
        }).where((fields, { eq: eq89 }) => eq89(fields.id, documentId));
      });
      await AuditService.log({
        userId,
        companyId: documentData.companyId,
        franchiseId: documentData.franchiseId,
        action: "DEVALIDATE" /* DEVALIDATE */,
        entity: documentType,
        entityId: documentId,
        details: {
          documentNumber: documentData.invoiceNumber || documentData.number || documentData.reference,
          reason,
          reversedLedgerEntryId: documentData.ledgerEntryId
        }
      });
      return {
        success: true,
        message: "Document devalidated successfully"
      };
    } catch (error) {
      console.error("[ValidateDocumentService] Error devalidating document:", error instanceof Error ? error.message : String(error));
      return {
        success: false,
        message: `Error devalidating document: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
};
var validate_document_default = ValidateDocumentService;

// server/modules/accounting/index.ts
function initAccountingModule(app2) {
  const accountingRoutes = setupAccountingRoutes();
  app2.use("/api/accounting", accountingRoutes);
  const ledgerRoutes = setupLedgerRoutes();
  app2.use("/api/accounting/ledger", ledgerRoutes);
  const noteContabilRoutes = setupNoteContabilRoutes();
  app2.use("/api/accounting/notes", noteContabilRoutes);
  const bankJournalRoutes = setupBankJournalRoutes();
  app2.use("/api/accounting/bank-journal", bankJournalRoutes);
  const cashRegisterRoutes = setupCashRegisterRoutes();
  app2.use("/api/accounting/cash-register", cashRegisterRoutes);
  const salesJournalRoutes = setupSalesJournalRoutes();
  app2.use("/api/accounting/sales-journal", salesJournalRoutes);
  const purchaseJournalRoutes = setupPurchaseJournalRoutes();
  app2.use("/api/accounting/purchase-journal", purchaseJournalRoutes);
  registerLegacyAccountingService();
  console.log("[Accounting Module] Registered accounting routes");
  return accountingRoutes;
}
function registerLegacyAccountingService() {
  if (Services) {
    Services.accounting = accountingService;
    console.log("[Accounting Module] Registered legacy accounting service in global registry");
  }
}
var accountingService = new AccountingService(storage);
var journalService = new journal_service_default();
var salesJournalService = new sales_journal_service_default();
var purchaseJournalService = new purchase_journal_service_default();
var bankJournalService = new bank_journal_service_default();
var cashRegisterService = new cash_register_service_default();
var noteContabilService = new NoteContabilService();
var validateDocumentService = new validate_document_default();
var accountingController = new AccountingController(accountingService);
var journalController = new JournalController(journalService);
var noteContabilController = new NoteContabilController(noteContabilService);
var bankJournalController = new BankJournalController(bankJournalService);
var cashRegisterController = new CashRegisterController(cashRegisterService);
var salesJournalController = new SalesJournalController(salesJournalService);
var purchaseJournalController = new PurchaseJournalController(purchaseJournalService);

// server/modules/comms/comms.module.ts
init_logger();

// server/modules/comms/services/threads.service.ts
import { eq as eq76, and as and63, desc as desc35, count as count4 } from "drizzle-orm";
init_logger();
var logger103 = new Logger("ThreadsService");
var ThreadsService = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Create a new message thread
   * 
   * @param companyId The company ID
   * @param data Thread data
   * @returns The created thread
   */
  async createThread(companyId, data) {
    try {
      logger103.info(`Creating new thread for company ${companyId}`);
      const [thread] = await this.db.insert(messageThreads).values({
        companyId,
        subject: data.subject,
        channel: data.channel,
        externalThreadId: data.externalThreadId,
        status: data.status || "new" /* NEW */,
        lastMessageAt: /* @__PURE__ */ new Date(),
        assignedTo: data.assignedTo,
        customerId: data.customerId,
        contactId: data.contactId,
        metadata: data.metadata ? JSON.stringify(data.metadata) : "{}"
      }).returning();
      return thread;
    } catch (error) {
      logger103.error(`Failed to create thread for company ${companyId}`, error);
      throw new Error(`Failed to create thread: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get a thread by ID
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @returns The thread
   */
  async getThreadById(threadId, companyId) {
    try {
      const threads = await this.db.select().from(messageThreads).where(
        and63(
          eq76(messageThreads.id, threadId),
          eq76(messageThreads.companyId, companyId)
        )
      );
      if (threads.length === 0) {
        return null;
      }
      return threads[0];
    } catch (error) {
      logger103.error(`Failed to get thread ${threadId}`, error);
      throw new Error(`Failed to get thread: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get threads for a company with message count
   * 
   * @param companyId Company ID
   * @param filter Filter options
   * @returns Array of threads with message count
   */
  async getThreadsWithMessageCount(companyId, filter) {
    try {
      let query = this.db.select({
        thread: messageThreads,
        messageCount: count4(messages.id)
      }).from(messageThreads).leftJoin(messages, eq76(messageThreads.id, messages.threadId)).where(eq76(messageThreads.companyId, companyId)).groupBy(messageThreads.id);
      if (filter) {
        if (filter.channel) {
          query = query.where(eq76(messageThreads.channel, filter.channel));
        }
        if (filter.status) {
          query = query.where(eq76(messageThreads.status, filter.status));
        }
        if (filter.assignedTo) {
          query = query.where(eq76(messageThreads.assignedTo, filter.assignedTo));
        }
        if (filter.customerId) {
          query = query.where(eq76(messageThreads.customerId, filter.customerId));
        }
        if (filter.contactId) {
          query = query.where(eq76(messageThreads.contactId, filter.contactId));
        }
      }
      const result = await query.orderBy(desc35(messageThreads.lastMessageAt));
      return result.map((item) => ({
        ...item.thread,
        messageCount: Number(item.messageCount)
      }));
    } catch (error) {
      logger103.error(`Failed to get threads for company ${companyId}`, error);
      throw new Error(`Failed to get threads: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update a thread
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @param data Update data
   * @returns The updated thread
   */
  async updateThread(threadId, companyId, data) {
    try {
      logger103.info(`Updating thread ${threadId}`);
      const updateData = {};
      if (data.subject !== void 0) {
        updateData.subject = data.subject;
      }
      if (data.status !== void 0) {
        updateData.status = data.status;
      }
      if (data.assignedTo !== void 0) {
        updateData.assignedTo = data.assignedTo;
      }
      if (data.customerId !== void 0) {
        updateData.customerId = data.customerId;
      }
      if (data.contactId !== void 0) {
        updateData.contactId = data.contactId;
      }
      if (data.metadata !== void 0) {
        updateData.metadata = JSON.stringify(data.metadata);
      }
      updateData.updatedAt = /* @__PURE__ */ new Date();
      const [updatedThread] = await this.db.update(messageThreads).set(updateData).where(
        and63(
          eq76(messageThreads.id, threadId),
          eq76(messageThreads.companyId, companyId)
        )
      ).returning();
      return updatedThread;
    } catch (error) {
      logger103.error(`Failed to update thread ${threadId}`, error);
      throw new Error(`Failed to update thread: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Delete a thread and all its messages
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @returns True if deleted
   */
  async deleteThread(threadId, companyId) {
    try {
      logger103.info(`Deleting thread ${threadId}`);
      await this.db.delete(messages).where(
        and63(
          eq76(messages.threadId, threadId),
          eq76(messages.companyId, companyId)
        )
      );
      const result = await this.db.delete(messageThreads).where(
        and63(
          eq76(messageThreads.id, threadId),
          eq76(messageThreads.companyId, companyId)
        )
      );
      return result.rowCount > 0;
    } catch (error) {
      logger103.error(`Failed to delete thread ${threadId}`, error);
      throw new Error(`Failed to delete thread: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update the last message timestamp for a thread
   * 
   * @param threadId Thread ID
   * @param timestamp Timestamp to set
   */
  async updateLastMessageTimestamp(threadId, timestamp24 = /* @__PURE__ */ new Date()) {
    try {
      await this.db.update(messageThreads).set({
        lastMessageAt: timestamp24,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq76(messageThreads.id, threadId));
    } catch (error) {
      logger103.error(`Failed to update last message timestamp for thread ${threadId}`, error);
    }
  }
};

// server/modules/comms/services/messages.service.ts
import { eq as eq77, and as and64, desc as desc36 } from "drizzle-orm";
init_logger();
var logger104 = new Logger("MessagesService");
var MessagesService = class {
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
    this.threadsService = new ThreadsService(drizzleService5);
  }
  /**
   * Create a new message in a thread
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @param data Message data
   * @returns The created message
   */
  async createMessage(threadId, companyId, data) {
    try {
      logger104.info(`Creating message in thread ${threadId} for company ${companyId}`);
      return await this.drizzleService.transaction(async (tx) => {
        const [message] = await tx.insert(messages).values({
          threadId,
          companyId,
          channel: data.channel,
          direction: data.direction,
          status: data.status || "new" /* NEW */,
          fromEmail: data.fromEmail,
          fromName: data.fromName,
          fromPhone: data.fromPhone,
          toEmail: data.toEmail,
          toName: data.toName,
          toPhone: data.toPhone,
          subject: data.subject,
          body: data.body,
          bodyHtml: data.bodyHtml,
          sentiment: data.sentiment,
          sentimentScore: data.sentimentScore,
          externalMessageId: data.externalMessageId,
          externalConversationId: data.externalConversationId,
          isFlagged: data.isFlagged || false,
          metadata: data.metadata ? JSON.stringify(data.metadata) : "{}",
          createdBy: data.createdBy
        }).returning();
        await this.threadsService.updateLastMessageTimestamp(threadId);
        return message;
      });
    } catch (error) {
      logger104.error(`Failed to create message in thread ${threadId}`, error);
      throw new Error(`Failed to create message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get messages for a thread
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @param filter Filter options
   * @returns Array of messages
   */
  async getThreadMessages(threadId, companyId, filter) {
    try {
      return await this.drizzleService.transaction(async (db4) => {
        let query = db4.select().from(messages).where(
          and64(
            eq77(messages.threadId, threadId),
            eq77(messages.companyId, companyId)
          )
        );
        if (filter) {
          if (filter.direction) {
            query = query.where(eq77(messages.direction, filter.direction));
          }
          if (filter.status) {
            query = query.where(eq77(messages.status, filter.status));
          }
        }
        query = query.orderBy(desc36(messages.createdAt));
        if (filter?.limit) {
          query = query.limit(filter.limit);
        }
        if (filter?.offset) {
          query = query.offset(filter.offset);
        }
        return await query;
      });
    } catch (error) {
      logger104.error(`Failed to get messages for thread ${threadId}`, error);
      throw new Error(`Failed to get thread messages: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get a message by ID
   * 
   * @param messageId Message ID
   * @param companyId Company ID
   * @returns The message
   */
  async getMessageById(messageId, companyId) {
    try {
      return await this.drizzleService.transaction(async (db4) => {
        const result = await db4.select().from(messages).where(
          and64(
            eq77(messages.id, messageId),
            eq77(messages.companyId, companyId)
          )
        );
        if (result.length === 0) {
          return null;
        }
        return result[0];
      });
    } catch (error) {
      logger104.error(`Failed to get message ${messageId}`, error);
      throw new Error(`Failed to get message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update a message
   * 
   * @param messageId Message ID
   * @param companyId Company ID
   * @param data Update data
   * @returns The updated message
   */
  async updateMessage(messageId, companyId, data) {
    try {
      logger104.info(`Updating message ${messageId}`);
      return await this.drizzleService.transaction(async (db4) => {
        const updateData = {};
        if (data.status !== void 0) {
          updateData.status = data.status;
        }
        if (data.sentiment !== void 0) {
          updateData.sentiment = data.sentiment;
        }
        if (data.sentimentScore !== void 0) {
          updateData.sentimentScore = data.sentimentScore;
        }
        if (data.isFlagged !== void 0) {
          updateData.isFlagged = data.isFlagged;
        }
        if (data.readAt !== void 0) {
          updateData.readAt = data.readAt;
        }
        if (data.deliveredAt !== void 0) {
          updateData.deliveredAt = data.deliveredAt;
        }
        if (data.metadata !== void 0) {
          updateData.metadata = JSON.stringify(data.metadata);
        }
        if (data.updatedBy !== void 0) {
          updateData.updatedBy = data.updatedBy;
        }
        updateData.updatedAt = /* @__PURE__ */ new Date();
        const [updatedMessage] = await db4.update(messages).set(updateData).where(
          and64(
            eq77(messages.id, messageId),
            eq77(messages.companyId, companyId)
          )
        ).returning();
        return updatedMessage;
      });
    } catch (error) {
      logger104.error(`Failed to update message ${messageId}`, error);
      throw new Error(`Failed to update message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Mark a message as read
   * 
   * @param messageId Message ID
   * @param companyId Company ID
   * @param userId User ID who read the message
   * @returns The updated message
   */
  async markMessageAsRead(messageId, companyId, userId) {
    try {
      return await this.updateMessage(messageId, companyId, {
        status: "read" /* READ */,
        readAt: /* @__PURE__ */ new Date(),
        updatedBy: userId
      });
    } catch (error) {
      logger104.error(`Failed to mark message ${messageId} as read`, error);
      throw error;
    }
  }
  /**
   * Delete a message
   * 
   * @param messageId Message ID
   * @param companyId Company ID
   * @returns True if deleted
   */
  async deleteMessage(messageId, companyId) {
    try {
      logger104.info(`Deleting message ${messageId}`);
      return await this.drizzleService.transaction(async (db4) => {
        const result = await db4.delete(messages).where(
          and64(
            eq77(messages.id, messageId),
            eq77(messages.companyId, companyId)
          )
        );
        return result.rowCount > 0;
      });
    } catch (error) {
      logger104.error(`Failed to delete message ${messageId}`, error);
      throw new Error(`Failed to delete message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Search messages across threads
   * 
   * @param companyId Company ID
   * @param query Search query
   * @returns Array of messages matching the search
   */
  async searchMessages(companyId, query) {
    try {
      return await this.drizzleService.transaction(async (db4) => {
        const result = await db4.select({
          message: messages,
          thread: messageThreads
        }).from(messages).leftJoin(messageThreads, eq77(messages.threadId, messageThreads.id)).where(
          and64(
            eq77(messages.companyId, companyId),
            // Search in subject or body
            db4.sql`${messages.subject} ILIKE ${"%" + query + "%"} OR
                ${messages.body} ILIKE ${"%" + query + "%"} OR
                ${messages.fromName} ILIKE ${"%" + query + "%"} OR
                ${messages.fromEmail} ILIKE ${"%" + query + "%"}`
          )
        ).orderBy(desc36(messages.createdAt)).limit(50);
        return result.map((item) => ({
          ...item.message,
          thread: item.thread
        }));
      });
    } catch (error) {
      logger104.error(`Failed to search messages for company ${companyId}`, error);
      throw new Error(`Failed to search messages: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/comms/services/contacts.service.ts
import { eq as eq78, and as and65, or as or17, like as like15, desc as desc37 } from "drizzle-orm";
init_logger();
var logger105 = new Logger("ContactsService");
var ContactsService = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Create a new contact profile
   * 
   * @param companyId Company ID
   * @param data Contact data
   * @returns The created contact
   */
  async createContact(companyId, data) {
    try {
      logger105.info(`Creating contact for company ${companyId}`);
      const [contact] = await this.db.insert(contacts2).values({
        companyId,
        email: data.email,
        phone: data.phone,
        firstName: data.firstName,
        lastName: data.lastName,
        displayName: data.displayName || `${data.firstName || ""} ${data.lastName || ""}`.trim(),
        company: data.company,
        jobTitle: data.jobTitle,
        avatarUrl: data.avatarUrl,
        socialProfiles: data.socialProfiles ? JSON.stringify(data.socialProfiles) : "{}",
        communicationPreferences: data.communicationPreferences ? JSON.stringify(data.communicationPreferences) : "{}",
        optOut: data.optOut ? JSON.stringify(data.optOut) : "{}",
        metadata: data.metadata ? JSON.stringify(data.metadata) : "{}",
        externalId: data.externalId,
        externalSource: data.externalSource,
        createdBy: data.createdBy
      }).returning();
      return contact;
    } catch (error) {
      logger105.error(`Failed to create contact for company ${companyId}`, error);
      throw new Error(`Failed to create contact: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get a contact by ID
   * 
   * @param contactId Contact ID
   * @param companyId Company ID
   * @returns The contact
   */
  async getContactById(contactId, companyId) {
    try {
      const result = await this.db.select().from(contacts2).where(
        and65(
          eq78(contacts2.id, contactId),
          eq78(contacts2.companyId, companyId)
        )
      );
      if (result.length === 0) {
        return null;
      }
      return result[0];
    } catch (error) {
      logger105.error(`Failed to get contact ${contactId}`, error);
      throw new Error(`Failed to get contact: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Find contacts by various identifiers
   * 
   * @param companyId Company ID
   * @param identifiers Email, phone or external ID
   * @returns Array of matching contacts
   */
  async findContactsByIdentifiers(companyId, identifiers) {
    try {
      const conditions = [];
      if (identifiers.email) {
        conditions.push(eq78(contacts2.email, identifiers.email));
      }
      if (identifiers.phone) {
        conditions.push(eq78(contacts2.phone, identifiers.phone));
      }
      if (identifiers.externalId) {
        conditions.push(eq78(contacts2.externalId, identifiers.externalId));
      }
      if (conditions.length === 0) {
        return [];
      }
      const result = await this.db.select().from(contacts2).where(
        and65(
          eq78(contacts2.companyId, companyId),
          or17(...conditions)
        )
      );
      return result;
    } catch (error) {
      logger105.error(`Failed to find contacts for company ${companyId}`, error);
      throw new Error(`Failed to find contacts: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get contacts for a company with pagination and search
   * 
   * @param companyId Company ID
   * @param options Search and pagination options
   * @returns Array of contacts
   */
  async getContacts(companyId, options) {
    try {
      let query = this.db.select().from(contacts2).where(eq78(contacts2.companyId, companyId));
      if (options?.search) {
        const searchTerm = `%${options.search}%`;
        query = query.where(
          or17(
            like15(contacts2.firstName, searchTerm),
            like15(contacts2.lastName, searchTerm),
            like15(contacts2.displayName, searchTerm),
            like15(contacts2.email, searchTerm),
            like15(contacts2.phone, searchTerm),
            like15(contacts2.company, searchTerm)
          )
        );
      }
      query = query.orderBy(desc37(contacts2.createdAt));
      if (options?.limit) {
        query = query.limit(options.limit);
      }
      if (options?.offset) {
        query = query.offset(options.offset);
      }
      return await query;
    } catch (error) {
      logger105.error(`Failed to get contacts for company ${companyId}`, error);
      throw new Error(`Failed to get contacts: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update a contact
   * 
   * @param contactId Contact ID
   * @param companyId Company ID
   * @param data Update data
   * @returns The updated contact
   */
  async updateContact(contactId, companyId, data) {
    try {
      logger105.info(`Updating contact ${contactId}`);
      const updateData = {};
      if (data.email !== void 0) {
        updateData.email = data.email;
      }
      if (data.phone !== void 0) {
        updateData.phone = data.phone;
      }
      if (data.firstName !== void 0) {
        updateData.firstName = data.firstName;
      }
      if (data.lastName !== void 0) {
        updateData.lastName = data.lastName;
      }
      if (data.displayName !== void 0) {
        updateData.displayName = data.displayName;
      } else if (data.firstName !== void 0 || data.lastName !== void 0) {
        const contact = await this.getContactById(contactId, companyId);
        if (contact) {
          const firstName = data.firstName !== void 0 ? data.firstName : contact.firstName;
          const lastName = data.lastName !== void 0 ? data.lastName : contact.lastName;
          updateData.displayName = `${firstName || ""} ${lastName || ""}`.trim();
        }
      }
      if (data.company !== void 0) {
        updateData.company = data.company;
      }
      if (data.jobTitle !== void 0) {
        updateData.jobTitle = data.jobTitle;
      }
      if (data.avatarUrl !== void 0) {
        updateData.avatarUrl = data.avatarUrl;
      }
      if (data.socialProfiles !== void 0) {
        updateData.socialProfiles = JSON.stringify(data.socialProfiles);
      }
      if (data.communicationPreferences !== void 0) {
        updateData.communicationPreferences = JSON.stringify(data.communicationPreferences);
      }
      if (data.optOut !== void 0) {
        updateData.optOut = JSON.stringify(data.optOut);
      }
      if (data.metadata !== void 0) {
        updateData.metadata = JSON.stringify(data.metadata);
      }
      if (data.externalId !== void 0) {
        updateData.externalId = data.externalId;
      }
      if (data.externalSource !== void 0) {
        updateData.externalSource = data.externalSource;
      }
      if (data.updatedBy !== void 0) {
        updateData.updatedBy = data.updatedBy;
      }
      updateData.updatedAt = /* @__PURE__ */ new Date();
      const [updatedContact] = await this.db.update(contacts2).set(updateData).where(
        and65(
          eq78(contacts2.id, contactId),
          eq78(contacts2.companyId, companyId)
        )
      ).returning();
      return updatedContact;
    } catch (error) {
      logger105.error(`Failed to update contact ${contactId}`, error);
      throw new Error(`Failed to update contact: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Delete a contact
   * 
   * @param contactId Contact ID
   * @param companyId Company ID
   * @returns True if deleted
   */
  async deleteContact(contactId, companyId) {
    try {
      logger105.info(`Deleting contact ${contactId}`);
      const result = await this.db.delete(contacts2).where(
        and65(
          eq78(contacts2.id, contactId),
          eq78(contacts2.companyId, companyId)
        )
      );
      return result.rowCount > 0;
    } catch (error) {
      logger105.error(`Failed to delete contact ${contactId}`, error);
      throw new Error(`Failed to delete contact: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/comms/services/channel-configs.service.ts
import { eq as eq79, and as and66 } from "drizzle-orm";
init_logger();
var logger106 = new Logger("ChannelConfigsService");
var ChannelConfigsService = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Create a new channel configuration
   * 
   * @param companyId Company ID
   * @param data Channel configuration data
   * @returns The created configuration
   */
  async createChannelConfig(companyId, data) {
    try {
      logger106.info(`Creating channel configuration for ${data.channel} in company ${companyId}`);
      const encryptedCredentials = JSON.stringify(data.credentials);
      const [config3] = await this.db.insert(channelConfigurations).values({
        companyId,
        channel: data.channel,
        name: data.name,
        isActive: data.isActive,
        credentials: encryptedCredentials,
        settings: data.settings ? JSON.stringify(data.settings) : "{}",
        webhookUrl: data.webhookUrl,
        createdBy: data.createdBy
      }).returning();
      return {
        ...config3,
        credentials: "REDACTED_FOR_SECURITY"
      };
    } catch (error) {
      logger106.error(`Failed to create channel configuration for ${data.channel}`, error);
      throw new Error(`Failed to create channel configuration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get a channel configuration by ID
   * 
   * @param configId Configuration ID
   * @param companyId Company ID
   * @param includeCredentials Whether to include decrypted credentials
   * @returns The channel configuration
   */
  async getChannelConfigById(configId, companyId, includeCredentials = false) {
    try {
      const result = await this.db.select().from(channelConfigurations).where(
        and66(
          eq79(channelConfigurations.id, configId),
          eq79(channelConfigurations.companyId, companyId)
        )
      );
      if (result.length === 0) {
        return null;
      }
      if (!includeCredentials) {
        return {
          ...result[0],
          credentials: "REDACTED_FOR_SECURITY"
        };
      }
      return {
        ...result[0],
        credentials: JSON.parse(result[0].credentials)
      };
    } catch (error) {
      logger106.error(`Failed to get channel configuration ${configId}`, error);
      throw new Error(`Failed to get channel configuration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get channel configurations for a company
   * 
   * @param companyId Company ID
   * @param channel Optional filter by channel type
   * @returns Array of channel configurations
   */
  async getChannelConfigs(companyId, channel) {
    try {
      let query = this.db.select().from(channelConfigurations).where(eq79(channelConfigurations.companyId, companyId));
      if (channel) {
        query = query.where(eq79(channelConfigurations.channel, channel));
      }
      const configs = await query;
      return configs.map((config3) => ({
        ...config3,
        credentials: "REDACTED_FOR_SECURITY"
      }));
    } catch (error) {
      logger106.error(`Failed to get channel configurations for company ${companyId}`, error);
      throw new Error(`Failed to get channel configurations: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update a channel configuration
   * 
   * @param configId Configuration ID
   * @param companyId Company ID
   * @param data Update data
   * @returns The updated configuration
   */
  async updateChannelConfig(configId, companyId, data) {
    try {
      logger106.info(`Updating channel configuration ${configId}`);
      const currentConfig = await this.getChannelConfigById(configId, companyId, true);
      if (!currentConfig) {
        throw new Error(`Channel configuration not found: ${configId}`);
      }
      const updateData = {};
      if (data.name !== void 0) {
        updateData.name = data.name;
      }
      if (data.isActive !== void 0) {
        updateData.isActive = data.isActive;
      }
      if (data.webhookUrl !== void 0) {
        updateData.webhookUrl = data.webhookUrl;
      }
      if (data.updatedBy !== void 0) {
        updateData.updatedBy = data.updatedBy;
      }
      if (data.credentials !== void 0) {
        updateData.credentials = JSON.stringify(data.credentials);
      }
      if (data.settings !== void 0) {
        const currentSettings = currentConfig.settings ? typeof currentConfig.settings === "string" ? JSON.parse(currentConfig.settings) : currentConfig.settings : {};
        const newSettings = { ...currentSettings, ...data.settings };
        updateData.settings = JSON.stringify(newSettings);
      }
      updateData.updatedAt = /* @__PURE__ */ new Date();
      const [updatedConfig] = await this.db.update(channelConfigurations).set(updateData).where(
        and66(
          eq79(channelConfigurations.id, configId),
          eq79(channelConfigurations.companyId, companyId)
        )
      ).returning();
      return {
        ...updatedConfig,
        credentials: "REDACTED_FOR_SECURITY"
      };
    } catch (error) {
      logger106.error(`Failed to update channel configuration ${configId}`, error);
      throw new Error(`Failed to update channel configuration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Delete a channel configuration
   * 
   * @param configId Configuration ID
   * @param companyId Company ID
   * @returns True if deleted
   */
  async deleteChannelConfig(configId, companyId) {
    try {
      logger106.info(`Deleting channel configuration ${configId}`);
      const result = await this.db.delete(channelConfigurations).where(
        and66(
          eq79(channelConfigurations.id, configId),
          eq79(channelConfigurations.companyId, companyId)
        )
      );
      return result.rowCount > 0;
    } catch (error) {
      logger106.error(`Failed to delete channel configuration ${configId}`, error);
      throw new Error(`Failed to delete channel configuration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get configuration for a specific channel type
   * 
   * @param companyId Company ID
   * @param channel Channel type
   * @param active Get only active configurations
   * @returns Channel configurations
   */
  async getConfigsForChannel(companyId, channel, active = true) {
    try {
      let query = this.db.select().from(channelConfigurations).where(
        and66(
          eq79(channelConfigurations.companyId, companyId),
          eq79(channelConfigurations.channel, channel)
        )
      );
      if (active) {
        query = query.where(eq79(channelConfigurations.isActive, true));
      }
      const configs = await query;
      return configs.map((config3) => ({
        ...config3,
        credentials: JSON.parse(config3.credentials),
        settings: config3.settings ? JSON.parse(config3.settings) : {}
      }));
    } catch (error) {
      logger106.error(`Failed to get configs for channel ${channel}`, error);
      throw new Error(`Failed to get channel configurations: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/comms/services/thread-access.service.ts
import { eq as eq80, and as and67 } from "drizzle-orm";
init_logger();
var logger107 = new Logger("ThreadAccessService");
var ThreadAccessService = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Grant access to a thread for a user
   * 
   * @param threadId Thread ID
   * @param userId User ID
   * @param companyId Company ID
   * @param permissions Access permissions
   * @returns The created access record
   */
  async grantThreadAccess(threadId, userId, companyId, permissions4) {
    try {
      logger107.info(`Granting access to thread ${threadId} for user ${userId}`);
      const existingAccess = await this.getThreadAccess(threadId, userId, companyId);
      if (existingAccess) {
        return this.updateThreadAccess(threadId, userId, companyId, permissions4);
      }
      const [access] = await this.db.insert(threadAccess).values({
        threadId,
        userId,
        companyId,
        canView: permissions4.canView !== void 0 ? permissions4.canView : true,
        canReply: permissions4.canReply !== void 0 ? permissions4.canReply : false,
        canAssign: permissions4.canAssign !== void 0 ? permissions4.canAssign : false,
        canDelete: permissions4.canDelete !== void 0 ? permissions4.canDelete : false
      }).returning();
      return access;
    } catch (error) {
      logger107.error(`Failed to grant thread access for thread ${threadId}, user ${userId}`, error);
      throw new Error(`Failed to grant thread access: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get access record for a thread and user
   * 
   * @param threadId Thread ID
   * @param userId User ID
   * @param companyId Company ID
   * @returns The access record if found
   */
  async getThreadAccess(threadId, userId, companyId) {
    try {
      const result = await this.db.select().from(threadAccess).where(
        and67(
          eq80(threadAccess.threadId, threadId),
          eq80(threadAccess.userId, userId),
          eq80(threadAccess.companyId, companyId)
        )
      );
      if (result.length === 0) {
        return null;
      }
      return result[0];
    } catch (error) {
      logger107.error(`Failed to get thread access for thread ${threadId}, user ${userId}`, error);
      throw new Error(`Failed to get thread access: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update access permissions for a thread and user
   * 
   * @param threadId Thread ID
   * @param userId User ID
   * @param companyId Company ID
   * @param permissions Updated permissions
   * @returns The updated access record
   */
  async updateThreadAccess(threadId, userId, companyId, permissions4) {
    try {
      logger107.info(`Updating access to thread ${threadId} for user ${userId}`);
      const updateData = {};
      if (permissions4.canView !== void 0) {
        updateData.canView = permissions4.canView;
      }
      if (permissions4.canReply !== void 0) {
        updateData.canReply = permissions4.canReply;
      }
      if (permissions4.canAssign !== void 0) {
        updateData.canAssign = permissions4.canAssign;
      }
      if (permissions4.canDelete !== void 0) {
        updateData.canDelete = permissions4.canDelete;
      }
      updateData.updatedAt = /* @__PURE__ */ new Date();
      const [updatedAccess] = await this.db.update(threadAccess).set(updateData).where(
        and67(
          eq80(threadAccess.threadId, threadId),
          eq80(threadAccess.userId, userId),
          eq80(threadAccess.companyId, companyId)
        )
      ).returning();
      return updatedAccess;
    } catch (error) {
      logger107.error(`Failed to update thread access for thread ${threadId}, user ${userId}`, error);
      throw new Error(`Failed to update thread access: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Remove access to a thread for a user
   * 
   * @param threadId Thread ID
   * @param userId User ID
   * @param companyId Company ID
   * @returns True if access was removed
   */
  async removeThreadAccess(threadId, userId, companyId) {
    try {
      logger107.info(`Removing access to thread ${threadId} for user ${userId}`);
      const result = await this.db.delete(threadAccess).where(
        and67(
          eq80(threadAccess.threadId, threadId),
          eq80(threadAccess.userId, userId),
          eq80(threadAccess.companyId, companyId)
        )
      );
      return result.rowCount > 0;
    } catch (error) {
      logger107.error(`Failed to remove thread access for thread ${threadId}, user ${userId}`, error);
      throw new Error(`Failed to remove thread access: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get all users with access to a thread
   * 
   * @param threadId Thread ID
   * @param companyId Company ID
   * @returns Array of access records
   */
  async getThreadAccessUsers(threadId, companyId) {
    try {
      return await this.db.select().from(threadAccess).where(
        and67(
          eq80(threadAccess.threadId, threadId),
          eq80(threadAccess.companyId, companyId)
        )
      );
    } catch (error) {
      logger107.error(`Failed to get users with access to thread ${threadId}`, error);
      throw new Error(`Failed to get thread access users: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Check if a user has specific permissions for a thread
   * 
   * @param threadId Thread ID
   * @param userId User ID
   * @param companyId Company ID
   * @param permission The permission to check
   * @returns True if the user has the permission
   */
  async checkThreadPermission(threadId, userId, companyId, permission) {
    try {
      const access = await this.getThreadAccess(threadId, userId, companyId);
      if (!access) {
        return false;
      }
      switch (permission) {
        case "view":
          return access.canView;
        case "reply":
          return access.canReply;
        case "assign":
          return access.canAssign;
        case "delete":
          return access.canDelete;
        default:
          return false;
      }
    } catch (error) {
      logger107.error(`Failed to check permission '${permission}' for thread ${threadId}, user ${userId}`, error);
      return false;
    }
  }
};

// server/modules/comms/services/message-access.service.ts
import { eq as eq81, and as and68 } from "drizzle-orm";
init_logger();
var logger108 = new Logger("MessageAccessService");
var MessageAccessService = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Grant access to a message for a user
   * 
   * @param messageId Message ID
   * @param userId User ID
   * @param companyId Company ID
   * @param permissions Access permissions
   * @returns The created access record
   */
  async grantMessageAccess(messageId, userId, companyId, permissions4) {
    try {
      logger108.info(`Granting access to message ${messageId} for user ${userId}`);
      const existingAccess = await this.getMessageAccess(messageId, userId, companyId);
      if (existingAccess) {
        return this.updateMessageAccess(messageId, userId, companyId, permissions4);
      }
      const [access] = await this.db.insert(messageAccess).values({
        messageId,
        userId,
        companyId,
        canView: permissions4.canView !== void 0 ? permissions4.canView : true,
        canReply: permissions4.canReply !== void 0 ? permissions4.canReply : false,
        canDelete: permissions4.canDelete !== void 0 ? permissions4.canDelete : false
      }).returning();
      return access;
    } catch (error) {
      logger108.error(`Failed to grant message access for message ${messageId}, user ${userId}`, error);
      throw new Error(`Failed to grant message access: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get access record for a message and user
   * 
   * @param messageId Message ID
   * @param userId User ID
   * @param companyId Company ID
   * @returns The access record if found
   */
  async getMessageAccess(messageId, userId, companyId) {
    try {
      const result = await this.db.select().from(messageAccess).where(
        and68(
          eq81(messageAccess.messageId, messageId),
          eq81(messageAccess.userId, userId),
          eq81(messageAccess.companyId, companyId)
        )
      );
      if (result.length === 0) {
        return null;
      }
      return result[0];
    } catch (error) {
      logger108.error(`Failed to get message access for message ${messageId}, user ${userId}`, error);
      throw new Error(`Failed to get message access: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Update access permissions for a message and user
   * 
   * @param messageId Message ID
   * @param userId User ID
   * @param companyId Company ID
   * @param permissions Updated permissions
   * @returns The updated access record
   */
  async updateMessageAccess(messageId, userId, companyId, permissions4) {
    try {
      logger108.info(`Updating access to message ${messageId} for user ${userId}`);
      const updateData = {};
      if (permissions4.canView !== void 0) {
        updateData.canView = permissions4.canView;
      }
      if (permissions4.canReply !== void 0) {
        updateData.canReply = permissions4.canReply;
      }
      if (permissions4.canDelete !== void 0) {
        updateData.canDelete = permissions4.canDelete;
      }
      updateData.updatedAt = /* @__PURE__ */ new Date();
      const [updatedAccess] = await this.db.update(messageAccess).set(updateData).where(
        and68(
          eq81(messageAccess.messageId, messageId),
          eq81(messageAccess.userId, userId),
          eq81(messageAccess.companyId, companyId)
        )
      ).returning();
      return updatedAccess;
    } catch (error) {
      logger108.error(`Failed to update message access for message ${messageId}, user ${userId}`, error);
      throw new Error(`Failed to update message access: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Remove access to a message for a user
   * 
   * @param messageId Message ID
   * @param userId User ID
   * @param companyId Company ID
   * @returns True if access was removed
   */
  async removeMessageAccess(messageId, userId, companyId) {
    try {
      logger108.info(`Removing access to message ${messageId} for user ${userId}`);
      const result = await this.db.delete(messageAccess).where(
        and68(
          eq81(messageAccess.messageId, messageId),
          eq81(messageAccess.userId, userId),
          eq81(messageAccess.companyId, companyId)
        )
      );
      return result.rowCount > 0;
    } catch (error) {
      logger108.error(`Failed to remove message access for message ${messageId}, user ${userId}`, error);
      throw new Error(`Failed to remove message access: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get all users with access to a message
   * 
   * @param messageId Message ID
   * @param companyId Company ID
   * @returns Array of access records
   */
  async getMessageAccessUsers(messageId, companyId) {
    try {
      return await this.db.select().from(messageAccess).where(
        and68(
          eq81(messageAccess.messageId, messageId),
          eq81(messageAccess.companyId, companyId)
        )
      );
    } catch (error) {
      logger108.error(`Failed to get users with access to message ${messageId}`, error);
      throw new Error(`Failed to get message access users: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Check if a user has specific permissions for a message
   * 
   * @param messageId Message ID
   * @param userId User ID
   * @param companyId Company ID
   * @param permission The permission to check
   * @returns True if the user has the permission
   */
  async checkMessagePermission(messageId, userId, companyId, permission) {
    try {
      const access = await this.getMessageAccess(messageId, userId, companyId);
      if (!access) {
        return false;
      }
      switch (permission) {
        case "view":
          return access.canView;
        case "reply":
          return access.canReply;
        case "delete":
          return access.canDelete;
        default:
          return false;
      }
    } catch (error) {
      logger108.error(`Failed to check permission '${permission}' for message ${messageId}, user ${userId}`, error);
      return false;
    }
  }
  /**
   * Bulk grant message access to multiple users
   * 
   * @param messageId Message ID
   * @param userIds Array of user IDs
   * @param companyId Company ID
   * @param permissions Access permissions
   * @returns Array of created access records
   */
  async bulkGrantMessageAccess(messageId, userIds, companyId, permissions4) {
    try {
      logger108.info(`Bulk granting access to message ${messageId} for ${userIds.length} users`);
      const results = [];
      for (const userId of userIds) {
        const access = await this.grantMessageAccess(messageId, userId, companyId, permissions4);
        results.push(access);
      }
      return results;
    } catch (error) {
      logger108.error(`Failed to bulk grant message access for message ${messageId}`, error);
      throw new Error(`Failed to bulk grant message access: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};

// server/modules/comms/routes/threads.routes.ts
import { Router as Router50 } from "express";

// server/modules/comms/controllers/threads.controller.ts
init_logger();
var logger109 = new Logger("ThreadsController");
var ThreadsController = class {
  constructor(threadsService) {
    this.threadsService = threadsService;
  }
  /**
   * Get all threads for a company
   */
  async getThreads(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const filter = {};
      if (req.query.channel) {
        filter.channel = req.query.channel;
      }
      if (req.query.status) {
        filter.status = req.query.status;
      }
      if (req.query.assignedTo) {
        filter.assignedTo = req.query.assignedTo;
      }
      if (req.query.customerId) {
        filter.customerId = req.query.customerId;
      }
      if (req.query.contactId) {
        filter.contactId = req.query.contactId;
      }
      const threads = await this.threadsService.getThreadsWithMessageCount(companyId, filter);
      return res.json(threads);
    } catch (error) {
      logger109.error("Error getting threads", error);
      return res.status(500).json({
        message: "Failed to get threads",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Get a specific thread by ID
   */
  async getThread(req, res) {
    try {
      const { threadId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const thread = await this.threadsService.getThreadById(threadId, companyId);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }
      return res.json(thread);
    } catch (error) {
      logger109.error(`Error getting thread ${req.params.threadId}`, error);
      return res.status(500).json({
        message: "Failed to get thread",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Create a new thread
   */
  async createThread(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      if (!req.body.channel) {
        return res.status(400).json({ message: "Channel is required" });
      }
      const thread = await this.threadsService.createThread(companyId, {
        subject: req.body.subject,
        channel: req.body.channel,
        externalThreadId: req.body.externalThreadId,
        status: req.body.status,
        assignedTo: req.body.assignedTo,
        customerId: req.body.customerId,
        contactId: req.body.contactId,
        metadata: req.body.metadata
      });
      return res.status(201).json(thread);
    } catch (error) {
      logger109.error("Error creating thread", error);
      return res.status(500).json({
        message: "Failed to create thread",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Update an existing thread
   */
  async updateThread(req, res) {
    try {
      const { threadId } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const thread = await this.threadsService.getThreadById(threadId, companyId);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }
      const updatedThread = await this.threadsService.updateThread(threadId, companyId, {
        subject: req.body.subject,
        status: req.body.status,
        assignedTo: req.body.assignedTo,
        customerId: req.body.customerId,
        contactId: req.body.contactId,
        metadata: req.body.metadata
      });
      return res.json(updatedThread);
    } catch (error) {
      logger109.error(`Error updating thread ${req.params.threadId}`, error);
      return res.status(500).json({
        message: "Failed to update thread",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Delete a thread
   */
  async deleteThread(req, res) {
    try {
      const { threadId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const deleted = await this.threadsService.deleteThread(threadId, companyId);
      if (!deleted) {
        return res.status(404).json({ message: "Thread not found" });
      }
      return res.status(204).end();
    } catch (error) {
      logger109.error(`Error deleting thread ${req.params.threadId}`, error);
      return res.status(500).json({
        message: "Failed to delete thread",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
};

// server/modules/comms/routes/threads.routes.ts
init_auth_guard();
init_auth_mode_enum();
var ThreadsRouter = class {
  constructor(threadsService) {
    this.router = Router50();
    this.threadsController = new ThreadsController(threadsService);
    this.setupRoutes();
  }
  /**
   * Set up the routes for the router
   */
  setupRoutes() {
    this.router.get(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadsController.getThreads(req, res)
    );
    this.router.get(
      "/:threadId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadsController.getThread(req, res)
    );
    this.router.post(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadsController.createThread(req, res)
    );
    this.router.patch(
      "/:threadId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadsController.updateThread(req, res)
    );
    this.router.delete(
      "/:threadId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadsController.deleteThread(req, res)
    );
  }
  /**
   * Get the configured router
   * @returns Express Router
   */
  getRouter() {
    return this.router;
  }
};

// server/modules/comms/routes/messages.routes.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
import express7 from "express";

// server/modules/comms/controllers/messages.controller.ts
init_logger();
var MessagesController = class {
  constructor(messagesService) {
    this.messagesService = messagesService;
    this._logger = new Logger("MessagesController");
  }
  /**
   * Create a new message
   */
  async createMessage(req, res) {
    try {
      const { threadId } = req.params;
      const { companyId } = req.user;
      const messageData = {
        ...req.body,
        threadId,
        companyId
      };
      const message = await this.messagesService.createMessage(
        threadId,
        companyId,
        messageData
      );
      res.status(201).json(message);
    } catch (error) {
      this._logger.error("Failed to create message", { error });
      res.status(500).json({
        error: "Failed to create message",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Get messages for a thread
   */
  async getThreadMessages(req, res) {
    try {
      const { threadId } = req.params;
      const { companyId } = req.user;
      const {
        direction,
        status,
        limit,
        offset
      } = req.query;
      const filter = {};
      if (direction) {
        filter.direction = direction;
      }
      if (status) {
        filter.status = status;
      }
      if (limit) {
        filter.limit = parseInt(limit, 10);
      }
      if (offset) {
        filter.offset = parseInt(offset, 10);
      }
      const messages2 = await this.messagesService.getThreadMessages(
        threadId,
        companyId,
        filter
      );
      res.json(messages2);
    } catch (error) {
      this._logger.error("Failed to get thread messages", { error });
      res.status(500).json({
        error: "Failed to get thread messages",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Get message by ID
   */
  async getMessageById(req, res) {
    try {
      const { messageId } = req.params;
      const { companyId } = req.user;
      const message = await this.messagesService.getMessageById(messageId, companyId);
      if (!message) {
        res.status(404).json({ error: "Message not found" });
        return;
      }
      res.json(message);
    } catch (error) {
      this._logger.error("Failed to get message", { error });
      res.status(500).json({
        error: "Failed to get message",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Update a message
   */
  async updateMessage(req, res) {
    try {
      const { messageId } = req.params;
      const { companyId, userId } = req.user;
      const updateData = {
        ...req.body,
        updatedBy: userId
      };
      const message = await this.messagesService.updateMessage(
        messageId,
        companyId,
        updateData
      );
      if (!message) {
        res.status(404).json({ error: "Message not found" });
        return;
      }
      res.json(message);
    } catch (error) {
      this._logger.error("Failed to update message", { error });
      res.status(500).json({
        error: "Failed to update message",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Mark a message as read
   */
  async markMessageAsRead(req, res) {
    try {
      const { messageId } = req.params;
      const { companyId, userId } = req.user;
      const message = await this.messagesService.markMessageAsRead(
        messageId,
        companyId,
        userId
      );
      if (!message) {
        res.status(404).json({ error: "Message not found" });
        return;
      }
      res.json(message);
    } catch (error) {
      this._logger.error("Failed to mark message as read", { error });
      res.status(500).json({
        error: "Failed to mark message as read",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Delete a message
   */
  async deleteMessage(req, res) {
    try {
      const { messageId } = req.params;
      const { companyId } = req.user;
      const success = await this.messagesService.deleteMessage(messageId, companyId);
      if (!success) {
        res.status(404).json({ error: "Message not found" });
        return;
      }
      res.status(204).send();
    } catch (error) {
      this._logger.error("Failed to delete message", { error });
      res.status(500).json({
        error: "Failed to delete message",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Search messages
   */
  async searchMessages(req, res) {
    try {
      const { companyId } = req.user;
      const { query } = req.query;
      if (!query || typeof query !== "string") {
        res.status(400).json({ error: "Query parameter is required" });
        return;
      }
      const messages2 = await this.messagesService.searchMessages(companyId, query);
      res.json(messages2);
    } catch (error) {
      this._logger.error("Failed to search messages", { error });
      res.status(500).json({
        error: "Failed to search messages",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  }
};
function createMessagesController(messagesService) {
  const controller = new MessagesController(messagesService);
  return {
    createMessage: controller.createMessage.bind(controller),
    getThreadMessages: controller.getThreadMessages.bind(controller),
    getMessageById: controller.getMessageById.bind(controller),
    updateMessage: controller.updateMessage.bind(controller),
    markMessageAsRead: controller.markMessageAsRead.bind(controller),
    deleteMessage: controller.deleteMessage.bind(controller),
    searchMessages: controller.searchMessages.bind(controller)
  };
}

// server/modules/comms/routes/messages.routes.ts
var logger110 = new Logger("MessagesRouter");
var MessagesRouter = class {
  constructor(messagesService) {
    this.messagesService = messagesService;
    this.router = express7.Router();
    this.messagesController = createMessagesController(messagesService);
    this.setupRoutes();
  }
  /**
   * Set up the routes for the router
   */
  setupRoutes() {
    this.router.get(
      "/thread/:threadId",
      AuthGuard.protect("required" /* REQUIRED */),
      this.messagesController.getThreadMessages
    );
    this.router.get(
      "/:messageId",
      AuthGuard.protect("required" /* REQUIRED */),
      this.messagesController.getMessageById
    );
    this.router.post(
      "/thread/:threadId",
      AuthGuard.protect("required" /* REQUIRED */),
      this.messagesController.createMessage
    );
    this.router.patch(
      "/:messageId",
      AuthGuard.protect("required" /* REQUIRED */),
      this.messagesController.updateMessage
    );
    this.router.patch(
      "/:messageId/read",
      AuthGuard.protect("required" /* REQUIRED */),
      this.messagesController.markMessageAsRead
    );
    this.router.delete(
      "/:messageId",
      AuthGuard.protect("required" /* REQUIRED */),
      this.messagesController.deleteMessage
    );
    this.router.get(
      "/search",
      AuthGuard.protect("required" /* REQUIRED */),
      this.messagesController.searchMessages
    );
  }
  /**
   * Get the configured router
   * @returns Express Router
   */
  getRouter() {
    return this.router;
  }
};

// server/modules/comms/routes/contacts.routes.ts
init_auth_guard();
init_auth_mode_enum();
init_logger();
import express8 from "express";
var logger111 = new Logger("ContactsRouter");
var ContactsRouter = class {
  constructor(contactsService) {
    this.contactsService = contactsService;
    this.router = express8.Router();
    this.setupRoutes();
  }
  /**
   * Set up the routes for the router
   */
  setupRoutes() {
    this.router.get("/", AuthGuard.protect("required" /* REQUIRED */), this.getContacts.bind(this));
    this.router.get("/:contactId", AuthGuard.protect("required" /* REQUIRED */), this.getContact.bind(this));
    this.router.post("/", AuthGuard.protect("required" /* REQUIRED */), this.createContact.bind(this));
    this.router.patch("/:contactId", AuthGuard.protect("required" /* REQUIRED */), this.updateContact.bind(this));
    this.router.delete("/:contactId", AuthGuard.protect("required" /* REQUIRED */), this.deleteContact.bind(this));
    this.router.post("/find", AuthGuard.protect("required" /* REQUIRED */), this.findContacts.bind(this));
  }
  /**
   * Get the configured router
   * @returns Express Router
   */
  getRouter() {
    return this.router;
  }
  /**
   * Handler for GET /contacts
   */
  async getContacts(req, res) {
    try {
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ error: "Missing company ID" });
      }
      const options = {};
      if (req.query.search) {
        options.search = req.query.search;
      }
      if (req.query.limit) {
        options.limit = parseInt(req.query.limit, 10);
      }
      if (req.query.offset) {
        options.offset = parseInt(req.query.offset, 10);
      }
      const contacts3 = await this.contactsService.getContacts(companyId, options);
      return res.json(contacts3);
    } catch (error) {
      logger111.error("Error getting contacts", error);
      return res.status(500).json({
        error: "Failed to get contacts",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handler for GET /contacts/:contactId
   */
  async getContact(req, res) {
    try {
      const { contactId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ error: "Missing company ID" });
      }
      const contact = await this.contactsService.getContactById(contactId, companyId);
      if (!contact) {
        return res.status(404).json({ error: "Contact not found" });
      }
      return res.json(contact);
    } catch (error) {
      logger111.error(`Error getting contact ${req.params.contactId}`, error);
      return res.status(500).json({
        error: "Failed to get contact",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handler for POST /contacts
   */
  async createContact(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ error: "Missing company ID" });
      }
      const contact = await this.contactsService.createContact(companyId, {
        email: req.body.email,
        phone: req.body.phone,
        firstName: req.body.firstName,
        lastName: req.body.lastName,
        displayName: req.body.displayName,
        company: req.body.company,
        jobTitle: req.body.jobTitle,
        avatarUrl: req.body.avatarUrl,
        socialProfiles: req.body.socialProfiles,
        communicationPreferences: req.body.communicationPreferences,
        optOut: req.body.optOut,
        metadata: req.body.metadata,
        externalId: req.body.externalId,
        externalSource: req.body.externalSource,
        createdBy: userId
      });
      return res.status(201).json(contact);
    } catch (error) {
      logger111.error("Error creating contact", error);
      return res.status(500).json({
        error: "Failed to create contact",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handler for PATCH /contacts/:contactId
   */
  async updateContact(req, res) {
    try {
      const { contactId } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ error: "Missing company ID" });
      }
      const contact = await this.contactsService.getContactById(contactId, companyId);
      if (!contact) {
        return res.status(404).json({ error: "Contact not found" });
      }
      const updatedContact = await this.contactsService.updateContact(contactId, companyId, {
        email: req.body.email,
        phone: req.body.phone,
        firstName: req.body.firstName,
        lastName: req.body.lastName,
        displayName: req.body.displayName,
        company: req.body.company,
        jobTitle: req.body.jobTitle,
        avatarUrl: req.body.avatarUrl,
        socialProfiles: req.body.socialProfiles,
        communicationPreferences: req.body.communicationPreferences,
        optOut: req.body.optOut,
        metadata: req.body.metadata,
        externalId: req.body.externalId,
        externalSource: req.body.externalSource,
        updatedBy: userId
      });
      return res.json(updatedContact);
    } catch (error) {
      logger111.error(`Error updating contact ${req.params.contactId}`, error);
      return res.status(500).json({
        error: "Failed to update contact",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handler for DELETE /contacts/:contactId
   */
  async deleteContact(req, res) {
    try {
      const { contactId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ error: "Missing company ID" });
      }
      const deleted = await this.contactsService.deleteContact(contactId, companyId);
      if (!deleted) {
        return res.status(404).json({ error: "Contact not found" });
      }
      return res.status(204).end();
    } catch (error) {
      logger111.error(`Error deleting contact ${req.params.contactId}`, error);
      return res.status(500).json({
        error: "Failed to delete contact",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handler for POST /contacts/find
   */
  async findContacts(req, res) {
    try {
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ error: "Missing company ID" });
      }
      const contacts3 = await this.contactsService.findContactsByIdentifiers(companyId, {
        email: req.body.email,
        phone: req.body.phone,
        externalId: req.body.externalId
      });
      return res.json(contacts3);
    } catch (error) {
      logger111.error("Error finding contacts", error);
      return res.status(500).json({
        error: "Failed to find contacts",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  }
};

// server/modules/comms/routes/channel-configs.routes.ts
import { Router as Router53 } from "express";

// server/modules/comms/controllers/channel-configs.controller.ts
init_logger();
var logger112 = new Logger("ChannelConfigsController");
var ChannelConfigsController = class {
  constructor(channelConfigsService) {
    this.channelConfigsService = channelConfigsService;
  }
  /**
   * Get all channel configurations for a company
   */
  async getChannelConfigs(req, res) {
    try {
      const companyId = req.user?.companyId;
      const channel = req.query.channel;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const configs = await this.channelConfigsService.getChannelConfigs(companyId, channel);
      return res.json(configs);
    } catch (error) {
      logger112.error("Error getting channel configurations", error);
      return res.status(500).json({
        message: "Failed to get channel configurations",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Get a specific channel configuration by ID
   */
  async getChannelConfig(req, res) {
    try {
      const { configId } = req.params;
      const companyId = req.user?.companyId;
      const includeCredentials = req.query.includeCredentials === "true";
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const config3 = await this.channelConfigsService.getChannelConfigById(configId, companyId, includeCredentials);
      if (!config3) {
        return res.status(404).json({ message: "Channel configuration not found" });
      }
      return res.json(config3);
    } catch (error) {
      logger112.error(`Error getting channel configuration ${req.params.configId}`, error);
      return res.status(500).json({
        message: "Failed to get channel configuration",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Create a new channel configuration
   */
  async createChannelConfig(req, res) {
    try {
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      if (!req.body.channel) {
        return res.status(400).json({ message: "Channel is required" });
      }
      if (!req.body.name) {
        return res.status(400).json({ message: "Name is required" });
      }
      if (!req.body.credentials) {
        return res.status(400).json({ message: "Credentials are required" });
      }
      const config3 = await this.channelConfigsService.createChannelConfig(companyId, {
        channel: req.body.channel,
        name: req.body.name,
        isActive: req.body.isActive !== void 0 ? req.body.isActive : true,
        credentials: req.body.credentials,
        settings: req.body.settings,
        webhookUrl: req.body.webhookUrl,
        createdBy: userId
      });
      return res.status(201).json(config3);
    } catch (error) {
      logger112.error("Error creating channel configuration", error);
      return res.status(500).json({
        message: "Failed to create channel configuration",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Update a channel configuration
   */
  async updateChannelConfig(req, res) {
    try {
      const { configId } = req.params;
      const userId = req.user?.id;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const config3 = await this.channelConfigsService.getChannelConfigById(configId, companyId);
      if (!config3) {
        return res.status(404).json({ message: "Channel configuration not found" });
      }
      const updatedConfig = await this.channelConfigsService.updateChannelConfig(configId, companyId, {
        name: req.body.name,
        isActive: req.body.isActive,
        credentials: req.body.credentials,
        settings: req.body.settings,
        webhookUrl: req.body.webhookUrl,
        updatedBy: userId
      });
      return res.json(updatedConfig);
    } catch (error) {
      logger112.error(`Error updating channel configuration ${req.params.configId}`, error);
      return res.status(500).json({
        message: "Failed to update channel configuration",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Delete a channel configuration
   */
  async deleteChannelConfig(req, res) {
    try {
      const { configId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const deleted = await this.channelConfigsService.deleteChannelConfig(configId, companyId);
      if (!deleted) {
        return res.status(404).json({ message: "Channel configuration not found" });
      }
      return res.status(204).end();
    } catch (error) {
      logger112.error(`Error deleting channel configuration ${req.params.configId}`, error);
      return res.status(500).json({
        message: "Failed to delete channel configuration",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Get configurations for a specific channel type
   */
  async getConfigsForChannel(req, res) {
    try {
      const { channel } = req.params;
      const companyId = req.user?.companyId;
      const activeOnly = req.query.activeOnly !== "false";
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      if (!Object.values(CommunicationChannel).includes(channel)) {
        return res.status(400).json({ message: "Invalid channel type" });
      }
      const configs = await this.channelConfigsService.getConfigsForChannel(
        companyId,
        channel,
        activeOnly
      );
      return res.json(configs);
    } catch (error) {
      logger112.error(`Error getting configurations for channel ${req.params.channel}`, error);
      return res.status(500).json({
        message: "Failed to get channel configurations",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
};

// server/modules/comms/routes/channel-configs.routes.ts
init_auth_guard();
init_auth_mode_enum();
var ChannelConfigsRouter = class {
  constructor(channelConfigsService) {
    this.router = Router53();
    this.channelConfigsController = new ChannelConfigsController(channelConfigsService);
    this.setupRoutes();
  }
  /**
   * Set up the routes for the router
   */
  setupRoutes() {
    this.router.get(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.channelConfigsController.getChannelConfigs(req, res)
    );
    this.router.get(
      "/type/:channel",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.channelConfigsController.getConfigsForChannel(req, res)
    );
    this.router.get(
      "/:configId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.channelConfigsController.getChannelConfig(req, res)
    );
    this.router.post(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.channelConfigsController.createChannelConfig(req, res)
    );
    this.router.patch(
      "/:configId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.channelConfigsController.updateChannelConfig(req, res)
    );
    this.router.delete(
      "/:configId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.channelConfigsController.deleteChannelConfig(req, res)
    );
  }
  /**
   * Get the configured router
   * @returns Express Router
   */
  getRouter() {
    return this.router;
  }
};

// server/modules/comms/routes/thread-access.routes.ts
import { Router as Router54 } from "express";

// server/modules/comms/controllers/thread-access.controller.ts
init_logger();
var logger113 = new Logger("ThreadAccessController");
var ThreadAccessController = class {
  constructor(threadAccessService) {
    this.threadAccessService = threadAccessService;
  }
  /**
   * Get users with access to a thread
   */
  async getThreadAccessUsers(req, res) {
    try {
      const { threadId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const accessRecords = await this.threadAccessService.getThreadAccessUsers(threadId, companyId);
      return res.json(accessRecords);
    } catch (error) {
      logger113.error(`Error getting access records for thread ${req.params.threadId}`, error);
      return res.status(500).json({
        message: "Failed to get thread access records",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Get access record for a specific user and thread
   */
  async getThreadAccess(req, res) {
    try {
      const { threadId, userId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const accessRecord = await this.threadAccessService.getThreadAccess(threadId, userId, companyId);
      if (!accessRecord) {
        return res.status(404).json({ message: "Access record not found" });
      }
      return res.json(accessRecord);
    } catch (error) {
      logger113.error(`Error getting access record for thread ${req.params.threadId} and user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to get thread access record",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Grant access to a thread for a user
   */
  async grantThreadAccess(req, res) {
    try {
      const { threadId, userId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const accessRecord = await this.threadAccessService.grantThreadAccess(threadId, userId, companyId, {
        canView: req.body.canView,
        canReply: req.body.canReply,
        canAssign: req.body.canAssign,
        canDelete: req.body.canDelete
      });
      return res.status(201).json(accessRecord);
    } catch (error) {
      logger113.error(`Error granting access to thread ${req.params.threadId} for user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to grant thread access",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Update thread access permissions
   */
  async updateThreadAccess(req, res) {
    try {
      const { threadId, userId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const existingAccess = await this.threadAccessService.getThreadAccess(threadId, userId, companyId);
      if (!existingAccess) {
        return res.status(404).json({ message: "Access record not found" });
      }
      const updatedAccess = await this.threadAccessService.updateThreadAccess(threadId, userId, companyId, {
        canView: req.body.canView,
        canReply: req.body.canReply,
        canAssign: req.body.canAssign,
        canDelete: req.body.canDelete
      });
      return res.json(updatedAccess);
    } catch (error) {
      logger113.error(`Error updating access for thread ${req.params.threadId} and user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to update thread access",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Remove thread access for a user
   */
  async removeThreadAccess(req, res) {
    try {
      const { threadId, userId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const removed = await this.threadAccessService.removeThreadAccess(threadId, userId, companyId);
      if (!removed) {
        return res.status(404).json({ message: "Access record not found" });
      }
      return res.status(204).end();
    } catch (error) {
      logger113.error(`Error removing access from thread ${req.params.threadId} for user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to remove thread access",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Check if user has a specific permission for a thread
   */
  async checkThreadPermission(req, res) {
    try {
      const { threadId, userId } = req.params;
      const companyId = req.user?.companyId;
      const permission = req.params.permission;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      if (!["view", "reply", "assign", "delete"].includes(permission)) {
        return res.status(400).json({ message: "Invalid permission type" });
      }
      const hasPermission = await this.threadAccessService.checkThreadPermission(
        threadId,
        userId,
        companyId,
        permission
      );
      return res.json({ hasPermission });
    } catch (error) {
      logger113.error(`Error checking permission for thread ${req.params.threadId} and user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to check thread permission",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
};

// server/modules/comms/routes/thread-access.routes.ts
init_auth_guard();
init_auth_mode_enum();
var ThreadAccessRouter = class {
  constructor(threadAccessService) {
    this.router = Router54();
    this.threadAccessController = new ThreadAccessController(threadAccessService);
    this.setupRoutes();
  }
  /**
   * Set up the thread access routes
   */
  setupRoutes() {
    this.router.get(
      "/:threadId/users",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadAccessController.getThreadAccessUsers(req, res)
    );
    this.router.get(
      "/:threadId/users/:userId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadAccessController.getThreadAccess(req, res)
    );
    this.router.post(
      "/:threadId/users/:userId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadAccessController.grantThreadAccess(req, res)
    );
    this.router.patch(
      "/:threadId/users/:userId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadAccessController.updateThreadAccess(req, res)
    );
    this.router.delete(
      "/:threadId/users/:userId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadAccessController.removeThreadAccess(req, res)
    );
    this.router.get(
      "/:threadId/users/:userId/permissions/:permission",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.threadAccessController.checkThreadPermission(req, res)
    );
  }
  /**
   * Get the configured router
   * @returns The Express router
   */
  getRouter() {
    return this.router;
  }
};

// server/modules/comms/routes/message-access.routes.ts
import { Router as Router55 } from "express";

// server/modules/comms/controllers/message-access.controller.ts
init_logger();
var logger114 = new Logger("MessageAccessController");
var MessageAccessController = class {
  constructor(messageAccessService) {
    this.messageAccessService = messageAccessService;
  }
  /**
   * Get users with access to a message
   */
  async getMessageAccessUsers(req, res) {
    try {
      const { messageId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const accessRecords = await this.messageAccessService.getMessageAccessUsers(messageId, companyId);
      return res.json(accessRecords);
    } catch (error) {
      logger114.error(`Error getting access records for message ${req.params.messageId}`, error);
      return res.status(500).json({
        message: "Failed to get message access records",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Get access record for a specific user and message
   */
  async getMessageAccess(req, res) {
    try {
      const { messageId, userId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const accessRecord = await this.messageAccessService.getMessageAccess(messageId, userId, companyId);
      if (!accessRecord) {
        return res.status(404).json({ message: "Access record not found" });
      }
      return res.json(accessRecord);
    } catch (error) {
      logger114.error(`Error getting access record for message ${req.params.messageId} and user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to get message access record",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Grant access to a message for a user
   */
  async grantMessageAccess(req, res) {
    try {
      const { messageId, userId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const accessRecord = await this.messageAccessService.grantMessageAccess(messageId, userId, companyId, {
        canView: req.body.canView,
        canReply: req.body.canReply,
        canDelete: req.body.canDelete
      });
      return res.status(201).json(accessRecord);
    } catch (error) {
      logger114.error(`Error granting access to message ${req.params.messageId} for user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to grant message access",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Update message access permissions
   */
  async updateMessageAccess(req, res) {
    try {
      const { messageId, userId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const existingAccess = await this.messageAccessService.getMessageAccess(messageId, userId, companyId);
      if (!existingAccess) {
        return res.status(404).json({ message: "Access record not found" });
      }
      const updatedAccess = await this.messageAccessService.updateMessageAccess(messageId, userId, companyId, {
        canView: req.body.canView,
        canReply: req.body.canReply,
        canDelete: req.body.canDelete
      });
      return res.json(updatedAccess);
    } catch (error) {
      logger114.error(`Error updating access for message ${req.params.messageId} and user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to update message access",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Remove message access for a user
   */
  async removeMessageAccess(req, res) {
    try {
      const { messageId, userId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      const removed = await this.messageAccessService.removeMessageAccess(messageId, userId, companyId);
      if (!removed) {
        return res.status(404).json({ message: "Access record not found" });
      }
      return res.status(204).end();
    } catch (error) {
      logger114.error(`Error removing access from message ${req.params.messageId} for user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to remove message access",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Check if user has a specific permission for a message
   */
  async checkMessagePermission(req, res) {
    try {
      const { messageId, userId } = req.params;
      const companyId = req.user?.companyId;
      const permission = req.params.permission;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      if (!["view", "reply", "delete"].includes(permission)) {
        return res.status(400).json({ message: "Invalid permission type" });
      }
      const hasPermission = await this.messageAccessService.checkMessagePermission(
        messageId,
        userId,
        companyId,
        permission
      );
      return res.json({ hasPermission });
    } catch (error) {
      logger114.error(`Error checking permission for message ${req.params.messageId} and user ${req.params.userId}`, error);
      return res.status(500).json({
        message: "Failed to check message permission",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Bulk grant access to multiple users for a message
   */
  async bulkGrantMessageAccess(req, res) {
    try {
      const { messageId } = req.params;
      const companyId = req.user?.companyId;
      if (!companyId) {
        return res.status(400).json({ message: "Missing company ID" });
      }
      if (!req.body.userIds || !Array.isArray(req.body.userIds) || req.body.userIds.length === 0) {
        return res.status(400).json({ message: "userIds array is required" });
      }
      const accessRecords = await this.messageAccessService.bulkGrantMessageAccess(
        messageId,
        req.body.userIds,
        companyId,
        {
          canView: req.body.canView,
          canReply: req.body.canReply,
          canDelete: req.body.canDelete
        }
      );
      return res.status(201).json(accessRecords);
    } catch (error) {
      logger114.error(`Error bulk granting access to message ${req.params.messageId}`, error);
      return res.status(500).json({
        message: "Failed to grant bulk message access",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
};

// server/modules/comms/routes/message-access.routes.ts
init_auth_guard();
init_auth_mode_enum();
var MessageAccessRouter = class {
  constructor(messageAccessService) {
    this.router = Router55();
    this.messageAccessController = new MessageAccessController(messageAccessService);
    this.setupRoutes();
  }
  /**
   * Set up the message access routes
   */
  setupRoutes() {
    this.router.get(
      "/:messageId/users",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.messageAccessController.getMessageAccessUsers(req, res)
    );
    this.router.get(
      "/:messageId/users/:userId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.messageAccessController.getMessageAccess(req, res)
    );
    this.router.post(
      "/:messageId/users/:userId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.messageAccessController.grantMessageAccess(req, res)
    );
    this.router.patch(
      "/:messageId/users/:userId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.messageAccessController.updateMessageAccess(req, res)
    );
    this.router.delete(
      "/:messageId/users/:userId",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.messageAccessController.removeMessageAccess(req, res)
    );
    this.router.get(
      "/:messageId/users/:userId/permissions/:permission",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.messageAccessController.checkMessagePermission(req, res)
    );
    this.router.post(
      "/:messageId/users/bulk",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.messageAccessController.bulkGrantMessageAccess(req, res)
    );
  }
  /**
   * Get the configured router
   * @returns The Express router
   */
  getRouter() {
    return this.router;
  }
};

// server/modules/comms/comms.module.ts
var logger115 = new Logger("CommsModule");
var CommsModule = {
  name: "communications",
  displayName: "Communications",
  description: "Universal inbox system with omni-channel communications support",
  version: "1.0.0",
  initialize: initCommsModule,
  /**
   * Register the module with the application
   * @param app Express application
   * @param drizzleService DrizzleService instance
   * @returns Information about the registered module
   */
  register: (app2, drizzleService5) => {
    const moduleInfo = initCommsModule(app2, drizzleService5);
    try {
      const { registerModule } = (init_services(), __toCommonJS(services_exports));
      registerModule("communications", {
        name: CommsModule.name,
        version: CommsModule.version,
        services: moduleInfo.services,
        permissions: CommsModule.permissions
      });
      logger115.info("Communications module registered with service registry");
    } catch (error) {
      logger115.warn("Service registry not available, module services will not be globally accessible");
    }
    return moduleInfo;
  },
  defaultRoles: [
    "comms_admin",
    "comms_user",
    "comms_viewer"
  ],
  permissions: [
    "communications.threads.create",
    "communications.threads.read",
    "communications.threads.update",
    "communications.threads.delete",
    "communications.messages.create",
    "communications.messages.read",
    "communications.messages.update",
    "communications.messages.delete",
    "communications.contacts.create",
    "communications.contacts.read",
    "communications.contacts.update",
    "communications.contacts.delete",
    "communications.channels.configure",
    "communications.channels.integrate",
    "communications.thread_access.create",
    "communications.thread_access.read",
    "communications.thread_access.update",
    "communications.thread_access.delete",
    "communications.message_access.create",
    "communications.message_access.read",
    "communications.message_access.update",
    "communications.message_access.delete"
  ],
  routes: [
    {
      path: "/api/communications/threads",
      methods: ["GET", "POST", "PUT", "DELETE"],
      description: "Manage message threads"
    },
    {
      path: "/api/communications/messages",
      methods: ["GET", "POST", "PUT", "DELETE"],
      description: "Manage individual messages"
    },
    {
      path: "/api/communications/contacts",
      methods: ["GET", "POST", "PUT", "DELETE"],
      description: "Manage communication contacts"
    },
    {
      path: "/api/communications/channels",
      methods: ["GET", "POST", "PUT", "DELETE"],
      description: "Configure communication channels"
    },
    {
      path: "/api/communications/thread-access",
      methods: ["GET", "POST", "PATCH", "DELETE"],
      description: "Manage thread access permissions"
    },
    {
      path: "/api/communications/message-access",
      methods: ["GET", "POST", "PATCH", "DELETE"],
      description: "Manage message access permissions"
    }
  ],
  dependencies: ["settings", "customers", "integrations", "crm"]
};
function initCommsModule(app2, drizzleService5) {
  logger115.info("Initializing Communications module");
  try {
    const threadsService = new ThreadsService(drizzleService5);
    const messagesService = new MessagesService(drizzleService5);
    const contactsService = new ContactsService(drizzleService5);
    const channelConfigsService = new ChannelConfigsService(drizzleService5);
    const threadAccessService = new ThreadAccessService(drizzleService5);
    const messageAccessService = new MessageAccessService(drizzleService5);
    const messagesController = createMessagesController(messagesService);
    const threadsRouter = new ThreadsRouter(threadsService);
    const messagesRouter = new MessagesRouter(messagesService);
    const contactsRouter = new ContactsRouter(contactsService);
    const channelConfigsRouter = new ChannelConfigsRouter(channelConfigsService);
    const threadAccessRouter = new ThreadAccessRouter(threadAccessService);
    const messageAccessRouter = new MessageAccessRouter(messageAccessService);
    if (app2) {
      app2.use("/api/communications/threads", threadsRouter.getRouter());
      app2.use("/api/communications/messages", messagesRouter.getRouter());
      app2.use("/api/communications/contacts", contactsRouter.getRouter());
      app2.use("/api/communications/channels", channelConfigsRouter.getRouter());
      app2.use("/api/communications/thread-access", threadAccessRouter.getRouter());
      app2.use("/api/communications/message-access", messageAccessRouter.getRouter());
    }
    logger115.info("Communications module initialized successfully");
    return {
      name: CommsModule.name,
      version: CommsModule.version,
      services: {
        threadsService,
        messagesService,
        contactsService,
        channelConfigsService,
        threadAccessService,
        messageAccessService
      },
      controllers: {
        messagesController
      }
    };
  } catch (error) {
    logger115.error("Failed to initialize Communications module", error);
    throw new Error("Communications module initialization failed");
  }
}

// server/modules/inventory/templates/template.router.ts
import { Router as Router56 } from "express";
import fs7 from "fs";
import path5 from "path";
var templateRouter = Router56();
templateRouter.get("/excel/:type", (req, res) => {
  const templateType = req.params.type;
  try {
    const csvFilePath = path5.join(process.cwd(), "public", "templates", `template_${templateType}.csv`);
    if (fs7.existsSync(csvFilePath)) {
      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", `attachment; filename="template_${templateType}.csv"`);
      const fileStream = fs7.createReadStream(csvFilePath);
      fileStream.pipe(res);
      console.log(`Serving CSV template for: ${templateType} (Excel fallback)`);
    } else {
      res.status(404).json({ error: "Template not found" });
    }
  } catch (error) {
    console.error("Error getting template file:", error);
    res.status(500).json({ error: "Failed to retrieve template file" });
  }
});
templateRouter.get("/csv/:type", (req, res) => {
  const templateType = req.params.type;
  try {
    const csvFilePath = path5.join(process.cwd(), "public", "templates", `template_${templateType}.csv`);
    if (fs7.existsSync(csvFilePath)) {
      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", `attachment; filename="template_${templateType}.csv"`);
      const fileStream = fs7.createReadStream(csvFilePath);
      fileStream.pipe(res);
      console.log(`Serving CSV template for: ${templateType}`);
    } else {
      res.status(404).json({ error: "Template not found" });
    }
  } catch (error) {
    console.error("Error getting CSV template:", error);
    res.status(500).json({ error: "Failed to retrieve CSV template" });
  }
});
templateRouter.get("/json/:type", (req, res) => {
  const templateType = req.params.type;
  try {
    const jsonFilePath = path5.join(process.cwd(), "public", "templates", `template_${templateType}.json`);
    if (fs7.existsSync(jsonFilePath)) {
      res.setHeader("Content-Type", "application/json");
      res.setHeader("Content-Disposition", `attachment; filename="template_${templateType}.json"`);
      const fileStream = fs7.createReadStream(jsonFilePath);
      fileStream.pipe(res);
      console.log(`Serving JSON template for: ${templateType}`);
    } else {
      res.status(404).json({ error: "Template not found" });
    }
  } catch (error) {
    console.error("Error getting JSON template:", error);
    res.status(500).json({ error: "Failed to retrieve JSON template" });
  }
});
var template_router_default = templateRouter;

// server/modules/inventory/routes/inventory.routes.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router63 } from "express";

// server/common/middleware/validate-request.ts
import { ZodError } from "zod";
function validateRequest(schemas) {
  return async (req, res, next) => {
    try {
      if (schemas.body) {
        req.body = await schemas.body.parseAsync(req.body);
      }
      if (schemas.query) {
        req.query = await schemas.query.parseAsync(req.query);
      }
      if (schemas.params) {
        req.params = await schemas.params.parseAsync(req.params);
      }
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        return res.status(400).json({
          message: "Validation error",
          errors: error.errors.map((err) => ({
            path: err.path.join("."),
            message: err.message
          }))
        });
      }
      next(error);
    }
  };
}

// server/modules/auth/middleware/company-access.middleware.ts
init_logger();
var logger116 = new Logger("CompanyAccessMiddleware");
var addCompanyFilter = (req, res, next) => {
  try {
    const user = req.user;
    if (!user) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const userCompanyId = user.companyId;
    if (!userCompanyId) {
      return res.status(403).json({ error: "User not associated with any company" });
    }
    if (!req.query.companyId) {
      req.query.companyId = userCompanyId;
    }
    req.companyId = userCompanyId;
    next();
  } catch (error) {
    logger116.error("Error in addCompanyFilter middleware", error);
    return res.status(500).json({ error: "Internal server error" });
  }
};

// server/modules/inventory/routes/inventory.routes.ts
import { z as z46 } from "zod";

// server/modules/inventory/services/nir.service.ts
init_base_drizzle_service();
import { randomUUID as randomUUID17 } from "crypto";

// server/modules/accounting/services/nota-contabila.service.ts
init_drizzle();
init_storage();
import { randomUUID as randomUUID16 } from "crypto";
var NotaContabilaService = class {
  constructor() {
    this.drizzle = getDrizzle();
    this.storage = storage;
    console.log("[NotaContabilaService] \u{1F527} Serviciu ini\u021Bializat");
  }
  /**
   * Creează o nouă notă contabilă și o înregistrează în jurnal
   * 
   * @param nota Datele notei contabile
   * @returns ID-ul notei contabile create
   */
  async createNotaContabila(nota) {
    console.log("[NotaContabilaService] \u{1F4DD} Creare not\u0103 contabil\u0103 pentru:", nota.documentType, nota.documentNumber);
    try {
      this.validateBalance(nota.lines);
      const journalEntryId = randomUUID16();
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const journalSql = `
        INSERT INTO ledger_entries (
          id, company_id, franchise_id, entry_type, reference_number, 
          amount, description, created_at, updated_at
        ) VALUES (
          '${journalEntryId}',
          '${nota.companyId}',
          ${nota.franchiseId ? `'${nota.franchiseId}'` : "NULL"},
          'PURCHASE',
          '${nota.documentNumber}',
          ${nota.amount},
          '${this.sanitizeString(nota.description)}',
          '${now}',
          '${now}'
        ) RETURNING *`;
      console.log("[NotaContabilaService] \u{1F4DC} Executare SQL pentru \xEEnregistrare jurnal...");
      const journalResult = await this.drizzle.executeQuery(journalSql);
      console.log("[NotaContabilaService] \u2705 \xCEnregistrare jurnal creat\u0103 cu ID:", journalEntryId);
      for (const line of nota.lines) {
        const lineId = randomUUID16();
        const accountId = await this.getAccountIdByCode(line.accountCode, line.accountSuffix);
        const lineSql = `
          INSERT INTO ledger_lines (
            id, ledger_entry_id, account_id, debit_amount, credit_amount,
            description, created_at, updated_at
          ) VALUES (
            '${lineId}',
            '${journalEntryId}',
            '${accountId}',
            ${line.debit},
            ${line.credit},
            '${this.sanitizeString(line.description)}',
            '${now}',
            '${now}'
          )`;
        await this.drizzle.executeQuery(lineSql);
      }
      const linkId = randomUUID16();
      const linkSql = `
        INSERT INTO document_ledger_links (
          id, document_id, document_type, ledger_entry_id, created_at
        ) VALUES (
          '${linkId}',
          '${nota.documentId}',
          '${nota.documentType}',
          '${journalEntryId}',
          '${now}'
        )`;
      await this.drizzle.executeQuery(linkSql);
      console.log("[NotaContabilaService] \u2705 Not\u0103 contabil\u0103 creat\u0103 cu succes pentru:", nota.documentType, nota.documentNumber);
      return journalEntryId;
    } catch (error) {
      console.error("[NotaContabilaService] \u274C Eroare la crearea notei contabile:", error);
      throw new Error(`Eroare la crearea notei contabile: ${error.message || String(error)}`);
    }
  }
  /**
   * Creează o notă contabilă pentru NIR tip Depozit
   * 
   * Înregistrare contabilă standard pentru NIR de tip Depozit:
   * - Debit: 371.x (Mărfuri) - valoarea fără TVA
   * - Debit: 4426.x (TVA deductibilă) - valoarea TVA
   * - Credit: 401 (Furnizori) - valoarea totală cu TVA
   *
   * @param nirId ID-ul documentului NIR
   * @param nirNumber Numărul documentului NIR
   * @param companyId ID-ul companiei
   * @param supplierId ID-ul furnizorului
   * @param warehouseId ID-ul depozitului
   * @param valueNoVat Valoarea totală fără TVA
   * @param vatValue Valoarea TVA
   * @param totalValue Valoarea totală cu TVA
   * @param date Data NIR-ului
   * @returns ID-ul notei contabile create
   */
  async createNirDepozitNotaContabila(nirId, nirNumber, companyId, supplierId, warehouseId, valueNoVat, vatValue, totalValue, date5, currency = "RON", exchangeRate = 1) {
    console.log("[NotaContabilaService] \u{1F4DD} Creare not\u0103 contabil\u0103 pentru NIR Depozit:", nirNumber);
    try {
      const warehouseSuffix = await this.getWarehouseAccountSuffix(warehouseId);
      console.log("[NotaContabilaService] \u{1F50D} Sufix conturi pentru depozit:", warehouseSuffix);
      const supplierName = await this.getSupplierName(supplierId);
      const lines = [
        // Linia 1: Debit 371.x (Mărfuri) cu valoarea fără TVA
        {
          accountCode: "371",
          accountSuffix: warehouseSuffix,
          accountName: "M\u0103rfuri",
          debit: valueNoVat,
          credit: 0,
          description: `Recep\u021Bie marf\u0103 conform NIR ${nirNumber} de la ${supplierName}`
        },
        // Linia 2: Debit 4426.x (TVA deductibilă) cu valoarea TVA
        {
          accountCode: "4426",
          accountSuffix: warehouseSuffix,
          accountName: "TVA deductibil\u0103",
          debit: vatValue,
          credit: 0,
          description: `TVA aferent NIR ${nirNumber} de la ${supplierName}`
        },
        // Linia 3: Credit 401 (Furnizori) cu valoarea totală cu TVA
        {
          accountCode: "401",
          accountName: "Furnizori",
          debit: 0,
          credit: totalValue,
          description: `Datorie c\u0103tre furnizor ${supplierName} pentru NIR ${nirNumber}`
        }
      ];
      const notaContabila = {
        documentId: nirId,
        documentType: "NIR",
        documentNumber: nirNumber,
        companyId,
        date: date5,
        description: `Not\u0103 contabil\u0103 pentru NIR ${nirNumber} - recep\u021Bie marf\u0103 de la ${supplierName}`,
        lines,
        amount: totalValue,
        currency,
        exchangeRate
      };
      return await this.createNotaContabila(notaContabila);
    } catch (error) {
      console.error("[NotaContabilaService] \u274C Eroare la crearea notei contabile pentru NIR:", error);
      throw new Error(`Eroare la crearea notei contabile pentru NIR: ${error.message || String(error)}`);
    }
  }
  /**
   * Obține sufixul conturilor analitice pentru un depozit (371.x, 4426.x, etc.)
   * 
   * @param warehouseId ID-ul depozitului
   * @returns Sufixul conturilor analitice (ex: "1" pentru 371.1)
   */
  async getWarehouseAccountSuffix(warehouseId) {
    const sql57 = `SELECT code FROM warehouses WHERE id = '${warehouseId}'`;
    const result = await this.drizzle.executeQuery(sql57);
    if (!result || result.length === 0) {
      throw new Error(`Depozitul cu ID ${warehouseId} nu a fost g\u0103sit`);
    }
    const code = result[0].code;
    const parts = code.split(".");
    if (parts.length !== 2) {
      throw new Error(`Codul depozitului ${code} nu are formatul a\u0219teptat (xxx.y)`);
    }
    return parts[1];
  }
  /**
   * Obține numele furnizorului
   * 
   * @param supplierId ID-ul furnizorului
   * @returns Numele furnizorului
   */
  async getSupplierName(supplierId) {
    const sql57 = `SELECT name FROM companies WHERE id = '${supplierId}'`;
    const result = await this.drizzle.executeQuery(sql57);
    if (!result || result.length === 0) {
      return "Furnizor necunoscut";
    }
    return result[0].name;
  }
  /**
   * Obține ID-ul contului contabil din baza de date bazat pe codul și sufixul său
   * 
   * @param accountCode Codul contului (ex: 371, 401, 4426)
   * @param accountSuffix Sufixul contului pentru conturi analitice (ex: "1" pentru 371.1)
   * @returns ID-ul contului din baza de date
   */
  async getAccountIdByCode(accountCode, accountSuffix) {
    let sql57;
    if (accountSuffix) {
      const analyticCode = `${accountCode}.${accountSuffix}`;
      sql57 = `SELECT id FROM analytic_accounts WHERE code = '${analyticCode}'`;
      const analyticResult = await this.drizzle.executeQuery(sql57);
      if (analyticResult && analyticResult.length > 0) {
        return analyticResult[0].id;
      }
      throw new Error(`Contul analitic ${analyticCode} nu a fost g\u0103sit`);
    } else {
      sql57 = `SELECT id FROM synthetic_accounts WHERE code = '${accountCode}'`;
      const syntheticResult = await this.drizzle.executeQuery(sql57);
      if (syntheticResult && syntheticResult.length > 0) {
        return syntheticResult[0].id;
      }
      throw new Error(`Contul sintetic ${accountCode} nu a fost g\u0103sit`);
    }
  }
  /**
   * Validează că suma debit este egală cu suma credit
   * 
   * @param lines Liniile contabile de validat
   */
  validateBalance(lines) {
    const totalDebit = lines.reduce((sum2, line) => sum2 + line.debit, 0);
    const totalCredit = lines.reduce((sum2, line) => sum2 + line.credit, 0);
    if (totalDebit.toFixed(2) !== totalCredit.toFixed(2)) {
      throw new Error(`Nota contabil\u0103 nu este echilibrat\u0103: totalDebit (${totalDebit}) != totalCredit (${totalCredit})`);
    }
  }
  /**
   * Sanitizează un șir de caractere pentru a preveni injecțiile SQL
   * 
   * @param value Valoarea de sanitizat
   * @returns Valoarea sanitizată
   */
  sanitizeString(value) {
    if (!value) return "";
    return value.replace(/'/g, "''");
  }
};
var notaContabilaService = new NotaContabilaService();

// server/modules/inventory/services/nir.service.ts
var NirService = class extends BaseDrizzleService {
  constructor() {
    super();
  }
  /**
   * Create a new NIR document with its items
   * @param nirData NIR document data
   * @param items NIR items
   * @returns Created NIR document
   */
  async createNirDocument(nirData, items) {
    console.log(`[NirService] \u{1F4C4} Creating NIR document ${nirData.nirNumber}`);
    try {
      const nirId = randomUUID17();
      const createdAt = /* @__PURE__ */ new Date();
      const sql57 = `
        INSERT INTO nir_documents (
          id, company_id, franchise_id, nir_number, supplier_id, supplier_invoice_number,
          warehouse_id, warehouse_type, is_custody, status, receipt_date,
          total_value_no_vat, total_vat, total_value_with_vat, created_at, updated_at,
          currency, exchange_rate
        ) VALUES (
          '${nirId}',
          '${nirData.companyId}',
          ${nirData.franchiseId ? `'${nirData.franchiseId}'` : "NULL"},
          '${nirData.nirNumber}',
          '${nirData.supplierId}',
          ${nirData.supplierInvoiceNumber ? `'${nirData.supplierInvoiceNumber}'` : "NULL"},
          '${nirData.warehouseId}',
          '${nirData.warehouseType}',
          ${nirData.isCustody || false},
          '${nirData.status || "draft"}',
          '${new Date(nirData.receiptDate || /* @__PURE__ */ new Date()).toISOString()}',
          ${nirData.totalValueNoVat || 0},
          ${nirData.totalVat || 0},
          ${nirData.totalValueWithVat || 0},
          '${createdAt.toISOString()}',
          '${createdAt.toISOString()}',
          '${nirData.currency || "RON"}',
          ${nirData.exchangeRate || 1}
        )
        RETURNING *`;
      console.log("[NirService] \u{1F50D} Executing SQL:", sql57.substring(0, 100) + "...");
      const nirResult = await this.executeQuery(sql57);
      console.log("[NirService] \u2705 SQL executed successfully");
      const nirDoc = nirResult[0];
      console.log(`[NirService] \u2705 Created NIR document: ${nirId}`);
      for (const item of items) {
        const itemId = randomUUID17();
        const itemSql = `
          INSERT INTO nir_items (
            id, nir_id, product_id, quantity, batch_no, expiry_date,
            purchase_price, purchase_price_with_vat, selling_price, selling_price_with_vat,
            vat_rate, vat_value, total_value_no_vat, total_value_with_vat, created_at
          ) VALUES (
            '${itemId}',
            '${nirId}',
            '${item.productId}',
            ${item.quantity},
            ${item.batchNo ? `'${item.batchNo}'` : "NULL"},
            ${item.expiryDate ? `'${new Date(item.expiryDate).toISOString()}'` : "NULL"},
            ${item.purchasePrice},
            ${item.purchasePriceWithVat || "NULL"},
            ${item.sellingPrice || "NULL"},
            ${item.sellingPriceWithVat || "NULL"},
            ${item.vatRate || 19},
            ${item.vatValue || 0},
            ${item.totalValueNoVat || 0},
            ${item.totalValueWithVat || 0},
            '${createdAt.toISOString()}'
          )
        `;
        console.log("[NirService] \u{1F50D} Executing item SQL:", itemSql.substring(0, 100) + "...");
        await this.executeQuery(itemSql);
        console.log("[NirService] \u2705 Item SQL executed successfully");
        await this.updateStock(nirDoc, item);
      }
      return nirDoc;
    } catch (error) {
      console.error(`[NirService] \u274C Error creating NIR document:`, error);
      throw new Error(`Failed to create NIR document: ${error}`);
    }
  }
  /**
   * Updates stock based on warehouse type and NIR item
   * Different warehouse types have different stock updating rules
   * @param nirDoc NIR document
   * @param item NIR item
   */
  async updateStock(nirDoc, item) {
    try {
      console.log("[NirService] \u{1F50D} NIR Document received:", JSON.stringify(nirDoc, null, 2));
      const dbWarehouseId = nirDoc.warehouse_id || nirDoc.warehouseId;
      const dbCompanyId = nirDoc.company_id || nirDoc.companyId;
      const dbFranchiseId = nirDoc.franchise_id || nirDoc.franchiseId;
      if (!dbWarehouseId) {
        console.error("[NirService] \u274C No warehouse ID found in NIR document:", nirDoc);
        throw new Error("Warehouse ID is undefined");
      }
      const warehouseSql = `SELECT * FROM warehouses WHERE id = '${dbWarehouseId}'`;
      const warehouseResult = await this.executeQuery(warehouseSql);
      console.log("[NirService] \u2705 Warehouse SQL executed successfully");
      if (!warehouseResult || warehouseResult.length === 0) {
        throw new Error(`Warehouse ${dbWarehouseId} not found`);
      }
      const warehouse = warehouseResult[0];
      const stockSql = `SELECT * FROM stocks WHERE product_id = '${item.productId}' AND warehouse_id = '${dbWarehouseId}'`;
      const stockResult = await this.executeQuery(stockSql);
      console.log("[NirService] \u2705 Stock SQL executed successfully");
      const quantity = parseFloat(item.quantity.toString());
      const existingStock = stockResult && stockResult.length > 0 ? stockResult[0] : null;
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const stockId = existingStock ? existingStock.id : randomUUID17();
      switch (warehouse.type) {
        case "depozit":
          if (existingStock) {
            const oldQuantity = parseFloat(existingStock.quantity);
            const oldValue = oldQuantity * parseFloat(existingStock.purchase_price || "0");
            const newValue = parseFloat(item.totalValueNoVat?.toString() || "0");
            const newTotalQuantity = oldQuantity + quantity;
            const newAverageCost = newTotalQuantity > 0 ? (oldValue + newValue) / newTotalQuantity : 0;
            const updateSql = `
              UPDATE stocks
              SET quantity = quantity + ${quantity},
                  purchase_price = ${newAverageCost},
                  updated_at = '${now}'
              WHERE id = '${existingStock.id}'
            `;
            await this.executeQuery(updateSql);
            console.log("[NirService] \u2705 Updated existing stock in depozit warehouse");
          } else {
            const insertSql = `
              INSERT INTO stocks (
                id, company_id, franchise_id, product_id, warehouse_id,
                quantity, batch_no, expiry_date, purchase_price, selling_price,
                created_at, updated_at
              ) VALUES (
                '${stockId}',
                '${nirDoc.companyId}',
                ${nirDoc.franchiseId ? `'${nirDoc.franchiseId}'` : "NULL"},
                '${item.productId}',
                '${dbWarehouseId}',
                ${quantity},
                ${item.batchNo ? `'${item.batchNo}'` : "NULL"},
                ${item.expiryDate ? `'${new Date(item.expiryDate).toISOString()}'` : "NULL"},
                ${item.purchasePrice || 0},
                ${item.sellingPrice || 0},
                '${now}',
                '${now}'
              )
            `;
            await this.executeQuery(insertSql);
            console.log("[NirService] \u2705 Created new stock in depozit warehouse");
          }
          break;
        case "magazin":
          if (existingStock) {
            const updateSql = `
              UPDATE stocks
              SET quantity = quantity + ${quantity},
                  selling_price = ${item.sellingPrice || 0},
                  updated_at = '${now}'
              WHERE id = '${existingStock.id}'
            `;
            await this.executeQuery(updateSql);
            console.log("[NirService] \u2705 Updated existing stock in magazin warehouse");
          } else {
            const insertSql = `
              INSERT INTO stocks (
                id, company_id, franchise_id, product_id, warehouse_id,
                quantity, batch_no, expiry_date, purchase_price, selling_price,
                created_at, updated_at
              ) VALUES (
                '${stockId}',
                '${nirDoc.companyId}',
                ${nirDoc.franchiseId ? `'${nirDoc.franchiseId}'` : "NULL"},
                '${item.productId}',
                '${dbWarehouseId}',
                ${quantity},
                ${item.batchNo ? `'${item.batchNo}'` : "NULL"},
                ${item.expiryDate ? `'${new Date(item.expiryDate).toISOString()}'` : "NULL"},
                ${item.purchasePrice || 0},
                ${item.sellingPrice || 0},
                '${now}',
                '${now}'
              )
            `;
            await this.executeQuery(insertSql);
            console.log("[NirService] \u2705 Created new stock in magazin warehouse");
          }
          break;
        case "custodie":
          if (existingStock) {
            const updateSql = `
              UPDATE stocks
              SET quantity = quantity + ${quantity},
                  updated_at = '${now}'
              WHERE id = '${existingStock.id}'
            `;
            await this.executeQuery(updateSql);
            console.log("[NirService] \u2705 Updated existing stock in custodie warehouse");
          } else {
            const insertSql = `
              INSERT INTO stocks (
                id, company_id, franchise_id, product_id, warehouse_id,
                quantity, batch_no, expiry_date, purchase_price,
                created_at, updated_at
              ) VALUES (
                '${stockId}',
                '${nirDoc.companyId}',
                ${nirDoc.franchiseId ? `'${nirDoc.franchiseId}'` : "NULL"},
                '${item.productId}',
                '${dbWarehouseId}',
                ${quantity},
                ${item.batchNo ? `'${item.batchNo}'` : "NULL"},
                ${item.expiryDate ? `'${new Date(item.expiryDate).toISOString()}'` : "NULL"},
                0, /* No cost for custody items */
                '${now}',
                '${now}'
              )
            `;
            await this.executeQuery(insertSql);
            console.log("[NirService] \u2705 Created new stock in custodie warehouse");
          }
          break;
        case "transfer":
          console.log(`[NirService] \u26A0\uFE0F Creating NIR for transfer warehouse is unusual`);
          if (existingStock) {
            const updateSql = `
              UPDATE stocks
              SET quantity = quantity + ${quantity},
                  updated_at = '${now}'
              WHERE id = '${existingStock.id}'
            `;
            await this.executeQuery(updateSql);
            console.log("[NirService] \u2705 Updated existing stock in transfer warehouse");
          } else {
            const insertSql = `
              INSERT INTO stocks (
                id, company_id, franchise_id, product_id, warehouse_id,
                quantity, batch_no, expiry_date, purchase_price,
                created_at, updated_at
              ) VALUES (
                '${stockId}',
                '${nirDoc.companyId}',
                ${nirDoc.franchiseId ? `'${nirDoc.franchiseId}'` : "NULL"},
                '${item.productId}',
                '${dbWarehouseId}',
                ${quantity},
                ${item.batchNo ? `'${item.batchNo}'` : "NULL"},
                ${item.expiryDate ? `'${new Date(item.expiryDate).toISOString()}'` : "NULL"},
                ${item.purchasePrice || 0},
                '${now}',
                '${now}'
              )
            `;
            await this.executeQuery(insertSql);
            console.log("[NirService] \u2705 Created new stock in transfer warehouse");
          }
          break;
      }
      console.log(`[NirService] \u2705 Updated stock for product ${item.productId} in ${warehouse.type} warehouse`);
    } catch (error) {
      console.error(`[NirService] \u274C Error updating stock:`, error);
      throw error;
    }
  }
  /**
   * Get a NIR document by ID with all its items
   * @param nirId NIR document ID
   * @returns NIR document with items
   */
  async getNirDocument(nirId) {
    console.log(`[NirService] \u{1F50D} Fetching NIR document: ${nirId}`);
    try {
      const documentSql = `SELECT * FROM nir_documents WHERE id = '${nirId}'`;
      const documentResult = await this.executeQuery(documentSql);
      console.log("[NirService] \u2705 Document SQL executed successfully");
      if (!documentResult || documentResult.length === 0) {
        throw new Error(`NIR document ${nirId} not found`);
      }
      const document = documentResult[0];
      const itemsSql = `SELECT * FROM nir_items WHERE nir_id = '${nirId}'`;
      const itemsResult = await this.executeQuery(itemsSql);
      console.log("[NirService] \u2705 Items SQL executed successfully");
      const items = itemsResult || [];
      console.log(`[NirService] \u2705 Found NIR document with ${items.length} items`);
      return { document, items };
    } catch (error) {
      console.error(`[NirService] \u274C Error getting NIR document:`, error);
      throw new Error(`Failed to get NIR document: ${error}`);
    }
  }
  /**
   * Update NIR document status
   * @param nirId NIR document ID
   * @param status New status
   * @returns Updated NIR document
   */
  async updateNirStatus(nirId, status) {
    console.log(`[NirService] \u{1F4DD} Updating NIR ${nirId} status to ${status}`);
    try {
      const now = (/* @__PURE__ */ new Date()).toISOString();
      let updateSql = `
        UPDATE nir_documents
        SET status = '${status}', 
            updated_at = '${now}'
      `;
      if (status === "approved") {
        updateSql += `, approved_at = '${now}'`;
      }
      updateSql += ` WHERE id = '${nirId}' RETURNING *`;
      console.log("[NirService] \u{1F50D} Executing update SQL:", updateSql.substring(0, 100) + "...");
      const result = await this.executeQuery(updateSql);
      console.log("[NirService] \u2705 Update SQL executed successfully");
      if (!result || result.length === 0) {
        throw new Error(`NIR document ${nirId} not found`);
      }
      const updatedDoc = result[0];
      console.log(`[NirService] \u2705 Updated NIR status to ${updatedDoc.status}`);
      if (status === "approved" && updatedDoc.warehouse_type === "depozit") {
        await this.createNirAccountingEntry(updatedDoc);
      }
      return updatedDoc;
    } catch (error) {
      console.error(`[NirService] \u274C Error updating NIR status:`, error);
      throw new Error(`Failed to update NIR status: ${error}`);
    }
  }
  /**
   * Get all NIR documents for a company, optionally filtered by warehouse
   * @param companyId Company ID
   * @param warehouseId Optional warehouse ID to filter by
   * @returns Array of NIR documents
   */
  async getNirDocuments(companyId, warehouseId) {
    console.log(`[NirService] \u{1F50D} Fetching NIR documents for company: ${companyId}${warehouseId ? `, warehouse: ${warehouseId}` : ""}`);
    try {
      let sql57 = `SELECT * FROM nir_documents WHERE company_id = '${companyId}'`;
      if (warehouseId) {
        sql57 += ` AND warehouse_id = '${warehouseId}'`;
      }
      sql57 += ` ORDER BY created_at DESC`;
      console.log("[NirService] \u{1F50D} Executing SQL:", sql57);
      const result = await this.executeQuery(sql57);
      console.log("[NirService] \u2705 SQL executed successfully");
      const documents2 = result || [];
      console.log(`[NirService] \u2705 Found ${documents2.length} NIR documents`);
      return documents2;
    } catch (error) {
      console.error(`[NirService] \u274C Error getting NIR documents:`, error);
      throw new Error(`Failed to get NIR documents: ${error}`);
    }
  }
  /**
   * Create accounting entry (nota contabila) for an approved NIR document
   * in a depozit type warehouse
   * 
   * According to Romanian accounting standards:
   * - Debit 371.x (Mărfuri) - value without VAT
   * - Debit 4426.x (TVA deductibilă) - VAT value
   * - Credit 401 (Furnizori) - total value with VAT
   * 
   * @param nirDoc NIR document
   */
  async createNirAccountingEntry(nirDoc) {
    try {
      console.log(`[NirService] \u{1F4D2} Creating accounting entry for NIR ${nirDoc.nir_number}`);
      const nirId = nirDoc.id;
      const nirNumber = nirDoc.nir_number || nirDoc.nirNumber;
      const companyId = nirDoc.company_id || nirDoc.companyId;
      const warehouseId = nirDoc.warehouse_id || nirDoc.warehouseId;
      const supplierId = nirDoc.supplier_id || nirDoc.supplierId;
      const valueNoVat = parseFloat(nirDoc.total_value_no_vat?.toString() || nirDoc.totalValueNoVat?.toString() || "0");
      const vatValue = parseFloat(nirDoc.total_vat?.toString() || nirDoc.totalVat?.toString() || "0");
      const totalValue = parseFloat(nirDoc.total_value_with_vat?.toString() || nirDoc.totalValueWithVat?.toString() || "0");
      const receiptDate = nirDoc.receipt_date || nirDoc.receiptDate || /* @__PURE__ */ new Date();
      const currency = nirDoc.currency || "RON";
      const exchangeRate = parseFloat(nirDoc.exchange_rate?.toString() || nirDoc.exchangeRate?.toString() || "1");
      await notaContabilaService.createNirDepozitNotaContabila(
        nirId,
        nirNumber,
        companyId,
        supplierId,
        warehouseId,
        valueNoVat,
        vatValue,
        totalValue,
        receiptDate instanceof Date ? receiptDate : new Date(receiptDate),
        currency,
        exchangeRate
      );
      console.log(`[NirService] \u2705 Accounting entry created successfully for NIR ${nirNumber}`);
    } catch (error) {
      console.error(`[NirService] \u274C Error creating accounting entry for NIR:`, error);
      throw new Error(`Failed to create accounting entry: ${error}`);
    }
  }
};
var nirService = new NirService();

// server/modules/inventory/controllers/nir.controller.ts
init_logger();
init_inventory_schema();
var INVENTORY_ROLES = ["inventory_manager" /* INVENTORY_MANAGER */, "admin" /* ADMIN */];
var NirController = class {
  constructor() {
    this.logger = new Logger("NirController");
  }
  /**
   * Create a new NIR document
   */
  async createNirDocument(req, res, next) {
    try {
      const { document, items } = req.body;
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      if (!document || !items || !Array.isArray(items) || items.length === 0) {
        res.status(400).json({
          success: false,
          message: "Invalid NIR document structure. Document and items array required."
        });
        return;
      }
      document.company_id = req.user.companyId;
      document.created_by = req.user.id;
      if (req.user.franchiseId) {
        document.franchise_id = req.user.franchiseId;
      }
      const nirDocument = await nirService.createNirDocument(document, items);
      this.logger.debug(`Created NIR document: ${nirDocument.id}`);
      res.status(201).json({
        success: true,
        message: "NIR document created successfully",
        document: nirDocument
      });
    } catch (error) {
      this.logger.error(`Error creating NIR document: ${error.message}`);
      if (error.message.includes("Validation")) {
        res.status(400).json({
          success: false,
          message: error.message
        });
        return;
      }
      next(error);
    }
  }
  /**
   * Get NIR document by ID
   */
  async getNirDocument(req, res, next) {
    try {
      const nirId = req.params.id;
      if (!nirId) {
        res.status(400).json({
          success: false,
          message: "NIR document ID is required"
        });
        return;
      }
      const result = await nirService.getNirDocument(nirId);
      if (!result) {
        res.status(404).json({
          success: false,
          message: "NIR document not found"
        });
        return;
      }
      if (req.user && !req.user.roles?.includes("admin" /* ADMIN */) && result.document.company_id !== req.user.companyId) {
        res.status(403).json({
          success: false,
          message: "Access denied to the requested NIR document"
        });
        return;
      }
      res.json({
        success: true,
        document: result.document,
        items: result.items
      });
    } catch (error) {
      this.logger.error(`Error retrieving NIR document: ${error.message}`);
      next(error);
    }
  }
  /**
   * Update NIR document status
   */
  async updateNirStatus(req, res, next) {
    try {
      const nirId = req.params.id;
      const { status } = req.body;
      if (!nirId) {
        res.status(400).json({
          success: false,
          message: "NIR document ID is required"
        });
        return;
      }
      if (!status || !nirStatusEnum.enumValues.includes(status)) {
        res.status(400).json({
          success: false,
          message: `Invalid status. Valid values are: ${nirStatusEnum.enumValues.join(", ")}`
        });
        return;
      }
      const updatedDocument = await nirService.updateNirStatus(nirId, status);
      res.json({
        success: true,
        message: `NIR document status updated to ${status}`,
        document: updatedDocument
      });
    } catch (error) {
      this.logger.error(`Error updating NIR document status: ${error.message}`);
      next(error);
    }
  }
  /**
   * Get all NIR documents for a company
   */
  async getNirDocuments(req, res, next) {
    try {
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const warehouseId = req.query.warehouseId;
      const documents2 = await nirService.getNirDocuments(req.user.companyId, warehouseId);
      this.logger.debug(`Found ${documents2.length} NIR documents for company ${req.user.companyId}`);
      res.json({
        success: true,
        message: `Found ${documents2.length} NIR documents`,
        documents: documents2
      });
    } catch (error) {
      this.logger.error(`Error fetching NIR documents: ${error.message}`);
      next(error);
    }
  }
};
var nirController = new NirController();

// server/modules/inventory/services/check-stock-levels.service.ts
init_drizzle();
import { randomUUID as randomUUID18 } from "crypto";

// server/common/bullmq/queues.ts
import { Queue as Queue3 } from "bullmq";

// server/services/redis.service.ts
import Redis3 from "ioredis";
var RedisService = class {
  constructor() {
    this.client = null;
    this.client = null;
  }
  async connect() {
    try {
      if (!process.env.REDIS_HOST && !process.env.REDIS_PASSWORD) {
        console.warn("Redis credentials not provided, using in-memory fallback");
        this.client = null;
        return null;
      }
      this.client = new Redis3({
        host: process.env.REDIS_HOST || "localhost",
        port: parseInt(process.env.REDIS_PORT || "6379", 10),
        password: process.env.REDIS_PASSWORD,
        username: process.env.REDIS_USERNAME,
        // Always enable TLS for Redis Cloud connections
        tls: process.env.REDIS_HOST?.endsWith(".upstash.io") || process.env.REDIS_HOST?.endsWith(".redis.cache.windows.net") || process.env.REDIS_HOST?.includes("redis.cloud.redislabs.com") ? { rejectUnauthorized: false } : void 0,
        connectTimeout: 5e3,
        // 5 seconds timeout
        maxRetriesPerRequest: 3,
        // Allow a few retries
        retryStrategy: (times) => {
          if (times > 3) return null;
          return Math.min(times * 500, 3e3);
        }
      });
      this.client.on("error", (err) => {
        console.error("Redis connection error:", err);
      });
      try {
        await Promise.race([
          this.client.ping(),
          new Promise(
            (_, reject) => setTimeout(() => reject(new Error("Redis ping timeout")), 3e3)
          )
        ]);
        console.log("Connected to Redis Cloud successfully");
        return this.client;
      } catch (pingError) {
        console.error("Redis ping failed:", pingError);
        await this.client.quit().catch(() => {
        });
        this.client = null;
        console.warn("Using in-memory fallback instead of Redis");
        return null;
      }
    } catch (error) {
      console.error("Failed to connect to Redis:", error);
      this.client = null;
      console.warn("Using in-memory fallback instead of Redis");
      return null;
    }
  }
  async disconnect() {
    if (this.client) {
      await this.client.quit();
      this.client = null;
      console.log("Disconnected from Redis");
    }
  }
  getClient() {
    if (!this.client) {
      throw new Error("Redis client not connected");
    }
    if (!this.client.__policyChecked) {
      this.client.config("GET", "maxmemory-policy").then((policyResponse) => {
        const policy = policyResponse;
        if (policy && policy.length > 1 && policy[1] !== "noeviction") {
          console.warn(`WARNING: Redis eviction policy is set to ${policy[1]} instead of 'noeviction'.`);
          console.warn("This may cause issues with BullMQ. Consider using a Redis instance with noeviction policy.");
          console.warn("Implementing application-level workaround to minimize impacts.");
          if (this.client) {
            this.client.on("error", (err) => {
              if (err.message && err.message.includes("OOM")) {
                console.error("Redis OOM error detected. This is likely due to eviction policy not being set to noeviction.");
              }
            });
          }
        }
        if (this.client) {
          this.client.__policyChecked = true;
        }
      }).catch((err) => {
        console.warn("Could not check Redis maxmemory-policy:", err.message);
      });
    }
    return this.client;
  }
  // Cache methods
  async get(key) {
    try {
      if (!this.client) return null;
      return await this.client.get(key);
    } catch (error) {
      console.error("Redis get error:", error);
      return null;
    }
  }
  async set(key, value, expiryInSeconds) {
    try {
      if (!this.client) return false;
      if (expiryInSeconds) {
        await this.client.set(key, value, "EX", expiryInSeconds);
      } else {
        await this.client.set(key, value);
      }
      return true;
    } catch (error) {
      console.error("Redis set error:", error);
      return false;
    }
  }
  async del(key) {
    try {
      if (!this.client) return false;
      await this.client.del(key);
      return true;
    } catch (error) {
      console.error("Redis del error:", error);
      return false;
    }
  }
  async incr(key) {
    try {
      if (!this.client) return 0;
      return await this.client.incr(key);
    } catch (error) {
      console.error("Redis incr error:", error);
      return 0;
    }
  }
  // Hash methods
  async hget(key, field) {
    try {
      if (!this.client) return null;
      return await this.client.hget(key, field);
    } catch (error) {
      console.error("Redis hget error:", error);
      return null;
    }
  }
  async hset(key, field, value) {
    try {
      if (!this.client) return false;
      await this.client.hset(key, field, value);
      return true;
    } catch (error) {
      console.error("Redis hset error:", error);
      return false;
    }
  }
  async hdel(key, field) {
    try {
      if (!this.client) return false;
      await this.client.hdel(key, field);
      return true;
    } catch (error) {
      console.error("Redis hdel error:", error);
      return false;
    }
  }
  async hgetall(key) {
    try {
      if (!this.client) return null;
      return await this.client.hgetall(key);
    } catch (error) {
      console.error("Redis hgetall error:", error);
      return null;
    }
  }
};

// server/common/bullmq/queues.ts
var redisConnection;
try {
  const redisService = new RedisService();
  redisService.connect().then((client) => {
    if (client) {
      redisConnection = client;
      log("Redis connection established for BullMQ queues", "bullmq");
    } else {
      log("Redis connection not available, using fallback options", "bullmq");
    }
  });
} catch (error) {
  log(`\u26A0\uFE0F Failed to establish Redis connection for BullMQ: ${error.message}`, "bullmq-error");
  console.error("Redis connection error:", error);
}
var defaultConnectionOptions = {
  connection: redisConnection || {
    host: process.env.REDIS_HOST || "localhost",
    port: parseInt(process.env.REDIS_PORT || "6379"),
    password: process.env.REDIS_PASSWORD || void 0,
    db: 0
    // default Redis database
  }
};
var defaultQueueOptions = {
  connection: defaultConnectionOptions.connection,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 1e3
    },
    removeOnComplete: {
      age: 24 * 3600,
      // Keep completed jobs for 24 hours (in seconds)
      count: 1e3
      // Keep last 1000 completed jobs
    },
    removeOnFail: {
      age: 7 * 24 * 3600
      // Keep failed jobs for 7 days (in seconds)
    }
  }
};
function createQueue(name, options = {}) {
  const queue = new Queue3(name, {
    ...defaultQueueOptions,
    ...options
  });
  queue.on("error", (error) => {
    log(`[Queue:${name}] \u274C Error: ${error.message}`, "queue-error");
    console.error(`Queue ${name} error:`, error);
  });
  log(`[Queue:${name}] \u2705 Initialized successfully`, "queue");
  return queue;
}
var inventoryQueue = createQueue("inventory-queue" /* Inventory */);
var stockQueue = inventoryQueue;
var accountingQueue = createQueue("accounting-queue" /* Accounting */);
var balanceQueue = accountingQueue;
var reportingQueue = createQueue("reporting-queue" /* Reporting */);
var reportQueue = reportingQueue;
var documentQueue = createQueue("document-queue" /* Document */);
var Queues = {
  ["inventory-queue" /* Inventory */]: inventoryQueue,
  ["accounting-queue" /* Accounting */]: accountingQueue,
  ["reporting-queue" /* Reporting */]: reportingQueue,
  ["document-queue" /* Document */]: documentQueue,
  // Aliases for backward compatibility
  "stock-updates": stockQueue,
  "balance-updates": balanceQueue,
  "report-generation": reportQueue
};

// server/common/bullmq/workers.ts
import { Worker as Worker3 } from "bullmq";
init_registry();
var defaultWorkerOptions = {
  connection: defaultConnectionOptions.connection,
  autorun: true,
  concurrency: 5,
  lockDuration: 3e4,
  maxStalledCount: 3
};

// server/modules/inventory/services/check-stock-levels.service.ts
init_registry();
init_notification_service();
var CheckStockLevelsService = class {
  /**
   * Create a new CheckStockLevelsService instance
   * 
   * @param stockQueue BullMQ queue for processing low stock alerts
   */
  constructor(stockQueue2) {
    this.stockQueue = stockQueue2;
    // Track notification settings in memory with company ID as key
    this.notificationSettingsCache = /* @__PURE__ */ new Map();
    // Default notification settings
    this.DEFAULT_NOTIFICATION_SETTINGS = {
      enabled: true,
      recipientEmails: [],
      notifyOnPercentage: 20,
      channels: ["email", "in-app"]
    };
    this.drizzle = new DrizzleService();
  }
  /**
   * Check stock levels for a company across all warehouses
   * 
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID filter
   * @param warehouseId Optional warehouse ID filter
   * @returns Results of the stock check with alerts
   */
  async checkLevels(companyId, franchiseId, warehouseId) {
    log(`[CheckStockLevelsService] \u{1F50D} Checking stock levels for company: ${companyId}`, "inventory-stock-check");
    try {
      let sql57 = `
        SELECT 
          s.id AS stock_id,
          s.product_id,
          s.warehouse_id,
          s.quantity,
          p.sku AS product_code,
          p.name AS product_name,
          p.stock_alert AS min_threshold,
          w.name AS warehouse_name,
          s.company_id,
          s.franchise_id
        FROM 
          stocks s
        JOIN 
          inventory_products p ON s.product_id = p.id
        JOIN
          warehouses w ON s.warehouse_id = w.id
        WHERE 
          s.company_id = '${companyId}'
          AND p.stock_alert > 0
          AND s.quantity <= p.stock_alert
      `;
      if (franchiseId) {
        sql57 += ` AND s.franchise_id = '${franchiseId}'`;
      }
      if (warehouseId) {
        sql57 += ` AND s.warehouse_id = '${warehouseId}'`;
      }
      sql57 += ` AND w.is_active = true`;
      log(`[CheckStockLevelsService] Running low stock query: ${sql57}`, "inventory-stock-check");
      const lowStockResult = await this.drizzle.executeQuery(sql57);
      const totalCountResult = await this.drizzle.executeQuery(
        `SELECT COUNT(DISTINCT s.product_id) AS total 
         FROM stocks s 
         WHERE s.company_id = '${companyId}'`
      );
      const lowStockRows = Array.isArray(lowStockResult) ? lowStockResult : lowStockResult?.rows || [];
      const totalCountRow = Array.isArray(totalCountResult) ? totalCountResult[0] : totalCountResult?.rows?.[0];
      const totalProducts = totalCountRow?.total || 0;
      const alerts = [];
      for (const item of lowStockRows) {
        const alert = {
          productId: item.product_id,
          productName: item.product_name,
          productCode: item.product_code,
          warehouseId: item.warehouse_id,
          warehouseName: item.warehouse_name,
          currentQuantity: parseFloat(item.quantity),
          minThreshold: parseFloat(item.min_threshold),
          companyId: item.company_id,
          franchiseId: item.franchise_id
        };
        alerts.push(alert);
        const percentageBelowThreshold = (alert.minThreshold - alert.currentQuantity) / alert.minThreshold * 100;
        let priority = "medium" /* MEDIUM */;
        let severity = "medium";
        if (percentageBelowThreshold >= 50) {
          priority = "critical" /* CRITICAL */;
          severity = "critical";
        } else if (percentageBelowThreshold >= 25) {
          priority = "high" /* HIGH */;
          severity = "high";
        } else if (percentageBelowThreshold < 10) {
          priority = "low" /* LOW */;
          severity = "low";
        }
        try {
          await inventoryQueue.add("alert", {
            id: randomUUID18(),
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            sku: alert.productCode,
            warehouseId: alert.warehouseId,
            productId: alert.productId,
            productName: alert.productName,
            currentQuantity: alert.currentQuantity,
            minThreshold: alert.minThreshold,
            companyId: alert.companyId,
            severity
            // Cast to match the enum values in InventoryAlertJob
          }, {
            // Set job options for better reliability
            attempts: 3,
            backoff: {
              type: "exponential",
              delay: 1e3
            },
            // Add to the job ID to ensure uniqueness
            jobId: `inventory-alert-${alert.productId}-${alert.warehouseId}-${(/* @__PURE__ */ new Date()).getTime()}`
          });
          log(`[CheckStockLevelsService] \u2705 Queued inventory alert job for ${item.product_name} with severity ${severity}`, "inventory-stock-check");
        } catch (error) {
          log(`[CheckStockLevelsService] \u26A0\uFE0F Failed to enqueue alert job: ${error?.message || String(error)}`, "inventory-stock-check-error");
          try {
            await Services.notification.notifyCompany(alert.companyId, {
              title: `Low Stock Alert: ${alert.productName}`,
              message: `Product ${alert.productName} (${alert.productCode}) in warehouse ${alert.warehouseName} is below minimum threshold. Current quantity: ${alert.currentQuantity}, Minimum threshold: ${alert.minThreshold}`,
              type: "warning" /* WARNING */,
              priority,
              metadata: {
                productId: alert.productId,
                warehouseId: alert.warehouseId,
                currentQuantity: alert.currentQuantity,
                minThreshold: alert.minThreshold,
                percentageBelowThreshold: Math.round(percentageBelowThreshold)
              },
              actionUrl: `/inventory/products/${alert.productId}`
            });
            log(`[CheckStockLevelsService] \u2705 Sent direct notification for ${item.product_name} (fallback)`, "inventory-stock-check");
          } catch (notifyError) {
            log(`[CheckStockLevelsService] \u26A0\uFE0F Failed to send fallback notification: ${notifyError?.message || String(notifyError)}`, "inventory-stock-check-error");
          }
        }
        if (this.stockQueue) {
          await this.stockQueue.add("low-stock-alert", {
            id: randomUUID18(),
            alert,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }, {
            // Set job options for better reliability
            attempts: 3,
            backoff: {
              type: "exponential",
              delay: 1e3
            },
            // Add to the job ID to ensure uniqueness
            jobId: `low-stock-${alert.productId}-${alert.warehouseId}-${(/* @__PURE__ */ new Date()).getTime()}`
          });
          log(`[CheckStockLevelsService] \u2705 Queued alert for ${item.product_name} in ${item.warehouse_name}`, "inventory-stock-check");
        } else {
          log(`[CheckStockLevelsService] \u26A0\uFE0F No queue available, alert for ${item.product_name} was not queued`, "inventory-stock-check");
        }
      }
      const result = {
        alerts,
        totalProducts: parseInt(totalProducts.toString()),
        belowThreshold: alerts.length,
        timestamp: /* @__PURE__ */ new Date()
      };
      log(`[CheckStockLevelsService] \u2705 Found ${alerts.length} products below threshold out of ${totalProducts} total`, "inventory-stock-check");
      return result;
    } catch (error) {
      log(`[CheckStockLevelsService] \u274C Error checking stock levels: ${error.message}`, "inventory-stock-check-error");
      throw new Error(`Failed to check stock levels: ${error.message || String(error)}`);
    }
  }
  /**
   * Create a scheduled job that checks stock levels periodically
   * 
   * @param companyId Company ID
   * @param schedulePattern Cron pattern (default: once per day at midnight)
   * @returns Job ID for the scheduled task
   */
  async scheduleRegularChecks(companyId, schedulePattern = "0 0 * * *") {
    if (!this.stockQueue) {
      log(`[CheckStockLevelsService] \u26A0\uFE0F Cannot schedule checks without a queue`, "inventory-stock-check");
      return null;
    }
    try {
      const jobId = `stock-check-${companyId}`;
      try {
        await this.stockQueue.removeRepeatable("scheduled-stock-check", { jobId, pattern: schedulePattern });
      } catch (error) {
        log(`[CheckStockLevelsService] No existing job found to remove, continuing...`, "inventory-stock-check");
      }
      await this.stockQueue.add(
        "scheduled-stock-check",
        {
          id: randomUUID18(),
          companyId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          jobId,
          attempts: 3,
          backoff: {
            type: "exponential",
            delay: 1e3
          },
          repeat: {
            pattern: schedulePattern
          }
        }
      );
      log(`[CheckStockLevelsService] \u2705 Scheduled regular stock checks for company ${companyId} with pattern: ${schedulePattern}`, "inventory-stock-check");
      return jobId;
    } catch (error) {
      log(`[CheckStockLevelsService] \u274C Error scheduling stock checks: ${error.message}`, "inventory-stock-check-error");
      throw new Error(`Failed to schedule stock checks: ${error.message || String(error)}`);
    }
  }
  /**
   * Get the list of products that are close to their minimum threshold
   * (between 100% and 120% of the threshold) and optionally send notifications
   * 
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID filter
   * @param sendNotifications Whether to send notifications (default: false)
   * @returns List of products approaching their minimum threshold
   */
  async getApproachingThreshold(companyId, franchiseId, sendNotifications = false) {
    try {
      let sql57 = `
        SELECT 
          s.id AS stock_id,
          s.product_id,
          s.warehouse_id,
          s.quantity,
          p.sku AS product_code,
          p.name AS product_name,
          p.stock_alert AS min_threshold,
          w.name AS warehouse_name,
          s.company_id,
          s.franchise_id,
          ROUND((s.quantity / p.stock_alert) * 100, 2) AS threshold_percentage
        FROM 
          stocks s
        JOIN 
          inventory_products p ON s.product_id = p.id
        JOIN
          warehouses w ON s.warehouse_id = w.id
        WHERE 
          s.company_id = '${companyId}'
          AND p.stock_alert > 0
          AND s.quantity > p.stock_alert
          AND s.quantity <= (p.stock_alert * 3.0)
      `;
      if (franchiseId) {
        sql57 += ` AND s.franchise_id = '${franchiseId}'`;
      }
      sql57 += ` AND w.is_active = true`;
      sql57 += ` ORDER BY threshold_percentage ASC`;
      log(`[CheckStockLevelsService] Running approaching threshold query: ${sql57}`, "inventory-stock-check");
      const result = await this.drizzle.executeQuery(sql57);
      const approachingRows = Array.isArray(result) ? result : result?.rows || [];
      log(`[CheckStockLevelsService] \u2705 Found ${approachingRows.length} products approaching threshold`, "inventory-stock-check");
      if (sendNotifications && approachingRows.length > 0) {
        for (const item of approachingRows) {
          try {
            const thresholdPercentage = parseFloat(item.threshold_percentage);
            let priority = "low" /* LOW */;
            if (thresholdPercentage < 105) {
              priority = "medium" /* MEDIUM */;
            }
            await Services.notification.notifyCompany(item.company_id, {
              title: `Stock Level Warning: ${item.product_name}`,
              message: `Product ${item.product_name} (${item.product_code}) in warehouse ${item.warehouse_name} is approaching minimum threshold. Current quantity: ${item.quantity}, Minimum threshold: ${item.min_threshold}`,
              type: "info" /* INFO */,
              priority,
              metadata: {
                productId: item.product_id,
                warehouseId: item.warehouse_id,
                currentQuantity: parseFloat(item.quantity),
                minThreshold: parseFloat(item.min_threshold),
                thresholdPercentage
              },
              actionUrl: `/inventory/products/${item.product_id}`
            });
            log(`[CheckStockLevelsService] \u2705 Sent approaching threshold notification for ${item.product_name}`, "inventory-stock-check");
          } catch (error) {
            log(`[CheckStockLevelsService] \u26A0\uFE0F Failed to send approaching threshold notification: ${error?.message || String(error)}`, "inventory-stock-check-error");
          }
        }
      }
      return approachingRows;
    } catch (error) {
      log(`[CheckStockLevelsService] \u274C Error getting approaching threshold products: ${error.message}`, "inventory-stock-check-error");
      throw new Error(`Failed to get approaching threshold products: ${error.message || String(error)}`);
    }
  }
  /**
   * Get low stock products based on threshold percentage
   * 
   * @param companyId Company ID to check
   * @param warehouseId Optional warehouse filter 
   * @param thresholdPercentage Percentage threshold (products with percentage <= this value will be returned)
   * @returns List of products below the specified threshold percentage
   */
  async getLowStockProducts(companyId, warehouseId, thresholdPercentage = 20) {
    try {
      log(`[CheckStockLevelsService] Getting low stock products for company ${companyId} (threshold: ${thresholdPercentage}%)`, "inventory-stock-check");
      let sql57 = `
        SELECT 
          s.id AS stock_id,
          s.product_id,
          s.warehouse_id,
          s.quantity,
          p.sku AS product_code,
          p.name AS product_name,
          p.stock_alert AS min_threshold,
          w.name AS warehouse_name,
          s.company_id,
          s.franchise_id,
          ROUND((s.quantity / p.stock_alert) * 100, 2) AS threshold_percentage
        FROM 
          stocks s
        JOIN 
          inventory_products p ON s.product_id = p.id
        JOIN
          warehouses w ON s.warehouse_id = w.id
        WHERE 
          s.company_id = '${companyId}'
          AND p.stock_alert > 0
          AND ((s.quantity / p.stock_alert) * 100) <= ${thresholdPercentage}
      `;
      if (warehouseId) {
        sql57 += ` AND s.warehouse_id = '${warehouseId}'`;
      }
      sql57 += ` AND w.is_active = true`;
      sql57 += ` ORDER BY threshold_percentage ASC`;
      const result = await this.drizzle.executeQuery(sql57);
      const lowStockProducts = Array.isArray(result) ? result : result?.rows || [];
      log(`[CheckStockLevelsService] \u2705 Found ${lowStockProducts.length} products below ${thresholdPercentage}% threshold`, "inventory-stock-check");
      return lowStockProducts;
    } catch (error) {
      log(`[CheckStockLevelsService] \u274C Error getting low stock products: ${error.message}`, "inventory-stock-check-error");
      throw new Error(`Failed to get low stock products: ${error.message || String(error)}`);
    }
  }
  /**
   * Get notification settings for a company
   * 
   * @param companyId Company ID
   * @returns The company's notification settings or default settings if none found
   */
  async getNotificationSettings(companyId) {
    try {
      log(`[CheckStockLevelsService] Getting notification settings for company ${companyId}`, "inventory-settings");
      if (this.notificationSettingsCache.has(companyId)) {
        return this.notificationSettingsCache.get(companyId);
      }
      const settingsQuery = `
        SELECT metadata
        FROM company_settings
        WHERE company_id = '${companyId}'
        AND key = 'inventory_stock_notifications'
        LIMIT 1
      `;
      try {
        const result = await this.drizzle.executeQuery(settingsQuery);
        const rows = Array.isArray(result) ? result : result?.rows || [];
        if (rows.length > 0 && rows[0].metadata) {
          const settings = typeof rows[0].metadata === "string" ? JSON.parse(rows[0].metadata) : rows[0].metadata;
          const validatedSettings = {
            enabled: settings.enabled !== void 0 ? Boolean(settings.enabled) : this.DEFAULT_NOTIFICATION_SETTINGS.enabled,
            recipientEmails: Array.isArray(settings.recipientEmails) ? settings.recipientEmails : this.DEFAULT_NOTIFICATION_SETTINGS.recipientEmails,
            notifyOnPercentage: typeof settings.notifyOnPercentage === "number" ? settings.notifyOnPercentage : this.DEFAULT_NOTIFICATION_SETTINGS.notifyOnPercentage,
            channels: Array.isArray(settings.channels) ? settings.channels : this.DEFAULT_NOTIFICATION_SETTINGS.channels
          };
          this.notificationSettingsCache.set(companyId, validatedSettings);
          log(`[CheckStockLevelsService] \u2705 Loaded notification settings for company ${companyId}`, "inventory-settings");
          return validatedSettings;
        }
      } catch (error) {
        log(`[CheckStockLevelsService] \u26A0\uFE0F Error querying notification settings: ${error.message}`, "inventory-settings-error");
      }
      this.notificationSettingsCache.set(companyId, { ...this.DEFAULT_NOTIFICATION_SETTINGS });
      log(`[CheckStockLevelsService] \u2139\uFE0F Using default notification settings for company ${companyId}`, "inventory-settings");
      return { ...this.DEFAULT_NOTIFICATION_SETTINGS };
    } catch (error) {
      log(`[CheckStockLevelsService] \u274C Error getting notification settings: ${error.message}`, "inventory-settings-error");
      return { ...this.DEFAULT_NOTIFICATION_SETTINGS };
    }
  }
  /**
   * Update notification settings for a company
   * 
   * @param companyId Company ID
   * @param settings New notification settings
   * @returns Updated notification settings
   */
  async updateNotificationSettings(companyId, settings) {
    try {
      log(`[CheckStockLevelsService] Updating notification settings for company ${companyId}`, "inventory-settings");
      const currentSettings = await this.getNotificationSettings(companyId);
      const updatedSettings = {
        enabled: settings.enabled !== void 0 ? Boolean(settings.enabled) : currentSettings.enabled,
        recipientEmails: settings.recipientEmails || currentSettings.recipientEmails,
        notifyOnPercentage: settings.notifyOnPercentage !== void 0 ? settings.notifyOnPercentage : currentSettings.notifyOnPercentage,
        channels: settings.channels || currentSettings.channels
      };
      if (updatedSettings.recipientEmails && updatedSettings.recipientEmails.length > 0) {
        updatedSettings.recipientEmails = updatedSettings.recipientEmails.filter((email) => typeof email === "string" && email.includes("@") && email.includes("."));
      }
      const upsertQuery = `
        INSERT INTO company_settings (company_id, key, metadata, created_at, updated_at)
        VALUES ('${companyId}', 'inventory_stock_notifications', '${JSON.stringify(updatedSettings)}', NOW(), NOW())
        ON CONFLICT (company_id, key) 
        DO UPDATE SET 
          metadata = '${JSON.stringify(updatedSettings)}',
          updated_at = NOW()
        RETURNING *
      `;
      try {
        await this.drizzle.executeQuery(upsertQuery);
        log(`[CheckStockLevelsService] \u2705 Saved notification settings for company ${companyId}`, "inventory-settings");
      } catch (error) {
        log(`[CheckStockLevelsService] \u26A0\uFE0F Error saving notification settings: ${error.message}`, "inventory-settings-error");
      }
      this.notificationSettingsCache.set(companyId, updatedSettings);
      return updatedSettings;
    } catch (error) {
      log(`[CheckStockLevelsService] \u274C Error updating notification settings: ${error.message}`, "inventory-settings-error");
      throw new Error(`Failed to update notification settings: ${error.message || String(error)}`);
    }
  }
};
var checkStockLevelsService = new CheckStockLevelsService();

// server/modules/inventory/controllers/stock-levels.controller.ts
init_logger();
var INVENTORY_ROLES2 = ["inventory_manager" /* INVENTORY_MANAGER */, "admin" /* ADMIN */];
var StockLevelsController = class {
  constructor() {
    this.logger = new Logger("StockLevelsController");
  }
  /**
   * Check stock levels for a company and send notifications for low stock
   */
  async checkStockLevels(req, res, next) {
    try {
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const warehouseId = req.query.warehouseId;
      const franchiseId = req.user.franchiseId || void 0;
      this.logger.debug(`Checking stock levels for company ${req.user.companyId}${warehouseId ? `, warehouse ${warehouseId}` : ""}`);
      const result = await checkStockLevelsService.checkLevels(
        req.user.companyId,
        franchiseId,
        warehouseId
      );
      res.json({
        success: true,
        result
      });
    } catch (error) {
      this.logger.error(`Error checking stock levels: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to check stock levels",
        error: error.message
      });
    }
  }
  /**
   * Get products approaching their minimum threshold
   */
  async getLowStockProducts(req, res, next) {
    try {
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const warehouseId = req.query.warehouseId;
      const thresholdPercentage = req.query.threshold ? parseInt(req.query.threshold) : 20;
      const lowStockProducts = await checkStockLevelsService.getLowStockProducts(
        req.user.companyId,
        warehouseId,
        thresholdPercentage
      );
      res.json({
        success: true,
        products: lowStockProducts
      });
    } catch (error) {
      this.logger.error(`Error fetching low stock products: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to get low stock products",
        error: error.message
      });
    }
  }
  /**
   * Configure stock level thresholds for products
   */
  async setStockThreshold(req, res, next) {
    try {
      const { productId, warehouseId, minStockLevel, maxStockLevel } = req.body;
      if (!productId || !warehouseId) {
        res.status(400).json({
          success: false,
          message: "Product ID and warehouse ID are required"
        });
        return;
      }
      if (minStockLevel === void 0 && maxStockLevel === void 0) {
        res.status(400).json({
          success: false,
          message: "At least one threshold (minStockLevel or maxStockLevel) must be provided"
        });
        return;
      }
      res.json({
        success: true,
        message: "Stock threshold updated successfully",
        thresholds: {
          productId,
          warehouseId,
          minStockLevel,
          maxStockLevel
        }
      });
    } catch (error) {
      this.logger.error(`Error setting stock threshold: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to set stock threshold",
        error: error.message
      });
    }
  }
  /**
   * Get notification settings for stock levels
   */
  async getNotificationSettings(req, res, next) {
    try {
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const settings = await checkStockLevelsService.getNotificationSettings(req.user.companyId);
      res.json({
        success: true,
        settings
      });
    } catch (error) {
      this.logger.error(`Error fetching notification settings: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to get notification settings",
        error: error.message
      });
    }
  }
  /**
   * Update notification settings for stock levels
   */
  async updateNotificationSettings(req, res, next) {
    try {
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const { enabled, recipientEmails, notifyOnPercentage, channels } = req.body;
      const updatedSettings = await checkStockLevelsService.updateNotificationSettings(
        req.user.companyId,
        {
          enabled,
          recipientEmails,
          notifyOnPercentage,
          channels
        }
      );
      res.json({
        success: true,
        message: "Notification settings updated successfully",
        settings: updatedSettings
      });
    } catch (error) {
      this.logger.error(`Error updating notification settings: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to update notification settings",
        error: error.message
      });
    }
  }
};
var stockLevelsController = new StockLevelsController();

// server/modules/inventory/services/transfer-stock.service.ts
init_drizzle();
init_registry();
init_audit_service();
import { randomUUID as randomUUID19 } from "crypto";
var TransferStockService = class {
  constructor() {
    this.drizzle = new DrizzleService();
  }
  /**
   * Transfer stock from one warehouse to another
   * 
   * @param input Transfer data
   * @returns Created transfer record with source and destination stock
   */
  async transferStock(input) {
    console.log(`[TransferStockService] \u{1F504} Transferring stock: ${input.quantity} units from stock ${input.sourceStockId} to warehouse ${input.destinationWarehouseId}`);
    try {
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const transferId = randomUUID19();
      const documentNumber = input.documentNumber || `TRF-${Date.now()}`;
      const sourceStockSql = `
        SELECT s.*, p.name as product_name
        FROM stocks s
        JOIN inventory_products p ON s.product_id = p.id
        WHERE s.id = '${input.sourceStockId}'
      `;
      const sourceStockResult = await this.drizzle.executeQuery(sourceStockSql);
      if (sourceStockResult.length === 0) {
        throw new Error("Source stock not found");
      }
      const sourceStock = sourceStockResult[0];
      if (sourceStock.quantity < input.quantity) {
        throw new Error(`Insufficient stock. Available: ${sourceStock.quantity}, Requested: ${input.quantity}`);
      }
      const updateSourceSql = `
        UPDATE stocks
        SET quantity = quantity - ${input.quantity},
            updated_at = '${now}'
        WHERE id = '${input.sourceStockId}'
        RETURNING *
      `;
      const updatedSourceStock = await this.drizzle.executeQuery(updateSourceSql);
      const checkDestinationSql = `
        SELECT *
        FROM stocks
        WHERE product_id = '${sourceStock.product_id}'
        AND warehouse_id = '${input.destinationWarehouseId}'
      `;
      const destinationStockResult = await this.drizzle.executeQuery(checkDestinationSql);
      let destinationStock;
      if (destinationStockResult.length > 0) {
        const updateDestinationSql = `
          UPDATE stocks
          SET quantity = quantity + ${input.quantity},
              updated_at = '${now}'
          WHERE id = '${destinationStockResult[0].id}'
          RETURNING *
        `;
        const result = await this.drizzle.executeQuery(updateDestinationSql);
        destinationStock = result[0];
        console.log(`[TransferStockService] \u2713 Updated existing stock in destination warehouse with ${input.quantity} units`);
      } else {
        const insertDestinationSql = `
          INSERT INTO stocks (
            id, company_id, franchise_id, product_id, warehouse_id, 
            quantity, batch_no, expiry_date, purchase_price, selling_price, 
            created_at, updated_at
          ) VALUES (
            '${randomUUID19()}',
            '${input.companyId}',
            ${input.franchiseId ? `'${input.franchiseId}'` : "NULL"},
            '${sourceStock.product_id}',
            '${input.destinationWarehouseId}',
            ${input.quantity},
            ${sourceStock.batch_no ? `'${sourceStock.batch_no}'` : "NULL"},
            ${sourceStock.expiry_date ? `'${sourceStock.expiry_date}'` : "NULL"},
            ${sourceStock.purchase_price || 0},
            ${sourceStock.selling_price || 0},
            '${now}',
            '${now}'
          )
          RETURNING *
        `;
        const result = await this.drizzle.executeQuery(insertDestinationSql);
        destinationStock = result[0];
        console.log(`[TransferStockService] \u2713 Created new stock in destination warehouse with ${input.quantity} units`);
      }
      const createTransferDocumentSql = `
        INSERT INTO transfer_documents (
          id, company_id, franchise_id, transfer_number, 
          source_warehouse_id, destination_warehouse_id, 
          status, transfer_date, notes, total_value,
          created_at, updated_at
        ) VALUES (
          '${transferId}',
          '${input.companyId}',
          ${input.franchiseId ? `'${input.franchiseId}'` : "NULL"},
          '${documentNumber}',
          '${sourceStock.warehouse_id}',
          '${input.destinationWarehouseId}',
          'in_transit',
          '${now}',
          ${input.notes ? `'${input.notes}'` : "NULL"},
          ${(sourceStock.purchase_price || 0) * input.quantity},
          '${now}',
          '${now}'
        )
        RETURNING *
      `;
      const transferDocument = await this.drizzle.executeQuery(createTransferDocumentSql);
      const createTransferItemSql = `
        INSERT INTO transfer_items (
          id, transfer_id, product_id, quantity, 
          batch_no, expiry_date, unit_value, total_value, 
          created_at
        ) VALUES (
          '${randomUUID19()}',
          '${transferId}',
          '${sourceStock.product_id}',
          ${input.quantity},
          ${sourceStock.batch_no ? `'${sourceStock.batch_no}'` : "NULL"},
          ${sourceStock.expiry_date ? `'${sourceStock.expiry_date}'` : "NULL"},
          ${sourceStock.purchase_price || 0},
          ${(sourceStock.purchase_price || 0) * input.quantity},
          '${now}'
        )
        RETURNING *
      `;
      const transferItem = await this.drizzle.executeQuery(createTransferItemSql);
      console.log(`[TransferStockService] \u2713 Created transfer document: ${documentNumber}`);
      if (input.userId) {
        try {
          await logAction({
            companyId: input.companyId,
            userId: input.userId,
            action: "CREATE" /* CREATE */,
            entity: "stock_transfer",
            entityId: transferId,
            details: {
              sourceWarehouseId: sourceStock.warehouse_id,
              destinationWarehouseId: input.destinationWarehouseId,
              productId: sourceStock.product_id,
              productName: sourceStock.product_name,
              quantity: input.quantity,
              documentNumber,
              transferId
            }
          });
          console.log(`[TransferStockService] \u2713 Logged audit event for transfer creation: ${transferId}`);
        } catch (auditError) {
          console.error(`[TransferStockService] \u274C Error logging audit event:`, auditError);
        }
      }
      return {
        transfer: transferDocument[0],
        sourceStock: updatedSourceStock[0],
        destinationStock,
        product: {
          id: sourceStock.product_id,
          name: sourceStock.product_name
        }
      };
    } catch (error) {
      console.error(`[TransferStockService] \u274C Error transferring stock:`, error);
      throw new Error(`Failed to transfer stock: ${error?.message || String(error)}`);
    }
  }
  /**
   * Get transfer document by ID
   * 
   * @param id Transfer document ID
   * @returns Transfer document with items
   */
  async getTransferById(id) {
    console.log(`[TransferStockService] \u{1F50D} Getting transfer by ID: ${id}`);
    try {
      const transferSql = `
        SELECT td.*, 
          src.name as source_warehouse_name, 
          dst.name as destination_warehouse_name
        FROM transfer_documents td
        JOIN warehouses src ON td.source_warehouse_id = src.id
        JOIN warehouses dst ON td.destination_warehouse_id = dst.id
        WHERE td.id = '${id}'
      `;
      const transferResult = await this.drizzle.executeQuery(transferSql);
      if (transferResult.length === 0) {
        console.log(`[TransferStockService] \u26A0\uFE0F Transfer not found: ${id}`);
        return null;
      }
      const transfer = transferResult[0];
      const itemsSql = `
        SELECT ti.*, p.name as product_name, p.code as product_code
        FROM transfer_items ti
        JOIN inventory_products p ON ti.product_id = p.id
        WHERE ti.transfer_id = '${id}'
      `;
      const items = await this.drizzle.executeQuery(itemsSql);
      console.log(`[TransferStockService] \u2705 Found transfer with ${items.length} items`);
      return {
        ...transfer,
        items
      };
    } catch (error) {
      console.error(`[TransferStockService] \u274C Error fetching transfer:`, error);
      throw new Error(`Failed to fetch transfer: ${error?.message || String(error)}`);
    }
  }
  /**
   * Get transfers for a company
   * 
   * @param companyId Company ID
   * @param status Optional status filter
   * @returns List of transfers
   */
  async getTransfersByCompany(companyId, status) {
    console.log(`[TransferStockService] \u{1F50D} Getting transfers for company: ${companyId}`);
    try {
      let sql57 = `
        SELECT td.*, 
          src.name as source_warehouse_name, 
          dst.name as destination_warehouse_name
        FROM transfer_documents td
        JOIN warehouses src ON td.source_warehouse_id = src.id
        JOIN warehouses dst ON td.destination_warehouse_id = dst.id
        WHERE td.company_id = '${companyId}'
      `;
      if (status) {
        sql57 += ` AND td.status = '${status}'`;
      }
      sql57 += ` ORDER BY td.created_at DESC`;
      const transfers = await this.drizzle.executeQuery(sql57);
      console.log(`[TransferStockService] \u2705 Found ${transfers.length} transfers`);
      return transfers;
    } catch (error) {
      console.error(`[TransferStockService] \u274C Error fetching transfers:`, error);
      throw new Error(`Failed to fetch transfers: ${error?.message || String(error)}`);
    }
  }
  /**
   * Update transfer status
   * 
   * @param id Transfer ID
   * @param status New status
   * @param userId User ID for audit logging
   * @returns Updated transfer
   */
  async updateTransferStatus(id, status, userId) {
    console.log(`[TransferStockService] \u{1F4DD} Updating transfer ${id} status to: ${status}`);
    try {
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const updateSql = `
        UPDATE transfer_documents
        SET status = '${status}',
            updated_at = '${now}'
        WHERE id = '${id}'
        RETURNING *
      `;
      const result = await this.drizzle.executeQuery(updateSql);
      if (result.length === 0) {
        throw new Error("Transfer not found");
      }
      try {
        const companyIdQuery = `
          SELECT company_id FROM transfer_documents WHERE id = '${id}'
        `;
        const companyResult = await this.drizzle.executeQuery(companyIdQuery);
        if (companyResult.length > 0) {
          const companyId = companyResult[0].company_id;
          await logAction({
            companyId,
            userId,
            action: "UPDATE" /* UPDATE */,
            entity: "stock_transfer",
            entityId: id,
            details: {
              status,
              previousStatus: result[0].status !== status ? result[0].status : "unknown",
              updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
              transferId: id
            }
          });
          console.log(`[TransferStockService] \u2713 Logged audit event for transfer status update: ${id}`);
        }
      } catch (auditError) {
        console.error(`[TransferStockService] \u274C Error logging audit event:`, auditError);
      }
      return result[0];
    } catch (error) {
      console.error(`[TransferStockService] \u274C Error updating transfer status:`, error);
      throw new Error(`Failed to update transfer status: ${error?.message || String(error)}`);
    }
  }
};
var transferStockService = new TransferStockService();

// server/modules/inventory/controllers/transfer-stock.controller.ts
init_logger();
import { z as z39 } from "zod";
var INVENTORY_ROLES3 = ["inventory_manager" /* INVENTORY_MANAGER */, "admin" /* ADMIN */];
var transferStockSchema = z39.object({
  sourceStockId: z39.string().uuid("Invalid source stock ID"),
  destinationWarehouseId: z39.string().uuid("Invalid destination warehouse ID"),
  quantity: z39.number().positive("Quantity must be positive"),
  documentNumber: z39.string().optional(),
  notes: z39.string().optional()
});
var TransferStockController = class {
  constructor() {
    this.logger = new Logger("TransferStockController");
  }
  /**
   * Transfer stock between warehouses
   */
  async transferStock(req, res, next) {
    try {
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const validationResult = transferStockSchema.safeParse(req.body);
      if (!validationResult.success) {
        res.status(400).json({
          success: false,
          message: "Invalid transfer data",
          errors: validationResult.error.format()
        });
        return;
      }
      const transferInput = {
        companyId: req.user.companyId,
        franchiseId: req.user.franchiseId || void 0,
        sourceStockId: req.body.sourceStockId,
        destinationWarehouseId: req.body.destinationWarehouseId,
        quantity: req.body.quantity,
        documentNumber: req.body.documentNumber,
        notes: req.body.notes,
        userId: req.user.id
        // Add user ID for audit logging
      };
      const result = await transferStockService.transferStock(transferInput);
      res.status(201).json({
        success: true,
        transfer: result.transfer,
        sourceStock: result.sourceStock,
        destinationStock: result.destinationStock,
        product: result.product
      });
    } catch (error) {
      this.logger.error(`Error transferring stock: ${error.message}`);
      if (error.message.includes("insufficient") || error.message.includes("not found")) {
        res.status(400).json({
          success: false,
          message: error.message
        });
        return;
      }
      res.status(500).json({
        success: false,
        message: "Failed to transfer stock",
        error: error.message
      });
    }
  }
  /**
   * Get transfer document by ID
   */
  async getTransferById(req, res, next) {
    try {
      const transferId = req.params.id;
      if (!transferId) {
        res.status(400).json({
          success: false,
          message: "Transfer ID is required"
        });
        return;
      }
      const transfer = await transferStockService.getTransferById(transferId);
      if (!transfer) {
        res.status(404).json({
          success: false,
          message: "Transfer not found"
        });
        return;
      }
      if (req.user && !req.user.roles?.includes("admin" /* ADMIN */) && transfer.company_id !== req.user.companyId) {
        res.status(403).json({
          success: false,
          message: "Access denied to the requested transfer"
        });
        return;
      }
      res.json({
        success: true,
        transfer
      });
    } catch (error) {
      this.logger.error(`Error fetching transfer: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to fetch transfer",
        error: error.message
      });
    }
  }
  /**
   * Get all transfers for a company
   */
  async getTransfersByCompany(req, res, next) {
    try {
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const status = req.query.status;
      const transfers = await transferStockService.getTransfersByCompany(
        req.user.companyId,
        status
      );
      res.json({
        success: true,
        transfers
      });
    } catch (error) {
      this.logger.error(`Error fetching transfers: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to fetch transfers",
        error: error.message
      });
    }
  }
  /**
   * Update transfer status
   */
  async updateTransferStatus(req, res, next) {
    try {
      const transferId = req.params.id;
      const { status } = req.body;
      if (!status || !["in_transit", "issued", "received", "canceled"].includes(status)) {
        res.status(400).json({
          success: false,
          message: "Invalid status value"
        });
        return;
      }
      const userId = req.user?.id;
      if (!userId) {
        res.status(400).json({
          success: false,
          message: "User ID is required"
        });
        return;
      }
      const transfer = await transferStockService.updateTransferStatus(
        transferId,
        status,
        userId
      );
      res.json({
        success: true,
        transfer
      });
    } catch (error) {
      this.logger.error(`Error updating transfer status: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to update transfer status",
        error: error.message
      });
    }
  }
};
var transferStockController = new TransferStockController();

// server/modules/inventory/controllers/categories.controller.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router59 } from "express";
import { z as z41 } from "zod";

// server/modules/inventory/categories.service.instance.ts
init_drizzle_service();
init_audit_service();

// server/modules/inventory/services/categories.service.ts
init_schema4();
import { desc as desc38, eq as eq82, isNull as isNull15, sql as sql54 } from "drizzle-orm";

// server/modules/inventory/inventory.module.ts
import { Router as Router58 } from "express";

// server/modules/inventory/services/inventory.service.ts
init_drizzle();

// server/modules/inventory/services/manage-warehouse.service.ts
init_drizzle();
import { randomUUID as randomUUID20 } from "crypto";
init_storage();
var ManageWarehouseService = class {
  constructor() {
    this.drizzle = new DrizzleService();
    this.storage = storage;
    this.accountingService = new AccountingService(this.storage);
    console.log("[ManageWarehouseService] \u{1F527} Service initialized with storage and accounting service");
    console.log("[ManageWarehouseService] \u{1F50D} Storage methods available:");
    console.log("[ManageWarehouseService] - createAnalyticAccount:", typeof this.storage.createAnalyticAccount);
  }
  /**
   * Generate the next available prefix.x analytic account code for all account types
   * This gets the highest existing x suffix across all account types that need to be assigned
   * to the warehouse to ensure consistency
   */
  async getNextAnalyticSuffix() {
    try {
      const accountPrefixes = ["371", "378", "4426", "4427", "4428", "5311", "607", "707", "8033", "8039"];
      const prefixPatterns = accountPrefixes.map((prefix) => `${prefix}.%`);
      const analyticAccountsSql = `
        SELECT code FROM analytic_accounts 
        WHERE code LIKE ANY(ARRAY['${prefixPatterns.join("','")}'])
      `;
      const warehousesSql = `
        SELECT code FROM warehouses
        WHERE code LIKE '371.%' OR code LIKE '8033.%' OR code LIKE '8039.%'
      `;
      const analyticResults = await this.drizzle.executeQuery(analyticAccountsSql);
      const warehouseResults = await this.drizzle.executeQuery(warehousesSql);
      console.log(`[ManageWarehouseService] \u{1F50D} Found ${analyticResults.length} analytic accounts and ${warehouseResults.length} warehouses with codes`);
      const allCodes = [
        ...analyticResults.map((row) => row.code),
        ...warehouseResults.map((row) => row.code)
      ];
      if (allCodes.length === 0) {
        console.log(`[ManageWarehouseService] \u{1F50D} No existing codes found, using suffix 1`);
        return 1;
      }
      const allSuffixes = allCodes.map((code) => {
        const parts = code.split(".");
        if (parts.length !== 2) return 0;
        return parseInt(parts[1]);
      }).filter((num) => !isNaN(num));
      const maxSuffix = Math.max(...allSuffixes);
      console.log(`[ManageWarehouseService] \u{1F50D} Highest suffix found: ${maxSuffix}, using ${maxSuffix + 1} as next suffix`);
      return maxSuffix + 1;
    } catch (error) {
      console.error(`[ManageWarehouseService] \u274C Error generating next analytic suffix:`, error);
      return Math.floor(Date.now() / 1e3) % 1e4;
    }
  }
  /**
   * Get synthetic account ID by code
   */
  async getSyntheticAccountId(code) {
    const syntheticResult = await this.drizzle.executeQuery(
      `SELECT id FROM synthetic_accounts WHERE code = '${code}' LIMIT 1`
    );
    if (syntheticResult.length === 0) {
      throw new Error(`Synthetic account ${code} not found`);
    }
    return syntheticResult[0].id;
  }
  /**
   * Create an analytic account
   */
  async createAnalyticAccount(syntheticId, code, name, description, accountFunction) {
    try {
      console.log(`[ManageWarehouseService] \u{1F4CA} Creating analytic account ${code}: ${name}`);
      const sanitizedCode = code.replace(/'/g, "''");
      const sanitizedName = name.replace(/'/g, "''");
      const sanitizedDescription = description ? description.replace(/'/g, "''") : "";
      try {
        const analyticAccountSQL = `
          INSERT INTO analytic_accounts (
            id, code, name, description, synthetic_id, account_function, is_active, created_at, updated_at
          ) VALUES (
            '${randomUUID20()}',
            '${sanitizedCode}',
            '${sanitizedName}',
            '${sanitizedDescription}',
            '${syntheticId}',
            '${accountFunction}',
            true,
            NOW(),
            NOW()
          ) RETURNING *
        `;
        const result = await this.drizzle.executeQuery(analyticAccountSQL);
        console.log(`[ManageWarehouseService] \u2705 Created analytic account with SQL: ${code} - ${name}`);
        return;
      } catch (sqlError) {
        console.error(`[ManageWarehouseService] \u26A0\uFE0F SQL insert failed, trying storage method: ${sqlError.message || String(sqlError)}`);
        const analyticAccount = {
          id: randomUUID20(),
          code,
          name,
          description,
          syntheticId,
          accountFunction,
          isActive: true
        };
        console.log(`[ManageWarehouseService] \u{1F504} Analytic account object:`, JSON.stringify(analyticAccount, null, 2));
        await this.storage.createAnalyticAccount(analyticAccount);
        console.log(`[ManageWarehouseService] \u2705 Created analytic account with storage: ${code} - ${name}`);
      }
    } catch (error) {
      console.error(`[ManageWarehouseService] \u274C Error creating specific analytic account ${code}:`, error);
      console.error(`[ManageWarehouseService] \u274C Detalii eroare cont analitic ${code}:`, error.message || String(error));
      console.error(`[ManageWarehouseService] \u274C Stack trace:`, error.stack || "No stack trace available");
      throw new Error(`Failed to create analytic account: ${error.message || String(error)}`);
    }
  }
  /**
   * Create analytic accounts for a warehouse based on its type
   * Different types of warehouses need different sets of analytic accounts
   */
  async createWarehouseAnalyticAccounts(warehouseId, name, type, suffix) {
    try {
      console.log(`[ManageWarehouseService] \u{1F4CA} Creating analytic accounts for ${type} warehouse: ${name}`);
      switch (type) {
        case "depozit":
          await this.createDepozitAnalyticAccounts(name, suffix);
          break;
        case "magazin":
          await this.createMagazinAnalyticAccounts(name, suffix);
          break;
        case "custodie":
          await this.createCustodieAnalyticAccounts(name, suffix);
          break;
        case "transfer":
          await this.createTransferAnalyticAccounts(name, suffix);
          break;
        default:
          throw new Error(`Unknown warehouse type: ${type}`);
      }
      console.log(`[ManageWarehouseService] \u2705 Created all analytic accounts for ${name}`);
    } catch (error) {
      console.error(`[ManageWarehouseService] \u274C Error creating analytic accounts:`, error);
      console.error(`[ManageWarehouseService] \u274C Detalii eroare conturi analitice:`, error.message || String(error));
      console.error(`[ManageWarehouseService] \u274C Stack trace:`, error.stack || "No stack trace available");
      throw new Error(`Failed to create analytic accounts: ${error.message || String(error)}`);
    }
  }
  /**
   * Create analytic accounts for a Depozit type warehouse
   */
  async createDepozitAnalyticAccounts(name, suffix) {
    const accountsToCreate = [
      { code: "371", namePrefix: "M\u0103rfuri \xEEn", function: "A" },
      { code: "4426", namePrefix: "TVA deductibil\u0103 pentru", function: "A" },
      { code: "4427", namePrefix: "TVA colectat\u0103 pentru", function: "P" },
      { code: "5311", namePrefix: "Casa \xEEn lei pentru", function: "A" },
      { code: "607", namePrefix: "Cheltuieli privind m\u0103rfurile pentru", function: "E" },
      { code: "707", namePrefix: "Venituri din v\xE2nzarea m\u0103rfurilor pentru", function: "V" }
    ];
    for (const account of accountsToCreate) {
      const syntheticId = await this.getSyntheticAccountId(account.code);
      const analyticCode = `${account.code}.${suffix}`;
      const analyticName = `${account.namePrefix} gestiunea ${name}`;
      const description = `Cont analitic pentru gestiunea ${name}`;
      await this.createAnalyticAccount(
        syntheticId,
        analyticCode,
        analyticName,
        description,
        account.function
      );
    }
  }
  /**
   * Create analytic accounts for a Magazin type warehouse
   */
  async createMagazinAnalyticAccounts(name, suffix) {
    const accountsToCreate = [
      { code: "371", namePrefix: "M\u0103rfuri \xEEn", function: "A" },
      { code: "378", namePrefix: "Diferen\u021Be de pre\u021B la m\u0103rfuri pentru", function: "A" },
      { code: "4426", namePrefix: "TVA deductibil\u0103 pentru", function: "A" },
      { code: "4427", namePrefix: "TVA colectat\u0103 pentru", function: "P" },
      { code: "4428", namePrefix: "TVA neexigibil\u0103 pentru", function: "P" },
      { code: "607", namePrefix: "Cheltuieli privind m\u0103rfurile pentru", function: "E" },
      { code: "707", namePrefix: "Venituri din v\xE2nzarea m\u0103rfurilor pentru", function: "V" }
    ];
    for (const account of accountsToCreate) {
      const syntheticId = await this.getSyntheticAccountId(account.code);
      const analyticCode = `${account.code}.${suffix}`;
      const analyticName = `${account.namePrefix} gestiunea ${name}`;
      const description = `Cont analitic pentru gestiunea ${name}`;
      await this.createAnalyticAccount(
        syntheticId,
        analyticCode,
        analyticName,
        description,
        account.function
      );
    }
  }
  /**
   * Create analytic accounts for a Custodie type warehouse
   */
  async createCustodieAnalyticAccounts(name, suffix) {
    const syntheticId = await this.getSyntheticAccountId("8033");
    const analyticCode = `8033.${suffix}`;
    const analyticName = `Valori materiale \xEEn custodie pentru ${name}`;
    const description = `Cont analitic de custodie pentru gestiunea ${name}`;
    await this.createAnalyticAccount(
      syntheticId,
      analyticCode,
      analyticName,
      description,
      "X"
      // Off-balance sheet accounts use X
    );
  }
  /**
   * Create analytic accounts for a Transfer type warehouse
   */
  async createTransferAnalyticAccounts(name, suffix) {
    const syntheticId = await this.getSyntheticAccountId("8039");
    const analyticCode = `8039.${suffix}`;
    const analyticName = `Alte valori \xEEn afara bilan\u021Bului pentru ${name}`;
    const description = `Cont analitic pentru valori \xEEn transfer - gestiunea ${name}`;
    await this.createAnalyticAccount(
      syntheticId,
      analyticCode,
      analyticName,
      description,
      "X"
      // Off-balance sheet accounts use X
    );
  }
  /**
   * Create a new warehouse (gestiune)
   * 
   * @param input Warehouse data to create
   * @returns Created warehouse object
   */
  // Sanitize SQL strings to prevent SQL injection
  sanitizeSqlString(value) {
    if (!value) return "";
    return value.replace(/'/g, "''");
  }
  async create(input) {
    console.log(`[ManageWarehouseService] \u{1F3ED} Creating warehouse: ${input.name} (type: ${input.type})`);
    try {
      const id = randomUUID20();
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const suffix = await this.getNextAnalyticSuffix();
      console.log(`[ManageWarehouseService] \u{1F4CA} Using suffix ${suffix} for new warehouse analytic accounts`);
      let mainCode;
      switch (input.type) {
        case "depozit":
        case "magazin":
          mainCode = `371.${suffix}`;
          break;
        case "custodie":
          mainCode = `8033.${suffix}`;
          break;
        case "transfer":
          mainCode = `8039.${suffix}`;
          break;
        default:
          throw new Error(`Unknown warehouse type: ${input.type}`);
      }
      const sanitizedName = this.sanitizeSqlString(input.name);
      const sanitizedLocation = input.location ? this.sanitizeSqlString(input.location) : null;
      const sanitizedAddress = input.address ? this.sanitizeSqlString(input.address) : null;
      const sanitizedType = this.sanitizeSqlString(input.type);
      try {
        const sql57 = `
          INSERT INTO warehouses (
            id, company_id, franchise_id, name, code, location, address, type, is_active, created_at, updated_at
          ) VALUES (
            '${id}',
            '${input.company_id}',
            ${input.franchise_id ? `'${input.franchise_id}'` : "NULL"},
            '${sanitizedName}',
            '${mainCode}',
            ${sanitizedLocation ? `'${sanitizedLocation}'` : "NULL"},
            ${sanitizedAddress ? `'${sanitizedAddress}'` : "NULL"},
            '${sanitizedType}',
            ${input.is_active !== void 0 ? input.is_active : true},
            '${now}',
            '${now}'
          ) RETURNING *`;
        const result = await this.drizzle.executeQuery(sql57);
        if (!result || result.length === 0) {
          throw new Error("Failed to create warehouse record - no result returned");
        }
        const warehouse = result[0];
        console.log(`[ManageWarehouseService] \u2705 Created warehouse with ID: ${warehouse.id}`);
        try {
          await this.createWarehouseAnalyticAccounts(
            warehouse.id,
            warehouse.name,
            warehouse.type,
            suffix
          );
          console.log(`[ManageWarehouseService] \u2705 Successfully created all analytic accounts for warehouse: ${warehouse.name}`);
        } catch (analyticError) {
          console.error(`[ManageWarehouseService] \u26A0\uFE0F Warning: Warehouse created but analytic accounts failed:`, analyticError);
        }
        return warehouse;
      } catch (sqlError) {
        console.error(`[ManageWarehouseService] \u274C SQL error while creating warehouse:`, sqlError);
        throw sqlError;
      }
    } catch (error) {
      console.error(`[ManageWarehouseService] \u274C Error creating warehouse:`, error);
      console.error(`[ManageWarehouseService] \u274C Error message:`, error.message || String(error));
      console.error(`[ManageWarehouseService] \u274C Stack trace:`, error.stack || "No stack trace available");
      throw new Error(`Failed to create warehouse: ${error.message || String(error)}`);
    }
  }
  /**
   * Get a warehouse by ID
   * 
   * @param id Warehouse ID
   * @returns Warehouse or null if not found
   */
  async getById(id) {
    console.log(`[ManageWarehouseService] \u{1F50D} Getting warehouse by ID: ${id}`);
    try {
      const sql57 = `SELECT * FROM warehouses WHERE id = '${id}'`;
      const result = await this.drizzle.executeQuery(sql57);
      if (result.length === 0) {
        console.log(`[ManageWarehouseService] \u26A0\uFE0F Warehouse not found: ${id}`);
        return null;
      }
      console.log(`[ManageWarehouseService] \u2705 Found warehouse: ${result[0].name}`);
      return result[0];
    } catch (error) {
      console.error(`[ManageWarehouseService] \u274C Error fetching warehouse:`, error);
      throw new Error(`Failed to fetch warehouse: ${error}`);
    }
  }
  /**
   * Get all warehouses for a company
   * 
   * @param companyId Company ID
   * @param franchiseId Optional franchise ID
   * @returns List of warehouses
   */
  async getByCompany(companyId, franchiseId) {
    console.log(`[ManageWarehouseService] \u{1F50D} Getting warehouses for company: ${companyId}`);
    try {
      let sql57 = `
        SELECT * FROM warehouses 
        WHERE company_id = '${companyId}' 
      `;
      if (franchiseId) {
        sql57 += ` AND franchise_id = '${franchiseId}'`;
      }
      sql57 += ` ORDER BY name ASC`;
      const result = await this.drizzle.executeQuery(sql57);
      console.log(`[ManageWarehouseService] \u2705 Found ${result.length} warehouses`);
      return result;
    } catch (error) {
      console.error(`[ManageWarehouseService] \u274C Error fetching warehouses:`, error);
      throw new Error(`Failed to fetch warehouses: ${error}`);
    }
  }
  /**
   * Update a warehouse
   * 
   * @param id Warehouse ID
   * @param data Warehouse data to update
   * @returns Updated warehouse
   */
  async update(id, data) {
    console.log(`[ManageWarehouseService] \u{1F4DD} Updating warehouse: ${id}`);
    try {
      const existing = await this.getById(id);
      if (!existing) {
        throw new Error(`Warehouse with ID ${id} not found`);
      }
      const updates = [];
      const now = (/* @__PURE__ */ new Date()).toISOString();
      if (data.name !== void 0) {
        updates.push(`name = '${data.name}'`);
      }
      if (data.code !== void 0) {
        updates.push(`code = '${data.code}'`);
      }
      if (data.location !== void 0) {
        updates.push(`location = ${data.location ? `'${data.location}'` : "NULL"}`);
      }
      if (data.address !== void 0) {
        updates.push(`address = ${data.address ? `'${data.address}'` : "NULL"}`);
      }
      if (data.type !== void 0) {
        updates.push(`type = '${data.type}'`);
      }
      if (data.is_active !== void 0) {
        updates.push(`is_active = ${data.is_active}`);
      }
      updates.push(`updated_at = '${now}'`);
      if (updates.length === 1) {
        return existing;
      }
      const sql57 = `
        UPDATE warehouses
        SET ${updates.join(", ")}
        WHERE id = '${id}'
        RETURNING *`;
      const result = await this.drizzle.executeQuery(sql57);
      console.log(`[ManageWarehouseService] \u2705 Updated warehouse: ${id}`);
      return result[0];
    } catch (error) {
      console.error(`[ManageWarehouseService] \u274C Error updating warehouse:`, error);
      throw new Error(`Failed to update warehouse: ${error}`);
    }
  }
  /**
   * Deactivate a warehouse (soft delete)
   * 
   * @param id Warehouse ID
   * @returns Success indicator
   */
  async deactivate(id) {
    console.log(`[ManageWarehouseService] \u{1F6AB} Deactivating warehouse: ${id}`);
    try {
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const sql57 = `
        UPDATE warehouses
        SET is_active = false, updated_at = '${now}'
        WHERE id = '${id}'
        RETURNING *`;
      const result = await this.drizzle.executeQuery(sql57);
      if (result.length === 0) {
        throw new Error(`Warehouse with ID ${id} not found`);
      }
      console.log(`[ManageWarehouseService] \u2705 Deactivated warehouse: ${id}`);
      return { success: true, warehouse: result[0] };
    } catch (error) {
      console.error(`[ManageWarehouseService] \u274C Error deactivating warehouse:`, error);
      throw new Error(`Failed to deactivate warehouse: ${error}`);
    }
  }
};
var manageWarehouseService = new ManageWarehouseService();

// server/modules/inventory/controllers/warehouse.controller.ts
init_auth_guard();
init_auth_mode_enum();
init_warehouse();
import { Router as Router57 } from "express";
import { z as z40 } from "zod";
var WAREHOUSE_MANAGER_ROLES = ["admin", "inventory_manager", "warehouse_manager"];
var WAREHOUSE_USER_ROLES = [...WAREHOUSE_MANAGER_ROLES, "inventory_clerk", "warehouse_clerk"];
function createWarehouseController(warehouseService) {
  const router14 = Router57();
  router14.post(
    "/",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(WAREHOUSE_MANAGER_ROLES),
    validateRequest({
      body: insertWarehouseSchema
    }),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const warehouseData = {
          ...req.body,
          companyId: req.user?.companyId
        };
        const warehouse = await warehouseService.createWarehouse(warehouseData, userId);
        res.status(201).json(warehouse);
      } catch (error) {
        next(error);
      }
    }
  );
  router14.put(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(WAREHOUSE_MANAGER_ROLES),
    validateRequest({
      params: z40.object({
        id: z40.string().uuid()
      }),
      body: insertWarehouseSchema.partial()
    }),
    async (req, res, next) => {
      try {
        const { id } = req.params;
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        const existingWarehouse = await warehouseService.getWarehouseById(id);
        if (!existingWarehouse) {
          return res.status(404).json({ error: "Warehouse not found" });
        }
        if (existingWarehouse.companyId !== companyId) {
          return res.status(403).json({ error: "You do not have permission to update this warehouse" });
        }
        const warehouse = await warehouseService.updateWarehouse(id, req.body, userId);
        res.json(warehouse);
      } catch (error) {
        next(error);
      }
    }
  );
  router14.get(
    "/",
    AuthGuard.protect("required" /* REQUIRED */),
    validateRequest({
      query: z40.object({
        search: z40.string().optional(),
        type: z40.enum([
          warehouseTypeEnum.DEPOZIT,
          warehouseTypeEnum.MAGAZIN,
          warehouseTypeEnum.CUSTODIE,
          warehouseTypeEnum.TRANSFER
        ]).optional(),
        isActive: z40.enum(["true", "false"]).transform((val) => val === "true").optional(),
        page: z40.string().optional().transform((val) => val ? parseInt(val) : 1),
        limit: z40.string().optional().transform((val) => val ? parseInt(val) : 20),
        parentId: z40.string().uuid().optional().nullable()
      })
    }),
    async (req, res, next) => {
      try {
        const companyId = req.user?.companyId;
        const { search, type, isActive, page, limit, parentId } = req.query;
        const result = await warehouseService.getWarehouses({
          companyId,
          search,
          type,
          isActive,
          page,
          limit,
          parentId
        });
        res.json(result);
      } catch (error) {
        next(error);
      }
    }
  );
  router14.get(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    validateRequest({
      params: z40.object({
        id: z40.string().uuid()
      })
    }),
    async (req, res, next) => {
      try {
        const { id } = req.params;
        const companyId = req.user?.companyId;
        const warehouse = await warehouseService.getWarehouseById(id);
        if (!warehouse) {
          return res.status(404).json({ error: "Warehouse not found" });
        }
        if (warehouse.companyId !== companyId) {
          return res.status(403).json({ error: "You do not have permission to view this warehouse" });
        }
        res.json(warehouse);
      } catch (error) {
        next(error);
      }
    }
  );
  router14.delete(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(WAREHOUSE_MANAGER_ROLES),
    validateRequest({
      params: z40.object({
        id: z40.string().uuid()
      })
    }),
    async (req, res, next) => {
      try {
        const { id } = req.params;
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        const existingWarehouse = await warehouseService.getWarehouseById(id);
        if (!existingWarehouse) {
          return res.status(404).json({ error: "Warehouse not found" });
        }
        if (existingWarehouse.companyId !== companyId) {
          return res.status(403).json({ error: "You do not have permission to delete this warehouse" });
        }
        await warehouseService.deleteWarehouse(id, userId);
        res.status(204).send();
      } catch (error) {
        next(error);
      }
    }
  );
  router14.get(
    "/:id/children",
    AuthGuard.protect("required" /* REQUIRED */),
    validateRequest({
      params: z40.object({
        id: z40.string().uuid()
      })
    }),
    async (req, res, next) => {
      try {
        const { id } = req.params;
        const companyId = req.user?.companyId;
        const parentWarehouse = await warehouseService.getWarehouseById(id);
        if (!parentWarehouse) {
          return res.status(404).json({ error: "Parent warehouse not found" });
        }
        if (parentWarehouse.companyId !== companyId) {
          return res.status(403).json({ error: "You do not have permission to view this warehouse" });
        }
        const children = await warehouseService.getChildWarehouses(id, companyId);
        res.json(children);
      } catch (error) {
        next(error);
      }
    }
  );
  return router14;
}
var warehouseController = Router57();

// server/modules/inventory/inventory.module.ts
var ENTITY_NAME3 = "inventory";

// server/modules/inventory/services/categories.service.ts
var CategoriesService = class {
  constructor(db4, auditService4) {
    this.db = db4;
    this.auditService = auditService4;
  }
  /**
   * Get all categories
   * @returns Promise with all categories
   */
  async getAllCategories() {
    return await this.db.query(async (db4) => {
      return await db4.select().from(inventoryCategories).orderBy(desc38(inventoryCategories.name));
    });
  }
  /**
   * Get a category by ID
   * @param id Category ID
   * @returns Category object or null if not found
   */
  async getCategoryById(id) {
    return await this.db.query(async (db4) => {
      const categories = await db4.select().from(inventoryCategories).where(eq82(inventoryCategories.id, id)).limit(1);
      return categories.length > 0 ? categories[0] : null;
    });
  }
  /**
   * Get root categories (categories without a parent)
   * @returns Promise with root categories
   */
  async getRootCategories() {
    return await this.db.query(async (db4) => {
      return await db4.select().from(inventoryCategories).where(isNull15(inventoryCategories.parentId)).orderBy(desc38(inventoryCategories.name));
    });
  }
  /**
   * Get child categories for a given parent category
   * @param parentId Parent category ID
   * @returns Promise with child categories
   */
  async getChildCategories(parentId) {
    return await this.db.query(async (db4) => {
      return await db4.select().from(inventoryCategories).where(eq82(inventoryCategories.parentId, parentId)).orderBy(desc38(inventoryCategories.name));
    });
  }
  /**
   * Create a new category
   * @param data Category data
   * @param userId User ID who created the category
   * @returns Created category
   */
  async createCategory(data, userId) {
    const result = await this.db.transaction(async (tx) => {
      const [category] = await tx.insert(inventoryCategories).values({
        name: data.name,
        description: data.description,
        parentId: data.parentId || null
      }).returning();
      await this.auditService.logAction({
        userId,
        action: "create",
        entityType: ENTITY_NAME3,
        entityId: category.id,
        details: `Created category: ${data.name}`,
        oldValue: null,
        newValue: JSON.stringify(category)
      });
      return category;
    });
    return result;
  }
  /**
   * Update a category
   * @param id Category ID
   * @param data Category update data
   * @param userId User ID who updated the category
   * @returns Updated category
   */
  async updateCategory(id, data, userId) {
    const oldCategory = await this.getCategoryById(id);
    if (!oldCategory) {
      throw new Error(`Category with ID ${id} not found`);
    }
    const result = await this.db.transaction(async (tx) => {
      const [updatedCategory] = await tx.update(inventoryCategories).set({
        name: data.name !== void 0 ? data.name : oldCategory.name,
        description: data.description !== void 0 ? data.description : oldCategory.description,
        parentId: data.parentId !== void 0 ? data.parentId : oldCategory.parentId,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq82(inventoryCategories.id, id)).returning();
      await this.auditService.logAction({
        userId,
        action: "update",
        entityType: ENTITY_NAME3,
        entityId: id,
        details: `Updated category: ${oldCategory.name} \u2192 ${updatedCategory.name}`,
        oldValue: JSON.stringify(oldCategory),
        newValue: JSON.stringify(updatedCategory)
      });
      return updatedCategory;
    });
    return result;
  }
  /**
   * Delete a category
   * @param id Category ID
   * @param userId User ID who deleted the category
   * @returns true if deletion was successful
   */
  async deleteCategory(id, userId) {
    const category = await this.getCategoryById(id);
    if (!category) {
      throw new Error(`Category with ID ${id} not found`);
    }
    const children = await this.getChildCategories(id);
    if (children.length > 0) {
      throw new Error(`Cannot delete category with children. Please delete or reassign child categories first.`);
    }
    const productsCount = await this.db.executeQuery(
      sql54`SELECT COUNT(*) FROM inventory_products WHERE category_id = ${id}`
    );
    if (productsCount.rows && productsCount.rows[0] && parseInt(productsCount.rows[0].count, 10) > 0) {
      throw new Error(`Cannot delete category that has products. Please reassign or delete products first.`);
    }
    return await this.db.transaction(async (tx) => {
      await tx.delete(inventoryCategories).where(eq82(inventoryCategories.id, id));
      await this.auditService.logAction({
        userId,
        action: "delete",
        entityType: ENTITY_NAME3,
        entityId: id,
        details: `Deleted category: ${category.name}`,
        oldValue: JSON.stringify(category),
        newValue: null
      });
      return true;
    });
  }
  /**
   * Get a complete category hierarchy as a tree structure
   * @returns Hierarchical tree of categories
   */
  async getCategoryHierarchy() {
    const allCategories = await this.getAllCategories();
    return this.buildCategoryTree(allCategories);
  }
  /**
   * Build a tree structure from flat category list
   * @param categories List of all categories
   * @param parentId Parent ID to start with (null for root level)
   * @returns Hierarchical tree structure
   */
  buildCategoryTree(categories, parentId = null) {
    return categories.filter((category) => category.parentId === parentId).map((category) => ({
      ...category,
      children: this.buildCategoryTree(categories, category.id)
    }));
  }
};

// server/modules/inventory/categories.service.instance.ts
var drizzleService3 = new DrizzleService();
var auditService2 = new AuditService();
var categoriesService = new CategoriesService(drizzleService3, auditService2);

// server/modules/inventory/controllers/categories.controller.ts
var createCategorySchema = z41.object({
  name: z41.string().min(2, "Numele categoriei trebuie s\u0103 aib\u0103 cel pu\u021Bin 2 caractere").max(100),
  description: z41.string().optional(),
  parentId: z41.string().uuid().optional()
});
var updateCategorySchema = z41.object({
  name: z41.string().min(2, "Numele categoriei trebuie s\u0103 aib\u0103 cel pu\u021Bin 2 caractere").max(100).optional(),
  description: z41.string().optional(),
  parentId: z41.string().uuid().nullable().optional()
});
function createCategoriesController(categoriesService2) {
  const router14 = Router59();
  router14.get(
    "/",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const categories = await categoriesService2.getAllCategories();
        res.json(categories);
      } catch (error) {
        log(`Error fetching categories: ${error.message}`, "inventory-categories");
        res.status(500).json({ error: "Eroare la ob\u021Binerea categoriilor" });
      }
    }
  );
  router14.get(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { id } = req.params;
        const category = await categoriesService2.getCategoryById(id);
        if (!category) {
          return res.status(404).json({ error: "Categoria nu a fost g\u0103sit\u0103" });
        }
        res.json(category);
      } catch (error) {
        log(`Error fetching category: ${error.message}`, "inventory-categories");
        res.status(500).json({ error: "Eroare la ob\u021Binerea categoriei" });
      }
    }
  );
  router14.get(
    "/structure/roots",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const rootCategories = await categoriesService2.getRootCategories();
        res.json(rootCategories);
      } catch (error) {
        log(`Error fetching root categories: ${error.message}`, "inventory-categories");
        res.status(500).json({ error: "Eroare la ob\u021Binerea categoriilor principale" });
      }
    }
  );
  router14.get(
    "/children/:parentId",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { parentId } = req.params;
        const childCategories = await categoriesService2.getChildCategories(parentId);
        res.json(childCategories);
      } catch (error) {
        log(`Error fetching child categories: ${error.message}`, "inventory-categories");
        res.status(500).json({ error: "Eroare la ob\u021Binerea subcategoriilor" });
      }
    }
  );
  router14.get(
    "/structure/hierarchy",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const hierarchy = await categoriesService2.getCategoryHierarchy();
        res.json(hierarchy);
      } catch (error) {
        log(`Error fetching category hierarchy: ${error.message}`, "inventory-categories");
        res.status(500).json({ error: "Eroare la ob\u021Binerea ierarhiei categoriilor" });
      }
    }
  );
  router14.post(
    "/",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const validation = createCategorySchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Date de intrare invalide",
            details: validation.error.errors
          });
        }
        const { name, description, parentId } = validation.data;
        if (parentId) {
          const parentCategory = await categoriesService2.getCategoryById(parentId);
          if (!parentCategory) {
            return res.status(400).json({ error: "Categoria p\u0103rinte specificat\u0103 nu exist\u0103" });
          }
        }
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Utilizator neautentificat" });
        }
        try {
          const newCategory = await categoriesService2.createCategory({
            name,
            description,
            parentId
          }, userId);
          res.status(201).json(newCategory);
        } catch (error) {
          log(`Error creating category: ${error.message}`, "inventory-categories");
          if (error.code === "23505" && error.constraint === "inventory_categories_name_unique") {
            return res.status(400).json({
              error: "Categoria nu a putut fi creat\u0103",
              details: "Exist\u0103 deja o categorie cu acest nume. Numele categoriilor trebuie s\u0103 fie unice."
            });
          }
          res.status(500).json({ error: "Eroare la crearea categoriei" });
        }
      } catch (error) {
        log(`Error processing category creation: ${error.message}`, "inventory-categories");
        res.status(500).json({ error: "Eroare la crearea categoriei" });
      }
    }
  );
  router14.put(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { id } = req.params;
        const validation = updateCategorySchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Date de intrare invalide",
            details: validation.error.errors
          });
        }
        const existingCategory = await categoriesService2.getCategoryById(id);
        if (!existingCategory) {
          return res.status(404).json({ error: "Categoria nu a fost g\u0103sit\u0103" });
        }
        const { name, description, parentId } = validation.data;
        if (parentId !== null && parentId !== void 0) {
          if (parentId === id) {
            return res.status(400).json({ error: "O categorie nu poate fi propria sa categorie p\u0103rinte" });
          }
          const parentCategory = await categoriesService2.getCategoryById(parentId);
          if (!parentCategory) {
            return res.status(400).json({ error: "Categoria p\u0103rinte specificat\u0103 nu exist\u0103" });
          }
        }
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Utilizator neautentificat" });
        }
        try {
          const updatedCategory = await categoriesService2.updateCategory(id, {
            name,
            description,
            parentId
          }, userId);
          res.json(updatedCategory);
        } catch (error) {
          log(`Error updating category: ${error.message}`, "inventory-categories");
          if (error.code === "23505" && error.constraint === "inventory_categories_name_unique") {
            return res.status(400).json({
              error: "Categoria nu a putut fi actualizat\u0103",
              details: "Exist\u0103 deja o categorie cu acest nume. Numele categoriilor trebuie s\u0103 fie unice."
            });
          }
          res.status(500).json({ error: "Eroare la actualizarea categoriei" });
        }
      } catch (error) {
        log(`Error processing category update: ${error.message}`, "inventory-categories");
        res.status(500).json({ error: "Eroare la actualizarea categoriei" });
      }
    }
  );
  router14.delete(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { id } = req.params;
        const existingCategory = await categoriesService2.getCategoryById(id);
        if (!existingCategory) {
          return res.status(404).json({ error: "Categoria nu a fost g\u0103sit\u0103" });
        }
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Utilizator neautentificat" });
        }
        await categoriesService2.deleteCategory(id, userId);
        res.json({ success: true, message: "Categoria a fost \u0219tears\u0103 cu succes" });
      } catch (error) {
        log(`Error deleting category: ${error.message}`, "inventory-categories");
        if (error.message && error.message.includes("Cannot delete category with children")) {
          return res.status(400).json({
            error: "Nu se poate \u0219terge o categorie care are subcategorii. V\u0103 rug\u0103m s\u0103 \u0219terge\u021Bi mai \xEEnt\xE2i subcategoriile sau s\u0103 le reatribui\u021Bi."
          });
        }
        if (error.message && error.message.includes("Cannot delete category that has products")) {
          return res.status(400).json({
            error: "Nu se poate \u0219terge o categorie care are produse atribuite. V\u0103 rug\u0103m s\u0103 reatribui\u021Bi produsele mai \xEEnt\xE2i."
          });
        }
        res.status(500).json({ error: "Eroare la \u0219tergerea categoriei" });
      }
    }
  );
  return router14;
}
var categoriesController = createCategoriesController(categoriesService);

// server/modules/inventory/controllers/products.controller.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router60 } from "express";
import { z as z43 } from "zod";

// server/modules/inventory/services/import-validator.service.ts
import { v4 as uuidv439 } from "uuid";

// server/modules/inventory/types/import-validation.ts
import { z as z42 } from "zod";
var ProductImportRowSchema = z42.object({
  name: z42.string().min(2, { message: "Numele produsului trebuie s\u0103 aib\u0103 cel pu\u021Bin 2 caractere" }).max(100, { message: "Numele produsului nu poate dep\u0103\u0219i 100 de caractere" }),
  sku: z42.string().min(2, { message: "Stock Keeping Unit (SKU) trebuie s\u0103 aib\u0103 cel pu\u021Bin 2 caractere" }).max(50, { message: "Stock Keeping Unit (SKU) nu poate dep\u0103\u0219i 50 de caractere" }),
  price: z42.preprocess(
    (val) => typeof val === "string" ? parseFloat(val.replace(",", ".")) : val,
    z42.number().positive({ message: "Pre\u021Bul trebuie s\u0103 fie un num\u0103r pozitiv" })
  ),
  // Câmpuri opționale
  description: z42.string().optional(),
  categoryId: z42.string().optional(),
  unitId: z42.string().optional(),
  vatRate: z42.preprocess(
    (val) => typeof val === "string" ? parseFloat(val.replace(",", ".")) : val,
    z42.number().min(0).max(100).optional()
  ),
  purchasePrice: z42.preprocess(
    (val) => typeof val === "string" ? parseFloat(val.replace(",", ".")) : val,
    z42.number().positive().optional()
  ),
  // Adăugăm câmpul barcode pentru codurile EAN13
  barcode: z42.string().regex(/^[0-9]{13}$/, { message: "Codul de bare trebuie s\u0103 fie un cod EAN13 valid (13 cifre)" }).optional(),
  stockAlert: z42.preprocess(
    (val) => typeof val === "string" ? parseInt(val.toString()) : val,
    z42.number().min(0).optional()
  ),
  isActive: z42.preprocess(
    (val) => {
      if (typeof val === "string") {
        const normalizedVal = val.toLowerCase();
        if (["true", "da", "1", "yes", "activ"].includes(normalizedVal)) return true;
        if (["false", "nu", "0", "no", "inactiv"].includes(normalizedVal)) return false;
      }
      return val;
    },
    z42.boolean().optional().default(true)
  )
});

// server/modules/inventory/utils/barcode-generator.ts
function calculateEAN13Checksum(digits) {
  if (digits.length !== 12 || !/^\d+$/.test(digits)) {
    throw new Error("EAN13 trebuie s\u0103 con\u021Bin\u0103 12 cifre pentru calculul checksum-ului");
  }
  let sum2 = 0;
  for (let i = 0; i < 12; i++) {
    const digit = parseInt(digits[i], 10);
    sum2 += i % 2 === 0 ? digit : digit * 3;
  }
  const checksum = (10 - sum2 % 10) % 10;
  return checksum;
}
function generateEAN13(companyId, productId, salt = 0) {
  const countryPrefix = "594";
  const companyHash = Math.abs(hashString(companyId)) % 1e4;
  const companyCode = companyHash.toString().padStart(4, "0");
  const productHash = (Math.abs(hashString(productId)) + salt) % 1e5;
  const productCode = productHash.toString().padStart(5, "0");
  const digits = countryPrefix + companyCode + productCode;
  const checksum = calculateEAN13Checksum(digits);
  return digits + checksum.toString();
}
async function generateUniqueEAN13(companyId, productId, checkExistingBarcode) {
  let salt = 0;
  let barcode = generateEAN13(companyId, productId, salt);
  while (await checkExistingBarcode(barcode)) {
    salt++;
    barcode = generateEAN13(companyId, productId, salt);
    if (salt > 1e3) {
      throw new Error("Nu s-a putut genera un cod de bare unic dup\u0103 1000 de \xEEncerc\u0103ri");
    }
  }
  return barcode;
}
function hashString(str) {
  let hash2 = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + char;
    hash2 = hash2 & hash2;
  }
  return hash2;
}

// server/modules/inventory/services/import-validator.service.ts
init_schema4();
import { eq as eq83 } from "drizzle-orm";
var ImportValidatorService = class {
  constructor(db4, auditService4) {
    this.db = db4;
    this.auditService = auditService4;
  }
  /**
   * Validează datele de import pentru produse
   * Verifică formatul și obligativitatea câmpurilor
   * 
   * @param data - Date de import sub formă de array de obiecte
   * @returns Raport de validare
   */
  async validateProductImport(data) {
    const report = {
      isValid: true,
      totalRows: data.length,
      validRows: 0,
      invalidRows: 0,
      errors: [],
      validData: []
    };
    if (!Array.isArray(data) || data.length === 0) {
      report.isValid = false;
      report.errors.push({
        row: 0,
        errors: ["Fi\u0219ierul de import nu con\u021Bine date valide sau este gol"]
      });
      return report;
    }
    for (let i = 0; i < data.length; i++) {
      const rowNumber = i + 1;
      const row = data[i];
      try {
        const result = ProductImportRowSchema.safeParse(row);
        if (result.success) {
          report.validRows++;
          report.validData.push(result.data);
        } else {
          report.invalidRows++;
          report.errors.push({
            row: rowNumber,
            errors: result.error.errors.map(
              (err) => `${err.path.join(".")}: ${err.message}`
            )
          });
          report.isValid = false;
        }
      } catch (error) {
        report.invalidRows++;
        report.errors.push({
          row: rowNumber,
          errors: [`Eroare la procesarea r\xE2ndului: ${error.message || "Eroare necunoscut\u0103"}`]
        });
        report.isValid = false;
      }
    }
    return report;
  }
  /**
   * Verifică dacă există un cod de bare în baza de date
   * 
   * @param barcode - Codul de bare de verificat
   * @returns true dacă există, false în caz contrar
   */
  async barcodeExists(barcode) {
    const result = await this.db.query(
      this.db.client.select({ id: inventoryProducts.id }).from(inventoryProducts).where(eq83(inventoryProducts.barcode, barcode)).limit(1)
    );
    return result.length > 0;
  }
  /**
   * Verifică dacă există un produs cu același SKU
   * 
   * @param sku - SKU-ul de verificat
   * @param companyId - ID-ul companiei
   * @returns Produsul găsit sau null
   */
  async getProductBySku(sku, companyId) {
    const products = await this.db.query(
      this.db.client.select().from(inventoryProducts).where(eq83(inventoryProducts.sku, sku)).where(eq83(inventoryProducts.companyId, companyId)).limit(1)
    );
    return products.length > 0 ? products[0] : null;
  }
  /**
   * Verifică dacă există un produs cu același nume
   * 
   * @param name - Numele produsului de verificat
   * @param companyId - ID-ul companiei
   * @returns Produsul găsit sau null
   */
  async getProductByName(name, companyId) {
    const products = await this.db.query(
      this.db.client.select().from(inventoryProducts).where(eq83(inventoryProducts.name, name)).where(eq83(inventoryProducts.companyId, companyId)).limit(1)
    );
    return products.length > 0 ? products[0] : null;
  }
  /**
   * Importă produse în baza de date
   * Procesează datele validate anterior
   * 
   * @param validatedData - Date validate
   * @param options - Opțiuni de import
   * @returns Rezultatul importului
   */
  async importProducts(validatedData, options) {
    const result = {
      success: true,
      message: "Import finalizat cu succes",
      report: {
        processedRows: validatedData.length,
        createdRows: 0,
        updatedRows: 0,
        skippedRows: 0,
        errors: []
      }
    };
    for (let i = 0; i < validatedData.length; i++) {
      const rowNumber = i + 1;
      const productData = validatedData[i];
      try {
        if (options.mode === "create") {
          await this.createProduct(productData, options, rowNumber, result);
        } else {
          await this.updateProduct(productData, options, rowNumber, result);
        }
      } catch (error) {
        result.report.errors.push({
          row: rowNumber,
          errors: [`Eroare la procesarea r\xE2ndului: ${error.message || "Eroare necunoscut\u0103"}`]
        });
      }
    }
    result.message = `Import finalizat: ${result.report.createdRows} produse create, ${result.report.updatedRows} produse actualizate, ${result.report.skippedRows} produse ignorate, ${result.report.errors.length} erori`;
    result.success = result.report.errors.length === 0;
    return result;
  }
  /**
   * Creează un produs nou în baza de date
   */
  async createProduct(productData, options, rowNumber, result) {
    const existingProduct = await this.getProductBySku(productData.sku, options.companyId);
    if (existingProduct) {
      result.report.skippedRows++;
      result.report.errors.push({
        row: rowNumber,
        errors: [`Produsul cu SKU ${productData.sku} exist\u0103 deja. Folosi\u021Bi modul de actualizare pentru a-l modifica.`]
      });
      return;
    }
    const productId = uuidv439();
    let barcode = "";
    if (options.generateBarcodes) {
      barcode = await generateUniqueEAN13(
        options.companyId,
        productId,
        this.barcodeExists.bind(this)
      );
    }
    const purchasePrice = productData.purchasePrice || productData.price * 0.8;
    await this.db.query(
      this.db.client.insert(inventoryProducts).values({
        id: productId,
        companyId: options.companyId,
        name: productData.name,
        sku: productData.sku,
        description: productData.description || "",
        categoryId: productData.categoryId,
        unitId: productData.unitId,
        barcode,
        sellingPrice: productData.price,
        purchasePrice,
        vatRate: productData.vatRate || 19,
        stockAlert: productData.stockAlert || 5,
        isActive: productData.isActive === void 0 ? true : productData.isActive,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      })
    );
    result.report.createdRows++;
    this.auditService.log({
      entityId: productId,
      entityType: "inventoryProducts",
      action: "create",
      userId: "system",
      companyId: options.companyId,
      details: {
        method: "import",
        importMode: options.mode
      }
    });
  }
  /**
   * Actualizează un produs existent în baza de date
   */
  async updateProduct(productData, options, rowNumber, result) {
    let existingProduct;
    if (options.matchField === "name") {
      existingProduct = await this.getProductByName(productData.name, options.companyId);
    } else {
      existingProduct = await this.getProductBySku(productData.sku, options.companyId);
    }
    if (!existingProduct) {
      result.report.skippedRows++;
      result.report.errors.push({
        row: rowNumber,
        errors: [
          `Produsul cu ${options.matchField === "name" ? "numele" : "SKU"} "${options.matchField === "name" ? productData.name : productData.sku}" nu exist\u0103. Folosi\u021Bi modul de creare pentru a-l ad\u0103uga.`
        ]
      });
      return;
    }
    await this.db.query(
      this.db.client.update(inventoryProducts).set({
        name: productData.name,
        sku: productData.sku,
        description: productData.description ?? existingProduct.description,
        categoryId: productData.categoryId ?? existingProduct.categoryId,
        unitId: productData.unitId ?? existingProduct.unitId,
        sellingPrice: productData.price,
        purchasePrice: productData.purchasePrice ?? existingProduct.purchasePrice,
        vatRate: productData.vatRate ?? existingProduct.vatRate,
        stockAlert: productData.stockAlert ?? existingProduct.stockAlert,
        isActive: productData.isActive ?? existingProduct.isActive,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq83(inventoryProducts.id, existingProduct.id))
    );
    result.report.updatedRows++;
    this.auditService.log({
      entityId: existingProduct.id,
      entityType: "inventoryProducts",
      action: "update",
      userId: "system",
      companyId: options.companyId,
      details: {
        method: "import",
        importMode: options.mode
      }
    });
  }
};

// server/common/drizzle/drizzle.service.instance.ts
init_drizzle_service();
var drizzleService4 = new DrizzleService();

// server/modules/audit/services/audit.service.instance.ts
init_audit_service();
var auditService3 = audit_service_default;

// server/modules/inventory/services/import-validator.service.instance.ts
var importValidatorService = new ImportValidatorService(
  drizzleService4,
  auditService3
);

// server/modules/inventory/services/products.service.ts
init_schema4();
init_audit_service();
import { desc as desc39, eq as eq84, sql as sql55 } from "drizzle-orm";
var ProductsService = class {
  constructor(db4, auditService4) {
    this.db = db4;
    this.auditService = auditService4;
  }
  /**
   * Get all products
   * @returns Promise with all products
   */
  async getAllProducts() {
    return await this.db.query(async (db4) => {
      return await db4.select().from(inventoryProducts).orderBy(desc39(inventoryProducts.name));
    });
  }
  /**
   * Get a product by ID
   * @param id Product ID
   * @returns Product object or null if not found
   */
  async getProductById(id) {
    return await this.db.query(async (db4) => {
      const products = await db4.select().from(inventoryProducts).where(eq84(inventoryProducts.id, id)).limit(1);
      return products.length > 0 ? products[0] : null;
    });
  }
  /**
   * Get products by category
   * @param categoryId Category ID
   * @returns Promise with products in the specified category
   */
  async getProductsByCategory(categoryId) {
    return await this.db.query(async (db4) => {
      return await db4.select().from(inventoryProducts).where(eq84(inventoryProducts.categoryId, categoryId)).orderBy(desc39(inventoryProducts.name));
    });
  }
  /**
   * Check if a product with the given name or SKU exists
   * @param name Product name
   * @param sku Product SKU
   * @param excludeId Optional ID to exclude from the check (for updates)
   * @returns Boolean indicating if a duplicate exists
   */
  async checkProductExists(name, sku, excludeId) {
    return await this.db.query(async (db4) => {
      let query = db4.select().from(inventoryProducts).where(sql55`${inventoryProducts.name} = ${name} OR ${inventoryProducts.sku} = ${sku}`);
      if (excludeId) {
        query = query.where(sql55`${inventoryProducts.id} != ${excludeId}`);
      }
      const results = await query.limit(1);
      return results.length > 0;
    });
  }
  /**
   * Create a new product
   * @param data Product data
   * @param userId User ID who created the product
   * @returns Created product
   */
  async createProduct(data, userId) {
    const existingProduct = await this.checkProductExists(data.name, data.sku);
    if (existingProduct) {
      throw new Error("A product with this name or SKU already exists");
    }
    const result = await this.db.transaction(async (tx) => {
      const [product] = await tx.insert(inventoryProducts).values({
        name: data.name,
        sku: data.sku,
        description: data.description,
        categoryId: data.categoryId,
        unitId: data.unitId,
        purchasePrice: data.purchasePrice !== void 0 ? data.purchasePrice.toString() : "0",
        sellingPrice: data.sellingPrice !== void 0 ? data.sellingPrice.toString() : "0",
        priceIncludesVat: data.priceIncludesVat !== void 0 ? data.priceIncludesVat : true,
        vatRate: data.vatRate,
        stockAlert: data.stockAlert !== void 0 ? data.stockAlert.toString() : "0",
        isActive: data.isActive !== void 0 ? data.isActive : true,
        barcode: data.barcode
      }).returning();
      await audit_service_default.log({
        userId,
        companyId: "system",
        // Temporar până avem companyId
        action: "CREATE" /* CREATE */,
        entity: ENTITY_NAME3,
        entityId: product.id,
        details: {
          message: `Created product: ${data.name} (${data.sku})`,
          oldValue: null,
          newValue: JSON.stringify(product)
        }
      });
      return product;
    });
    return result;
  }
  /**
   * Update a product
   * @param id Product ID
   * @param data Product update data
   * @param userId User ID who updated the product
   * @returns Updated product
   */
  async updateProduct(id, data, userId) {
    const oldProduct = await this.getProductById(id);
    if (!oldProduct) {
      throw new Error(`Product with ID ${id} not found`);
    }
    if (data.name && data.name !== oldProduct.name || data.sku && data.sku !== oldProduct.sku) {
      const nameToCheck = data.name || oldProduct.name;
      const skuToCheck = data.sku || oldProduct.sku;
      const existingProduct = await this.checkProductExists(nameToCheck, skuToCheck, id);
      if (existingProduct) {
        throw new Error("A product with this name or SKU already exists");
      }
    }
    const result = await this.db.transaction(async (tx) => {
      const [updatedProduct] = await tx.update(inventoryProducts).set({
        name: data.name !== void 0 ? data.name : oldProduct.name,
        sku: data.sku !== void 0 ? data.sku : oldProduct.sku,
        description: data.description !== void 0 ? data.description : oldProduct.description,
        categoryId: data.categoryId !== void 0 ? data.categoryId : oldProduct.categoryId,
        unitId: data.unitId !== void 0 ? data.unitId : oldProduct.unitId,
        purchasePrice: data.purchasePrice !== void 0 ? data.purchasePrice.toString() : oldProduct.purchasePrice,
        sellingPrice: data.sellingPrice !== void 0 ? data.sellingPrice.toString() : oldProduct.sellingPrice,
        priceIncludesVat: data.priceIncludesVat !== void 0 ? data.priceIncludesVat : oldProduct.priceIncludesVat,
        vatRate: data.vatRate !== void 0 ? data.vatRate : oldProduct.vatRate,
        stockAlert: data.stockAlert !== void 0 ? data.stockAlert.toString() : oldProduct.stockAlert,
        isActive: data.isActive !== void 0 ? data.isActive : oldProduct.isActive,
        barcode: data.barcode !== void 0 ? data.barcode : oldProduct.barcode,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq84(inventoryProducts.id, id)).returning();
      await audit_service_default.log({
        userId,
        companyId: "system",
        // Temporar până avem companyId
        action: "UPDATE" /* UPDATE */,
        entity: ENTITY_NAME3,
        entityId: id,
        details: {
          message: `Updated product: ${oldProduct.name} \u2192 ${updatedProduct.name}`,
          oldValue: JSON.stringify(oldProduct),
          newValue: JSON.stringify(updatedProduct)
        }
      });
      return updatedProduct;
    });
    return result;
  }
  /**
   * Delete a product
   * @param id Product ID
   * @param userId User ID who deleted the product
   * @returns true if deletion was successful
   */
  async deleteProduct(id, userId) {
    const product = await this.getProductById(id);
    if (!product) {
      throw new Error(`Product with ID ${id} not found`);
    }
    const movementsCount = await this.db.query(async (db4) => {
      const result = await db4.execute(
        sql55`SELECT COUNT(*) as count FROM inventory_stock_movements WHERE product_id = ${id}`
      );
      return result.rows && result.rows.length > 0 ? parseInt(result.rows[0].count, 10) : 0;
    });
    if (movementsCount > 0) {
      throw new Error(`Cannot delete product that has stock movements. Consider deactivating it instead.`);
    }
    return await this.db.transaction(async (tx) => {
      await tx.delete(inventoryProducts).where(eq84(inventoryProducts.id, id));
      await audit_service_default.log({
        userId,
        companyId: "system",
        // Temporar până avem companyId
        action: "DELETE" /* DELETE */,
        entity: ENTITY_NAME3,
        entityId: id,
        details: {
          message: `Deleted product: ${product.name} (${product.sku})`,
          oldValue: JSON.stringify(product),
          newValue: null
        }
      });
      return true;
    });
  }
  /**
   * Deactivate a product without deleting it
   * @param id Product ID
   * @param userId User ID who deactivated the product
   * @returns Updated product
   */
  async deactivateProduct(id, userId) {
    const oldProduct = await this.getProductById(id);
    if (!oldProduct) {
      throw new Error(`Product with ID ${id} not found`);
    }
    const result = await this.db.transaction(async (tx) => {
      const [updatedProduct] = await tx.update(inventoryProducts).set({
        isActive: false,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq84(inventoryProducts.id, id)).returning();
      await audit_service_default.log({
        userId,
        companyId: "system",
        // Temporar până avem companyId
        action: "UPDATE" /* UPDATE */,
        entity: ENTITY_NAME3,
        entityId: id,
        details: {
          message: `Deactivated product: ${oldProduct.name}`,
          oldValue: JSON.stringify(oldProduct),
          newValue: JSON.stringify(updatedProduct)
        }
      });
      return updatedProduct;
    });
    return result;
  }
};

// server/modules/inventory/services/products.service.instance.ts
init_audit_service();
var productsService = new ProductsService(drizzleService4, audit_service_default);

// server/modules/inventory/controllers/products.controller.ts
var createProductSchema = z43.object({
  name: z43.string().min(2, "Numele produsului trebuie s\u0103 aib\u0103 cel pu\u021Bin 2 caractere").max(100),
  sku: z43.string().min(2, "SKU-ul produsului trebuie s\u0103 aib\u0103 cel pu\u021Bin 2 caractere").max(50),
  description: z43.string().optional(),
  categoryId: z43.string().uuid().optional(),
  unitId: z43.string().uuid().optional(),
  purchasePrice: z43.number().nonnegative().optional(),
  sellingPrice: z43.number().nonnegative().optional(),
  vatRate: z43.number().min(0).max(100).optional(),
  stockAlert: z43.number().nonnegative().optional(),
  isActive: z43.boolean().optional(),
  barcode: z43.string().optional()
});
var updateProductSchema = z43.object({
  name: z43.string().min(2, "Numele produsului trebuie s\u0103 aib\u0103 cel pu\u021Bin 2 caractere").max(100).optional(),
  sku: z43.string().min(2, "SKU-ul produsului trebuie s\u0103 aib\u0103 cel pu\u021Bin 2 caractere").max(50).optional(),
  description: z43.string().optional(),
  categoryId: z43.string().uuid().optional(),
  unitId: z43.string().uuid().optional(),
  purchasePrice: z43.number().nonnegative().optional(),
  sellingPrice: z43.number().nonnegative().optional(),
  vatRate: z43.number().min(0).max(100).optional(),
  stockAlert: z43.number().nonnegative().optional(),
  isActive: z43.boolean().optional(),
  barcode: z43.string().optional()
});
function createProductsController(productsService2) {
  const router14 = Router60();
  router14.get(
    "/",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const products = await productsService2.getAllProducts();
        res.json(products);
      } catch (error) {
        log(`Error fetching products: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la ob\u021Binerea produselor" });
      }
    }
  );
  router14.get(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { id } = req.params;
        const product = await productsService2.getProductById(id);
        if (!product) {
          return res.status(404).json({ error: "Produsul nu a fost g\u0103sit" });
        }
        res.json(product);
      } catch (error) {
        log(`Error fetching product: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la ob\u021Binerea produsului" });
      }
    }
  );
  router14.get(
    "/category/:categoryId",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { categoryId } = req.params;
        const products = await productsService2.getProductsByCategory(categoryId);
        res.json(products);
      } catch (error) {
        log(`Error fetching products by category: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la ob\u021Binerea produselor dup\u0103 categorie" });
      }
    }
  );
  router14.post(
    "/",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const validation = createProductSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Date de intrare invalide",
            details: validation.error.errors
          });
        }
        const productData = validation.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Utilizator neautentificat" });
        }
        try {
          const newProduct = await productsService2.createProduct(productData, userId);
          res.status(201).json(newProduct);
        } catch (error) {
          log(`Error creating product: ${error.message}`, "inventory-products");
          if (error.message && error.message.includes("already exists")) {
            return res.status(400).json({
              error: "Produsul nu a putut fi creat",
              details: "Exist\u0103 deja un produs cu acest nume sau SKU. Numele \u0219i SKU-ul produselor trebuie s\u0103 fie unice."
            });
          } else if (error.code === "23505") {
            if (error.constraint === "inventory_products_name_unique") {
              return res.status(400).json({
                error: "Produsul nu a putut fi creat",
                details: "Exist\u0103 deja un produs cu acest nume. Numele produselor trebuie s\u0103 fie unice."
              });
            } else if (error.constraint === "inventory_products_sku_unique") {
              return res.status(400).json({
                error: "Produsul nu a putut fi creat",
                details: "Exist\u0103 deja un produs cu acest SKU. SKU-ul produselor trebuie s\u0103 fie unic."
              });
            }
          }
          res.status(500).json({ error: "Eroare la crearea produsului" });
        }
      } catch (error) {
        log(`Error processing product creation: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la crearea produsului" });
      }
    }
  );
  router14.put(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { id } = req.params;
        const validation = updateProductSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Date de intrare invalide",
            details: validation.error.errors
          });
        }
        const existingProduct = await productsService2.getProductById(id);
        if (!existingProduct) {
          return res.status(404).json({ error: "Produsul nu a fost g\u0103sit" });
        }
        const productData = validation.data;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Utilizator neautentificat" });
        }
        try {
          const updatedProduct = await productsService2.updateProduct(id, productData, userId);
          res.json(updatedProduct);
        } catch (error) {
          log(`Error updating product: ${error.message}`, "inventory-products");
          if (error.message && error.message.includes("already exists")) {
            return res.status(400).json({
              error: "Produsul nu a putut fi actualizat",
              details: "Exist\u0103 deja un produs cu acest nume sau SKU. Numele \u0219i SKU-ul produselor trebuie s\u0103 fie unice."
            });
          } else if (error.code === "23505") {
            if (error.constraint === "inventory_products_name_unique") {
              return res.status(400).json({
                error: "Produsul nu a putut fi actualizat",
                details: "Exist\u0103 deja un produs cu acest nume. Numele produselor trebuie s\u0103 fie unice."
              });
            } else if (error.constraint === "inventory_products_sku_unique") {
              return res.status(400).json({
                error: "Produsul nu a putut fi actualizat",
                details: "Exist\u0103 deja un produs cu acest SKU. SKU-ul produselor trebuie s\u0103 fie unic."
              });
            }
          }
          res.status(500).json({ error: "Eroare la actualizarea produsului" });
        }
      } catch (error) {
        log(`Error processing product update: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la actualizarea produsului" });
      }
    }
  );
  router14.delete(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { id } = req.params;
        const existingProduct = await productsService2.getProductById(id);
        if (!existingProduct) {
          return res.status(404).json({ error: "Produsul nu a fost g\u0103sit" });
        }
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Utilizator neautentificat" });
        }
        try {
          await productsService2.deleteProduct(id, userId);
          res.json({ success: true, message: "Produsul a fost \u0219ters cu succes" });
        } catch (error) {
          log(`Error deleting product: ${error.message}`, "inventory-products");
          if (error.message && error.message.includes("has stock movements")) {
            return res.status(400).json({
              error: "Nu se poate \u0219terge un produs care are mi\u0219c\u0103ri de stoc. V\u0103 rug\u0103m s\u0103 \xEEl dezactiva\u021Bi \xEEn loc s\u0103-l \u0219terge\u021Bi."
            });
          }
          res.status(500).json({ error: "Eroare la \u0219tergerea produsului" });
        }
      } catch (error) {
        log(`Error processing product deletion: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la \u0219tergerea produsului" });
      }
    }
  );
  router14.put(
    "/:id/deactivate",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { id } = req.params;
        const existingProduct = await productsService2.getProductById(id);
        if (!existingProduct) {
          return res.status(404).json({ error: "Produsul nu a fost g\u0103sit" });
        }
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Utilizator neautentificat" });
        }
        const deactivatedProduct = await productsService2.deactivateProduct(id, userId);
        res.json(deactivatedProduct);
      } catch (error) {
        log(`Error deactivating product: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la dezactivarea produsului" });
      }
    }
  );
  router14.post(
    "/validate-import",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Utilizator neautentificat" });
        }
        const { data } = req.body;
        if (!Array.isArray(data) || data.length === 0) {
          return res.status(400).json({
            error: "Format invalid pentru importul de produse",
            details: "Date lips\u0103 sau \xEEn format incorect."
          });
        }
        const validationReport = await importValidatorService.validateProductImport(data);
        if (!validationReport.isValid) {
          return res.status(400).json({
            error: "Fi\u0219ierul de import con\u021Bine erori",
            validationReport
          });
        }
        res.json({
          message: "Validarea importului a reu\u0219it",
          validationReport,
          preview: validationReport.validData.slice(0, 5)
          // Primele 5 înregistrări pentru previzualizare
        });
      } catch (error) {
        log(`Error validating import: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la validarea importului" });
      }
    }
  );
  router14.post(
    "/import",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Utilizator neautentificat" });
        }
        const { data, options } = req.body;
        if (!Array.isArray(data) || data.length === 0) {
          return res.status(400).json({
            error: "Date invalide",
            details: "Datele validat anterior lipsesc sau sunt incorecte."
          });
        }
        if (!options || typeof options !== "object") {
          return res.status(400).json({
            error: "Op\u021Biuni invalide",
            details: "Op\u021Biunile de import lipsesc sau sunt incorecte."
          });
        }
        const importOptions = {
          mode: options.mode || "create",
          matchField: options.matchField || "sku",
          format: options.format || "excel",
          generateBarcodes: options.generateBarcodes !== false,
          // Implicit true
          companyId: options.companyId || req.user?.companyId || ""
        };
        if (!importOptions.companyId) {
          return res.status(400).json({
            error: "Op\u021Biuni invalide",
            details: "ID-ul companiei lipse\u0219te."
          });
        }
        const importResult = await importValidatorService.importProducts(data, importOptions);
        res.json({
          message: importResult.message,
          success: importResult.success,
          report: importResult.report
        });
      } catch (error) {
        log(`Error importing products: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la importul produselor" });
      }
    }
  );
  router14.get(
    "/check-barcode/:barcode",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res) => {
      try {
        const { barcode } = req.params;
        if (!barcode || barcode.length !== 13) {
          return res.status(400).json({
            error: "Cod de bare invalid",
            details: "Codul de bare trebuie s\u0103 aib\u0103 exact 13 cifre."
          });
        }
        const exists = await importValidatorService.barcodeExists(barcode);
        res.json({
          barcode,
          exists,
          message: exists ? "Codul de bare exist\u0103 deja \xEEn baza de date" : "Codul de bare este disponibil"
        });
      } catch (error) {
        log(`Error checking barcode: ${error.message}`, "inventory-products");
        res.status(500).json({ error: "Eroare la verificarea codului de bare" });
      }
    }
  );
  return router14;
}
var productsController = createProductsController(productsService);

// server/modules/inventory/controllers/units.controller.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router61 } from "express";
init_db();
init_schema4();
import { eq as eq85 } from "drizzle-orm";
var router13 = Router61();
var INVENTORY_ROLES4 = ["admin" /* ADMIN */, "user" /* USER */];
router13.get(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res, next) => {
    try {
      const db4 = db_default.getDrizzleInstance();
      const units = await db4.select().from(inventoryUnits);
      return res.status(200).json(units);
    } catch (error) {
      console.error("Error fetching inventory units:", error);
      return res.status(500).json({
        error: "Failed to retrieve inventory units",
        details: error.message
      });
    }
  }
);
router13.get(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  async (req, res, next) => {
    try {
      const { id } = req.params;
      const db4 = db_default.getDrizzleInstance();
      const [unit] = await db4.select().from(inventoryUnits).where(eq85(inventoryUnits.id, id));
      if (!unit) {
        return res.status(404).json({ error: "Unit not found" });
      }
      return res.status(200).json(unit);
    } catch (error) {
      console.error("Error fetching inventory unit:", error);
      return res.status(500).json({
        error: "Failed to retrieve inventory unit",
        details: error.message
      });
    }
  }
);
router13.post(
  "/",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(INVENTORY_ROLES4),
  async (req, res, next) => {
    try {
      const { name, abbreviation } = req.body;
      const db4 = db_default.getDrizzleInstance();
      if (!name || !abbreviation) {
        return res.status(400).json({
          error: "Unit name and abbreviation are required"
        });
      }
      const existingUnits = await db4.select().from(inventoryUnits).where(eq85(inventoryUnits.name, name));
      if (existingUnits.length > 0) {
        return res.status(409).json({
          error: "Unit with this name already exists"
        });
      }
      const [newUnit] = await db4.insert(inventoryUnits).values({
        name,
        abbreviation
      }).returning();
      return res.status(201).json(newUnit);
    } catch (error) {
      console.error("Error creating inventory unit:", error);
      return res.status(500).json({
        error: "Failed to create inventory unit",
        details: error.message
      });
    }
  }
);
router13.put(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(INVENTORY_ROLES4),
  async (req, res, next) => {
    try {
      const { id } = req.params;
      const { name, abbreviation } = req.body;
      const db4 = db_default.getDrizzleInstance();
      if (!name && !abbreviation) {
        return res.status(400).json({
          error: "At least one field (name or abbreviation) must be provided for update"
        });
      }
      const [existingUnit] = await db4.select().from(inventoryUnits).where(eq85(inventoryUnits.id, id));
      if (!existingUnit) {
        return res.status(404).json({ error: "Unit not found" });
      }
      if (name && name !== existingUnit.name) {
        const duplicateUnits = await db4.select().from(inventoryUnits).where(eq85(inventoryUnits.name, name));
        if (duplicateUnits.length > 0) {
          return res.status(409).json({
            error: "Unit with this name already exists"
          });
        }
      }
      const [updatedUnit] = await db4.update(inventoryUnits).set({
        name: name || existingUnit.name,
        abbreviation: abbreviation || existingUnit.abbreviation,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq85(inventoryUnits.id, id)).returning();
      return res.status(200).json(updatedUnit);
    } catch (error) {
      console.error("Error updating inventory unit:", error);
      return res.status(500).json({
        error: "Failed to update inventory unit",
        details: error.message
      });
    }
  }
);
router13.delete(
  "/:id",
  AuthGuard.protect("required" /* REQUIRED */),
  AuthGuard.roleGuard(INVENTORY_ROLES4),
  async (req, res, next) => {
    try {
      const { id } = req.params;
      const db4 = db_default.getDrizzleInstance();
      const [existingUnit] = await db4.select().from(inventoryUnits).where(eq85(inventoryUnits.id, id));
      if (!existingUnit) {
        return res.status(404).json({ error: "Unit not found" });
      }
      const products = await db4.select().from(inventoryProducts).where(eq85(inventoryProducts.unitId, id)).limit(1);
      if (products.length > 0) {
        return res.status(409).json({
          error: "This unit is used by products and cannot be deleted"
        });
      }
      await db4.delete(inventoryUnits).where(eq85(inventoryUnits.id, id));
      return res.status(200).json({
        message: "Unit deleted successfully",
        id
      });
    } catch (error) {
      console.error("Error deleting inventory unit:", error);
      return res.status(500).json({
        error: "Failed to delete inventory unit",
        details: error.message
      });
    }
  }
);
var unitsController = router13;

// server/modules/inventory/controllers/stock-items.controller.ts
init_logger();
init_drizzle();
var INVENTORY_ROLES5 = ["inventory_manager" /* INVENTORY_MANAGER */, "admin" /* ADMIN */];
var StockItemsController = class {
  constructor() {
    this.logger = new Logger("StockItemsController");
    this.drizzle = new DrizzleService();
  }
  /**
   * Get all stock items for a company
   */
  async getStockItems(req, res, next) {
    try {
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const warehouseId = req.query.warehouseId;
      const franchiseId = req.user.franchiseId || void 0;
      this.logger.debug(`Fetching stock items for company ${req.user.companyId}${warehouseId ? `, warehouse ${warehouseId}` : ""}`);
      let sql57 = `
        SELECT 
          s.id,
          s.product_id AS "productId",
          s.warehouse_id AS "warehouseId",
          s.quantity,
          COALESCE(
            (SELECT SUM(sr.reservation_quantity) 
             FROM stock_reservations sr 
             WHERE sr.stock_id = s.id AND sr.is_active = true),
            0
          ) AS "reservedQuantity",
          COALESCE(s.purchase_price, 0) AS "purchasePrice",
          COALESCE(s.selling_price, 0) AS "sellingPrice",
          s.created_at AS "createdAt",
          s.updated_at AS "updatedAt"
        FROM 
          stocks s
        JOIN
          warehouses w ON s.warehouse_id = w.id
        WHERE 
          w.company_id = '${req.user.companyId}'
      `;
      if (warehouseId) {
        sql57 += ` AND s.warehouse_id = '${warehouseId}'`;
      }
      if (franchiseId) {
        sql57 += ` AND w.franchise_id = '${franchiseId}'`;
      }
      sql57 += ` ORDER BY s.updated_at DESC`;
      const stockItems = await this.drizzle.executeQuery(sql57);
      res.json(stockItems || []);
    } catch (error) {
      this.logger.error(`Error fetching stock items: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to fetch stock items",
        error: error.message
      });
    }
  }
  /**
   * Get stock item by ID
   */
  async getStockItemById(req, res, next) {
    try {
      const stockItemId = req.params.id;
      if (!stockItemId) {
        res.status(400).json({
          success: false,
          message: "Stock item ID is required"
        });
        return;
      }
      const sql57 = `
        SELECT 
          s.id,
          s.product_id AS "productId",
          s.warehouse_id AS "warehouseId",
          s.quantity,
          COALESCE(
            (SELECT SUM(sr.reservation_quantity) 
             FROM stock_reservations sr 
             WHERE sr.stock_id = s.id AND sr.is_active = true),
            0
          ) AS "reservedQuantity",
          COALESCE(s.purchase_price, 0) AS "purchasePrice",
          COALESCE(s.selling_price, 0) AS "sellingPrice",
          s.created_at AS "createdAt",
          s.updated_at AS "updatedAt",
          w.name AS "warehouseName",
          p.name AS "productName",
          p.code AS "productCode"
        FROM 
          stocks s
        JOIN
          warehouses w ON s.warehouse_id = w.id
        JOIN
          inventory_products p ON s.product_id = p.id
        WHERE 
          s.id = '${stockItemId}'
      `;
      const result = await this.drizzle.executeQuery(sql57);
      if (!result || result.length === 0) {
        res.status(404).json({
          success: false,
          message: "Stock item not found"
        });
        return;
      }
      const stockItem = result[0];
      if (req.user && !req.user.roles?.includes("admin" /* ADMIN */) && stockItem.company_id !== req.user.companyId) {
        res.status(403).json({
          success: false,
          message: "Access denied to the requested stock item"
        });
        return;
      }
      res.json({
        success: true,
        stockItem
      });
    } catch (error) {
      this.logger.error(`Error fetching stock item: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to fetch stock item",
        error: error.message
      });
    }
  }
  /**
   * Check stock levels for a particular warehouse or all warehouses
   */
  async checkStockLevels(req, res, next) {
    try {
      if (!req.user?.companyId) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const warehouseId = req.body.warehouseId;
      this.logger.debug(`Checking stock levels for ${warehouseId ? `warehouse ${warehouseId}` : "all warehouses"}`);
      res.json({
        success: true,
        message: "Stock level check initiated",
        warehouseId: warehouseId || "all"
      });
    } catch (error) {
      this.logger.error(`Error checking stock levels: ${error.message}`);
      res.status(500).json({
        success: false,
        message: "Failed to check stock levels",
        error: error.message
      });
    }
  }
};
var stockItemsController = new StockItemsController();

// server/modules/inventory/controllers/inventory-assessment.controller.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router62 } from "express";
import { z as z44 } from "zod";

// server/db.ts
init_schema4();
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle as drizzle3 } from "drizzle-orm/neon-serverless";
import ws from "ws";
neonConfig.webSocketConstructor = ws;
if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?"
  );
}
var pool = new Pool({ connectionString: process.env.DATABASE_URL });
var db3 = drizzle3({ client: pool, schema: schema_exports });
globalThis.pool = pool;

// server/modules/inventory/controllers/inventory-assessment.controller.ts
var INVENTORY_MANAGER_ROLES = ["admin" /* ADMIN */, "inventory_manager" /* INVENTORY_MANAGER */];
var INVENTORY_USER_ROLES = ["admin" /* ADMIN */, "inventory_manager" /* INVENTORY_MANAGER */, "user" /* USER */];
var createAssessmentSchema = z44.object({
  // NOTE: assessmentNumber is required by the service layer
  // but we'll derive it from name if not provided
  assessmentNumber: z44.string().min(3, "Num\u0103rul documentului trebuie s\u0103 aib\u0103 cel pu\u021Bin 3 caractere"),
  // Name is required for display purposes
  name: z44.string().min(3, "Numele trebuie s\u0103 aib\u0103 cel pu\u021Bin 3 caractere"),
  // Either assessmentType or type is required
  assessmentType: z44.enum(["annual", "monthly", "unscheduled", "special"]).optional(),
  type: z44.enum(["annual", "monthly", "unscheduled", "special"]).optional(),
  // All other fields
  warehouseId: z44.string().uuid("ID-ul gestiunii trebuie s\u0103 fie un UUID valid"),
  startDate: z44.string().refine((value) => !isNaN(Date.parse(value)), {
    message: "Data \xEEnceperii trebuie s\u0103 fie o dat\u0103 valid\u0103"
  }),
  endDate: z44.string().optional().refine((value) => !value || !isNaN(Date.parse(value)), {
    message: "Data finaliz\u0103rii trebuie s\u0103 fie o dat\u0103 valid\u0103"
  }),
  commissionOrderNumber: z44.string().optional(),
  documentNumber: z44.string().optional(),
  legalBasis: z44.string().optional(),
  valuationMethod: z44.string().optional(),
  notes: z44.string().optional(),
  description: z44.string().optional()
}).refine((data) => data.type || data.assessmentType, {
  message: "Trebuie s\u0103 specifica\u021Bi fie 'type', fie 'assessmentType'",
  path: ["type"]
});
var updateStatusSchema = z44.object({
  status: z44.enum(["draft", "in_progress", "pending_approval", "approved", "finalized", "cancelled"])
});
var recordCountSchema = z44.object({
  actualQuantity: z44.number().min(0, "Cantitatea trebuie s\u0103 fie un num\u0103r pozitiv"),
  notes: z44.string().optional().nullable(),
  countedBy: z44.string().uuid("ID-ul utilizatorului trebuie s\u0103 fie un UUID valid").optional().nullable()
});
var inventoryValuationSchema = z44.object({
  productId: z44.string().uuid("ID-ul produsului trebuie s\u0103 fie un UUID valid"),
  warehouseId: z44.string().uuid("ID-ul gestiunii trebuie s\u0103 fie un UUID valid"),
  valuationMethod: z44.enum(["FIFO", "LIFO", "weighted_average"]),
  date: z44.string().optional().refine((value) => !value || !isNaN(Date.parse(value)), {
    message: "Data evalu\u0103rii trebuie s\u0103 fie o dat\u0103 valid\u0103"
  })
});
function createInventoryAssessmentController(assessmentService, valuationService) {
  const router14 = Router62();
  router14.post(
    "/",
    (req, res, next) => {
      try {
        let requestBody = { ...req.body };
        if (!requestBody.assessmentNumber && requestBody.name) {
          requestBody.assessmentNumber = requestBody.name;
          log(`Added assessmentNumber from name: ${requestBody.assessmentNumber}`, "inventory-assessment");
        }
        log(`Validating request body: ${JSON.stringify(requestBody, null, 2)}`, "inventory-assessment");
        const validationResult = createAssessmentSchema.safeParse(requestBody);
        if (!validationResult.success) {
          const errors = validationResult.error.format();
          log(`Validation errors: ${JSON.stringify(errors)}`, "inventory-assessment");
          return res.status(400).json({
            message: "Validation error",
            errors
          });
        }
        req.body = requestBody;
        next();
      } catch (error) {
        log(`Validation error: ${error.message}`, "inventory-assessment");
        return res.status(400).json({
          message: "Validation error",
          error: error.message
        });
      }
    },
    async (req, res, next) => {
      try {
        log(`Request headers: ${JSON.stringify({
          authorization: req.headers.authorization ? "Bearer ***" : "none",
          contentType: req.headers["content-type"],
          userId: req.headers["x-user-id"],
          companyId: req.headers["x-company-id"]
        }, null, 2)}`, "inventory-assessment");
        let userId = req.user?.id;
        let companyId = req.user?.companyId;
        if (!userId || !companyId) {
          log("Auth not from middleware, trying X-User-ID and X-Company-ID headers", "inventory-assessment");
          userId = req.headers["x-user-id"];
          companyId = req.headers["x-company-id"];
          if (!userId || !companyId) {
            return res.status(401).json({ error: "Missing authentication information. Please login again." });
          }
        }
        log(`Creating assessment with user=${userId}, company=${companyId}`, "inventory-assessment");
        log(`Creating assessment with body: ${JSON.stringify(req.body, null, 2)}`, "inventory-assessment");
        log(`Request headers: ${JSON.stringify({
          authorization: req.headers.authorization ? "Bearer ***" : "none",
          contentType: req.headers["content-type"],
          userId: req.headers["x-user-id"],
          companyId: req.headers["x-company-id"]
        }, null, 2)}`, "inventory-assessment");
        const assessmentData = {
          companyId,
          // Convert null to undefined for franchiseId
          franchiseId: req.user?.franchiseId || void 0,
          // Map to assessment_type column
          assessment_type: req.body.type || req.body.assessmentType,
          warehouse_id: req.body.warehouseId,
          // Set both name and assessment_number for compatibility
          name: req.body.name || req.body.assessmentNumber || `Inventariere ${(/* @__PURE__ */ new Date()).toLocaleDateString("ro-RO")}`,
          assessment_number: req.body.assessmentNumber || req.body.name || `Inventariere ${(/* @__PURE__ */ new Date()).toLocaleDateString("ro-RO")}`,
          // Use commissionOrderNumber instead of documentNumber
          commission_order_number: req.body.commissionOrderNumber || req.body.documentNumber || `INV-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`,
          start_date: new Date(req.body.startDate),
          end_date: req.body.endDate ? new Date(req.body.endDate) : void 0,
          status: "draft",
          notes: req.body.notes
        };
        log(`Mapped assessment data: ${JSON.stringify(assessmentData, null, 2)}`, "inventory-assessment");
        const result = await assessmentService.createAssessment(assessmentData, userId, companyId);
        res.status(201).json(result);
      } catch (error) {
        log(`Error creating inventory assessment: ${error.message}`, "inventory-assessment");
        res.status(500).json({ error: "Eroare la crearea documentului de inventariere", details: error.message });
      }
    }
  );
  router14.get(
    "/",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ error: "Utilizator neautentificat sau lips\u0103 ID companie" });
        }
        const query = `
          SELECT a.*, w.name as warehouse_name
          FROM inventory_assessments a
          LEFT JOIN warehouses w ON a.warehouse_id = w.id
          WHERE a.company_id = $1
          ORDER BY a.created_at DESC
        `;
        const client = await pool.connect();
        try {
          const result = await client.query(query, [companyId]);
          res.json({
            assessments: result.rows
          });
        } finally {
          client.release();
        }
      } catch (error) {
        log(`Error fetching inventory assessments: ${error.message}`, "inventory-assessment");
        res.status(500).json({ error: "Eroare la ob\u021Binerea documentelor de inventariere", details: error.message });
      }
    }
  );
  router14.get(
    "/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ error: "Utilizator neautentificat sau lips\u0103 ID companie" });
        }
        const assessmentId = req.params.id;
        const assessmentQuery = `
          SELECT a.*, w.name as warehouse_name
          FROM inventory_assessments a
          LEFT JOIN warehouses w ON a.warehouse_id = w.id
          WHERE a.id = $1 AND a.company_id = $2
          LIMIT 1
        `;
        const itemsQuery = `
          SELECT i.*, p.name as product_name, p.sku, u.name as unit_name
          FROM inventory_assessment_items i
          LEFT JOIN inventory_products p ON i.product_id = p.id
          LEFT JOIN inventory_units u ON p.unit_id = u.id
          WHERE i.assessment_id = $1
          ORDER BY i.created_at
        `;
        const client = await pool.connect();
        try {
          const assessmentResult = await client.query(assessmentQuery, [assessmentId, companyId]);
          if (assessmentResult.rows.length === 0) {
            return res.status(404).json({
              error: "Document de inventariere neg\u0103sit",
              details: "Documentul de inventariere solicitat nu exist\u0103 sau nu apar\u021Bine companiei dvs."
            });
          }
          const assessment = assessmentResult.rows[0];
          const itemsResult = await client.query(itemsQuery, [assessmentId]);
          const items = itemsResult.rows;
          res.json({
            assessment: {
              ...assessment,
              items
            }
          });
        } finally {
          client.release();
        }
      } catch (error) {
        log(`Error fetching inventory assessment: ${error.message}`, "inventory-assessment");
        res.status(error.message.includes("not found") ? 404 : 500).json({ error: "Eroare la ob\u021Binerea documentului de inventariere", details: error.message });
      }
    }
  );
  router14.post(
    "/:id/initialize",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_MANAGER_ROLES),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ error: "Utilizator neautentificat sau lips\u0103 ID companie" });
        }
        const assessmentId = req.params.id;
        console.log(`[inventory-assessment-controller] Initializing assessment items for ID: ${assessmentId}, User ID: ${userId}`);
        try {
          const getAssessmentQuery = `
            SELECT * FROM inventory_assessments WHERE id = $1 AND company_id = $2
          `;
          const client = await pool.connect();
          try {
            const assessmentResult = await client.query(getAssessmentQuery, [assessmentId, companyId]);
            if (assessmentResult.rows.length === 0) {
              return res.status(404).json({ error: "Document de inventariere neg\u0103sit" });
            }
            const assessment = assessmentResult.rows[0];
            const warehouseId = assessment.warehouse_id;
            console.log(`[inventory-assessment-controller] Found assessment with warehouseId: ${warehouseId}`);
            const result = await assessmentService.initializeAssessmentItems(assessmentId, warehouseId, companyId, userId);
            console.log(`[inventory-assessment-controller] Successfully initialized assessment items:`, result ? "Result returned" : "No result");
            res.json(result);
          } finally {
            client.release();
          }
        } catch (initError) {
          console.error(`[inventory-assessment-controller] Error in initializeAssessmentItems:`, initError);
          throw initError;
        }
      } catch (error) {
        log(`Error initializing assessment items: ${error.message}`, "inventory-assessment");
        res.status(500).json({ error: "Eroare la ini\u021Bializarea articolelor de inventariere", details: error.message });
      }
    }
  );
  router14.put(
    "/:id/status",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_MANAGER_ROLES),
    validateRequest({ body: updateStatusSchema }),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ error: "Utilizator neautentificat sau lips\u0103 ID companie" });
        }
        const assessmentId = req.params.id;
        const status = req.body.status;
        const result = await assessmentService.updateAssessmentStatus(assessmentId, status, userId);
        res.json(result);
      } catch (error) {
        log(`Error updating assessment status: ${error.message}`, "inventory-assessment");
        res.status(500).json({ error: "Eroare la actualizarea st\u0103rii documentului de inventariere", details: error.message });
      }
    }
  );
  router14.put(
    "/items/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_USER_ROLES),
    validateRequest({ body: recordCountSchema }),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ error: "Utilizator neautentificat sau lips\u0103 ID companie" });
        }
        const itemId = req.params.id;
        const { actualQuantity, notes, countedBy } = req.body;
        const result = await assessmentService.recordItemCount(
          itemId,
          actualQuantity,
          notes || null,
          countedBy || userId,
          userId
        );
        res.json(result);
      } catch (error) {
        log(`Error recording item count: ${error.message}`, "inventory-assessment");
        res.status(500).json({ error: "Eroare la \xEEnregistrarea num\u0103r\u0103rii articolului", details: error.message });
      }
    }
  );
  router14.post(
    "/:id/process",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_MANAGER_ROLES),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ error: "Utilizator neautentificat sau lips\u0103 ID companie" });
        }
        const assessmentId = req.params.id;
        const result = await assessmentService.processInventoryDifferences(assessmentId, userId);
        res.json(result);
      } catch (error) {
        log(`Error processing inventory differences: ${error.message}`, "inventory-assessment");
        res.status(500).json({ error: "Eroare la procesarea diferen\u021Belor de inventar", details: error.message });
      }
    }
  );
  router14.get(
    "/summary/status",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ error: "Utilizator neautentificat sau lips\u0103 ID companie" });
        }
        const query = `
          SELECT
            COUNT(*) AS total_count,
            COUNT(CASE WHEN status = 'draft' THEN 1 END) AS draft_count,
            COUNT(CASE WHEN status = 'in_progress' THEN 1 END) AS in_progress_count,
            COUNT(CASE WHEN status = 'pending_approval' THEN 1 END) AS pending_approval_count,
            COUNT(CASE WHEN status = 'approved' THEN 1 END) AS approved_count,
            COUNT(CASE WHEN status = 'finalized' THEN 1 END) AS finalized_count,
            COUNT(CASE WHEN status = 'cancelled' THEN 1 END) AS cancelled_count
          FROM inventory_assessments
          WHERE company_id = $1
        `;
        const client = await pool.connect();
        try {
          const result = await client.query(query, [companyId]);
          const summary = result.rows[0] || {
            total_count: 0,
            draft_count: 0,
            in_progress_count: 0,
            pending_approval_count: 0,
            approved_count: 0,
            finalized_count: 0,
            cancelled_count: 0
          };
          res.json({
            summary: {
              totalCount: parseInt(summary.total_count),
              statusCounts: {
                draft: parseInt(summary.draft_count),
                in_progress: parseInt(summary.in_progress_count),
                pending_approval: parseInt(summary.pending_approval_count),
                approved: parseInt(summary.approved_count),
                finalized: parseInt(summary.finalized_count),
                cancelled: parseInt(summary.cancelled_count)
              }
            }
          });
        } finally {
          client.release();
        }
      } catch (error) {
        log(`Error fetching assessment summary: ${error.message}`, "inventory-assessment");
        res.status(500).json({ error: "Eroare la ob\u021Binerea rezumatului de inventariere", details: error.message });
      }
    }
  );
  router14.post(
    "/valuation/calculate",
    AuthGuard.protect("required" /* REQUIRED */),
    validateRequest({ body: inventoryValuationSchema }),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ error: "Utilizator neautentificat sau lips\u0103 ID companie" });
        }
        const { productId, warehouseId, valuationMethod, date: date5 } = req.body;
        const calculationDate = date5 ? new Date(date5) : void 0;
        const result = await valuationService.calculateStockValue(
          productId,
          warehouseId,
          valuationMethod,
          calculationDate
        );
        res.json(result);
      } catch (error) {
        log(`Error calculating stock valuation: ${error.message}`, "inventory-assessment");
        res.status(500).json({ error: "Eroare la calcularea valorii stocului", details: error.message });
      }
    }
  );
  router14.get(
    "/valuation/history",
    AuthGuard.protect("required" /* REQUIRED */),
    async (req, res, next) => {
      try {
        const userId = req.user?.id;
        const companyId = req.user?.companyId;
        if (!userId || !companyId) {
          return res.status(401).json({ error: "Utilizator neautentificat sau lips\u0103 ID companie" });
        }
        const productId = req.query.productId;
        const warehouseId = req.query.warehouseId;
        if (!productId || !warehouseId) {
          return res.status(400).json({ error: "ID-ul produsului \u0219i ID-ul gestiunii sunt obligatorii" });
        }
        const startDate = req.query.startDate ? new Date(req.query.startDate) : void 0;
        const endDate = req.query.endDate ? new Date(req.query.endDate) : void 0;
        const result = await valuationService.getValuationHistory(
          productId,
          warehouseId,
          startDate,
          endDate
        );
        res.json(result);
      } catch (error) {
        log(`Error fetching valuation history: ${error.message}`, "inventory-assessment");
        res.status(500).json({ error: "Eroare la ob\u021Binerea istoricului de evaluare", details: error.message });
      }
    }
  );
  return router14;
}
var inventoryAssessmentController = Router62();

// server/modules/inventory/services/inventory-assessment.service.ts
import { v4 as uuidv440 } from "uuid";
var pool2 = globalThis.pool;
var InventoryAssessmentService = class {
  constructor() {
  }
  /**
   * Create a new inventory assessment document
   */
  async createAssessment(data, userId, companyId) {
    console.log(`[inventory-assessment] Creating assessment with data:`, JSON.stringify(data, null, 2));
    const client = await pool2.connect();
    try {
      const assessmentId = uuidv440();
      const timestamp24 = /* @__PURE__ */ new Date();
      const insertData = {
        id: assessmentId,
        name: data.name || "Inventariere",
        company_id: companyId,
        warehouse_id: data.warehouseId,
        assessment_type: data.assessmentType || data.type || "annual",
        status: "draft",
        start_date: data.startDate ? new Date(data.startDate) : timestamp24,
        end_date: data.endDate ? new Date(data.endDate) : null,
        commission_order_number: data.commissionOrderNumber || "",
        legal_basis: data.legalBasis || "OMFP 2861/2009, Legea contabilit\u0103\u021Bii 82/1991",
        assessment_number: data.assessmentNumber || data.name || "",
        document_number: data.documentNumber || "",
        valuation_method: data.valuationMethod || "WEIGHTED_AVERAGE",
        notes: data.notes || "",
        created_by: userId,
        created_at: timestamp24,
        updated_at: timestamp24
      };
      const query = `
        INSERT INTO inventory_assessments (
          id, name, company_id, warehouse_id, assessment_type,
          status, start_date, end_date, commission_order_number,
          legal_basis, assessment_number, document_number, valuation_method,
          notes, created_by, created_at, updated_at
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
        ) RETURNING *
      `;
      const values = [
        insertData.id,
        insertData.name,
        insertData.company_id,
        insertData.warehouse_id,
        insertData.assessment_type,
        insertData.status,
        insertData.start_date,
        insertData.end_date,
        insertData.commission_order_number,
        insertData.legal_basis,
        insertData.assessment_number,
        insertData.document_number,
        insertData.valuation_method,
        insertData.notes,
        insertData.created_by,
        insertData.created_at,
        insertData.updated_at
      ];
      const result = await client.query(query, values);
      console.log(`[inventory-assessment] Assessment created successfully`);
      return result.rows[0];
    } catch (error) {
      console.error(`[inventory-assessment] Error creating assessment:`, error);
      throw error;
    } finally {
      client.release();
    }
  }
  /**
   * Initialize assessment with products from stock
   */
  async initializeAssessmentItems(assessmentId, warehouseId, companyId, userId) {
    console.log(`[inventory-assessment] Initializing assessment items for assessment: ${assessmentId}`);
    try {
      const client = await pool2.connect();
      try {
        const assessmentQuery = `
          SELECT * FROM inventory_assessments 
          WHERE id = $1
        `;
        const assessmentResult = await client.query(assessmentQuery, [assessmentId]);
        if (assessmentResult.rows.length === 0) {
          throw new Error(`Assessment not found: ${assessmentId}`);
        }
        const assessment = assessmentResult.rows[0];
        if (assessment.status !== "draft") {
          throw new Error(`Assessment must be in DRAFT status to initialize items. Current status: ${assessment.status}`);
        }
        console.log(`[inventory-assessment] Assessment warehouse ID: ${warehouseId}`);
        console.log(`[inventory-assessment] Getting stock items for warehouse ${warehouseId}`);
        const stocksQuery = `
          SELECT 
            p.id as product_id, 
            p.name as product_name,
            p.sku as product_code,
            COALESCE(u.name, 'buc') as unit_of_measure,
            SUM(s.quantity) as theoretical_quantity,
            COALESCE(SUM(s.quantity * s.purchase_price), 0) as theoretical_value
          FROM 
            stocks s
          JOIN 
            inventory_products p ON s.product_id = p.id
          LEFT JOIN 
            inventory_units u ON p.unit_id = u.id
          WHERE 
            s.warehouse_id = $1
            AND s.quantity > 0
          GROUP BY 
            p.id, p.name, p.sku, u.name
        `;
        const stocksResult = await client.query(stocksQuery, [warehouseId]);
        let stockItems = stocksResult.rows;
        console.log(`[inventory-assessment] Found ${stockItems.length} stock items in stocks table`);
        if (stockItems.length === 0) {
          console.log(`[inventory-assessment] No items in stocks table, trying inventory_stock table`);
          const inventoryStockQuery = `
            SELECT 
              s.product_id, 
              p.name as product_name,
              p.code as product_code,
              s.quantity as theoretical_quantity,
              p.unit_of_measure,
              COALESCE(s.value, 0) as theoretical_value
            FROM 
              inventory_stock s
            JOIN 
              inventory_products p ON s.product_id = p.id
            WHERE 
              s.warehouse_id = $1 AND s.company_id = $2
              AND s.quantity > 0
          `;
          const inventoryStockResult = await client.query(inventoryStockQuery, [warehouseId, companyId]);
          stockItems = inventoryStockResult.rows;
          console.log(`[inventory-assessment] Found ${stockItems.length} stock items in inventory_stock table`);
        }
        let assessmentItems = [];
        let successCount = 0;
        let errorCount = 0;
        if (stockItems.length === 0) {
          console.log(`[inventory-assessment] No stock items found for warehouse: ${warehouseId}`);
          const updateStatusQuery2 = `
            UPDATE inventory_assessments
            SET status = $1, updated_at = NOW()
            WHERE id = $2
            RETURNING *
          `;
          await client.query(updateStatusQuery2, ["in_progress", assessmentId]);
          return {
            assessment: {
              ...assessment,
              status: "in_progress"
            },
            items: []
          };
        }
        console.log(`[inventory-assessment] Processing ${stockItems.length} stock items`);
        for (const item of stockItems) {
          console.log(`[inventory-assessment] Processing stock item for ${item.product_name || "unknown product"}`);
          try {
            const itemId = uuidv440();
            const insertQuery = `
              INSERT INTO inventory_assessment_items (
                id, assessment_id, product_id, accounting_quantity, actual_quantity,
                unit_of_measure, accounting_value, actual_value, difference_quantity,
                difference_value, result_type, is_processed, notes, created_at
              ) VALUES (
                $1, $2, $3, 
                CAST($4 AS NUMERIC), CAST($5 AS NUMERIC),
                $6, 
                CAST($7 AS NUMERIC), CAST($8 AS NUMERIC), 
                CAST($9 AS NUMERIC), CAST($10 AS NUMERIC),
                $11, $12, $13, NOW()
              ) RETURNING *
            `;
            const insertResult = await client.query(insertQuery, [
              itemId,
              assessmentId,
              item.product_id,
              parseFloat(item.theoretical_quantity) || 0,
              0,
              // actual_quantity
              item.unit_of_measure || "buc",
              parseFloat(item.theoretical_value) || 0,
              0,
              // actual_value
              0,
              // difference_quantity
              0,
              // difference_value
              "MATCH",
              // result_type
              false,
              // is_processed
              `${item.product_code || ""} - ${item.product_name || "Produs necunoscut"}`
            ]);
            const assessmentItem = insertResult.rows[0];
            console.log(`[inventory-assessment] Item created with ID: ${assessmentItem.id}`);
            assessmentItems.push(assessmentItem);
            successCount++;
          } catch (insertError) {
            console.error(`[inventory-assessment] Error inserting item:`, insertError);
            errorCount++;
          }
        }
        console.log(`[inventory-assessment] Processed items with success: ${successCount}, errors: ${errorCount}`);
        if (successCount === 0 && errorCount > 0) {
          throw new Error(`Failed to insert any assessment items. Please check the error logs.`);
        }
        console.log(`[inventory-assessment] Updating assessment status to IN_PROGRESS`);
        const updateStatusQuery = `
          UPDATE inventory_assessments
          SET status = $1, updated_at = NOW()
          WHERE id = $2
          RETURNING *
        `;
        const updateResult = await client.query(updateStatusQuery, ["in_progress", assessmentId]);
        if (updateResult.rows.length === 0) {
          throw new Error(`Failed to update assessment status to IN_PROGRESS`);
        }
        const updatedAssessment = updateResult.rows[0];
        return {
          assessment: updatedAssessment,
          items: assessmentItems
        };
      } finally {
        client.release();
      }
    } catch (error) {
      console.error(`[inventory-assessment] Error in initializeAssessmentItems:`, error);
      throw error;
    }
  }
  /**
   * Get assessment by ID
   */
  async getAssessmentById(assessmentId) {
    console.log(`[inventory-assessment] Getting assessment details for ID: ${assessmentId}`);
    try {
      const client = await pool2.connect();
      try {
        const query = `
          SELECT * FROM inventory_assessments 
          WHERE id = $1
        `;
        const result = await client.query(query, [assessmentId]);
        if (result.rows.length === 0) {
          return null;
        }
        return result.rows[0];
      } finally {
        client.release();
      }
    } catch (error) {
      console.error(`[inventory-assessment] Error in getAssessmentById:`, error);
      throw error;
    }
  }
  /**
   * Get assessment with items
   */
  async getAssessmentWithItems(assessmentId) {
    console.log(`[inventory-assessment] Getting assessment details with items for ID: ${assessmentId}`);
    try {
      const assessment = await this.getAssessmentById(assessmentId);
      if (!assessment) {
        return null;
      }
      const client = await pool2.connect();
      try {
        const query = `
          SELECT * FROM inventory_assessment_items 
          WHERE assessment_id = $1
        `;
        const result = await client.query(query, [assessmentId]);
        const items = result.rows;
        return {
          assessment,
          items
        };
      } finally {
        client.release();
      }
    } catch (error) {
      console.error(`[inventory-assessment] Error in getAssessmentWithItems:`, error);
      throw error;
    }
  }
};

// server/modules/inventory/services/inventory-valuation.service.ts
init_audit_service();
import { desc as desc40, eq as eq86, and as and71, sql as sql56, asc as asc14, lt, gte as gte7 } from "drizzle-orm";

// shared/schema/inventory-assessment.ts
import { pgTable as pgTable23, text as text23, uuid as uuid22, timestamp as timestamp23, boolean as boolean20, pgEnum as pgEnum12, numeric as numeric9 } from "drizzle-orm/pg-core";
import { relations as relations7 } from "drizzle-orm";
import { createInsertSchema as createInsertSchema16 } from "drizzle-zod";
import { z as z45 } from "zod";
var warehouseTypeEnum2 = {
  DEPOZIT: "depozit",
  MAGAZIN: "magazin",
  CUSTODIE: "custodie",
  TRANSFER: "transfer"
};
var inventoryAssessmentTypeEnum = {
  ANNUAL: "annual",
  MONTHLY: "monthly",
  UNSCHEDULED: "unscheduled",
  SPECIAL: "special"
};
var inventoryAssessmentStatusEnum = {
  DRAFT: "draft",
  IN_PROGRESS: "in_progress",
  PENDING_APPROVAL: "pending_approval",
  APPROVED: "approved",
  FINALIZED: "finalized",
  CANCELLED: "cancelled"
};
var inventoryValuationMethodEnum = {
  FIFO: "FIFO",
  LIFO: "LIFO",
  WEIGHTED_AVERAGE: "WEIGHTED_AVERAGE",
  STANDARD_COST: "STANDARD_COST"
};
var inventoryCountResultEnum = {
  MATCH: "MATCH",
  SURPLUS: "SURPLUS",
  DEFICIT: "DEFICIT"
};
var warehouseTypeEnumType2 = pgEnum12("warehouse_type", Object.values(warehouseTypeEnum2));
var assessmentTypeEnumType = pgEnum12("inventory_assessment_type", Object.values(inventoryAssessmentTypeEnum));
var assessmentStatusEnumType = pgEnum12("inventory_assessment_status", Object.values(inventoryAssessmentStatusEnum));
var valuationMethodEnumType = pgEnum12("inventory_valuation_method", Object.values(inventoryValuationMethodEnum));
var countResultEnumType = pgEnum12("inventory_count_result", Object.values(inventoryCountResultEnum));
var inventoryWarehouses = pgTable23("inventory_warehouses", {
  id: uuid22("id").primaryKey().defaultRandom(),
  companyId: uuid22("company_id").notNull(),
  parentId: uuid22("parent_id"),
  name: text23("name").notNull(),
  code: text23("code").notNull().unique(),
  type: warehouseTypeEnumType2("type").notNull(),
  address: text23("address"),
  location: text23("location"),
  isActive: boolean20("is_active").notNull().default(true),
  notes: text23("notes"),
  createdBy: uuid22("created_by"),
  createdAt: timestamp23("created_at").notNull().defaultNow(),
  updatedAt: timestamp23("updated_at")
});
var inventoryAssessments = pgTable23("inventory_assessments", {
  id: uuid22("id").primaryKey().defaultRandom(),
  companyId: uuid22("company_id").notNull(),
  warehouseId: uuid22("warehouse_id").notNull(),
  name: text23("name").notNull(),
  description: text23("description"),
  documentNumber: text23("document_number").notNull(),
  type: assessmentTypeEnumType("assessment_type").notNull(),
  status: assessmentStatusEnumType("status").notNull().default("draft"),
  startDate: timestamp23("start_date").notNull().defaultNow(),
  endDate: timestamp23("end_date"),
  legalBasis: text23("legal_basis"),
  valuationMethod: valuationMethodEnumType("valuation_method"),
  notes: text23("notes"),
  createdBy: uuid22("created_by"),
  createdAt: timestamp23("created_at").notNull().defaultNow(),
  updatedAt: timestamp23("updated_at"),
  approvedBy: uuid22("approved_by"),
  approvedAt: timestamp23("approved_at"),
  finalizedBy: uuid22("finalized_by"),
  finalizedAt: timestamp23("finalized_at"),
  cancelledBy: uuid22("cancelled_by"),
  cancelledAt: timestamp23("cancelled_at")
});
var inventoryAssessmentItems = pgTable23("inventory_assessment_items", {
  id: uuid22("id").primaryKey().defaultRandom(),
  assessmentId: uuid22("assessment_id").notNull().references(() => inventoryAssessments.id),
  productId: uuid22("product_id").notNull(),
  theoreticalQuantity: numeric9("theoretical_quantity").notNull(),
  actualQuantity: numeric9("actual_quantity"),
  unitOfMeasure: text23("unit_of_measure").notNull(),
  theoreticalValue: numeric9("theoretical_value"),
  actualValue: numeric9("actual_value"),
  difference: numeric9("difference"),
  valueDifference: numeric9("value_difference"),
  countResult: countResultEnumType("count_result"),
  notes: text23("notes"),
  countedBy: uuid22("counted_by"),
  countedAt: timestamp23("counted_at"),
  processedBy: uuid22("processed_by"),
  processedAt: timestamp23("processed_at"),
  createdAt: timestamp23("created_at").notNull().defaultNow(),
  updatedAt: timestamp23("updated_at")
});
var inventoryValuations = pgTable23("inventory_valuations", {
  id: uuid22("id").primaryKey().defaultRandom(),
  companyId: uuid22("company_id").notNull(),
  productId: uuid22("product_id").notNull(),
  warehouseId: uuid22("warehouse_id").notNull(),
  method: valuationMethodEnumType("method").notNull(),
  quantity: numeric9("quantity").notNull(),
  unitValue: numeric9("unit_value").notNull(),
  totalValue: numeric9("total_value").notNull(),
  valuationDate: timestamp23("valuation_date").notNull(),
  referenceDocument: text23("reference_document"),
  referenceId: uuid22("reference_id"),
  assessmentId: uuid22("assessment_id").references(() => inventoryAssessments.id),
  notes: text23("notes"),
  createdBy: uuid22("created_by"),
  createdAt: timestamp23("created_at").notNull().defaultNow(),
  updatedAt: timestamp23("updated_at")
});
var inventoryBatches = pgTable23("inventory_batches", {
  id: uuid22("id").primaryKey().defaultRandom(),
  companyId: uuid22("company_id").notNull(),
  productId: uuid22("product_id").notNull(),
  warehouseId: uuid22("warehouse_id").notNull(),
  batchNumber: text23("batch_number").notNull(),
  purchasePrice: numeric9("purchase_price").notNull(),
  quantity: numeric9("quantity").notNull(),
  remainingQuantity: numeric9("remaining_quantity").notNull().default("0"),
  purchaseDate: timestamp23("purchase_date").notNull(),
  expiryDate: timestamp23("expiry_date"),
  supplier: text23("supplier"),
  invoiceNumber: text23("invoice_number"),
  notes: text23("notes"),
  createdBy: uuid22("created_by"),
  createdAt: timestamp23("created_at").notNull().defaultNow(),
  updatedAt: timestamp23("updated_at")
});
var warehouseRelations = relations7(inventoryWarehouses, ({ one, many }) => ({
  company: one("companies", {
    fields: [inventoryWarehouses.companyId],
    references: ["id"]
  }),
  parent: one(inventoryWarehouses, {
    fields: [inventoryWarehouses.parentId],
    references: [inventoryWarehouses.id]
  }),
  children: many(inventoryWarehouses)
}));
var assessmentRelations = relations7(inventoryAssessments, ({ one, many }) => ({
  company: one("companies", {
    fields: [inventoryAssessments.companyId],
    references: ["id"]
  }),
  warehouse: one(inventoryWarehouses, {
    fields: [inventoryAssessments.warehouseId],
    references: [inventoryWarehouses.id]
  }),
  items: many(inventoryAssessmentItems)
}));
var assessmentItemRelations = relations7(inventoryAssessmentItems, ({ one }) => ({
  assessment: one(inventoryAssessments, {
    fields: [inventoryAssessmentItems.assessmentId],
    references: [inventoryAssessments.id]
  }),
  product: one("inventory_products", {
    fields: [inventoryAssessmentItems.productId],
    references: ["id"]
  })
}));
var insertWarehouseSchema3 = createInsertSchema16(inventoryWarehouses, {
  type: z45.enum([
    warehouseTypeEnum2.DEPOZIT,
    warehouseTypeEnum2.MAGAZIN,
    warehouseTypeEnum2.CUSTODIE,
    warehouseTypeEnum2.TRANSFER
  ]),
  code: z45.string().optional()
}).omit({ id: true, createdAt: true, updatedAt: true });
var insertAssessmentSchema = createInsertSchema16(inventoryAssessments, {
  type: z45.enum([
    inventoryAssessmentTypeEnum.ANNUAL,
    inventoryAssessmentTypeEnum.MONTHLY,
    inventoryAssessmentTypeEnum.UNSCHEDULED,
    inventoryAssessmentTypeEnum.SPECIAL
  ]),
  status: z45.enum([
    inventoryAssessmentStatusEnum.DRAFT,
    inventoryAssessmentStatusEnum.IN_PROGRESS,
    inventoryAssessmentStatusEnum.PENDING_APPROVAL,
    inventoryAssessmentStatusEnum.APPROVED,
    inventoryAssessmentStatusEnum.FINALIZED,
    inventoryAssessmentStatusEnum.CANCELLED
  ]).optional(),
  valuationMethod: z45.enum([
    inventoryValuationMethodEnum.FIFO,
    inventoryValuationMethodEnum.LIFO,
    inventoryValuationMethodEnum.WEIGHTED_AVERAGE,
    inventoryValuationMethodEnum.STANDARD_COST
  ]).optional()
}).omit({ id: true, createdAt: true, updatedAt: true, approvedAt: true, finalizedAt: true, cancelledAt: true });
var insertAssessmentItemSchema = createInsertSchema16(inventoryAssessmentItems, {
  countResult: z45.enum([
    inventoryCountResultEnum.MATCH,
    inventoryCountResultEnum.SURPLUS,
    inventoryCountResultEnum.DEFICIT
  ]).optional()
}).omit({ id: true, createdAt: true, updatedAt: true, countedAt: true, processedAt: true });
var insertValuationSchema = createInsertSchema16(inventoryValuations, {
  method: z45.enum([
    inventoryValuationMethodEnum.FIFO,
    inventoryValuationMethodEnum.LIFO,
    inventoryValuationMethodEnum.WEIGHTED_AVERAGE,
    inventoryValuationMethodEnum.STANDARD_COST
  ])
}).omit({ id: true, createdAt: true, updatedAt: true });
var insertBatchSchema = createInsertSchema16(inventoryBatches).omit({ id: true, createdAt: true, updatedAt: true });

// server/utils/code-generator.ts
function generateRandomCode(length = 6, type = "alphanumeric") {
  let chars;
  switch (type) {
    case "alpha":
      chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      break;
    case "numeric":
      chars = "0123456789";
      break;
    case "alphanumeric":
    default:
      chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      break;
  }
  let result = "";
  const charsLength = chars.length;
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * charsLength));
  }
  return result;
}
function generateDateBasedCode(prefix, date5 = /* @__PURE__ */ new Date(), separator = "", currentNumber = 1, padding = 3) {
  const year = date5.getFullYear();
  const month = String(date5.getMonth() + 1).padStart(2, "0");
  const day = String(date5.getDate()).padStart(2, "0");
  const paddedNumber = String(currentNumber).padStart(padding, "0");
  return `${prefix}${year}${separator}${month}${separator}${day}${separator}${paddedNumber}`;
}

// server/modules/inventory/services/inventory-valuation.service.ts
var InventoryValuationService = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Calculate stock value using FIFO method
   * "primul intrat, primul ieșit" - according to Romanian accounting standards
   * 
   * @param productId - Product ID to calculate value for
   * @param warehouseId - Warehouse ID to calculate value for
   * @param date - Optional date for historical valuation
   */
  async calculateFIFOValue(productId, warehouseId, date5) {
    let batchesQuery = this.db.select({
      id: inventoryBatches.id,
      purchaseDate: inventoryBatches.purchaseDate,
      purchasePrice: inventoryBatches.purchasePrice,
      remainingQuantity: inventoryBatches.remainingQuantity
    }).from(inventoryBatches).where(
      and71(
        eq86(inventoryBatches.productId, productId),
        eq86(inventoryBatches.warehouseId, warehouseId),
        sql56`${inventoryBatches.remainingQuantity} > 0`
      )
    ).orderBy(asc14(inventoryBatches.purchaseDate));
    if (date5) {
      batchesQuery = batchesQuery.where(lt(inventoryBatches.purchaseDate, date5));
    }
    const batches = await batchesQuery;
    let totalQuantity = 0;
    let totalValue = 0;
    const batchesWithValues = batches.map((batch) => {
      const quantity = Number(batch.remainingQuantity);
      const unitValue = Number(batch.purchasePrice);
      const totalBatchValue = quantity * unitValue;
      totalQuantity += quantity;
      totalValue += totalBatchValue;
      return {
        id: batch.id,
        purchaseDate: batch.purchaseDate,
        quantity,
        unitValue,
        totalValue: totalBatchValue
      };
    });
    const averageUnitValue = totalQuantity > 0 ? totalValue / totalQuantity : 0;
    return {
      quantity: totalQuantity,
      value: totalValue,
      averageUnitValue,
      batches: batchesWithValues
    };
  }
  /**
   * Calculate stock value using LIFO method
   * "ultimul intrat, primul ieșit" - according to Romanian accounting standards
   * 
   * @param productId - Product ID to calculate value for
   * @param warehouseId - Warehouse ID to calculate value for
   * @param date - Optional date for historical valuation
   */
  async calculateLIFOValue(productId, warehouseId, date5) {
    let batchesQuery = this.db.select({
      id: inventoryBatches.id,
      purchaseDate: inventoryBatches.purchaseDate,
      purchasePrice: inventoryBatches.purchasePrice,
      remainingQuantity: inventoryBatches.remainingQuantity
    }).from(inventoryBatches).where(
      and71(
        eq86(inventoryBatches.productId, productId),
        eq86(inventoryBatches.warehouseId, warehouseId),
        sql56`${inventoryBatches.remainingQuantity} > 0`
      )
    ).orderBy(desc40(inventoryBatches.purchaseDate));
    if (date5) {
      batchesQuery = batchesQuery.where(lt(inventoryBatches.purchaseDate, date5));
    }
    const batches = await batchesQuery;
    let totalQuantity = 0;
    let totalValue = 0;
    const batchesWithValues = batches.map((batch) => {
      const quantity = Number(batch.remainingQuantity);
      const unitValue = Number(batch.purchasePrice);
      const totalBatchValue = quantity * unitValue;
      totalQuantity += quantity;
      totalValue += totalBatchValue;
      return {
        id: batch.id,
        purchaseDate: batch.purchaseDate,
        quantity,
        unitValue,
        totalValue: totalBatchValue
      };
    });
    const averageUnitValue = totalQuantity > 0 ? totalValue / totalQuantity : 0;
    return {
      quantity: totalQuantity,
      value: totalValue,
      averageUnitValue,
      batches: batchesWithValues
    };
  }
  /**
   * Calculate stock value using Weighted Average Method
   * "costul mediu ponderat" - according to Romanian accounting standards
   * 
   * @param productId - Product ID to calculate value for
   * @param warehouseId - Warehouse ID to calculate value for
   * @param date - Optional date for historical valuation
   */
  async calculateWeightedAverageValue(productId, warehouseId, date5) {
    let batchesQuery = this.db.select({
      purchasePrice: inventoryBatches.purchasePrice,
      remainingQuantity: inventoryBatches.remainingQuantity
    }).from(inventoryBatches).where(
      and71(
        eq86(inventoryBatches.productId, productId),
        eq86(inventoryBatches.warehouseId, warehouseId),
        sql56`${inventoryBatches.remainingQuantity} > 0`
      )
    );
    if (date5) {
      batchesQuery = batchesQuery.where(lt(inventoryBatches.purchaseDate, date5));
    }
    const batches = await batchesQuery;
    let totalQuantity = 0;
    let totalValue = 0;
    for (const batch of batches) {
      const quantity = Number(batch.remainingQuantity);
      const unitValue = Number(batch.purchasePrice);
      totalQuantity += quantity;
      totalValue += quantity * unitValue;
    }
    const averageUnitValue = totalQuantity > 0 ? totalValue / totalQuantity : 0;
    return {
      quantity: totalQuantity,
      value: totalValue,
      averageUnitValue
    };
  }
  /**
   * Get the latest valuation for a product in a warehouse
   * 
   * @param productId - Product ID
   * @param warehouseId - Warehouse ID
   */
  async getLatestValuation(productId, warehouseId) {
    const [valuation] = await this.db.select().from(inventoryValuations).where(
      and71(
        eq86(inventoryValuations.productId, productId),
        eq86(inventoryValuations.warehouseId, warehouseId)
      )
    ).orderBy(desc40(inventoryValuations.valuationDate)).limit(1);
    return valuation;
  }
  /**
   * Calculate stock value using the specified method
   * 
   * @param productId - Product ID
   * @param warehouseId - Warehouse ID
   * @param method - Valuation method (FIFO, LIFO, weighted_average)
   * @param date - Optional date for historical valuation
   */
  async calculateStockValue(productId, warehouseId, method, date5) {
    switch (method) {
      case inventoryValuationMethodEnum.FIFO:
        const fifoResult = await this.calculateFIFOValue(productId, warehouseId, date5);
        return {
          ...fifoResult,
          method
        };
      case inventoryValuationMethodEnum.LIFO:
        const lifoResult = await this.calculateLIFOValue(productId, warehouseId, date5);
        return {
          ...lifoResult,
          method
        };
      case inventoryValuationMethodEnum.WEIGHTED_AVERAGE:
        const avgResult = await this.calculateWeightedAverageValue(productId, warehouseId, date5);
        return {
          ...avgResult,
          method,
          batches: []
          // Weighted average doesn't track individual batches
        };
      default:
        throw new Error(`Unsupported valuation method: ${method}`);
    }
  }
  /**
   * Save a valuation record for audit and historical tracking purposes
   * Required for Romanian accounting compliance and reporting
   * 
   * @param data - Valuation data to save
   * @param userId - User ID who performed the valuation
   */
  async saveValuation(data, userId) {
    const valuationDate = data.valuationDate || /* @__PURE__ */ new Date();
    const referenceDocument = data.referenceDocument || generateDateBasedCode("VAL", valuationDate, "", 1);
    const valuation = {
      ...data,
      valuationDate,
      referenceDocument,
      createdBy: userId
    };
    const validatedData = insertValuationSchema.parse(valuation);
    const [result] = await this.db.insertInto(inventoryValuations).values(validatedData).returning();
    await AuditService.log({
      action: "CREATE" /* CREATE */,
      entity: "valuation",
      entityId: result.id,
      userId,
      companyId: result.companyId,
      data: {
        productId: data.productId,
        warehouseId: data.warehouseId,
        method: data.method,
        quantity: data.quantity,
        totalValue: data.totalValue
      }
    });
    return result;
  }
  /**
   * Get valuation history for a product in a warehouse
   * 
   * @param productId - Product ID
   * @param warehouseId - Warehouse ID
   * @param startDate - Optional start date
   * @param endDate - Optional end date
   */
  async getValuationHistory(productId, warehouseId, startDate, endDate) {
    let query = this.db.select().from(inventoryValuations).where(
      and71(
        eq86(inventoryValuations.productId, productId),
        eq86(inventoryValuations.warehouseId, warehouseId)
      )
    ).orderBy(desc40(inventoryValuations.valuationDate));
    if (startDate) {
      query = query.where(gte7(inventoryValuations.valuationDate, startDate));
    }
    if (endDate) {
      query = query.where(lt(inventoryValuations.valuationDate, endDate));
    }
    return query;
  }
  /**
   * Create a new batch record when receiving stock
   * Used for FIFO/LIFO tracking
   * 
   * @param data - Batch data
   * @param userId - User ID who created the batch
   */
  async createBatch(data, userId) {
    const batchData = {
      ...data,
      remainingQuantity: data.quantity,
      createdBy: userId
    };
    const validatedData = insertBatchSchema.parse(batchData);
    const [batch] = await this.db.insertInto(inventoryBatches).values(validatedData).returning();
    await AuditService.log({
      action: "CREATE" /* CREATE */,
      entity: "batch",
      entityId: batch.id,
      userId,
      companyId: batch.companyId,
      data: {
        productId: data.productId,
        warehouseId: data.warehouseId,
        batchNumber: data.batchNumber,
        quantity: data.quantity,
        purchasePrice: data.purchasePrice
      }
    });
    return batch;
  }
  /**
   * Update batch quantities when stock is consumed
   * Used for FIFO/LIFO inventory management
   * 
   * @param productId - Product ID
   * @param warehouseId - Warehouse ID
   * @param quantity - Quantity to consume
   * @param method - FIFO or LIFO method
   * @param userId - User ID who is consuming the stock
   */
  async consumeStock(productId, warehouseId, quantity, method, userId) {
    if (quantity <= 0) {
      throw new Error("Quantity to consume must be positive");
    }
    let batches;
    if (method === "FIFO") {
      batches = await this.db.select().from(inventoryBatches).where(
        and71(
          eq86(inventoryBatches.productId, productId),
          eq86(inventoryBatches.warehouseId, warehouseId),
          sql56`${inventoryBatches.remainingQuantity} > 0`
        )
      ).orderBy(asc14(inventoryBatches.purchaseDate));
    } else {
      batches = await this.db.select().from(inventoryBatches).where(
        and71(
          eq86(inventoryBatches.productId, productId),
          eq86(inventoryBatches.warehouseId, warehouseId),
          sql56`${inventoryBatches.remainingQuantity} > 0`
        )
      ).orderBy(desc40(inventoryBatches.purchaseDate));
    }
    let remainingToConsume = quantity;
    let consumedValue = 0;
    const batchesUpdated = [];
    for (const batch of batches) {
      if (remainingToConsume <= 0) break;
      const batchRemaining = Number(batch.remainingQuantity);
      const consumeFromBatch = Math.min(batchRemaining, remainingToConsume);
      const newRemaining = batchRemaining - consumeFromBatch;
      const [updatedBatch] = await this.db.update(inventoryBatches).set({
        remainingQuantity: newRemaining,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq86(inventoryBatches.id, batch.id)).returning();
      const batchValue = consumeFromBatch * Number(batch.purchasePrice);
      consumedValue += batchValue;
      batchesUpdated.push({
        id: batch.id,
        quantityConsumed: consumeFromBatch,
        valueConsumed: batchValue,
        remainingQuantity: newRemaining
      });
      remainingToConsume -= consumeFromBatch;
    }
    await AuditService.log({
      action: "UPDATE" /* UPDATE */,
      entity: "stock",
      entityId: `${productId}-${warehouseId}`,
      userId,
      companyId: batchesUpdated.length > 0 ? batchesUpdated[0].companyId : warehouseId.split("-")[0],
      // Get companyId from batch or extract from warehouseId
      data: {
        productId,
        warehouseId,
        quantityRequested: quantity,
        quantityConsumed: quantity - remainingToConsume,
        valueConsumed: consumedValue,
        method,
        batchesUpdated: batchesUpdated.map((b) => b.id)
      }
    });
    return {
      success: remainingToConsume === 0,
      consumedQuantity: quantity - remainingToConsume,
      consumedValue,
      remainingToConsume,
      batchesUpdated
    };
  }
  /**
   * Update product and stock records with the latest valuation
   * 
   * @param productId - Product ID
   * @param warehouseId - Warehouse ID
   * @param method - Valuation method
   * @param userId - User ID
   */
  async updateProductValuation(productId, warehouseId, method, userId) {
    const valuation = await this.calculateStockValue(productId, warehouseId, method);
    const [product] = await this.db.select({ companyId: inventoryBatches.companyId }).from(inventoryBatches).where(eq86(inventoryBatches.productId, productId)).limit(1);
    if (!product) {
      throw new Error(`Product with ID ${productId} not found in any batch records`);
    }
    return this.saveValuation({
      companyId: product.companyId,
      productId,
      warehouseId,
      method,
      quantity: valuation.quantity,
      unitValue: valuation.averageUnitValue,
      totalValue: valuation.value,
      valuationDate: /* @__PURE__ */ new Date(),
      notes: `Automatic valuation using ${method} method`
    }, userId);
  }
};

// server/modules/inventory/services/warehouse.service.ts
init_audit_service();
import { eq as eq87, and as and72 } from "drizzle-orm";
init_warehouse();
var WarehouseService = class {
  constructor(db4) {
    this.db = db4;
  }
  /**
   * Create a new warehouse
   * 
   * @param data - Warehouse data
   * @param userId - ID of the user creating the warehouse
   * @returns The created warehouse
   */
  async createWarehouse(data, userId) {
    const warehouseData = {
      ...data,
      code: data.code || await this.generateWarehouseCode(data.companyId)
    };
    const [warehouse] = await this.db.insertInto(warehouses).values(warehouseData).returning();
    await AuditService.log({
      action: "CREATE" /* CREATE */,
      entity: "warehouse",
      entityId: warehouse.id,
      userId,
      companyId: warehouse.companyId,
      data: {
        name: warehouse.name,
        code: warehouse.code,
        type: warehouse.type
      }
    });
    return warehouse;
  }
  /**
   * Update an existing warehouse
   * 
   * @param id - Warehouse ID
   * @param data - Updated warehouse data
   * @param userId - ID of the user updating the warehouse
   * @returns The updated warehouse
   */
  async updateWarehouse(id, data, userId) {
    const [warehouse] = await this.db.update(warehouses).set({
      ...data,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq87(warehouses.id, id)).returning();
    if (!warehouse) {
      throw new Error(`Warehouse with ID ${id} not found`);
    }
    await AuditService.log({
      action: "UPDATE" /* UPDATE */,
      entity: "warehouse",
      entityId: warehouse.id,
      userId,
      companyId: warehouse.companyId,
      data: {
        name: warehouse.name,
        code: warehouse.code,
        type: warehouse.type,
        updatedFields: Object.keys(data)
      }
    });
    return warehouse;
  }
  /**
   * Get warehouse by ID
   * 
   * @param id - Warehouse ID
   * @returns The warehouse or null if not found
   */
  async getWarehouseById(id) {
    const [warehouse] = await this.db.from(warehouses).where(eq87(warehouses.id, id)).limit(1);
    return warehouse || null;
  }
  /**
   * Delete a warehouse
   * 
   * @param id - Warehouse ID
   * @param userId - ID of the user deleting the warehouse
   * @returns True if deleted successfully
   */
  async deleteWarehouse(id, userId) {
    const warehouse = await this.getWarehouseById(id);
    if (!warehouse) {
      throw new Error(`Warehouse with ID ${id} not found`);
    }
    await this.validateWarehouseCanBeDeleted(id);
    const [result] = await this.db.update(warehouses).set({
      isActive: false,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq87(warehouses.id, id)).returning();
    await AuditService.log({
      action: "DELETE" /* DELETE */,
      entity: "warehouse",
      entityId: id,
      userId,
      companyId: warehouse.companyId,
      data: {
        name: warehouse.name,
        code: warehouse.code,
        type: warehouse.type
      }
    });
    return !!result;
  }
  /**
   * Get all warehouses for a company with filtering and pagination
   * 
   * @param options - Filter and pagination options
   * @returns List of warehouses and total count
   */
  async getWarehouses(options) {
    const {
      companyId,
      search,
      type,
      isActive = true,
      page = 1,
      limit = 20,
      parentId
    } = options;
    const countQuery = `
      SELECT COUNT(*) as count
      FROM warehouses
      WHERE company_id = $1
    `;
    const countResult = await pool.query(countQuery, [companyId]);
    const total = Number(countResult.rows[0]?.count || 0);
    let query = `
      SELECT * 
      FROM warehouses 
      WHERE company_id = $1
    `;
    const queryParams = [companyId];
    let paramCounter = 2;
    if (isActive !== void 0) {
      query += ` AND is_active = $${paramCounter}`;
      queryParams.push(isActive);
      paramCounter++;
    }
    if (type) {
      query += ` AND type = $${paramCounter}`;
      queryParams.push(type);
      paramCounter++;
    }
    if (parentId !== void 0) {
      if (parentId === null) {
        query += ` AND franchise_id IS NULL`;
      } else {
        query += ` AND franchise_id = $${paramCounter}`;
        queryParams.push(parentId);
        paramCounter++;
      }
    }
    if (search) {
      query += ` AND (name ILIKE $${paramCounter} OR code ILIKE $${paramCounter} OR address ILIKE $${paramCounter})`;
      queryParams.push(`%${search}%`);
      paramCounter++;
    }
    query += ` ORDER BY created_at DESC LIMIT $${paramCounter} OFFSET $${paramCounter + 1}`;
    const offset = (page - 1) * limit;
    queryParams.push(limit, offset);
    const result = await pool.query(query, queryParams);
    const warehouseRows = result.rows;
    return { warehouses: warehouseRows, total };
  }
  /**
   * Get all child warehouses for a parent warehouse
   * 
   * @param parentId - Parent warehouse ID
   * @param companyId - Company ID
   * @returns List of child warehouses
   */
  async getChildWarehouses(parentId, companyId) {
    const query = `
      SELECT *
      FROM warehouses
      WHERE franchise_id = $1
        AND company_id = $2
        AND is_active = true
      ORDER BY name
    `;
    const result = await pool.query(query, [parentId, companyId]);
    return result.rows;
  }
  /**
   * Generate a unique warehouse code
   * 
   * @param companyId - Company ID
   * @returns A unique warehouse code
   */
  async generateWarehouseCode(companyId) {
    const prefix = "WH";
    let code;
    let isUnique = false;
    while (!isUnique) {
      code = `${prefix}${generateRandomCode(5, "numeric")}`;
      const [existing] = await this.db.from(warehouses).where(
        and72(
          eq87(warehouses.code, code),
          eq87(warehouses.companyId, companyId)
        )
      ).limit(1);
      isUnique = !existing;
    }
    return code;
  }
  /**
   * Validate if a warehouse can be deleted
   * 
   * @param warehouseId - Warehouse ID
   * @throws Error if warehouse cannot be deleted
   */
  async validateWarehouseCanBeDeleted(warehouseId) {
    const childWarehouses = await this.db.from(warehouses).where(eq87(warehouses.franchiseId, warehouseId)).limit(1);
    if (childWarehouses.length > 0) {
      throw new Error("Cannot delete warehouse with child warehouses. Please delete child warehouses first.");
    }
  }
};

// server/modules/inventory/routes/inventory.routes.ts
init_drizzle_service();
var INVENTORY_ROLES6 = ["admin" /* ADMIN */, "user" /* USER */];
var createWarehouseSchema2 = z46.object({
  name: z46.string().min(2, "Warehouse name must be at least 2 characters"),
  code: z46.string().optional(),
  location: z46.string().optional(),
  address: z46.string().optional(),
  type: z46.enum(["depozit", "magazin", "custodie", "transfer"]),
  is_active: z46.boolean().optional().default(true)
});
var transferStockSchema2 = z46.object({
  sourceStockId: z46.string().uuid("Invalid source stock ID"),
  destinationWarehouseId: z46.string().uuid("Invalid destination warehouse ID"),
  quantity: z46.number().positive("Quantity must be positive"),
  documentNumber: z46.string().optional(),
  notes: z46.string().optional()
});
function setupInventoryRoutes() {
  const router14 = Router63();
  const drizzleService5 = new DrizzleService();
  const inventoryValuationService = new InventoryValuationService(drizzleService5);
  const inventoryAssessmentService = new InventoryAssessmentService(
    drizzleService5,
    inventoryValuationService
  );
  const assessmentController = createInventoryAssessmentController(
    inventoryAssessmentService,
    inventoryValuationService
  );
  router14.post(
    "/nir",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_ROLES6),
    (req, res, next) => nirController.createNirDocument(req, res, next)
  );
  router14.get(
    "/nir/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res, next) => nirController.getNirDocument(req, res, next)
  );
  router14.put(
    "/nir/:id/status",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_ROLES6),
    (req, res, next) => nirController.updateNirStatus(req, res, next)
  );
  router14.get(
    "/nir",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res, next) => nirController.getNirDocuments(req, res, next)
  );
  const warehouseService = new WarehouseService(drizzleService5);
  const newWarehouseController = createWarehouseController(warehouseService);
  router14.use(
    "/warehouses",
    AuthGuard.protect("required" /* REQUIRED */),
    addCompanyFilter,
    newWarehouseController
  );
  router14.post(
    "/transfer",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_ROLES6),
    validateRequest({ body: transferStockSchema2 }),
    (req, res, next) => transferStockController.transferStock(req, res, next)
  );
  router14.get(
    "/transfer/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res, next) => transferStockController.getTransferById(req, res, next)
  );
  router14.get(
    "/transfers",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res, next) => transferStockController.getTransfersByCompany(req, res, next)
  );
  router14.put(
    "/transfer/:id/status",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_ROLES6),
    (req, res, next) => transferStockController.updateTransferStatus(req, res, next)
  );
  router14.post(
    "/check-stock-levels",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_ROLES6),
    (req, res, next) => stockLevelsController.checkStockLevels(req, res, next)
  );
  router14.get(
    "/stock/low",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res, next) => stockLevelsController.getLowStockProducts(req, res, next)
  );
  router14.post(
    "/stock/threshold",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_ROLES6),
    (req, res, next) => stockLevelsController.setStockThreshold(req, res, next)
  );
  router14.get(
    "/stock/notifications",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res, next) => stockLevelsController.getNotificationSettings(req, res, next)
  );
  router14.put(
    "/stock/notifications",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_ROLES6),
    (req, res, next) => stockLevelsController.updateNotificationSettings(req, res, next)
  );
  router14.use("/categories", categoriesController);
  router14.use("/products", productsController);
  router14.use("/units", unitsController);
  router14.get(
    "/stock-items",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res, next) => stockItemsController.getStockItems(req, res, next)
  );
  router14.get(
    "/stock-items/:id",
    AuthGuard.protect("required" /* REQUIRED */),
    (req, res, next) => stockItemsController.getStockItemById(req, res, next)
  );
  router14.post(
    "/stock-items/check-levels",
    AuthGuard.protect("required" /* REQUIRED */),
    AuthGuard.roleGuard(INVENTORY_ROLES6),
    (req, res, next) => stockItemsController.checkStockLevels(req, res, next)
  );
  router14.use("/assessments", assessmentController);
  return router14;
}

// server/modules/inventory/index.ts
function initializeInventoryModule(app2) {
  app2.use("/api/inventory/templates", template_router_default);
  app2.use("/api/inventory", setupInventoryRoutes());
  log("\u{1F4E6} Inventory module registered with complete route structure", "inventory");
  console.log("Inventory module initialized");
}

// server/modules/company/services/company.service.ts
init_logger();
import { eq as eq88, and as and73, isNull as isNull17 } from "drizzle-orm";
var logger117 = new Logger("CompanyService");
var CompanyService = class {
  /**
   * Constructor for the CompanyService
   * @param drizzleService Injectable DrizzleService instance
   */
  constructor(drizzleService5) {
    this.drizzleService = drizzleService5;
  }
  /**
   * Get all companies
   * Optionally filter by parent company
   * 
   * @param parentId Optional parent company ID to filter by
   * @returns Promise resolving to an array of companies
   */
  async getAllCompanies(parentId) {
    try {
      return await this.drizzleService.transaction(async (tx) => {
        let query = tx.select().from(companies2);
        if (parentId) {
          query = query.where(eq88(companies2.parentId, parentId));
        }
        query = query.where(isNull17(companies2.deletedAt));
        return await query;
      });
    } catch (error) {
      logger117.error("Failed to get all companies", error);
      throw new Error("Failed to retrieve companies");
    }
  }
  /**
   * Get a company by ID
   * 
   * @param id Company ID
   * @returns Promise resolving to the company or null if not found
   */
  async getCompanyById(id) {
    try {
      return await this.drizzleService.transaction(async (tx) => {
        const result = await tx.select().from(companies2).where(
          and73(
            eq88(companies2.id, id),
            isNull17(companies2.deletedAt)
          )
        ).limit(1);
        return result.length > 0 ? result[0] : null;
      });
    } catch (error) {
      logger117.error(`Failed to get company with ID ${id}`, error);
      throw new Error("Failed to retrieve company");
    }
  }
  /**
   * Create a new company
   * 
   * @param data Company data to insert
   * @param createdBy User ID of the creator
   * @returns Promise resolving to the created company
   */
  async createCompany(data, createdBy) {
    try {
      return await this.drizzleService.transaction(async (tx) => {
        const companyData = {
          ...data,
          createdBy,
          updatedBy: createdBy
        };
        const [createdCompany] = await tx.insert(companies2).values(companyData).returning();
        return createdCompany;
      });
    } catch (error) {
      logger117.error("Failed to create company", error);
      throw new Error("Failed to create company");
    }
  }
  /**
   * Update an existing company
   * 
   * @param id Company ID to update
   * @param data Company data to update
   * @param updatedBy User ID of the updater
   * @returns Promise resolving to the updated company
   */
  async updateCompany(id, data, updatedBy) {
    try {
      return await this.drizzleService.transaction(async (tx) => {
        const existingCompany = await tx.select().from(companies2).where(
          and73(
            eq88(companies2.id, id),
            isNull17(companies2.deletedAt)
          )
        ).limit(1);
        if (existingCompany.length === 0) {
          return null;
        }
        const companyData = {
          ...data,
          updatedBy,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        const [updatedCompany] = await tx.update(companies2).set(companyData).where(eq88(companies2.id, id)).returning();
        return updatedCompany;
      });
    } catch (error) {
      logger117.error(`Failed to update company with ID ${id}`, error);
      throw new Error("Failed to update company");
    }
  }
  /**
   * Soft delete a company
   * 
   * @param id Company ID to delete
   * @param deletedBy User ID of the person performing the deletion
   * @returns Promise resolving to true if successful, false if company not found
   */
  async deleteCompany(id, deletedBy) {
    try {
      return await this.drizzleService.transaction(async (tx) => {
        const existingCompany = await tx.select().from(companies2).where(
          and73(
            eq88(companies2.id, id),
            isNull17(companies2.deletedAt)
          )
        ).limit(1);
        if (existingCompany.length === 0) {
          return false;
        }
        const [deletedCompany] = await tx.update(companies2).set({
          deletedAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedBy: deletedBy,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        }).where(eq88(companies2.id, id)).returning();
        return !!deletedCompany;
      });
    } catch (error) {
      logger117.error(`Failed to delete company with ID ${id}`, error);
      throw new Error("Failed to delete company");
    }
  }
  /**
   * Search for companies by name or fiscal code
   * 
   * @param searchTerm Search term to look for
   * @param limit Maximum number of results to return
   * @returns Promise resolving to matching companies
   */
  async searchCompanies(searchTerm, limit = 10) {
    try {
      return await this.drizzleService.transaction(async (tx) => {
        const result = await tx.select().from(companies2).where(
          and73(
            isNull17(companies2.deletedAt),
            tx.sql`(${companies2.name} ILIKE ${"%" + searchTerm + "%"} OR
                     ${companies2.fiscalCode} ILIKE ${"%" + searchTerm + "%"})`
          )
        ).limit(limit);
        return result;
      });
    } catch (error) {
      logger117.error(`Failed to search companies with term "${searchTerm}"`, error);
      throw new Error("Failed to search companies");
    }
  }
  /**
   * Get companies with subsidiaries/child companies
   * Returns parent companies with an array of their subsidiaries
   * 
   * @returns Promise resolving to an array of company trees
   */
  async getCompanyHierarchy() {
    try {
      return await this.drizzleService.transaction(async (tx) => {
        const parentCompanies = await tx.select().from(companies2).where(
          and73(
            isNull17(companies2.parentId),
            isNull17(companies2.deletedAt)
          )
        );
        const result = await Promise.all(parentCompanies.map(async (parent) => {
          const subsidiaries = await tx.select().from(companies2).where(
            and73(
              eq88(companies2.parentId, parent.id),
              isNull17(companies2.deletedAt)
            )
          );
          return {
            ...parent,
            subsidiaries
          };
        }));
        return result;
      });
    } catch (error) {
      logger117.error("Failed to get company hierarchy", error);
      throw new Error("Failed to retrieve company hierarchy");
    }
  }
  /**
   * Get franchises
   * Retrieves all franchises, optionally filtered by parent company ID
   * 
   * @param companyId Optional parent company ID to filter franchises by
   * @returns Promise resolving to an array of franchise companies
   */
  async getFranchises(companyId) {
    try {
      logger117.debug(`Getting franchises with filter:`, companyId || "all");
      return await this.drizzleService.company.getFranchises(companyId);
    } catch (error) {
      logger117.error("Failed to get franchises", error);
      throw new Error("Failed to retrieve franchises");
    }
  }
};

// server/modules/company/routes/company.routes.ts
init_auth_guard();
init_auth_mode_enum();
import { Router as Router64 } from "express";
var CompanyRouter = class {
  constructor(companyController) {
    this.companyController = companyController;
    this.router = Router64();
    this.setupRoutes();
  }
  /**
   * Configure all company routes
   */
  setupRoutes() {
    this.router.get(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.companyController.getAllCompanies(req, res)
    );
    this.router.get(
      "/search",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.companyController.searchCompanies(req, res)
    );
    this.router.get(
      "/hierarchy",
      AuthGuard.protect("required" /* REQUIRED */),
      (req, res) => this.companyController.getCompanyHierarchy(req, res)
    );
    this.router.get(
      "/franchises",
      (req, res) => {
        const authReq = req;
        this.companyController.getFranchises(authReq, res);
      }
    );
    this.router.get(
      "/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.companyGuard("id"),
      (req, res) => this.companyController.getCompanyById(req, res)
    );
    this.router.post(
      "/",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */]),
      (req, res) => this.companyController.createCompany(req, res)
    );
    this.router.put(
      "/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */, "company_admin" /* COMPANY_ADMIN */]),
      AuthGuard.companyGuard("id"),
      (req, res) => this.companyController.updateCompany(req, res)
    );
    this.router.delete(
      "/:id",
      AuthGuard.protect("required" /* REQUIRED */),
      AuthGuard.roleGuard(["admin" /* ADMIN */]),
      (req, res) => this.companyController.deleteCompany(req, res)
    );
  }
  /**
   * Get the configured router
   */
  getRouter() {
    return this.router;
  }
};
function createCompanyRouter(companyController) {
  return new CompanyRouter(companyController).getRouter();
}

// server/modules/company/controllers/company.controller.ts
init_logger();
var logger118 = new Logger("CompanyController");
var CompanyController2 = class {
  /**
   * Constructor for the CompanyController
   * @param companyService Injected CompanyService instance
   */
  constructor(companyService) {
    this.companyService = companyService;
  }
  /**
   * Get all companies
   * 
   * @param req Express request with authenticated user
   * @param res Express response
   */
  async getAllCompanies(req, res) {
    try {
      const parentId = req.query.parentId;
      const companies3 = await this.companyService.getAllCompanies(parentId);
      res.status(200).json({
        success: true,
        data: companies3
      });
    } catch (error) {
      logger118.error("Failed to get all companies", error);
      res.status(500).json({
        success: false,
        message: "Failed to retrieve companies"
      });
    }
  }
  /**
   * Get company by ID
   * 
   * @param req Express request with authenticated user
   * @param res Express response
   */
  async getCompanyById(req, res) {
    try {
      const id = req.params.id;
      if (!id) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const company = await this.companyService.getCompanyById(id);
      if (!company) {
        res.status(404).json({
          success: false,
          message: "Company not found"
        });
        return;
      }
      res.status(200).json({
        success: true,
        data: company
      });
    } catch (error) {
      logger118.error(`Failed to get company with ID ${req.params.id}`, error);
      res.status(500).json({
        success: false,
        message: "Failed to retrieve company"
      });
    }
  }
  /**
   * Create a new company
   * 
   * @param req Express request with authenticated user
   * @param res Express response
   */
  async createCompany(req, res) {
    try {
      const validationResult = insertCompanySchema2.safeParse(req.body);
      if (!validationResult.success) {
        res.status(400).json({
          success: false,
          message: "Invalid company data",
          errors: validationResult.error.format()
        });
        return;
      }
      const userId = req.user?.userId || req.user?.id;
      if (!userId) {
        res.status(401).json({
          success: false,
          message: "User not authenticated"
        });
        return;
      }
      const company = await this.companyService.createCompany(
        validationResult.data,
        userId
      );
      res.status(201).json({
        success: true,
        data: company
      });
    } catch (error) {
      logger118.error("Failed to create company", error);
      res.status(500).json({
        success: false,
        message: "Failed to create company"
      });
    }
  }
  /**
   * Update an existing company
   * 
   * @param req Express request with authenticated user
   * @param res Express response
   */
  async updateCompany(req, res) {
    try {
      const id = req.params.id;
      if (!id) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const validationSchema = insertCompanySchema2.partial();
      const validationResult = validationSchema.safeParse(req.body);
      if (!validationResult.success) {
        res.status(400).json({
          success: false,
          message: "Invalid company data",
          errors: validationResult.error.format()
        });
        return;
      }
      const userId = req.user?.userId || req.user?.id;
      if (!userId) {
        res.status(401).json({
          success: false,
          message: "User not authenticated"
        });
        return;
      }
      const updatedCompany = await this.companyService.updateCompany(
        id,
        validationResult.data,
        userId
      );
      if (!updatedCompany) {
        res.status(404).json({
          success: false,
          message: "Company not found"
        });
        return;
      }
      res.status(200).json({
        success: true,
        data: updatedCompany
      });
    } catch (error) {
      logger118.error(`Failed to update company with ID ${req.params.id}`, error);
      res.status(500).json({
        success: false,
        message: "Failed to update company"
      });
    }
  }
  /**
   * Delete a company
   * 
   * @param req Express request with authenticated user
   * @param res Express response
   */
  async deleteCompany(req, res) {
    try {
      const id = req.params.id;
      if (!id) {
        res.status(400).json({
          success: false,
          message: "Company ID is required"
        });
        return;
      }
      const userId = req.user?.userId || req.user?.id;
      if (!userId) {
        res.status(401).json({
          success: false,
          message: "User not authenticated"
        });
        return;
      }
      const success = await this.companyService.deleteCompany(id, userId);
      if (!success) {
        res.status(404).json({
          success: false,
          message: "Company not found"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "Company deleted successfully"
      });
    } catch (error) {
      logger118.error(`Failed to delete company with ID ${req.params.id}`, error);
      res.status(500).json({
        success: false,
        message: "Failed to delete company"
      });
    }
  }
  /**
   * Search companies
   * 
   * @param req Express request with authenticated user
   * @param res Express response
   */
  async searchCompanies(req, res) {
    try {
      const searchTerm = req.query.term;
      const limit = parseInt(req.query.limit) || 10;
      if (!searchTerm) {
        res.status(400).json({
          success: false,
          message: "Search term is required"
        });
        return;
      }
      const companies3 = await this.companyService.searchCompanies(searchTerm, limit);
      res.status(200).json({
        success: true,
        data: companies3
      });
    } catch (error) {
      logger118.error(`Failed to search companies with term "${req.query.term}"`, error);
      res.status(500).json({
        success: false,
        message: "Failed to search companies"
      });
    }
  }
  /**
   * Get company hierarchy
   * 
   * @param req Express request with authenticated user
   * @param res Express response
   */
  async getCompanyHierarchy(req, res) {
    try {
      const hierarchy = await this.companyService.getCompanyHierarchy();
      res.status(200).json({
        success: true,
        data: hierarchy
      });
    } catch (error) {
      logger118.error("Failed to get company hierarchy", error);
      res.status(500).json({
        success: false,
        message: "Failed to retrieve company hierarchy"
      });
    }
  }
  /**
   * Get franchises
   * Retrieves all franchises, optionally filtered by parent company ID
   * 
   * @param req Express request with authenticated user
   * @param res Express response
   */
  async getFranchises(req, res) {
    try {
      console.log(`[CompanyController] Getting franchises, auth user:`, req.user);
      console.log(`[CompanyController] Query params:`, req.query);
      const companyId = req.query.companyId;
      const franchises = await this.companyService.getFranchises(companyId);
      console.log(`[CompanyController] Found ${franchises?.length || 0} franchises`);
      res.status(200).json({
        success: true,
        data: franchises
      });
    } catch (error) {
      logger118.error("Failed to get franchises", error);
      console.error(`[CompanyController] Error getting franchises:`, error);
      res.status(500).json({
        success: false,
        message: "Failed to retrieve franchises",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
};
function createCompanyController(companyService) {
  return new CompanyController2(companyService);
}

// server/modules/company/company.module.ts
init_logger();
var logger119 = new Logger("CompanyModule");
var CompanyModule = {
  name: "company",
  displayName: "Company Management",
  description: "Manages company information and hierarchy",
  version: "1.0.0",
  initialize: initCompanyModule,
  /**
   * Register the module with the application
   * @param app Express application
   * @param drizzleService DrizzleService instance
   * @returns Information about the registered module
   */
  register: (app2, drizzleService5) => {
    const moduleInfo = initCompanyModule(app2, drizzleService5);
    try {
      const { registerModule } = (init_services(), __toCommonJS(services_exports));
      registerModule("company", {
        name: CompanyModule.name,
        version: CompanyModule.version,
        services: moduleInfo.services,
        permissions: CompanyModule.permissions
      });
      logger119.info("Company module registered with service registry");
    } catch (error) {
      logger119.warn("Service registry not available, module services will not be globally accessible");
    }
    return moduleInfo;
  },
  defaultRoles: [
    "company_admin",
    "company_manager",
    "company_viewer"
  ],
  permissions: [
    "company.create",
    "company.read",
    "company.update",
    "company.delete",
    "company.hierarchy.read",
    "company.subsidiaries.manage"
  ],
  routes: [
    {
      path: "/api/companies",
      methods: ["GET", "POST", "PUT", "DELETE"],
      description: "Manage company information"
    },
    {
      path: "/api/companies/search",
      methods: ["GET"],
      description: "Search for companies"
    },
    {
      path: "/api/companies/hierarchy",
      methods: ["GET"],
      description: "Get company hierarchy"
    }
  ],
  dependencies: ["auth", "users"]
};
function initCompanyModule(app2, drizzleService5) {
  logger119.info("Initializing Company module");
  try {
    const companyService = new CompanyService(drizzleService5);
    const companyController = createCompanyController(companyService);
    const companyRouter = createCompanyRouter(companyController);
    if (app2) {
      app2.use("/api/companies", companyRouter);
    }
    logger119.info("Company module initialized successfully");
    return {
      name: CompanyModule.name,
      version: CompanyModule.version,
      services: {
        companyService
      },
      controllers: {
        companyController
      }
    };
  } catch (error) {
    logger119.error("Failed to initialize Company module", error);
    throw new Error("Company module initialization failed");
  }
}

// server/modules/index.ts
async function initializeModules(app2) {
  console.log("Starting minimal module initialization for debugging");
  try {
    const db4 = getDrizzle();
    console.log("Database connection established");
    console.log("Initializing Auth module...");
    const authRouter = initAuthModule(app2, storage.sessionStore);
    console.log("Auth module initialized");
    console.log("Initializing Users module...");
    initUserModule(app2);
    console.log("Users module initialized");
    console.log("Initializing Admin module...");
    const adminModuleInfo = initAdminModule(app2);
    console.log("Admin module initialized");
    console.log("Initializing Invoices module...");
    InvoicesModule.register(app2);
    console.log("Invoices module initialized");
    console.log("Initializing CRM module...");
    initCrmModule(app2);
    console.log("CRM module initialized");
    console.log("Initializing HR module...");
    initHrModule(app2);
    console.log("HR module initialized");
    console.log("Initializing E-Commerce module...");
    ECommerceModule.register(app2, db4);
    console.log("E-Commerce module initialized");
    console.log("Initializing Integrations module...");
    initializeIntegrationsModule(app2);
    console.log("Integrations module initialized");
    console.log("Initializing BPM module...");
    const bpmModule = BpmModule.getInstance();
    bpmModule.initialize(db4);
    bpmModule.registerRoutes(app2);
    console.log("BPM module initialized");
    console.log("Initializing Collaboration module...");
    const collabModule = CollabModule.getInstance();
    collabModule.initialize(db4);
    collabModule.registerRoutes(app2);
    console.log("Collaboration module initialized");
    console.log("Initializing AI module...");
    initAiModule(app2, db4);
    console.log("AI module initialized");
    console.log("Initializing Settings module...");
    const settingsInfo = SettingsModule.registerRoutes(app2);
    console.log("Settings module initialized");
    console.log("Initializing Marketing module...");
    await MarketingModule.register(app2);
    console.log("Marketing module initialized");
    console.log("Initializing Examples module...");
    initExampleModule(app2);
    console.log("Examples module initialized");
    console.log("Initializing Sales module...");
    initSalesModule(app2);
    console.log("Sales module initialized");
    console.log("Initializing Accounting module...");
    initAccountingModule(app2);
    console.log("Accounting module initialized");
    console.log("Initializing Communications module...");
    CommsModule.register(app2, db4);
    console.log("Communications module initialized");
    console.log("Initializing Inventory module...");
    initializeInventoryModule(app2);
    console.log("Inventory module initialized");
    console.log("Initializing Company module...");
    initCompanyModule(app2, db4);
    console.log("Company module initialized");
    console.log("Core modules initialized successfully");
    return {
      authRouter
    };
  } catch (error) {
    console.error("Error during module initialization:", error);
    console.log("Continuing with limited functionality");
    return {};
  }
}

// server/index.ts
init_services();

// server/common/services/registry.init.ts
init_registry();
init_logger();
var logger120 = new Logger("ServiceRegistry");
function registerJournalServices() {
  try {
    logger120.info("Journal services registration pending");
    Services.salesJournal = null;
    Services.purchasesJournal = null;
    Services.bankJournal = null;
    Services.cashRegister = null;
    logger120.info("Accounting journal services registered");
  } catch (error) {
    logger120.error("Failed to register journal services:", error);
  }
}
function initializeServiceRegistry() {
  try {
    logger120.info("Initializing service registry...");
    registerJournalServices();
    Services.queue = null;
    Services.redis = null;
    Services.openai = null;
    logger120.info("Service registry initialized successfully");
  } catch (error) {
    logger120.error("Failed to initialize service registry:", error);
    throw error;
  }
}

// server/index.ts
dotenv3.config();
process.env.BULLMQ_IGNORE_EVICTION_POLICY = "true";
console.log("Starting Express application...");
var app = express9();
app.use(express9.json());
app.use(express9.urlencoded({ extended: false }));
app.use("/templates", express9.static("public/templates"));
app.get("/health", (req, res) => {
  res.status(200).json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
});
app.use((req, res, next) => {
  const start = Date.now();
  const path6 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path6.startsWith("/api")) {
      let logLine = `${req.method} ${path6} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
var httpServer = createServer(app);
(async () => {
  try {
    console.log("Starting server with minimal services for debugging");
    console.log("Initializing modules...");
    await initializeModules(app);
    console.log("Initializing service registry...");
    initializeServiceRegistry();
    console.log("Essential services initialized successfully");
    app.use((err, _req, res, _next) => {
      const status = err.status || err.statusCode || 500;
      const message = err.message || "Internal Server Error";
      console.error("Error handler:", status, message, err.stack);
      res.status(status).json({ message });
    });
    if (app.get("env") === "development") {
      console.log("Setting up Vite development server...");
      await setupVite(app, httpServer);
    } else {
      serveStatic(app);
    }
    const port = 5e3;
    httpServer.listen({
      port,
      host: "0.0.0.0",
      reusePort: true
    }, () => {
      log(`Server is running on port ${port}`);
    });
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
})();
