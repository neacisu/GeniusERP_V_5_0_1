/**
 * Accounting Attachments Service
 * 
 * Serviciu pentru gestionarea ata»ôamentelor la notele contabile
 * ImplementeazƒÉ stocarea documentelor justificative conform OMFP 2634/2015
 */

import fs from 'fs';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { DrizzleService } from '../../../common/drizzle/drizzle.service';
import { AuditLogService } from './audit-log.service';

/**
 * Interface pentru ata»ôament
 */
interface AccountingAttachment {
  id: string;
  ledgerEntryId: string;
  companyId: string;
  fileName: string;
  originalFileName: string;
  filePath: string;
  fileSize: number;
  mimeType: string;
  description?: string;
  attachmentType: AttachmentType;
  uploadedBy: string;
  uploadedAt: Date;
  isActive: boolean;
}

/**
 * Tipuri de ata»ôamente
 */
type AttachmentType = 
  | 'supporting_document'   // Document justificativ
  | 'calculation_note'     // NotƒÉ de calcul
  | 'approval_document'    // Document de aprobare
  | 'correction_note'      // NotƒÉ de corec»õie
  | 'other';              // Altele

/**
 * Request pentru upload ata»ôament
 */
interface UploadAttachmentRequest {
  ledgerEntryId: string;
  companyId: string;
  file: {
    buffer: Buffer;
    originalname: string;
    mimetype: string;
    size: number;
  };
  description?: string;
  attachmentType: AttachmentType;
  userId: string;
}

/**
 * Serviciu pentru ata»ôamente note contabile
 */
export class AccountingAttachmentsService extends DrizzleService {
  private auditService: AuditLogService;
  private readonly UPLOAD_DIR = path.join(process.cwd(), 'uploads', 'accounting-attachments');
  private readonly MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
  private readonly ALLOWED_MIME_TYPES = [
    'application/pdf',
    'image/jpeg',
    'image/png',
    'image/gif',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-excel',
    'text/plain'
  ];

  constructor() {
    super();
    this.auditService = new AuditLogService();
    this.ensureUploadDirectory();
  }

  /**
   * Upload ata»ôament pentru o notƒÉ contabilƒÉ
   */
  async uploadAttachment(request: UploadAttachmentRequest): Promise<AccountingAttachment> {
    // ValidƒÉri
    this.validateFile(request.file);

    // VerificƒÉ dacƒÉ nota contabilƒÉ existƒÉ
    await this.validateLedgerEntry(request.ledgerEntryId, request.companyId);

    // GenereazƒÉ numele unic pentru fi»ôier
    const fileExtension = path.extname(request.file.originalname);
    const uniqueFileName = `${uuidv4()}${fileExtension}`;
    const filePath = path.join(this.UPLOAD_DIR, uniqueFileName);

    try {
      // SalveazƒÉ fi»ôierul pe disc
      await fs.promises.writeFile(filePath, request.file.buffer);

      // CreeazƒÉ √Ænregistrarea √Æn baza de date
      const attachment: AccountingAttachment = {
        id: uuidv4(),
        ledgerEntryId: request.ledgerEntryId,
        companyId: request.companyId,
        fileName: uniqueFileName,
        originalFileName: request.file.originalname,
        filePath,
        fileSize: request.file.size,
        mimeType: request.file.mimetype,
        description: request.description,
        attachmentType: request.attachmentType,
        uploadedBy: request.userId,
        uploadedAt: new Date(),
        isActive: true
      };

      // TODO: SalveazƒÉ √Æn baza de date c√¢nd va fi implementat schema
      // Pentru moment doar simulez salvarea
      console.log(`üíæ Ata»ôament salvat (simulat): ${attachment.originalFileName}`);

      // Log audit
      await this.auditService.log({
        companyId: request.companyId,
        userId: request.userId,
        action: 'ATTACHMENT_UPLOADED' as any,
        severity: 'INFO' as any,
        entityType: 'accounting_attachments',
        entityId: attachment.id,
        description: `Ata»ôament √ÆncƒÉrcat: ${request.file.originalname}`,
        metadata: {
          ledgerEntryId: request.ledgerEntryId,
          fileName: request.file.originalname,
          fileSize: request.file.size,
          attachmentType: request.attachmentType
        }
      });

      console.log(`‚úÖ Ata»ôament √ÆncƒÉrcat cu succes: ${attachment.originalFileName}`);

      return attachment;

    } catch (error) {
      // »òterge fi»ôierul dacƒÉ s-a creat dar a e»ôuat salvarea √Æn BD
      try {
        await fs.promises.unlink(filePath);
      } catch (unlinkError) {
        console.warn('Nu s-a putut »ôterge fi»ôierul temporar:', unlinkError);
      }

      console.error('‚ùå Eroare la √ÆncƒÉrcarea ata»ôamentului:', error);
      throw new Error(`Nu s-a putut √ÆncƒÉrca ata»ôamentul: ${error}`);
    }
  }

  /**
   * Ob»õine ata»ôamentele pentru o notƒÉ contabilƒÉ
   */
  async getAttachmentsForEntry(ledgerEntryId: string, companyId: string): Promise<AccountingAttachment[]> {
    // TODO: ImplementeazƒÉ query √Æn baza de date
    // Pentru moment returnez date simulate
    
    const simulatedAttachments: AccountingAttachment[] = [
      {
        id: 'att_1',
        ledgerEntryId,
        companyId,
        fileName: 'sample_invoice.pdf',
        originalFileName: 'Factura_furnizor_123.pdf',
        filePath: path.join(this.UPLOAD_DIR, 'sample_invoice.pdf'),
        fileSize: 245760,
        mimeType: 'application/pdf',
        description: 'FacturƒÉ justificativƒÉ pentru cheltuielile √Ænregistrate',
        attachmentType: 'supporting_document',
        uploadedBy: 'user123',
        uploadedAt: new Date(),
        isActive: true
      }
    ];

    return simulatedAttachments;
  }

  /**
   * DescarcƒÉ un ata»ôament
   */
  async downloadAttachment(
    attachmentId: string,
    companyId: string,
    userId: string
  ): Promise<{ filePath: string; fileName: string; mimeType: string }> {
    // TODO: Ob»õine ata»ôamentul din baza de date
    // Pentru moment simulez
    
    const attachment = {
      id: attachmentId,
      companyId,
      filePath: path.join(this.UPLOAD_DIR, 'sample_invoice.pdf'),
      originalFileName: 'Factura_furnizor_123.pdf',
      mimeType: 'application/pdf'
    };

    // VerificƒÉ dacƒÉ fi»ôierul existƒÉ fizic
    if (!fs.existsSync(attachment.filePath)) {
      throw new Error('Fi»ôierul ata»ôat nu a fost gƒÉsit pe disc');
    }

    // Log audit pentru descƒÉrcare
    await this.auditService.log({
      companyId,
      userId,
      action: 'ATTACHMENT_DOWNLOADED' as any,
      severity: 'INFO' as any,
      entityType: 'accounting_attachments',
      entityId: attachmentId,
      description: `Ata»ôament descƒÉrcat: ${attachment.originalFileName}`,
      metadata: {
        fileName: attachment.originalFileName
      }
    });

    return {
      filePath: attachment.filePath,
      fileName: attachment.originalFileName,
      mimeType: attachment.mimeType
    };
  }

  /**
   * »òterge un ata»ôament
   */
  async deleteAttachment(
    attachmentId: string,
    companyId: string,
    userId: string,
    reason: string
  ): Promise<void> {
    // TODO: Ob»õine ata»ôamentul din baza de date
    const attachment = {
      id: attachmentId,
      companyId,
      filePath: path.join(this.UPLOAD_DIR, 'sample_file.pdf'),
      originalFileName: 'sample_file.pdf'
    };

    try {
      // MarcheazƒÉ ca »ôters √Æn baza de date (soft delete)
      // TODO: UPDATE accounting_attachments SET is_active = false WHERE id = ...

      // »òterge fi»ôierul fizic (op»õional, depinde de politica companiei)
      if (fs.existsSync(attachment.filePath)) {
        await fs.promises.unlink(attachment.filePath);
      }

      // Log audit
      await this.auditService.log({
        companyId,
        userId,
        action: 'ATTACHMENT_DELETED' as any,
        severity: 'WARNING' as any,
        entityType: 'accounting_attachments',
        entityId: attachmentId,
        description: `Ata»ôament »ôters: ${attachment.originalFileName} - Motiv: ${reason}`,
        metadata: {
          reason,
          fileName: attachment.originalFileName
        }
      });

      console.log(`‚úÖ Ata»ôament »ôters: ${attachment.originalFileName}`);

    } catch (error) {
      console.error('‚ùå Eroare la »ôtergerea ata»ôamentului:', error);
      throw new Error(`Nu s-a putut »ôterge ata»ôamentul: ${error}`);
    }
  }

  /**
   * ValideazƒÉ fi»ôierul √Ænainte de upload
   */
  private validateFile(file: UploadAttachmentRequest['file']): void {
    // VerificƒÉ dimensiunea
    if (file.size > this.MAX_FILE_SIZE) {
      throw new Error(`Fi»ôierul este prea mare. Dimensiunea maximƒÉ este ${this.MAX_FILE_SIZE / 1024 / 1024}MB`);
    }

    // VerificƒÉ tipul MIME
    if (!this.ALLOWED_MIME_TYPES.includes(file.mimetype)) {
      throw new Error(`Tipul de fi»ôier ${file.mimetype} nu este permis`);
    }

    // VerificƒÉ extensia fi»ôierului
    const allowedExtensions = ['.pdf', '.jpg', '.jpeg', '.png', '.gif', '.doc', '.docx', '.xls', '.xlsx', '.txt'];
    const fileExtension = path.extname(file.originalname).toLowerCase();
    
    if (!allowedExtensions.includes(fileExtension)) {
      throw new Error(`Extensia ${fileExtension} nu este permisƒÉ`);
    }

    // VerificƒÉ cƒÉ numele fi»ôierului nu con»õine caractere periculoase
    if (/[<>:"/\\|?*]/.test(file.originalname)) {
      throw new Error('Numele fi»ôierului con»õine caractere interzise');
    }
  }

  /**
   * ValideazƒÉ cƒÉ nota contabilƒÉ existƒÉ »ôi apar»õine companiei
   */
  private async validateLedgerEntry(ledgerEntryId: string, companyId: string): Promise<void> {
    // TODO: ImplementeazƒÉ verificarea √Æn baza de date
    // Pentru moment doar simulez validarea
    
    if (!ledgerEntryId || !companyId) {
      throw new Error('ID-ul notei contabile »ôi al companiei sunt obligatorii');
    }

    // Simulare verificare - √Æn realitate ar trebui sƒÉ fie query √Æn BD
    console.log(`‚úì Validare nota contabilƒÉ ${ledgerEntryId} pentru compania ${companyId}`);
  }

  /**
   * AsigurƒÉ cƒÉ directorul de upload existƒÉ
   */
  private ensureUploadDirectory(): void {
    if (!fs.existsSync(this.UPLOAD_DIR)) {
      fs.mkdirSync(this.UPLOAD_DIR, { recursive: true });
      console.log(`üìÅ Director creat pentru ata»ôamente: ${this.UPLOAD_DIR}`);
    }
  }

  /**
   * Ob»õine informa»õii sumare despre ata»ôamente
   */
  async getAttachmentsSummary(companyId: string): Promise<{
    totalAttachments: number;
    totalSize: number;
    byType: Record<AttachmentType, number>;
  }> {
    // TODO: ImplementeazƒÉ query agregat √Æn baza de date
    
    return {
      totalAttachments: 0,
      totalSize: 0,
      byType: {
        supporting_document: 0,
        calculation_note: 0,
        approval_document: 0,
        correction_note: 0,
        other: 0
      }
    };
  }

  /**
   * CurƒÉ»õare fi»ôiere orfane (fƒÉrƒÉ √ÆnregistrƒÉri √Æn BD)
   */
  async cleanupOrphanedFiles(): Promise<number> {
    try {
      const files = await fs.promises.readdir(this.UPLOAD_DIR);
      const deletedCount = 0;

      for (const fileName of files) {
        const filePath = path.join(this.UPLOAD_DIR, fileName);
        
        // TODO: VerificƒÉ dacƒÉ fi»ôierul existƒÉ √Æn baza de date
        // Pentru moment skip cleanup-ul
        console.log(`üîç Verificare fi»ôier: ${fileName}`);
      }

      console.log(`üßπ Cleanup completat: ${deletedCount} fi»ôiere »ôterse`);
      return deletedCount;

    } catch (error) {
      console.error('‚ùå Eroare la cleanup fi»ôiere:', error);
      return 0;
    }
  }
}

export default AccountingAttachmentsService;
