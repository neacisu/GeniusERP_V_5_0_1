/**
 * ANAF Queue Service
 * 
 * Acest serviciu gestioneazÄƒ cererile cÄƒtre API-ul ANAF folosind BullMQ pentru a evita
 * depÄƒÈ™irea limitelor de rate (1 request/secundÄƒ, maximum 100 CUI-uri per cerere).
 * ImplementeazÄƒ caching, batch processing È™i rate limiting.
 */

import { Queue, Worker, Job } from 'bullmq';
import { nanoid } from 'nanoid';
import Redis from 'ioredis';
import { anafService, AnafCompanyData } from './anaf.service';
import AuditService from '../../../modules/audit/services/audit.service';
// EliminatÄƒ dependenÈ›a de external save
import { getDrizzleInstance } from '../../../common/drizzle/db';
import { anafCompanyData } from '../schema/crm.schema';
import { eq } from 'drizzle-orm';
import { safeIsoString, nowIsoString } from '../utils/date-utils';

// ConfiguraÈ›ia pentru conectarea la Redis
const REDIS_CONNECTION = {
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  maxRetriesPerRequest: null // Necesar pentru BullMQ
};

// Numele cozii BullMQ
const ANAF_QUEUE_NAME = 'anaf-requests';

// Tipul pentru batch-ul de cereri
interface AnafBatchRequest {
  batchId: string;
  cuiList: string[];
  requesterId: string;
  requesterCompanyId: string;
}

// Tipuri pentru callback-uri
type AnafCompanyCallback = (company: AnafCompanyData | null, error?: Error) => void;

// Cache timeout Ã®n secunde (24 ore)
const CACHE_TIMEOUT = 24 * 60 * 60;

export class AnafQueueService {
  private queue: Queue;
  private worker: Worker;
  private redis: Redis;
  private db = getDrizzleInstance();
  
  // Map pentru stocarea callback-urilor
  private callbacks: Map<string, AnafCompanyCallback> = new Map();
  
  constructor() {
    // IniÈ›ializare Redis
    this.redis = new Redis(REDIS_CONNECTION);
    
    // IniÈ›ializare coadÄƒ BullMQ
    this.queue = new Queue(ANAF_QUEUE_NAME, {
      connection: this.redis,
      defaultJobOptions: {
        removeOnComplete: true,
        removeOnFail: 1000, // Keep failed jobs for debugging
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 5000
        }
      }
    });
    
    // IniÈ›ializare worker BullMQ
    this.worker = new Worker(
      ANAF_QUEUE_NAME,
      async (job) => this.processBatch(job),
      { connection: this.redis, concurrency: 1 } // Un singur job la un moment dat pentru a respecta limita de rate
    );
    
    // Log iniÈ›ializare
    console.log('[AnafQueueService] ğŸš€ Serviciu de coadÄƒ ANAF iniÈ›ializat');
    
    // Setare handler pentru erori
    this.worker.on('failed', (job, error) => {
      console.error(`[AnafQueueService] âŒ Job eÈ™uat ${job?.id}:`, error);
    });
    
    // Setare handler pentru completare
    this.worker.on('completed', (job) => {
      console.log(`[AnafQueueService] âœ… Job finalizat ${job.id}`);
    });
  }
  
  /**
   * AdaugÄƒ o cerere Ã®n coadÄƒ pentru un singur CUI
   * VerificÄƒ mai Ã®ntÃ¢i cache-ul, apoi adaugÄƒ cererea Ã®n coada de batch dacÄƒ e necesar
   * 
   * @param cui Codul fiscal (cu sau fÄƒrÄƒ RO)
   * @param userId ID-ul utilizatorului care face cererea
   * @param companyId ID-ul companiei utilizatorului  
   * @returns Promise cu datele companiei
   */
  async queueCompanyRequest(cui: string, userId: string, companyId: string): Promise<AnafCompanyData | null> {
    // CurÄƒÈ›Äƒ CUI-ul
    const cleanCui = cui.replace(/^RO/i, '').trim();
    
    console.log(`[AnafQueueService] ğŸ“ Ãncepe procesarea cererii pentru CUI ${cleanCui}`);
    
    // VerificÄƒ cache-ul
    const cachedData = await this.getFromCache(cleanCui);
    if (cachedData) {
      console.log(`[AnafQueueService] ğŸ” Date gÄƒsite Ã®n cache pentru CUI ${cleanCui}`);
      
      // VerificÄƒ dacÄƒ existÄƒ È™i Ã®n DB - dacÄƒ nu, salveazÄƒ din cache Ã®n DB
      const existsInDb = await this.checkExistsInDatabase(cleanCui);
      if (!existsInDb) {
        console.log(`[AnafQueueService] ğŸ’¾ Date gÄƒsite Ã®n cache dar nu Ã®n baza de date pentru CUI ${cleanCui}, salvÄƒm Ã®n DB`);
        await this.saveToDatabase(cachedData, userId, companyId);
      }
      
      return cachedData;
    }
    
    // VerificÄƒ DB-ul
    const dbData = await this.getFromDatabase(cleanCui);
    if (dbData) {
      console.log(`[AnafQueueService] ğŸ” Date gÄƒsite Ã®n baza de date pentru CUI ${cleanCui}`);
      // ActualizeazÄƒ È™i cache-ul
      await this.addToCache(cleanCui, dbData);
      return dbData;
    }
    
    console.log(`[AnafQueueService] ğŸ“‹ Nu s-au gÄƒsit date locale pentru CUI ${cleanCui}, se adaugÄƒ Ã®n batch`);
    
    // DacÄƒ nu existÄƒ Ã®n cache, creeazÄƒ o cerere nouÄƒ
    return new Promise((resolve, reject) => {
      // GenereazÄƒ un ID unic pentru cerere
      const requestId = nanoid();
      
      console.log(`[AnafQueueService] ğŸ†” Generat ID pentru cerere: ${requestId} pentru CUI ${cleanCui}`);
      
      // SalveazÄƒ callback-ul pentru a fi apelat cÃ¢nd avem rezultatul
      this.callbacks.set(requestId, (company, error) => {
        if (error) {
          console.error(`[AnafQueueService] âŒ Eroare la callback pentru CUI ${cleanCui}:`, error);
          reject(error);
        } else {
          console.log(`[AnafQueueService] âœ… Callback executat cu succes pentru CUI ${cleanCui}`);
          resolve(company);
        }
      });
      
      // AdaugÄƒ CUI-ul Ã®n batch
      this.addToBatch(cleanCui, requestId, userId, companyId);
    });
  }
  
  /**
   * AdaugÄƒ un CUI la un batch de cereri sau creeazÄƒ un batch nou
   * 
   * @param cui Codul fiscal
   * @param requestId ID-ul cererii
   * @param userId ID-ul utilizatorului
   * @param companyId ID-ul companiei
   */
  private async addToBatch(cui: string, requestId: string, userId: string, companyId: string): Promise<void> {
    try {
      // SalvÄƒm asocierea CUI - requestId pentru a È™ti la ce cerere aparÈ›ine rezultatul
      await this.redis.set(`anaf:request:${cui}`, requestId, 'EX', 3600); // ExpirÄƒ dupÄƒ 1 orÄƒ
      
      // GenerÄƒm un timer de 500ms pentru a grupa mai multe cereri Ã®n acelaÈ™i batch
      setTimeout(async () => {
        // VerificÄƒm dacÄƒ mai existÄƒ deja un batch Ã®n aÈ™teptare
        const pendingBatch = await this.redis.get('anaf:pending-batch');
        
        if (pendingBatch) {
          // AdÄƒugÄƒm CUI-ul la batch-ul existent
          const batch: AnafBatchRequest = JSON.parse(pendingBatch);
          
          // VerificÄƒm dacÄƒ CUI-ul nu este deja Ã®n batch
          if (!batch.cuiList.includes(cui)) {
            batch.cuiList.push(cui);
            
            // DacÄƒ am atins limita de 100 de CUI-uri sau alt prag, trimitem batch-ul
            if (batch.cuiList.length >= 50) { // Folosim 50 ca limitÄƒ pentru siguranÈ›Äƒ
              // È˜tergem batch-ul din Redis
              await this.redis.del('anaf:pending-batch');
              
              // AdÄƒugÄƒm batch-ul Ã®n coadÄƒ
              await this.queue.add('anaf-batch', batch);
              console.log(`[AnafQueueService] ğŸ“¦ Batch trimis cu ${batch.cuiList.length} CUI-uri`);
            } else {
              // ActualizÄƒm batch-ul Ã®n Redis
              await this.redis.set('anaf:pending-batch', JSON.stringify(batch), 'EX', 60);
            }
          }
        } else {
          // CreÄƒm un batch nou
          const newBatch: AnafBatchRequest = {
            batchId: nanoid(),
            cuiList: [cui],
            requesterId: userId,
            requesterCompanyId: companyId
          };
          
          // SalvÄƒm batch-ul Ã®n Redis
          await this.redis.set('anaf:pending-batch', JSON.stringify(newBatch), 'EX', 60);
          
          // SetÄƒm un timer pentru a trimite batch-ul dupÄƒ o perioadÄƒ, chiar dacÄƒ nu atinge limita
          setTimeout(async () => {
            // VerificÄƒm dacÄƒ batch-ul mai existÄƒ
            const currentBatch = await this.redis.get('anaf:pending-batch');
            if (currentBatch) {
              const batch: AnafBatchRequest = JSON.parse(currentBatch);
              
              // VerificÄƒm dacÄƒ ID-ul batch-ului este acelaÈ™i
              if (batch.batchId === newBatch.batchId) {
                // È˜tergem batch-ul din Redis
                await this.redis.del('anaf:pending-batch');
                
                // AdÄƒugÄƒm batch-ul Ã®n coadÄƒ doar dacÄƒ conÈ›ine cel puÈ›in un CUI
                if (batch.cuiList.length > 0) {
                  await this.queue.add('anaf-batch', batch);
                  console.log(`[AnafQueueService] â±ï¸ Timeout batch cu ${batch.cuiList.length} CUI-uri`);
                }
              }
            }
          }, 2000); // Trimite batch-ul dupÄƒ 2 secunde dacÄƒ nu s-au mai adÄƒugat cereri
        }
      }, 100); // 100ms delay pentru a permite gruparea cererilor
    } catch (error) {
      console.error('[AnafQueueService] âŒ Eroare la adÄƒugarea Ã®n batch:', error);
      
      // ApelÄƒm callback-ul cu eroare
      const callback = this.callbacks.get(requestId);
      if (callback) {
        callback(null, error instanceof Error ? error : new Error(String(error)));
        this.callbacks.delete(requestId);
      }
    }
  }
  
  /**
   * ProceseazÄƒ un batch de cereri ANAF
   * 
   * @param job Job-ul BullMQ 
   */
  private async processBatch(job: Job): Promise<void> {
    try {
      const batch = job.data as AnafBatchRequest;
      console.log(`[AnafQueueService] ğŸ”„ Procesare batch ${batch.batchId} cu ${batch.cuiList.length} CUI-uri`);
      
      // ÃmpÄƒrÈ›im CUI-urile Ã®n batch-uri mai mici dacÄƒ este necesar
      const maxBatchSize = 100; // Limita API-ului ANAF
      const batches: string[][] = [];
      
      for (let i = 0; i < batch.cuiList.length; i += maxBatchSize) {
        batches.push(batch.cuiList.slice(i, i + maxBatchSize));
      }
      
      // ProcesÄƒm fiecare sub-batch
      for (const subBatch of batches) {
        try {
          const response = await anafService.queryAnaf(subBatch);
          console.log(`[AnafQueueService] âœ… RÄƒspuns ANAF pentru sub-batch: ${response.found.length} gÄƒsite, ${response.notFound.length} negÄƒsite`);
          
          // ProcesÄƒm companiile gÄƒsite
          for (const company of response.found) {
            const cui = company.date_generale.cui;
            
            // SalvÄƒm datele Ã®n cache
            await this.addToCache(cui, company);
            
            // SalvÄƒm datele Ã®n baza de date
            await this.saveToDatabase(company, batch.requesterId, batch.requesterCompanyId);
            
            // ApelÄƒm callback-ul asociat cu acest CUI
            const requestId = await this.redis.get(`anaf:request:${cui}`);
            if (requestId) {
              const callback = this.callbacks.get(requestId);
              if (callback) {
                callback(company);
                this.callbacks.delete(requestId);
              }
              
              // È˜tergem asocierea din Redis
              await this.redis.del(`anaf:request:${cui}`);
            }
          }
          
          // ProcesÄƒm CUI-urile negÄƒsite
          for (const cui of response.notFound) {
            const requestId = await this.redis.get(`anaf:request:${cui}`);
            if (requestId) {
              const callback = this.callbacks.get(requestId);
              if (callback) {
                callback(null);
                this.callbacks.delete(requestId);
              }
              
              // È˜tergem asocierea din Redis
              await this.redis.del(`anaf:request:${cui}`);
            }
          }
        } catch (error) {
          console.error(`[AnafQueueService] âŒ Eroare la interogarea sub-batch ANAF:`, error);
          
          // GestionÄƒm erorile pentru acest sub-batch
          // DacÄƒ eÈ™ueazÄƒ, Ã®ncercÄƒm sÄƒ apelÄƒm callback-urile cu erori
          for (const cui of subBatch) {
            const requestId = await this.redis.get(`anaf:request:${cui}`);
            if (requestId) {
              const callback = this.callbacks.get(requestId);
              if (callback) {
                callback(null, error instanceof Error ? error : new Error(String(error)));
                this.callbacks.delete(requestId);
              }
              
              // È˜tergem asocierea din Redis
              await this.redis.del(`anaf:request:${cui}`);
            }
          }
        }
        
        // AÈ™teptÄƒm 1 secundÄƒ Ã®ntre sub-batch-uri pentru a respecta limita de rate
        if (batches.length > 1) {
          await new Promise(resolve => setTimeout(resolve, 1100)); // 1.1 secunde pentru siguranÈ›Äƒ
        }
      }
      
      console.log(`[AnafQueueService] âœ… Procesare batch ${batch.batchId} finalizatÄƒ`);
    } catch (error) {
      console.error(`[AnafQueueService] âŒ Eroare la procesarea batch-ului:`, error);
      throw error; // PropagÄƒm eroarea pentru ca BullMQ sÄƒ poatÄƒ face retry
    }
  }
  
  /**
   * SalveazÄƒ datele unei companii Ã®n cache
   * 
   * @param cui CUI-ul companiei
   * @param data Datele companiei
   */
  private async addToCache(cui: string, data: AnafCompanyData): Promise<void> {
    try {
      await this.redis.set(`anaf:company:${cui}`, JSON.stringify(data), 'EX', CACHE_TIMEOUT);
    } catch (error) {
      console.error(`[AnafQueueService] âŒ Eroare la salvarea Ã®n cache:`, error);
    }
  }
  
  /**
   * ObÈ›ine datele unei companii din cache
   * 
   * @param cui CUI-ul companiei
   * @returns Datele companiei sau null dacÄƒ nu existÄƒ Ã®n cache
   */
  private async getFromCache(cui: string): Promise<AnafCompanyData | null> {
    try {
      const data = await this.redis.get(`anaf:company:${cui}`);
      if (data) {
        return JSON.parse(data) as AnafCompanyData;
      }
      return null;
    } catch (error) {
      console.error(`[AnafQueueService] âŒ Eroare la obÈ›inerea din cache:`, error);
      return null;
    }
  }
  
  /**
   * SalveazÄƒ datele unei companii Ã®n baza de date
   * 
   * @param company Datele companiei
   * @param userId ID-ul utilizatorului care a fÄƒcut cererea
   * @param companyId ID-ul companiei utilizatorului
   */
  private async saveToDatabase(company: AnafCompanyData, userId: string, companyId: string): Promise<void> {
    try {
      const cui = company.date_generale.cui;
      console.log(`[AnafQueueService] ğŸ’¾ Salvare date ANAF pentru CUI ${cui} Ã®n baza de date`);
      
      // TratÄƒm cazul cÃ¢nd perioade_TVA poate fi un array sau un obiect direct
      let perioadeArray: any[] = [];
      const perioadeTva = company.inregistrare_scop_Tva?.perioade_TVA;
      
      if (perioadeTva) {
        if (Array.isArray(perioadeTva)) {
          perioadeArray = perioadeTva;
        } else {
          // DacÄƒ nu e array, Ã®l tratÄƒm ca un singur obiect È™i Ã®l punem Ã®ntr-un array
          perioadeArray = [perioadeTva];
        }
      }
      
      // Convertim datele Ã®n formatul corect pentru baza de date (Date object)
      const convertToDate = (dateStr: string | null | undefined): Date | null => {
        if (!dateStr) return null;
        if (dateStr === '') return null;
        
        // DacÄƒ este deja un obiect Date, Ã®l returnÄƒm direct
        if (dateStr instanceof Date) return dateStr;
        
        try {
          // NormalizÄƒm stringul
          const trimmedDate = typeof dateStr === 'string' ? dateStr.trim() : dateStr;
          
          // Pentru date Ã®n format PostgreSQL sau ISO (YYYY-MM-DD sau YYYY-MM-DDTHH:MM:SS)
          if (typeof trimmedDate === 'string' && trimmedDate.match(/^\d{4}-\d{2}-\d{2}(T.*)?$/)) {
            const dateObj = new Date(trimmedDate);
            if (!isNaN(dateObj.getTime())) {
              return dateObj;
            }
          }
          
          // Pentru formate tip ANAF (DD.MM.YYYY)
          if (typeof trimmedDate === 'string' && trimmedDate.includes('.') && trimmedDate.match(/^\d{2}\.\d{2}\.\d{4}$/)) {
            const parts = trimmedDate.split('.');
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Luna Ã®n JS este 0-indexed
            const year = parseInt(parts[2], 10);
            
            // ValidÄƒm componentele
            if (!isNaN(day) && !isNaN(month) && !isNaN(year) && 
                day >= 1 && day <= 31 && month >= 0 && month <= 11 && year >= 1900) {
              const date = new Date(year, month, day, 12, 0, 0); // SetÄƒm ora la 12 pentru a evita probleme de fus orar
              
              // VerificÄƒm dacÄƒ data rezultatÄƒ e validÄƒ
              if (!isNaN(date.getTime())) {
                return date;
              }
            }
          }
          
          // ANAF foloseÈ™te È™i formatul YYYY-MM-DD
          if (typeof trimmedDate === 'string' && trimmedDate.includes('-')) {
            const parts = trimmedDate.split('-');
            if (parts.length === 3) {
              const year = parseInt(parts[0]);
              const month = parseInt(parts[1]) - 1; // Lunile sunt indexate de la 0
              const day = parseInt(parts[2]);
              
              // ValidÄƒm datele
              if (!isNaN(year) && !isNaN(month) && !isNaN(day) && 
                  year >= 1900 && year <= 2100 && month >= 0 && month <= 11 && day >= 1 && day <= 31) {
                const date = new Date(year, month, day, 12, 0, 0); // SetÄƒm ora la 12 pentru a evita probleme de fus orar
                
                // VerificÄƒm dacÄƒ data rezultatÄƒ este validÄƒ
                if (!isNaN(date.getTime())) {
                  return date;
                }
              }
            }
          }
          
          // Pentru timestamp-uri (numÄƒr sau string numeric)
          if (typeof trimmedDate === 'string' && /^\d+$/.test(trimmedDate)) {
            const timestamp = parseInt(trimmedDate, 10);
            const timestampDate = new Date(timestamp);
            if (!isNaN(timestampDate.getTime())) {
              return timestampDate;
            }
          }
          
          // ÃncercÄƒm cu Date() direct dacÄƒ formatul este diferit
          if (typeof trimmedDate === 'string') {
            const date = new Date(trimmedDate);
            if (!isNaN(date.getTime())) {
              return date;
            }
          }
          
          console.warn(`[AnafQueueService] âš ï¸ Format de datÄƒ nerecunoscut sau invalid: ${trimmedDate}`);
          return null;
        } catch (e) {
          console.error(`[AnafQueueService] âŒ Eroare la conversia datei [${dateStr}]:`, e);
          return null;
        }
      };
      
      // VerificÄƒm dacÄƒ existÄƒ deja Ã®nregistrarea
      const existingRecord = await this.db.select().from(anafCompanyData).where(eq(anafCompanyData.cui, cui));
      
      // VerificÄƒm dacÄƒ existÄƒ perioade TVA È™i extragem prima
      const inregistrareTva = company.inregistrare_scop_Tva || {};
      const perioadeArrayTva = inregistrareTva.perioade_TVA || [];
      const primaPerioadaTva = perioadeArrayTva[0] || {};
      
      /**
       * FuncÈ›ia robustÄƒ globalÄƒ pentru conversia datelor Ã®n format ISO string sau null
       * GestioneazÄƒ multiple formate de date inclusiv ISO, romÃ¢nesc, È™i timestamp
       * 
       * @param value Valoarea de convertit (string, Date, timestamp, etc.)
       * @returns String Ã®n format ISO 8601 sau null dacÄƒ conversia nu este posibilÄƒ
       */
      const toIsoString = (value: any): string | null => {
        if (value === null || value === undefined || value === '') return null;
        
        // DacÄƒ e deja un Date, convertim direct la ISO string
        if (value instanceof Date) {
          return isNaN(value.getTime()) ? null : value.toISOString();
        }
        
        // DacÄƒ e numeric (timestamp), convertim la Date
        if (typeof value === 'number') {
          try {
            const date = new Date(value);
            return isNaN(date.getTime()) ? null : date.toISOString();
          } catch (e) {
            console.error(`[AnafQueueService] âŒ Eroare la conversia timestamp [${value}] Ã®n ISO string:`, e);
            return null;
          }
        }
        
        // DacÄƒ e string, verificÄƒm diverse formate
        if (typeof value === 'string') {
          // CurÄƒÈ›Äƒm stringul
          const cleanValue = value.trim();
          
          // VerificÄƒm dacÄƒ e deja Ã®n format ISO
          if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(cleanValue)) {
            return cleanValue; // deja e Ã®n format ISO
          }
          
          // Pattern pentru data Ã®n format YYYY-MM-DD
          if (/^\d{4}-\d{2}-\d{2}$/.test(cleanValue)) {
            return `${cleanValue}T00:00:00.000Z`;
          }
          
          // Pattern pentru data Ã®n format DD.MM.YYYY (romÃ¢nesc cu punct)
          if (/^\d{2}\.\d{2}\.\d{4}$/.test(cleanValue)) {
            const parts = cleanValue.split('.');
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Luna 0-11 Ã®n JS
            const year = parseInt(parts[2], 10);
            const date = new Date(Date.UTC(year, month, day));
            return isNaN(date.getTime()) ? null : date.toISOString();
          }
          
          // Pattern pentru data Ã®n format DD-MM-YYYY (romÃ¢nesc cu liniuÈ›Äƒ)
          if (/^\d{2}-\d{2}-\d{4}$/.test(cleanValue)) {
            const parts = cleanValue.split('-');
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // Luna 0-11 Ã®n JS
            const year = parseInt(parts[2], 10);
            const date = new Date(Date.UTC(year, month, day));
            return isNaN(date.getTime()) ? null : date.toISOString();
          }
          
          // ÃncercÄƒm sÄƒ convertim direct ca ultimÄƒ opÈ›iune
          try {
            const date = new Date(cleanValue);
            // VerificÄƒm explicit dacÄƒ avem o datÄƒ validÄƒ
            if (!isNaN(date.getTime())) {
              return date.toISOString();
            }
            return null;
          } catch (e) {
            console.error(`[AnafQueueService] âŒ Eroare la conversia datei [${cleanValue}] Ã®n ISO string:`, e);
            return null;
          }
        }
        
        // Alte tipuri nu sunt acceptate
        console.warn(`[AnafQueueService] âš ï¸ Tip de datÄƒ neacceptat pentru conversie: ${typeof value}`);
        return null;
      };
      
      // MapÄƒm cÃ¢mpurile din API la structura bazei noastre de date
      const anafData = {
        companyId: companyId || undefined, // Folosim undefined Ã®n loc de null pentru Drizzle
        cui: cui,
        dataInterogare: company.date_generale?.data || null,
        denumire: company.date_generale?.denumire || null,
        adresa: company.date_generale?.adresa || null,
        nrRegCom: company.date_generale?.nrRegCom || null,
        telefon: company.date_generale?.telefon || null,
        fax: company.date_generale?.fax || null,
        codPostal: company.date_generale?.codPostal || null,
        act: company.date_generale?.act || null,
        stareInregistrare: company.date_generale?.stare_inregistrare || null,
        dataInregistrare: company.date_generale?.data_inregistrare || null,
        codCaen: company.date_generale?.cod_CAEN || null,
        iban: company.date_generale?.iban || null,
        statusRoEFactura: company.date_generale?.statusRO_e_Factura || false,
        organFiscalCompetent: company.date_generale?.organ_fiscal_competent || null,
        formaJuridica: company.date_generale?.forma_juridica || null,
        formaOrganizare: company.date_generale?.forma_organizare || null,
        formaProprietate: company.date_generale?.forma_de_proprietate || null,
        
        // Date fiscale È™i TVA
        platitorTva: inregistrareTva?.scpTVA || false,
        dataTva: primaPerioadaTva?.data || null,
        dataStartTva: primaPerioadaTva?.data_inceput_ScpTVA || null,
        dataEndTva: primaPerioadaTva?.data_sfarsit_ScpTVA || null,
        mesajTva: primaPerioadaTva?.mesaj_ScpTVA || null,
        statusTva: primaPerioadaTva?.statusScpTVA || null,
        
        // TVA la Ã®ncasare - structura corectatÄƒ
        platitorTvaIncasare: company.inregistrare_RTVAI?.statusTvaIncasare || false,
        dataInceputTvaIncasare: company.inregistrare_RTVAI?.dataInceputTvaInc || null,
        dataAnulareTvaIncasare: null, // Acest cÃ¢mp nu existÄƒ Ã®n APIv9, trebuie calculat sau lÄƒsat null
        dataPanaLaTvaIncasare: company.inregistrare_RTVAI?.dataSfarsitTvaInc || null,
        
        // Split TVA - structura corectatÄƒ
        platitorTvaSplit: company.inregistrare_SplitTVA?.statusSplitTVA || false,
        dataInregistrareTvaSplit: company.inregistrare_SplitTVA?.dataInceputSplitTVA || null,
        dataRadiereTvaSplit: company.inregistrare_SplitTVA?.dataSfarsitSplitTVA || null,
        
        // Alte date fiscale
        statusInactivi: company.stare_inactiv?.statusInactivi || false,
        dataInactivare: company.stare_inactiv?.dataInactivare || null,
        dataReactivare: company.stare_inactiv?.dataReactivare || null,
        dataPublicare: company.stare_inactiv?.dataPublicare || null,
        dataRadiere: company.stare_inactiv?.dataRadiere || null,
        
        // Split TVA È™i insolvenÈ›Äƒ
        statusSplitTva: company.inregistrare_SplitTVA?.statusSplitTVA || false,
        dataInceputSplitTva: company.inregistrare_SplitTVA?.dataInceputSplitTVA || null,
        statusInsolventa: company.inregistrare_RISF?.dataInceputRISF ? true : false,
        dataInceputInsolventa: company.inregistrare_RISF?.dataInceputRISF || null,
        dataInchidereInsolventa: company.inregistrare_RISF?.dataInchidereRISF || null,
        
        // Capitol TVA È™i alte metadate
        capitolTva: inregistrareTva.capitol || null,
        
        // Stare È™i metadate
        statusActiv: true,
        rawResponse: JSON.stringify(company),
        lastCheckedAt: new Date().toISOString(),
        observatii: null,
        isUpdatedFromAnaf: true,
        
        // Timestamps pentru audit
        createdAt: existingRecord.length > 0 ? undefined : new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      // SalvÄƒm Ã®n baza de date
      if (existingRecord.length > 0) {
        // ActualizÄƒm Ã®nregistrarea existentÄƒ
        console.log(`[AnafQueueService] ğŸ”„ ActualizÄƒm datele pentru CUI ${cui}`);
        
        // Folosim funcÈ›ia robustÄƒ globalÄƒ definitÄƒ la linia 488
        
        // FiltrÄƒm doar cÃ¢mpurile care existÄƒ Ã®n schema bazei de date
        // È™i convertim valorile temporale Ã®n ISO string pentru compatibilitate cu Postgres
        // Folosim funcÈ›ia robustÄƒ globalÄƒ toIsoString definitÄƒ mai sus
        const normalizedData = {
          cui: anafData.cui,
          companyId: anafData.companyId,
          dataInterogare: anafData.dataInterogare,
          denumire: anafData.denumire,
          adresa: anafData.adresa,
          nrRegCom: anafData.nrRegCom,
          telefon: anafData.telefon,
          fax: anafData.fax,
          codPostal: anafData.codPostal,
          act: anafData.act,
          stareInregistrare: anafData.stareInregistrare,
          
          // Date tipuri temporale - CONVERTITE LA ISO STRING
          dataInregistrare: toIsoString(anafData.dataInregistrare),
          dataStartTva: toIsoString(anafData.dataStartTva),
          dataEndTva: toIsoString(anafData.dataEndTva),
          dataInceputTvaIncasare: toIsoString(anafData.dataInceputTvaIncasare),
          dataAnulareTvaIncasare: toIsoString(anafData.dataAnulareTvaIncasare),
          dataPanaLaTvaIncasare: toIsoString(anafData.dataPanaLaTvaIncasare),
          dataInregistrareTvaSplit: toIsoString(anafData.dataInregistrareTvaSplit),
          dataRadiereTvaSplit: toIsoString(anafData.dataRadiereTvaSplit),
          dataInactivare: toIsoString(anafData.dataInactivare),
          dataReactivare: toIsoString(anafData.dataReactivare),
          dataPublicare: toIsoString(anafData.dataPublicare),
          dataRadiere: toIsoString(anafData.dataRadiere),
          dataInceputSplitTva: toIsoString(anafData.dataInceputSplitTva),
          dataInceputInsolventa: toIsoString(anafData.dataInceputInsolventa),
          dataInchidereInsolventa: toIsoString(anafData.dataInchidereInsolventa),
          
          // Valori booleene È™i text
          codCaen: anafData.codCaen,
          iban: anafData.iban,
          statusRoEFactura: anafData.statusRoEFactura,
          organFiscalCompetent: anafData.organFiscalCompetent,
          formaJuridica: anafData.formaJuridica,
          formaOrganizare: anafData.formaOrganizare,
          formaProprietate: anafData.formaProprietate,
          
          // TVA È™i fiscalitate
          platitorTva: anafData.platitorTva,
          dataTva: toIsoString(anafData.dataTva),
          mesajTva: anafData.mesajTva,
          statusTva: anafData.statusTva,
          platitorTvaIncasare: anafData.platitorTvaIncasare,
          platitorTvaSplit: anafData.platitorTvaSplit,
          statusInactivi: anafData.statusInactivi,
          statusSplitTva: anafData.statusSplitTva,
          statusInsolventa: anafData.statusInsolventa,
          capitolTva: anafData.capitolTva,
          
          // Metadata
          statusActiv: anafData.statusActiv,
          rawResponse: anafData.rawResponse,
          lastCheckedAt: toIsoString(new Date()),
          observatii: anafData.observatii,
          isUpdatedFromAnaf: anafData.isUpdatedFromAnaf,
          
          // Date audit
          updatedAt: toIsoString(new Date()),
          updatedBy: userId || undefined
        };
        
        await this.db.update(anafCompanyData)
          .set(normalizedData)
          .where(eq(anafCompanyData.cui, cui));
          
        console.log(`[AnafQueueService] âœ… Date ANAF actualizate pentru CUI ${cui}`);
      } else {
        // InserÄƒm o nouÄƒ Ã®nregistrare
        console.log(`[AnafQueueService] ğŸ“¥ InserÄƒm date ANAF noi pentru CUI ${cui}`);
        
        // FiltrÄƒm doar cÃ¢mpurile care existÄƒ Ã®n schema bazei de date
        // È™i convertim valorile temporale È™i de tip potrivit
        // Folosim funcÈ›ia robustÄƒ globalÄƒ toIsoString definitÄƒ mai sus
        
        const normalizedData = {
          cui: anafData.cui,
          companyId: anafData.companyId,
          dataInterogare: anafData.dataInterogare,
          denumire: anafData.denumire,
          adresa: anafData.adresa,
          nrRegCom: anafData.nrRegCom,
          telefon: anafData.telefon,
          fax: anafData.fax,
          codPostal: anafData.codPostal,
          act: anafData.act,
          stareInregistrare: anafData.stareInregistrare,
          
          // Date tipuri temporale - CONVERTITE LA ISO STRING
          dataInregistrare: toIsoString(anafData.dataInregistrare),
          dataStartTva: toIsoString(anafData.dataStartTva),
          dataEndTva: toIsoString(anafData.dataEndTva),
          dataInceputTvaIncasare: toIsoString(anafData.dataInceputTvaIncasare),
          dataAnulareTvaIncasare: toIsoString(anafData.dataAnulareTvaIncasare),
          dataPanaLaTvaIncasare: toIsoString(anafData.dataPanaLaTvaIncasare),
          dataInregistrareTvaSplit: toIsoString(anafData.dataInregistrareTvaSplit),
          dataRadiereTvaSplit: toIsoString(anafData.dataRadiereTvaSplit),
          dataInactivare: toIsoString(anafData.dataInactivare),
          dataReactivare: toIsoString(anafData.dataReactivare),
          dataPublicare: toIsoString(anafData.dataPublicare),
          dataRadiere: toIsoString(anafData.dataRadiere),
          dataInceputSplitTva: toIsoString(anafData.dataInceputSplitTva),
          dataInceputInsolventa: toIsoString(anafData.dataInceputInsolventa),
          dataInchidereInsolventa: toIsoString(anafData.dataInchidereInsolventa),
          
          // Valori booleene È™i text
          codCaen: anafData.codCaen,
          iban: anafData.iban,
          statusRoEFactura: anafData.statusRoEFactura,
          organFiscalCompetent: anafData.organFiscalCompetent,
          formaJuridica: anafData.formaJuridica,
          formaOrganizare: anafData.formaOrganizare,
          formaProprietate: anafData.formaProprietate,
          
          // TVA È™i fiscalitate
          platitorTva: anafData.platitorTva,
          dataTva: toIsoString(anafData.dataTva),
          mesajTva: anafData.mesajTva,
          statusTva: anafData.statusTva,
          platitorTvaIncasare: anafData.platitorTvaIncasare,
          platitorTvaSplit: anafData.platitorTvaSplit,
          statusInactivi: anafData.statusInactivi,
          statusSplitTva: anafData.statusSplitTva,
          statusInsolventa: anafData.statusInsolventa,
          capitolTva: anafData.capitolTva,
          
          // Metadata
          statusActiv: anafData.statusActiv,
          rawResponse: anafData.rawResponse,
          lastCheckedAt: toIsoString(new Date()),
          observatii: anafData.observatii,
          isUpdatedFromAnaf: anafData.isUpdatedFromAnaf,
          
          // Date audit
          createdAt: toIsoString(new Date()),
          updatedAt: toIsoString(new Date()),
          createdBy: userId || undefined,
          updatedBy: userId || undefined
        };
        
        await this.db.insert(anafCompanyData).values(normalizedData);
        console.log(`[AnafQueueService] âœ… Date ANAF noi inserate pentru CUI ${cui}`);
      }
      
      // Auditare
      AuditService.log({
        userId: userId || 'system',
        companyId: companyId || 'unknown',
        action: 'anaf_company_data_saved',
        entity: 'anaf_company_data',
        details: { 
          cui,
          success: true 
        }
      });
      
      console.log(`[AnafQueueService] âœ… Date ANAF pentru CUI ${cui} salvate Ã®n baza de date`);
    } catch (error) {
      console.error('[AnafQueueService] âŒ Eroare la salvarea datelor ANAF Ã®n baza de date:', error);
    }
  }
  
  /**
   * ObÈ›ine datele unei companii din baza de date
   * 
   * @param cui CUI-ul companiei  
   * @returns Datele companiei sau null dacÄƒ nu existÄƒ
   */
  /**
   * VerificÄƒ dacÄƒ existÄƒ o Ã®nregistrare Ã®n baza de date pentru acest CUI
   * 
   * @param cui CUI-ul companiei
   * @returns true dacÄƒ existÄƒ, false dacÄƒ nu
   */
  private async checkExistsInDatabase(cui: string): Promise<boolean> {
    try {
      const record = await this.db.select({ id: anafCompanyData.id }).from(anafCompanyData).where(eq(anafCompanyData.cui, cui));
      return record.length > 0;
    } catch (error) {
      console.error('[AnafQueueService] âŒ Eroare la verificarea existenÈ›ei Ã®n baza de date:', error);
      return false;
    }
  }

  /**
   * ObÈ›ine datele unei companii din baza de date
   * 
   * @param cui CUI-ul companiei  
   * @returns Datele companiei sau null dacÄƒ nu existÄƒ
   */
  private async getFromDatabase(cui: string): Promise<AnafCompanyData | null> {
    try {
      const record = await this.db.select().from(anafCompanyData).where(eq(anafCompanyData.cui, cui));
      
      if (record.length > 0) {
        // VerificÄƒm dacÄƒ datele sunt recente (mai noi de 24 ore)
        const lastCheckedDate = record[0].lastCheckedAt;
        
        // lastCheckedAt poate fi un string ISO sau un obiect Date, tratÄƒm ambele cazuri
        let lastChecked: Date | null = null;
        if (lastCheckedDate instanceof Date) {
          lastChecked = lastCheckedDate;
        } else if (typeof lastCheckedDate === 'string' && lastCheckedDate) {
          lastChecked = new Date(lastCheckedDate);
        }
        
        // VerificÄƒ validitatea datei
        if (lastChecked && !isNaN(lastChecked.getTime())) {
          const now = new Date();
          // CalculÄƒm diferenÈ›a Ã®n milisecunde
          const diff = now.getTime() - lastChecked.getTime();
          
          // DacÄƒ datele sunt mai vechi de 24 ore, le considerÄƒm expirate
          if (diff > CACHE_TIMEOUT * 1000) {
            console.log(`[AnafQueueService] ğŸ•’ Date pentru CUI ${cui} expirate Ã®n baza de date (mai vechi de ${CACHE_TIMEOUT/3600} ore)`);
            return null;
          }
        } else {
          console.warn(`[AnafQueueService] âš ï¸ lastCheckedAt invalid pentru CUI ${cui}: ${lastCheckedDate}`);
        }
        
        // Convertim Ã®nregistrarea din DB Ã®n formatul AnafCompanyData
        if (record[0].rawResponse) {
          try {
            let parsedResponse: AnafCompanyData;
            
            // VerificÄƒm dacÄƒ rawResponse este deja un obiect sau un string JSON
            if (typeof record[0].rawResponse === 'object' && record[0].rawResponse !== null) {
              parsedResponse = record[0].rawResponse as unknown as AnafCompanyData;
            } else if (typeof record[0].rawResponse === 'string') {
              parsedResponse = JSON.parse(record[0].rawResponse) as AnafCompanyData;
            } else {
              console.warn(`[AnafQueueService] âš ï¸ Format rawResponse neaÈ™teptat pentru CUI ${cui}: ${typeof record[0].rawResponse}`);
              return null;
            }
            
            console.log(`[AnafQueueService] âœ… Date pentru CUI ${cui} gÄƒsite Ã®n baza de date`);
            return parsedResponse;
          } catch (e) {
            console.error(`[AnafQueueService] âŒ Eroare la parsarea JSON din baza de date pentru CUI ${cui}:`, e);
            return null;
          }
        } else {
          console.warn(`[AnafQueueService] âš ï¸ Ãnregistrarea pentru CUI ${cui} nu conÈ›ine rawResponse`);
        }
      } else {
        console.log(`[AnafQueueService] ğŸ” Nu s-au gÄƒsit date Ã®n baza de date pentru CUI ${cui}`);
      }
      
      return null;
    } catch (error) {
      console.error(`[AnafQueueService] âŒ Eroare la obÈ›inerea datelor din baza de date pentru CUI ${cui}:`, error);
      return null;
    }
  }
  
  /**
   * Ãnchide serviciul È™i conexiunile
   */
  async close(): Promise<void> {
    await this.worker.close();
    await this.queue.close();
    await this.redis.quit();
  }
}

// ExportÄƒ o instanÈ›Äƒ singleton
export const anafQueueService = new AnafQueueService();